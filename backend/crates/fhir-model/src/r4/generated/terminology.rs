#![allow(non_camel_case_types)]
#[doc = r" DO NOT EDIT THIS FILE. It is auto-generated by the FHIR Rust code generator."]
use self::super::types::Element;
use haste_fhir_serialization_json::derive::{FHIRJSONDeserialize, FHIRJSONSerialize};
use haste_reflect::MetaValue;
use std::any::Any;
use std::io::Write;
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FHIRVersion {
    #[doc = "0.0.80"]
    #[code = "0.0.80"]
    V0080(Option<Element>),
    #[doc = "0.0.81"]
    #[code = "0.0.81"]
    V0081(Option<Element>),
    #[doc = "0.0.82"]
    #[code = "0.0.82"]
    V0082(Option<Element>),
    #[doc = "0.01"]
    #[code = "0.01"]
    V001(Option<Element>),
    #[doc = "0.05"]
    #[code = "0.05"]
    V005(Option<Element>),
    #[doc = "0.06"]
    #[code = "0.06"]
    V006(Option<Element>),
    #[doc = "0.11"]
    #[code = "0.11"]
    V011(Option<Element>),
    #[doc = "0.4.0"]
    #[code = "0.4.0"]
    V040(Option<Element>),
    #[doc = "0.5.0"]
    #[code = "0.5.0"]
    V050(Option<Element>),
    #[doc = "1.0.0"]
    #[code = "1.0.0"]
    V100(Option<Element>),
    #[doc = "1.0.1"]
    #[code = "1.0.1"]
    V101(Option<Element>),
    #[doc = "1.0.2"]
    #[code = "1.0.2"]
    V102(Option<Element>),
    #[doc = "1.1.0"]
    #[code = "1.1.0"]
    V110(Option<Element>),
    #[doc = "1.4.0"]
    #[code = "1.4.0"]
    V140(Option<Element>),
    #[doc = "1.6.0"]
    #[code = "1.6.0"]
    V160(Option<Element>),
    #[doc = "1.8.0"]
    #[code = "1.8.0"]
    V180(Option<Element>),
    #[doc = "3.0.0"]
    #[code = "3.0.0"]
    V300(Option<Element>),
    #[doc = "3.0.1"]
    #[code = "3.0.1"]
    V301(Option<Element>),
    #[doc = "3.3.0"]
    #[code = "3.3.0"]
    V330(Option<Element>),
    #[doc = "3.5.0"]
    #[code = "3.5.0"]
    V350(Option<Element>),
    #[doc = "4.0.0"]
    #[code = "4.0.0"]
    V400(Option<Element>),
    #[doc = "4.0.1"]
    #[code = "4.0.1"]
    V401(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FHIRVersion {
    fn default() -> Self {
        FHIRVersion::Null(None)
    }
}
impl TryFrom<String> for FHIRVersion {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "0.0.80" => Ok(FHIRVersion::V0080(None)),
            "0.0.81" => Ok(FHIRVersion::V0081(None)),
            "0.0.82" => Ok(FHIRVersion::V0082(None)),
            "0.01" => Ok(FHIRVersion::V001(None)),
            "0.05" => Ok(FHIRVersion::V005(None)),
            "0.06" => Ok(FHIRVersion::V006(None)),
            "0.11" => Ok(FHIRVersion::V011(None)),
            "0.4.0" => Ok(FHIRVersion::V040(None)),
            "0.5.0" => Ok(FHIRVersion::V050(None)),
            "1.0.0" => Ok(FHIRVersion::V100(None)),
            "1.0.1" => Ok(FHIRVersion::V101(None)),
            "1.0.2" => Ok(FHIRVersion::V102(None)),
            "1.1.0" => Ok(FHIRVersion::V110(None)),
            "1.4.0" => Ok(FHIRVersion::V140(None)),
            "1.6.0" => Ok(FHIRVersion::V160(None)),
            "1.8.0" => Ok(FHIRVersion::V180(None)),
            "3.0.0" => Ok(FHIRVersion::V300(None)),
            "3.0.1" => Ok(FHIRVersion::V301(None)),
            "3.3.0" => Ok(FHIRVersion::V330(None)),
            "3.5.0" => Ok(FHIRVersion::V350(None)),
            "4.0.0" => Ok(FHIRVersion::V400(None)),
            "4.0.1" => Ok(FHIRVersion::V401(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FHIRVersion {
    fn into(self) -> Option<String> {
        match self {
            FHIRVersion::V0080(_) => Some("0.0.80".to_string()),
            FHIRVersion::V0081(_) => Some("0.0.81".to_string()),
            FHIRVersion::V0082(_) => Some("0.0.82".to_string()),
            FHIRVersion::V001(_) => Some("0.01".to_string()),
            FHIRVersion::V005(_) => Some("0.05".to_string()),
            FHIRVersion::V006(_) => Some("0.06".to_string()),
            FHIRVersion::V011(_) => Some("0.11".to_string()),
            FHIRVersion::V040(_) => Some("0.4.0".to_string()),
            FHIRVersion::V050(_) => Some("0.5.0".to_string()),
            FHIRVersion::V100(_) => Some("1.0.0".to_string()),
            FHIRVersion::V101(_) => Some("1.0.1".to_string()),
            FHIRVersion::V102(_) => Some("1.0.2".to_string()),
            FHIRVersion::V110(_) => Some("1.1.0".to_string()),
            FHIRVersion::V140(_) => Some("1.4.0".to_string()),
            FHIRVersion::V160(_) => Some("1.6.0".to_string()),
            FHIRVersion::V180(_) => Some("1.8.0".to_string()),
            FHIRVersion::V300(_) => Some("3.0.0".to_string()),
            FHIRVersion::V301(_) => Some("3.0.1".to_string()),
            FHIRVersion::V330(_) => Some("3.3.0".to_string()),
            FHIRVersion::V350(_) => Some("3.5.0".to_string()),
            FHIRVersion::V400(_) => Some("4.0.0".to_string()),
            FHIRVersion::V401(_) => Some("4.0.1".to_string()),
            FHIRVersion::Null(_) => None,
        }
    }
}
impl MetaValue for FHIRVersion {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FHIRVersion::V0080(Some(e)) => e.get_field(field),
                FHIRVersion::V0081(Some(e)) => e.get_field(field),
                FHIRVersion::V0082(Some(e)) => e.get_field(field),
                FHIRVersion::V001(Some(e)) => e.get_field(field),
                FHIRVersion::V005(Some(e)) => e.get_field(field),
                FHIRVersion::V006(Some(e)) => e.get_field(field),
                FHIRVersion::V011(Some(e)) => e.get_field(field),
                FHIRVersion::V040(Some(e)) => e.get_field(field),
                FHIRVersion::V050(Some(e)) => e.get_field(field),
                FHIRVersion::V100(Some(e)) => e.get_field(field),
                FHIRVersion::V101(Some(e)) => e.get_field(field),
                FHIRVersion::V102(Some(e)) => e.get_field(field),
                FHIRVersion::V110(Some(e)) => e.get_field(field),
                FHIRVersion::V140(Some(e)) => e.get_field(field),
                FHIRVersion::V160(Some(e)) => e.get_field(field),
                FHIRVersion::V180(Some(e)) => e.get_field(field),
                FHIRVersion::V300(Some(e)) => e.get_field(field),
                FHIRVersion::V301(Some(e)) => e.get_field(field),
                FHIRVersion::V330(Some(e)) => e.get_field(field),
                FHIRVersion::V350(Some(e)) => e.get_field(field),
                FHIRVersion::V400(Some(e)) => e.get_field(field),
                FHIRVersion::V401(Some(e)) => e.get_field(field),
                FHIRVersion::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FHIRVersion::V0080(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V0081(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V0082(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V001(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V005(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V006(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V011(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V040(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V050(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V100(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V101(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V102(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V110(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V140(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V160(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V180(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V300(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V301(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V330(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V350(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V400(Some(e)) => e.get_field_mut(field),
                FHIRVersion::V401(Some(e)) => e.get_field_mut(field),
                FHIRVersion::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AbstractTypes {
    #[doc = "Any"]
    #[code = "Any"]
    Any(Option<Element>),
    #[doc = "Type"]
    #[code = "Type"]
    Type(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AbstractTypes {
    fn default() -> Self {
        AbstractTypes::Null(None)
    }
}
impl TryFrom<String> for AbstractTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Any" => Ok(AbstractTypes::Any(None)),
            "Type" => Ok(AbstractTypes::Type(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AbstractTypes {
    fn into(self) -> Option<String> {
        match self {
            AbstractTypes::Any(_) => Some("Any".to_string()),
            AbstractTypes::Type(_) => Some("Type".to_string()),
            AbstractTypes::Null(_) => None,
        }
    }
}
impl MetaValue for AbstractTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AbstractTypes::Any(Some(e)) => e.get_field(field),
                AbstractTypes::Type(Some(e)) => e.get_field(field),
                AbstractTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AbstractTypes::Any(Some(e)) => e.get_field_mut(field),
                AbstractTypes::Type(Some(e)) => e.get_field_mut(field),
                AbstractTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccountStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccountStatus {
    fn default() -> Self {
        AccountStatus::Null(None)
    }
}
impl TryFrom<String> for AccountStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(AccountStatus::Active(None)),
            "entered-in-error" => Ok(AccountStatus::EnteredInError(None)),
            "inactive" => Ok(AccountStatus::Inactive(None)),
            "on-hold" => Ok(AccountStatus::OnHold(None)),
            "unknown" => Ok(AccountStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccountStatus {
    fn into(self) -> Option<String> {
        match self {
            AccountStatus::Active(_) => Some("active".to_string()),
            AccountStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            AccountStatus::Inactive(_) => Some("inactive".to_string()),
            AccountStatus::OnHold(_) => Some("on-hold".to_string()),
            AccountStatus::Unknown(_) => Some("unknown".to_string()),
            AccountStatus::Null(_) => None,
        }
    }
}
impl MetaValue for AccountStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccountStatus::Active(Some(e)) => e.get_field(field),
                AccountStatus::EnteredInError(Some(e)) => e.get_field(field),
                AccountStatus::Inactive(Some(e)) => e.get_field(field),
                AccountStatus::OnHold(Some(e)) => e.get_field(field),
                AccountStatus::Unknown(Some(e)) => e.get_field(field),
                AccountStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccountStatus::Active(Some(e)) => e.get_field_mut(field),
                AccountStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                AccountStatus::Inactive(Some(e)) => e.get_field_mut(field),
                AccountStatus::OnHold(Some(e)) => e.get_field_mut(field),
                AccountStatus::Unknown(Some(e)) => e.get_field_mut(field),
                AccountStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionCardinalityBehavior {
    #[doc = "Multiple"]
    #[code = "multiple"]
    Multiple(Option<Element>),
    #[doc = "Single"]
    #[code = "single"]
    Single(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionCardinalityBehavior {
    fn default() -> Self {
        ActionCardinalityBehavior::Null(None)
    }
}
impl TryFrom<String> for ActionCardinalityBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "multiple" => Ok(ActionCardinalityBehavior::Multiple(None)),
            "single" => Ok(ActionCardinalityBehavior::Single(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionCardinalityBehavior {
    fn into(self) -> Option<String> {
        match self {
            ActionCardinalityBehavior::Multiple(_) => Some("multiple".to_string()),
            ActionCardinalityBehavior::Single(_) => Some("single".to_string()),
            ActionCardinalityBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for ActionCardinalityBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionCardinalityBehavior::Multiple(Some(e)) => e.get_field(field),
                ActionCardinalityBehavior::Single(Some(e)) => e.get_field(field),
                ActionCardinalityBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionCardinalityBehavior::Multiple(Some(e)) => e.get_field_mut(field),
                ActionCardinalityBehavior::Single(Some(e)) => e.get_field_mut(field),
                ActionCardinalityBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionConditionKind {
    #[doc = "Applicability"]
    #[code = "applicability"]
    Applicability(Option<Element>),
    #[doc = "Start"]
    #[code = "start"]
    Start(Option<Element>),
    #[doc = "Stop"]
    #[code = "stop"]
    Stop(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionConditionKind {
    fn default() -> Self {
        ActionConditionKind::Null(None)
    }
}
impl TryFrom<String> for ActionConditionKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "applicability" => Ok(ActionConditionKind::Applicability(None)),
            "start" => Ok(ActionConditionKind::Start(None)),
            "stop" => Ok(ActionConditionKind::Stop(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionConditionKind {
    fn into(self) -> Option<String> {
        match self {
            ActionConditionKind::Applicability(_) => Some("applicability".to_string()),
            ActionConditionKind::Start(_) => Some("start".to_string()),
            ActionConditionKind::Stop(_) => Some("stop".to_string()),
            ActionConditionKind::Null(_) => None,
        }
    }
}
impl MetaValue for ActionConditionKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionConditionKind::Applicability(Some(e)) => e.get_field(field),
                ActionConditionKind::Start(Some(e)) => e.get_field(field),
                ActionConditionKind::Stop(Some(e)) => e.get_field(field),
                ActionConditionKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionConditionKind::Applicability(Some(e)) => e.get_field_mut(field),
                ActionConditionKind::Start(Some(e)) => e.get_field_mut(field),
                ActionConditionKind::Stop(Some(e)) => e.get_field_mut(field),
                ActionConditionKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionGroupingBehavior {
    #[doc = "Logical Group"]
    #[code = "logical-group"]
    LogicalGroup(Option<Element>),
    #[doc = "Sentence Group"]
    #[code = "sentence-group"]
    SentenceGroup(Option<Element>),
    #[doc = "Visual Group"]
    #[code = "visual-group"]
    VisualGroup(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionGroupingBehavior {
    fn default() -> Self {
        ActionGroupingBehavior::Null(None)
    }
}
impl TryFrom<String> for ActionGroupingBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "logical-group" => Ok(ActionGroupingBehavior::LogicalGroup(None)),
            "sentence-group" => Ok(ActionGroupingBehavior::SentenceGroup(None)),
            "visual-group" => Ok(ActionGroupingBehavior::VisualGroup(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionGroupingBehavior {
    fn into(self) -> Option<String> {
        match self {
            ActionGroupingBehavior::LogicalGroup(_) => Some("logical-group".to_string()),
            ActionGroupingBehavior::SentenceGroup(_) => Some("sentence-group".to_string()),
            ActionGroupingBehavior::VisualGroup(_) => Some("visual-group".to_string()),
            ActionGroupingBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for ActionGroupingBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionGroupingBehavior::LogicalGroup(Some(e)) => e.get_field(field),
                ActionGroupingBehavior::SentenceGroup(Some(e)) => e.get_field(field),
                ActionGroupingBehavior::VisualGroup(Some(e)) => e.get_field(field),
                ActionGroupingBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionGroupingBehavior::LogicalGroup(Some(e)) => e.get_field_mut(field),
                ActionGroupingBehavior::SentenceGroup(Some(e)) => e.get_field_mut(field),
                ActionGroupingBehavior::VisualGroup(Some(e)) => e.get_field_mut(field),
                ActionGroupingBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionParticipantType {
    #[doc = "Device"]
    #[code = "device"]
    Device(Option<Element>),
    #[doc = "Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "practitioner"]
    Practitioner(Option<Element>),
    #[doc = "Related Person"]
    #[code = "related-person"]
    RelatedPerson(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionParticipantType {
    fn default() -> Self {
        ActionParticipantType::Null(None)
    }
}
impl TryFrom<String> for ActionParticipantType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "device" => Ok(ActionParticipantType::Device(None)),
            "patient" => Ok(ActionParticipantType::Patient(None)),
            "practitioner" => Ok(ActionParticipantType::Practitioner(None)),
            "related-person" => Ok(ActionParticipantType::RelatedPerson(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionParticipantType {
    fn into(self) -> Option<String> {
        match self {
            ActionParticipantType::Device(_) => Some("device".to_string()),
            ActionParticipantType::Patient(_) => Some("patient".to_string()),
            ActionParticipantType::Practitioner(_) => Some("practitioner".to_string()),
            ActionParticipantType::RelatedPerson(_) => Some("related-person".to_string()),
            ActionParticipantType::Null(_) => None,
        }
    }
}
impl MetaValue for ActionParticipantType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionParticipantType::Device(Some(e)) => e.get_field(field),
                ActionParticipantType::Patient(Some(e)) => e.get_field(field),
                ActionParticipantType::Practitioner(Some(e)) => e.get_field(field),
                ActionParticipantType::RelatedPerson(Some(e)) => e.get_field(field),
                ActionParticipantType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionParticipantType::Device(Some(e)) => e.get_field_mut(field),
                ActionParticipantType::Patient(Some(e)) => e.get_field_mut(field),
                ActionParticipantType::Practitioner(Some(e)) => e.get_field_mut(field),
                ActionParticipantType::RelatedPerson(Some(e)) => e.get_field_mut(field),
                ActionParticipantType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionPrecheckBehavior {
    #[doc = "No"]
    #[code = "no"]
    No(Option<Element>),
    #[doc = "Yes"]
    #[code = "yes"]
    Yes(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionPrecheckBehavior {
    fn default() -> Self {
        ActionPrecheckBehavior::Null(None)
    }
}
impl TryFrom<String> for ActionPrecheckBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "no" => Ok(ActionPrecheckBehavior::No(None)),
            "yes" => Ok(ActionPrecheckBehavior::Yes(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionPrecheckBehavior {
    fn into(self) -> Option<String> {
        match self {
            ActionPrecheckBehavior::No(_) => Some("no".to_string()),
            ActionPrecheckBehavior::Yes(_) => Some("yes".to_string()),
            ActionPrecheckBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for ActionPrecheckBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionPrecheckBehavior::No(Some(e)) => e.get_field(field),
                ActionPrecheckBehavior::Yes(Some(e)) => e.get_field(field),
                ActionPrecheckBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionPrecheckBehavior::No(Some(e)) => e.get_field_mut(field),
                ActionPrecheckBehavior::Yes(Some(e)) => e.get_field_mut(field),
                ActionPrecheckBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionRelationshipType {
    #[doc = "After"]
    #[code = "after"]
    After(Option<Element>),
    #[doc = "After End"]
    #[code = "after-end"]
    AfterEnd(Option<Element>),
    #[doc = "After Start"]
    #[code = "after-start"]
    AfterStart(Option<Element>),
    #[doc = "Before"]
    #[code = "before"]
    Before(Option<Element>),
    #[doc = "Before End"]
    #[code = "before-end"]
    BeforeEnd(Option<Element>),
    #[doc = "Before Start"]
    #[code = "before-start"]
    BeforeStart(Option<Element>),
    #[doc = "Concurrent"]
    #[code = "concurrent"]
    Concurrent(Option<Element>),
    #[doc = "Concurrent With End"]
    #[code = "concurrent-with-end"]
    ConcurrentWithEnd(Option<Element>),
    #[doc = "Concurrent With Start"]
    #[code = "concurrent-with-start"]
    ConcurrentWithStart(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionRelationshipType {
    fn default() -> Self {
        ActionRelationshipType::Null(None)
    }
}
impl TryFrom<String> for ActionRelationshipType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "after" => Ok(ActionRelationshipType::After(None)),
            "after-end" => Ok(ActionRelationshipType::AfterEnd(None)),
            "after-start" => Ok(ActionRelationshipType::AfterStart(None)),
            "before" => Ok(ActionRelationshipType::Before(None)),
            "before-end" => Ok(ActionRelationshipType::BeforeEnd(None)),
            "before-start" => Ok(ActionRelationshipType::BeforeStart(None)),
            "concurrent" => Ok(ActionRelationshipType::Concurrent(None)),
            "concurrent-with-end" => Ok(ActionRelationshipType::ConcurrentWithEnd(None)),
            "concurrent-with-start" => Ok(ActionRelationshipType::ConcurrentWithStart(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionRelationshipType {
    fn into(self) -> Option<String> {
        match self {
            ActionRelationshipType::After(_) => Some("after".to_string()),
            ActionRelationshipType::AfterEnd(_) => Some("after-end".to_string()),
            ActionRelationshipType::AfterStart(_) => Some("after-start".to_string()),
            ActionRelationshipType::Before(_) => Some("before".to_string()),
            ActionRelationshipType::BeforeEnd(_) => Some("before-end".to_string()),
            ActionRelationshipType::BeforeStart(_) => Some("before-start".to_string()),
            ActionRelationshipType::Concurrent(_) => Some("concurrent".to_string()),
            ActionRelationshipType::ConcurrentWithEnd(_) => Some("concurrent-with-end".to_string()),
            ActionRelationshipType::ConcurrentWithStart(_) => {
                Some("concurrent-with-start".to_string())
            }
            ActionRelationshipType::Null(_) => None,
        }
    }
}
impl MetaValue for ActionRelationshipType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionRelationshipType::After(Some(e)) => e.get_field(field),
                ActionRelationshipType::AfterEnd(Some(e)) => e.get_field(field),
                ActionRelationshipType::AfterStart(Some(e)) => e.get_field(field),
                ActionRelationshipType::Before(Some(e)) => e.get_field(field),
                ActionRelationshipType::BeforeEnd(Some(e)) => e.get_field(field),
                ActionRelationshipType::BeforeStart(Some(e)) => e.get_field(field),
                ActionRelationshipType::Concurrent(Some(e)) => e.get_field(field),
                ActionRelationshipType::ConcurrentWithEnd(Some(e)) => e.get_field(field),
                ActionRelationshipType::ConcurrentWithStart(Some(e)) => e.get_field(field),
                ActionRelationshipType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionRelationshipType::After(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::AfterEnd(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::AfterStart(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::Before(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::BeforeEnd(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::BeforeStart(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::Concurrent(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::ConcurrentWithEnd(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::ConcurrentWithStart(Some(e)) => e.get_field_mut(field),
                ActionRelationshipType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionRequiredBehavior {
    #[doc = "Could"]
    #[code = "could"]
    Could(Option<Element>),
    #[doc = "Must"]
    #[code = "must"]
    Must(Option<Element>),
    #[doc = "Must Unless Documented"]
    #[code = "must-unless-documented"]
    MustUnlessDocumented(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionRequiredBehavior {
    fn default() -> Self {
        ActionRequiredBehavior::Null(None)
    }
}
impl TryFrom<String> for ActionRequiredBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "could" => Ok(ActionRequiredBehavior::Could(None)),
            "must" => Ok(ActionRequiredBehavior::Must(None)),
            "must-unless-documented" => Ok(ActionRequiredBehavior::MustUnlessDocumented(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionRequiredBehavior {
    fn into(self) -> Option<String> {
        match self {
            ActionRequiredBehavior::Could(_) => Some("could".to_string()),
            ActionRequiredBehavior::Must(_) => Some("must".to_string()),
            ActionRequiredBehavior::MustUnlessDocumented(_) => {
                Some("must-unless-documented".to_string())
            }
            ActionRequiredBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for ActionRequiredBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionRequiredBehavior::Could(Some(e)) => e.get_field(field),
                ActionRequiredBehavior::Must(Some(e)) => e.get_field(field),
                ActionRequiredBehavior::MustUnlessDocumented(Some(e)) => e.get_field(field),
                ActionRequiredBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionRequiredBehavior::Could(Some(e)) => e.get_field_mut(field),
                ActionRequiredBehavior::Must(Some(e)) => e.get_field_mut(field),
                ActionRequiredBehavior::MustUnlessDocumented(Some(e)) => e.get_field_mut(field),
                ActionRequiredBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionSelectionBehavior {
    #[doc = "All"]
    #[code = "all"]
    All(Option<Element>),
    #[doc = "All Or None"]
    #[code = "all-or-none"]
    AllOrNone(Option<Element>),
    #[doc = "Any"]
    #[code = "any"]
    Any(Option<Element>),
    #[doc = "At Most One"]
    #[code = "at-most-one"]
    AtMostOne(Option<Element>),
    #[doc = "Exactly One"]
    #[code = "exactly-one"]
    ExactlyOne(Option<Element>),
    #[doc = "One Or More"]
    #[code = "one-or-more"]
    OneOrMore(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionSelectionBehavior {
    fn default() -> Self {
        ActionSelectionBehavior::Null(None)
    }
}
impl TryFrom<String> for ActionSelectionBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all" => Ok(ActionSelectionBehavior::All(None)),
            "all-or-none" => Ok(ActionSelectionBehavior::AllOrNone(None)),
            "any" => Ok(ActionSelectionBehavior::Any(None)),
            "at-most-one" => Ok(ActionSelectionBehavior::AtMostOne(None)),
            "exactly-one" => Ok(ActionSelectionBehavior::ExactlyOne(None)),
            "one-or-more" => Ok(ActionSelectionBehavior::OneOrMore(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionSelectionBehavior {
    fn into(self) -> Option<String> {
        match self {
            ActionSelectionBehavior::All(_) => Some("all".to_string()),
            ActionSelectionBehavior::AllOrNone(_) => Some("all-or-none".to_string()),
            ActionSelectionBehavior::Any(_) => Some("any".to_string()),
            ActionSelectionBehavior::AtMostOne(_) => Some("at-most-one".to_string()),
            ActionSelectionBehavior::ExactlyOne(_) => Some("exactly-one".to_string()),
            ActionSelectionBehavior::OneOrMore(_) => Some("one-or-more".to_string()),
            ActionSelectionBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for ActionSelectionBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionSelectionBehavior::All(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::AllOrNone(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::Any(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::AtMostOne(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::ExactlyOne(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::OneOrMore(Some(e)) => e.get_field(field),
                ActionSelectionBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionSelectionBehavior::All(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::AllOrNone(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::Any(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::AtMostOne(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::ExactlyOne(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::OneOrMore(Some(e)) => e.get_field_mut(field),
                ActionSelectionBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActionType {
    #[doc = "Create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "Fire Event"]
    #[code = "fire-event"]
    FireEvent(Option<Element>),
    #[doc = "Remove"]
    #[code = "remove"]
    Remove(Option<Element>),
    #[doc = "Update"]
    #[code = "update"]
    Update(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActionType {
    fn default() -> Self {
        ActionType::Null(None)
    }
}
impl TryFrom<String> for ActionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "create" => Ok(ActionType::Create(None)),
            "fire-event" => Ok(ActionType::FireEvent(None)),
            "remove" => Ok(ActionType::Remove(None)),
            "update" => Ok(ActionType::Update(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActionType {
    fn into(self) -> Option<String> {
        match self {
            ActionType::Create(_) => Some("create".to_string()),
            ActionType::FireEvent(_) => Some("fire-event".to_string()),
            ActionType::Remove(_) => Some("remove".to_string()),
            ActionType::Update(_) => Some("update".to_string()),
            ActionType::Null(_) => None,
        }
    }
}
impl MetaValue for ActionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActionType::Create(Some(e)) => e.get_field(field),
                ActionType::FireEvent(Some(e)) => e.get_field(field),
                ActionType::Remove(Some(e)) => e.get_field(field),
                ActionType::Update(Some(e)) => e.get_field(field),
                ActionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActionType::Create(Some(e)) => e.get_field_mut(field),
                ActionType::FireEvent(Some(e)) => e.get_field_mut(field),
                ActionType::Remove(Some(e)) => e.get_field_mut(field),
                ActionType::Update(Some(e)) => e.get_field_mut(field),
                ActionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ActivityDefinitionCategory {
    #[doc = "Assessment"]
    #[code = "assessment"]
    Assessment(Option<Element>),
    #[doc = "Education"]
    #[code = "education"]
    Education(Option<Element>),
    #[doc = "Treatment"]
    #[code = "treatment"]
    Treatment(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ActivityDefinitionCategory {
    fn default() -> Self {
        ActivityDefinitionCategory::Null(None)
    }
}
impl TryFrom<String> for ActivityDefinitionCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "assessment" => Ok(ActivityDefinitionCategory::Assessment(None)),
            "education" => Ok(ActivityDefinitionCategory::Education(None)),
            "treatment" => Ok(ActivityDefinitionCategory::Treatment(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ActivityDefinitionCategory {
    fn into(self) -> Option<String> {
        match self {
            ActivityDefinitionCategory::Assessment(_) => Some("assessment".to_string()),
            ActivityDefinitionCategory::Education(_) => Some("education".to_string()),
            ActivityDefinitionCategory::Treatment(_) => Some("treatment".to_string()),
            ActivityDefinitionCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ActivityDefinitionCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ActivityDefinitionCategory::Assessment(Some(e)) => e.get_field(field),
                ActivityDefinitionCategory::Education(Some(e)) => e.get_field(field),
                ActivityDefinitionCategory::Treatment(Some(e)) => e.get_field(field),
                ActivityDefinitionCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ActivityDefinitionCategory::Assessment(Some(e)) => e.get_field_mut(field),
                ActivityDefinitionCategory::Education(Some(e)) => e.get_field_mut(field),
                ActivityDefinitionCategory::Treatment(Some(e)) => e.get_field_mut(field),
                ActivityDefinitionCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Additionalmaterials {
    #[doc = "Document"]
    #[code = "document"]
    Document(Option<Element>),
    #[doc = "Email"]
    #[code = "email"]
    Email(Option<Element>),
    #[doc = "Image"]
    #[code = "image"]
    Image(Option<Element>),
    #[doc = "Model"]
    #[code = "model"]
    Model(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "XRay"]
    #[code = "xray"]
    Xray(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Additionalmaterials {
    fn default() -> Self {
        Additionalmaterials::Null(None)
    }
}
impl TryFrom<String> for Additionalmaterials {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "document" => Ok(Additionalmaterials::Document(None)),
            "email" => Ok(Additionalmaterials::Email(None)),
            "image" => Ok(Additionalmaterials::Image(None)),
            "model" => Ok(Additionalmaterials::Model(None)),
            "other" => Ok(Additionalmaterials::Other(None)),
            "xray" => Ok(Additionalmaterials::Xray(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Additionalmaterials {
    fn into(self) -> Option<String> {
        match self {
            Additionalmaterials::Document(_) => Some("document".to_string()),
            Additionalmaterials::Email(_) => Some("email".to_string()),
            Additionalmaterials::Image(_) => Some("image".to_string()),
            Additionalmaterials::Model(_) => Some("model".to_string()),
            Additionalmaterials::Other(_) => Some("other".to_string()),
            Additionalmaterials::Xray(_) => Some("xray".to_string()),
            Additionalmaterials::Null(_) => None,
        }
    }
}
impl MetaValue for Additionalmaterials {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Additionalmaterials::Document(Some(e)) => e.get_field(field),
                Additionalmaterials::Email(Some(e)) => e.get_field(field),
                Additionalmaterials::Image(Some(e)) => e.get_field(field),
                Additionalmaterials::Model(Some(e)) => e.get_field(field),
                Additionalmaterials::Other(Some(e)) => e.get_field(field),
                Additionalmaterials::Xray(Some(e)) => e.get_field(field),
                Additionalmaterials::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Additionalmaterials::Document(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Email(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Image(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Model(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Other(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Xray(Some(e)) => e.get_field_mut(field),
                Additionalmaterials::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AddressType {
    #[doc = "Postal & Physical"]
    #[code = "both"]
    Both(Option<Element>),
    #[doc = "Physical"]
    #[code = "physical"]
    Physical(Option<Element>),
    #[doc = "Postal"]
    #[code = "postal"]
    Postal(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AddressType {
    fn default() -> Self {
        AddressType::Null(None)
    }
}
impl TryFrom<String> for AddressType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "both" => Ok(AddressType::Both(None)),
            "physical" => Ok(AddressType::Physical(None)),
            "postal" => Ok(AddressType::Postal(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AddressType {
    fn into(self) -> Option<String> {
        match self {
            AddressType::Both(_) => Some("both".to_string()),
            AddressType::Physical(_) => Some("physical".to_string()),
            AddressType::Postal(_) => Some("postal".to_string()),
            AddressType::Null(_) => None,
        }
    }
}
impl MetaValue for AddressType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AddressType::Both(Some(e)) => e.get_field(field),
                AddressType::Physical(Some(e)) => e.get_field(field),
                AddressType::Postal(Some(e)) => e.get_field(field),
                AddressType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AddressType::Both(Some(e)) => e.get_field_mut(field),
                AddressType::Physical(Some(e)) => e.get_field_mut(field),
                AddressType::Postal(Some(e)) => e.get_field_mut(field),
                AddressType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AddressUse {
    #[doc = "Billing"]
    #[code = "billing"]
    Billing(Option<Element>),
    #[doc = "Home"]
    #[code = "home"]
    Home(Option<Element>),
    #[doc = "Old / Incorrect"]
    #[code = "old"]
    Old(Option<Element>),
    #[doc = "Temporary"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "Work"]
    #[code = "work"]
    Work(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AddressUse {
    fn default() -> Self {
        AddressUse::Null(None)
    }
}
impl TryFrom<String> for AddressUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "billing" => Ok(AddressUse::Billing(None)),
            "home" => Ok(AddressUse::Home(None)),
            "old" => Ok(AddressUse::Old(None)),
            "temp" => Ok(AddressUse::Temp(None)),
            "work" => Ok(AddressUse::Work(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AddressUse {
    fn into(self) -> Option<String> {
        match self {
            AddressUse::Billing(_) => Some("billing".to_string()),
            AddressUse::Home(_) => Some("home".to_string()),
            AddressUse::Old(_) => Some("old".to_string()),
            AddressUse::Temp(_) => Some("temp".to_string()),
            AddressUse::Work(_) => Some("work".to_string()),
            AddressUse::Null(_) => None,
        }
    }
}
impl MetaValue for AddressUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AddressUse::Billing(Some(e)) => e.get_field(field),
                AddressUse::Home(Some(e)) => e.get_field(field),
                AddressUse::Old(Some(e)) => e.get_field(field),
                AddressUse::Temp(Some(e)) => e.get_field(field),
                AddressUse::Work(Some(e)) => e.get_field(field),
                AddressUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AddressUse::Billing(Some(e)) => e.get_field_mut(field),
                AddressUse::Home(Some(e)) => e.get_field_mut(field),
                AddressUse::Old(Some(e)) => e.get_field_mut(field),
                AddressUse::Temp(Some(e)) => e.get_field_mut(field),
                AddressUse::Work(Some(e)) => e.get_field_mut(field),
                AddressUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Adjudication {
    #[doc = "Benefit Amount"]
    #[code = "benefit"]
    Benefit(Option<Element>),
    #[doc = "CoPay"]
    #[code = "copay"]
    Copay(Option<Element>),
    #[doc = "Deductible"]
    #[code = "deductible"]
    Deductible(Option<Element>),
    #[doc = "Eligible Amount"]
    #[code = "eligible"]
    Eligible(Option<Element>),
    #[doc = "Eligible %"]
    #[code = "eligpercent"]
    Eligpercent(Option<Element>),
    #[doc = "Submitted Amount"]
    #[code = "submitted"]
    Submitted(Option<Element>),
    #[doc = "Tax"]
    #[code = "tax"]
    Tax(Option<Element>),
    #[doc = "Unallocated Deductible"]
    #[code = "unallocdeduct"]
    Unallocdeduct(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Adjudication {
    fn default() -> Self {
        Adjudication::Null(None)
    }
}
impl TryFrom<String> for Adjudication {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "benefit" => Ok(Adjudication::Benefit(None)),
            "copay" => Ok(Adjudication::Copay(None)),
            "deductible" => Ok(Adjudication::Deductible(None)),
            "eligible" => Ok(Adjudication::Eligible(None)),
            "eligpercent" => Ok(Adjudication::Eligpercent(None)),
            "submitted" => Ok(Adjudication::Submitted(None)),
            "tax" => Ok(Adjudication::Tax(None)),
            "unallocdeduct" => Ok(Adjudication::Unallocdeduct(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Adjudication {
    fn into(self) -> Option<String> {
        match self {
            Adjudication::Benefit(_) => Some("benefit".to_string()),
            Adjudication::Copay(_) => Some("copay".to_string()),
            Adjudication::Deductible(_) => Some("deductible".to_string()),
            Adjudication::Eligible(_) => Some("eligible".to_string()),
            Adjudication::Eligpercent(_) => Some("eligpercent".to_string()),
            Adjudication::Submitted(_) => Some("submitted".to_string()),
            Adjudication::Tax(_) => Some("tax".to_string()),
            Adjudication::Unallocdeduct(_) => Some("unallocdeduct".to_string()),
            Adjudication::Null(_) => None,
        }
    }
}
impl MetaValue for Adjudication {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Adjudication::Benefit(Some(e)) => e.get_field(field),
                Adjudication::Copay(Some(e)) => e.get_field(field),
                Adjudication::Deductible(Some(e)) => e.get_field(field),
                Adjudication::Eligible(Some(e)) => e.get_field(field),
                Adjudication::Eligpercent(Some(e)) => e.get_field(field),
                Adjudication::Submitted(Some(e)) => e.get_field(field),
                Adjudication::Tax(Some(e)) => e.get_field(field),
                Adjudication::Unallocdeduct(Some(e)) => e.get_field(field),
                Adjudication::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Adjudication::Benefit(Some(e)) => e.get_field_mut(field),
                Adjudication::Copay(Some(e)) => e.get_field_mut(field),
                Adjudication::Deductible(Some(e)) => e.get_field_mut(field),
                Adjudication::Eligible(Some(e)) => e.get_field_mut(field),
                Adjudication::Eligpercent(Some(e)) => e.get_field_mut(field),
                Adjudication::Submitted(Some(e)) => e.get_field_mut(field),
                Adjudication::Tax(Some(e)) => e.get_field_mut(field),
                Adjudication::Unallocdeduct(Some(e)) => e.get_field_mut(field),
                Adjudication::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdjudicationError {
    #[doc = "Missing Identifier"]
    #[code = "a001"]
    A001(Option<Element>),
    #[doc = "Missing Creation Date"]
    #[code = "a002"]
    A002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdjudicationError {
    fn default() -> Self {
        AdjudicationError::Null(None)
    }
}
impl TryFrom<String> for AdjudicationError {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a001" => Ok(AdjudicationError::A001(None)),
            "a002" => Ok(AdjudicationError::A002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdjudicationError {
    fn into(self) -> Option<String> {
        match self {
            AdjudicationError::A001(_) => Some("a001".to_string()),
            AdjudicationError::A002(_) => Some("a002".to_string()),
            AdjudicationError::Null(_) => None,
        }
    }
}
impl MetaValue for AdjudicationError {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdjudicationError::A001(Some(e)) => e.get_field(field),
                AdjudicationError::A002(Some(e)) => e.get_field(field),
                AdjudicationError::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdjudicationError::A001(Some(e)) => e.get_field_mut(field),
                AdjudicationError::A002(Some(e)) => e.get_field_mut(field),
                AdjudicationError::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdjudicationReason {
    #[doc = "Not covered"]
    #[code = "ar001"]
    Ar001(Option<Element>),
    #[doc = "Plan Limit Reached"]
    #[code = "ar002"]
    Ar002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdjudicationReason {
    fn default() -> Self {
        AdjudicationReason::Null(None)
    }
}
impl TryFrom<String> for AdjudicationReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ar001" => Ok(AdjudicationReason::Ar001(None)),
            "ar002" => Ok(AdjudicationReason::Ar002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdjudicationReason {
    fn into(self) -> Option<String> {
        match self {
            AdjudicationReason::Ar001(_) => Some("ar001".to_string()),
            AdjudicationReason::Ar002(_) => Some("ar002".to_string()),
            AdjudicationReason::Null(_) => None,
        }
    }
}
impl MetaValue for AdjudicationReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdjudicationReason::Ar001(Some(e)) => e.get_field(field),
                AdjudicationReason::Ar002(Some(e)) => e.get_field(field),
                AdjudicationReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdjudicationReason::Ar001(Some(e)) => e.get_field_mut(field),
                AdjudicationReason::Ar002(Some(e)) => e.get_field_mut(field),
                AdjudicationReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdministrativeGender {
    #[doc = "Female"]
    #[code = "female"]
    Female(Option<Element>),
    #[doc = "Male"]
    #[code = "male"]
    Male(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdministrativeGender {
    fn default() -> Self {
        AdministrativeGender::Null(None)
    }
}
impl TryFrom<String> for AdministrativeGender {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "female" => Ok(AdministrativeGender::Female(None)),
            "male" => Ok(AdministrativeGender::Male(None)),
            "other" => Ok(AdministrativeGender::Other(None)),
            "unknown" => Ok(AdministrativeGender::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdministrativeGender {
    fn into(self) -> Option<String> {
        match self {
            AdministrativeGender::Female(_) => Some("female".to_string()),
            AdministrativeGender::Male(_) => Some("male".to_string()),
            AdministrativeGender::Other(_) => Some("other".to_string()),
            AdministrativeGender::Unknown(_) => Some("unknown".to_string()),
            AdministrativeGender::Null(_) => None,
        }
    }
}
impl MetaValue for AdministrativeGender {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdministrativeGender::Female(Some(e)) => e.get_field(field),
                AdministrativeGender::Male(Some(e)) => e.get_field(field),
                AdministrativeGender::Other(Some(e)) => e.get_field(field),
                AdministrativeGender::Unknown(Some(e)) => e.get_field(field),
                AdministrativeGender::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdministrativeGender::Female(Some(e)) => e.get_field_mut(field),
                AdministrativeGender::Male(Some(e)) => e.get_field_mut(field),
                AdministrativeGender::Other(Some(e)) => e.get_field_mut(field),
                AdministrativeGender::Unknown(Some(e)) => e.get_field_mut(field),
                AdministrativeGender::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventActuality {
    #[doc = "Adverse Event"]
    #[code = "actual"]
    Actual(Option<Element>),
    #[doc = "Potential Adverse Event"]
    #[code = "potential"]
    Potential(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventActuality {
    fn default() -> Self {
        AdverseEventActuality::Null(None)
    }
}
impl TryFrom<String> for AdverseEventActuality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "actual" => Ok(AdverseEventActuality::Actual(None)),
            "potential" => Ok(AdverseEventActuality::Potential(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventActuality {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventActuality::Actual(_) => Some("actual".to_string()),
            AdverseEventActuality::Potential(_) => Some("potential".to_string()),
            AdverseEventActuality::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventActuality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventActuality::Actual(Some(e)) => e.get_field(field),
                AdverseEventActuality::Potential(Some(e)) => e.get_field(field),
                AdverseEventActuality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventActuality::Actual(Some(e)) => e.get_field_mut(field),
                AdverseEventActuality::Potential(Some(e)) => e.get_field_mut(field),
                AdverseEventActuality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventCategory {
    #[doc = "Expired Drug"]
    #[code = "expired-drug"]
    ExpiredDrug(Option<Element>),
    #[doc = "Incorrect Prescribing Information"]
    #[code = "incorrect-prescribing-information"]
    IncorrectPrescribingInformation(Option<Element>),
    #[doc = "Medical Device Use Error"]
    #[code = "medical-device-use-error"]
    MedicalDeviceUseError(Option<Element>),
    #[doc = "Problem with Different Manufacturer of Same Medicine"]
    #[code = "problem-different-manufacturer"]
    ProblemDifferentManufacturer(Option<Element>),
    #[doc = "Product Problem"]
    #[code = "product-problem"]
    ProductProblem(Option<Element>),
    #[doc = "Product Quality"]
    #[code = "product-quality"]
    ProductQuality(Option<Element>),
    #[doc = "Product Use Error"]
    #[code = "product-use-error"]
    ProductUseError(Option<Element>),
    #[doc = "Unsafe Physical Environment"]
    #[code = "unsafe-physical-environment"]
    UnsafePhysicalEnvironment(Option<Element>),
    #[doc = "Wrong Dose"]
    #[code = "wrong-dose"]
    WrongDose(Option<Element>),
    #[doc = "Wrong Duration"]
    #[code = "wrong-duration"]
    WrongDuration(Option<Element>),
    #[doc = "Wrong Rate"]
    #[code = "wrong-rate"]
    WrongRate(Option<Element>),
    #[doc = "Wrong Route of Administration"]
    #[code = "wrong-route-of-administration"]
    WrongRouteOfAdministration(Option<Element>),
    #[doc = "Wrong Technique"]
    #[code = "wrong-technique"]
    WrongTechnique(Option<Element>),
    #[doc = "Wrong Time"]
    #[code = "wrong-time"]
    WrongTime(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventCategory {
    fn default() -> Self {
        AdverseEventCategory::Null(None)
    }
}
impl TryFrom<String> for AdverseEventCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "expired-drug" => Ok(AdverseEventCategory::ExpiredDrug(None)),
            "incorrect-prescribing-information" => {
                Ok(AdverseEventCategory::IncorrectPrescribingInformation(None))
            }
            "medical-device-use-error" => Ok(AdverseEventCategory::MedicalDeviceUseError(None)),
            "problem-different-manufacturer" => {
                Ok(AdverseEventCategory::ProblemDifferentManufacturer(None))
            }
            "product-problem" => Ok(AdverseEventCategory::ProductProblem(None)),
            "product-quality" => Ok(AdverseEventCategory::ProductQuality(None)),
            "product-use-error" => Ok(AdverseEventCategory::ProductUseError(None)),
            "unsafe-physical-environment" => {
                Ok(AdverseEventCategory::UnsafePhysicalEnvironment(None))
            }
            "wrong-dose" => Ok(AdverseEventCategory::WrongDose(None)),
            "wrong-duration" => Ok(AdverseEventCategory::WrongDuration(None)),
            "wrong-rate" => Ok(AdverseEventCategory::WrongRate(None)),
            "wrong-route-of-administration" => {
                Ok(AdverseEventCategory::WrongRouteOfAdministration(None))
            }
            "wrong-technique" => Ok(AdverseEventCategory::WrongTechnique(None)),
            "wrong-time" => Ok(AdverseEventCategory::WrongTime(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventCategory {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventCategory::ExpiredDrug(_) => Some("expired-drug".to_string()),
            AdverseEventCategory::IncorrectPrescribingInformation(_) => {
                Some("incorrect-prescribing-information".to_string())
            }
            AdverseEventCategory::MedicalDeviceUseError(_) => {
                Some("medical-device-use-error".to_string())
            }
            AdverseEventCategory::ProblemDifferentManufacturer(_) => {
                Some("problem-different-manufacturer".to_string())
            }
            AdverseEventCategory::ProductProblem(_) => Some("product-problem".to_string()),
            AdverseEventCategory::ProductQuality(_) => Some("product-quality".to_string()),
            AdverseEventCategory::ProductUseError(_) => Some("product-use-error".to_string()),
            AdverseEventCategory::UnsafePhysicalEnvironment(_) => {
                Some("unsafe-physical-environment".to_string())
            }
            AdverseEventCategory::WrongDose(_) => Some("wrong-dose".to_string()),
            AdverseEventCategory::WrongDuration(_) => Some("wrong-duration".to_string()),
            AdverseEventCategory::WrongRate(_) => Some("wrong-rate".to_string()),
            AdverseEventCategory::WrongRouteOfAdministration(_) => {
                Some("wrong-route-of-administration".to_string())
            }
            AdverseEventCategory::WrongTechnique(_) => Some("wrong-technique".to_string()),
            AdverseEventCategory::WrongTime(_) => Some("wrong-time".to_string()),
            AdverseEventCategory::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventCategory::ExpiredDrug(Some(e)) => e.get_field(field),
                AdverseEventCategory::IncorrectPrescribingInformation(Some(e)) => {
                    e.get_field(field)
                }
                AdverseEventCategory::MedicalDeviceUseError(Some(e)) => e.get_field(field),
                AdverseEventCategory::ProblemDifferentManufacturer(Some(e)) => e.get_field(field),
                AdverseEventCategory::ProductProblem(Some(e)) => e.get_field(field),
                AdverseEventCategory::ProductQuality(Some(e)) => e.get_field(field),
                AdverseEventCategory::ProductUseError(Some(e)) => e.get_field(field),
                AdverseEventCategory::UnsafePhysicalEnvironment(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongDose(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongDuration(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongRate(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongRouteOfAdministration(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongTechnique(Some(e)) => e.get_field(field),
                AdverseEventCategory::WrongTime(Some(e)) => e.get_field(field),
                AdverseEventCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventCategory::ExpiredDrug(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::IncorrectPrescribingInformation(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventCategory::MedicalDeviceUseError(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::ProblemDifferentManufacturer(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventCategory::ProductProblem(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::ProductQuality(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::ProductUseError(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::UnsafePhysicalEnvironment(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongDose(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongDuration(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongRate(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongRouteOfAdministration(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongTechnique(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::WrongTime(Some(e)) => e.get_field_mut(field),
                AdverseEventCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventCausalityAssess {
    #[doc = "Certain"]
    #[code = "Certain"]
    Certain(Option<Element>),
    #[doc = "Conditional/Classified"]
    #[code = "Conditional-Classified"]
    ConditionalClassified(Option<Element>),
    #[doc = "Possible"]
    #[code = "Possible"]
    Possible(Option<Element>),
    #[doc = "Probably/Likely"]
    #[code = "Probably-Likely"]
    ProbablyLikely(Option<Element>),
    #[doc = "Unassessable/Unclassifiable"]
    #[code = "Unassessable-Unclassifiable"]
    UnassessableUnclassifiable(Option<Element>),
    #[doc = "Unlikely"]
    #[code = "Unlikely"]
    Unlikely(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventCausalityAssess {
    fn default() -> Self {
        AdverseEventCausalityAssess::Null(None)
    }
}
impl TryFrom<String> for AdverseEventCausalityAssess {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Certain" => Ok(AdverseEventCausalityAssess::Certain(None)),
            "Conditional-Classified" => {
                Ok(AdverseEventCausalityAssess::ConditionalClassified(None))
            }
            "Possible" => Ok(AdverseEventCausalityAssess::Possible(None)),
            "Probably-Likely" => Ok(AdverseEventCausalityAssess::ProbablyLikely(None)),
            "Unassessable-Unclassifiable" => Ok(
                AdverseEventCausalityAssess::UnassessableUnclassifiable(None),
            ),
            "Unlikely" => Ok(AdverseEventCausalityAssess::Unlikely(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventCausalityAssess {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventCausalityAssess::Certain(_) => Some("Certain".to_string()),
            AdverseEventCausalityAssess::ConditionalClassified(_) => {
                Some("Conditional-Classified".to_string())
            }
            AdverseEventCausalityAssess::Possible(_) => Some("Possible".to_string()),
            AdverseEventCausalityAssess::ProbablyLikely(_) => Some("Probably-Likely".to_string()),
            AdverseEventCausalityAssess::UnassessableUnclassifiable(_) => {
                Some("Unassessable-Unclassifiable".to_string())
            }
            AdverseEventCausalityAssess::Unlikely(_) => Some("Unlikely".to_string()),
            AdverseEventCausalityAssess::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventCausalityAssess {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventCausalityAssess::Certain(Some(e)) => e.get_field(field),
                AdverseEventCausalityAssess::ConditionalClassified(Some(e)) => e.get_field(field),
                AdverseEventCausalityAssess::Possible(Some(e)) => e.get_field(field),
                AdverseEventCausalityAssess::ProbablyLikely(Some(e)) => e.get_field(field),
                AdverseEventCausalityAssess::UnassessableUnclassifiable(Some(e)) => {
                    e.get_field(field)
                }
                AdverseEventCausalityAssess::Unlikely(Some(e)) => e.get_field(field),
                AdverseEventCausalityAssess::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventCausalityAssess::Certain(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityAssess::ConditionalClassified(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventCausalityAssess::Possible(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityAssess::ProbablyLikely(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityAssess::UnassessableUnclassifiable(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventCausalityAssess::Unlikely(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityAssess::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventCausalityMethod {
    #[doc = "Bayesian"]
    #[code = "Bayesian"]
    Bayesian(Option<Element>),
    #[doc = "Checklist"]
    #[code = "Checklist"]
    Checklist(Option<Element>),
    #[doc = "Probability Scale"]
    #[code = "ProbabilityScale"]
    ProbabilityScale(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventCausalityMethod {
    fn default() -> Self {
        AdverseEventCausalityMethod::Null(None)
    }
}
impl TryFrom<String> for AdverseEventCausalityMethod {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Bayesian" => Ok(AdverseEventCausalityMethod::Bayesian(None)),
            "Checklist" => Ok(AdverseEventCausalityMethod::Checklist(None)),
            "ProbabilityScale" => Ok(AdverseEventCausalityMethod::ProbabilityScale(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventCausalityMethod {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventCausalityMethod::Bayesian(_) => Some("Bayesian".to_string()),
            AdverseEventCausalityMethod::Checklist(_) => Some("Checklist".to_string()),
            AdverseEventCausalityMethod::ProbabilityScale(_) => {
                Some("ProbabilityScale".to_string())
            }
            AdverseEventCausalityMethod::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventCausalityMethod {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventCausalityMethod::Bayesian(Some(e)) => e.get_field(field),
                AdverseEventCausalityMethod::Checklist(Some(e)) => e.get_field(field),
                AdverseEventCausalityMethod::ProbabilityScale(Some(e)) => e.get_field(field),
                AdverseEventCausalityMethod::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventCausalityMethod::Bayesian(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityMethod::Checklist(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityMethod::ProbabilityScale(Some(e)) => e.get_field_mut(field),
                AdverseEventCausalityMethod::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventOutcome {
    #[doc = "Fatal"]
    #[code = "fatal"]
    Fatal(Option<Element>),
    #[doc = "Ongoing"]
    #[code = "ongoing"]
    Ongoing(Option<Element>),
    #[doc = "Recovering"]
    #[code = "recovering"]
    Recovering(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "Resolved with Sequelae"]
    #[code = "resolvedWithSequelae"]
    ResolvedWithSequelae(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventOutcome {
    fn default() -> Self {
        AdverseEventOutcome::Null(None)
    }
}
impl TryFrom<String> for AdverseEventOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fatal" => Ok(AdverseEventOutcome::Fatal(None)),
            "ongoing" => Ok(AdverseEventOutcome::Ongoing(None)),
            "recovering" => Ok(AdverseEventOutcome::Recovering(None)),
            "resolved" => Ok(AdverseEventOutcome::Resolved(None)),
            "resolvedWithSequelae" => Ok(AdverseEventOutcome::ResolvedWithSequelae(None)),
            "unknown" => Ok(AdverseEventOutcome::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventOutcome {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventOutcome::Fatal(_) => Some("fatal".to_string()),
            AdverseEventOutcome::Ongoing(_) => Some("ongoing".to_string()),
            AdverseEventOutcome::Recovering(_) => Some("recovering".to_string()),
            AdverseEventOutcome::Resolved(_) => Some("resolved".to_string()),
            AdverseEventOutcome::ResolvedWithSequelae(_) => {
                Some("resolvedWithSequelae".to_string())
            }
            AdverseEventOutcome::Unknown(_) => Some("unknown".to_string()),
            AdverseEventOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventOutcome::Fatal(Some(e)) => e.get_field(field),
                AdverseEventOutcome::Ongoing(Some(e)) => e.get_field(field),
                AdverseEventOutcome::Recovering(Some(e)) => e.get_field(field),
                AdverseEventOutcome::Resolved(Some(e)) => e.get_field(field),
                AdverseEventOutcome::ResolvedWithSequelae(Some(e)) => e.get_field(field),
                AdverseEventOutcome::Unknown(Some(e)) => e.get_field(field),
                AdverseEventOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventOutcome::Fatal(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::Ongoing(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::Recovering(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::Resolved(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::ResolvedWithSequelae(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::Unknown(Some(e)) => e.get_field_mut(field),
                AdverseEventOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventSeriousness {
    #[doc = "Non-serious"]
    #[code = "Non-serious"]
    NonSerious(Option<Element>),
    #[doc = "Serious"]
    #[code = "Serious"]
    Serious(Option<Element>),
    #[doc = "Is a congenital anomaly/birth defect"]
    #[code = "SeriousIsBirthDefect"]
    SeriousIsBirthDefect(Option<Element>),
    #[doc = "Is Life-threatening"]
    #[code = "SeriousIsLifeThreatening"]
    SeriousIsLifeThreatening(Option<Element>),
    #[doc = "Requires intervention to prevent permanent impairment"]
    #[code = "SeriousRequiresPreventImpairment"]
    SeriousRequiresPreventImpairment(Option<Element>),
    #[doc = "Results in death"]
    #[code = "SeriousResultsInDeath"]
    SeriousResultsInDeath(Option<Element>),
    #[doc = "Results in persistent or significant disability/incapacity"]
    #[code = "SeriousResultsInDisability"]
    SeriousResultsInDisability(Option<Element>),
    #[doc = "Requires or prolongs inpatient hospitalization"]
    #[code = "SeriousResultsInHospitalization"]
    SeriousResultsInHospitalization(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventSeriousness {
    fn default() -> Self {
        AdverseEventSeriousness::Null(None)
    }
}
impl TryFrom<String> for AdverseEventSeriousness {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Non-serious" => Ok(AdverseEventSeriousness::NonSerious(None)),
            "Serious" => Ok(AdverseEventSeriousness::Serious(None)),
            "SeriousIsBirthDefect" => Ok(AdverseEventSeriousness::SeriousIsBirthDefect(None)),
            "SeriousIsLifeThreatening" => {
                Ok(AdverseEventSeriousness::SeriousIsLifeThreatening(None))
            }
            "SeriousRequiresPreventImpairment" => Ok(
                AdverseEventSeriousness::SeriousRequiresPreventImpairment(None),
            ),
            "SeriousResultsInDeath" => Ok(AdverseEventSeriousness::SeriousResultsInDeath(None)),
            "SeriousResultsInDisability" => {
                Ok(AdverseEventSeriousness::SeriousResultsInDisability(None))
            }
            "SeriousResultsInHospitalization" => Ok(
                AdverseEventSeriousness::SeriousResultsInHospitalization(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventSeriousness {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventSeriousness::NonSerious(_) => Some("Non-serious".to_string()),
            AdverseEventSeriousness::Serious(_) => Some("Serious".to_string()),
            AdverseEventSeriousness::SeriousIsBirthDefect(_) => {
                Some("SeriousIsBirthDefect".to_string())
            }
            AdverseEventSeriousness::SeriousIsLifeThreatening(_) => {
                Some("SeriousIsLifeThreatening".to_string())
            }
            AdverseEventSeriousness::SeriousRequiresPreventImpairment(_) => {
                Some("SeriousRequiresPreventImpairment".to_string())
            }
            AdverseEventSeriousness::SeriousResultsInDeath(_) => {
                Some("SeriousResultsInDeath".to_string())
            }
            AdverseEventSeriousness::SeriousResultsInDisability(_) => {
                Some("SeriousResultsInDisability".to_string())
            }
            AdverseEventSeriousness::SeriousResultsInHospitalization(_) => {
                Some("SeriousResultsInHospitalization".to_string())
            }
            AdverseEventSeriousness::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventSeriousness {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventSeriousness::NonSerious(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::Serious(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::SeriousIsBirthDefect(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::SeriousIsLifeThreatening(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::SeriousRequiresPreventImpairment(Some(e)) => {
                    e.get_field(field)
                }
                AdverseEventSeriousness::SeriousResultsInDeath(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::SeriousResultsInDisability(Some(e)) => e.get_field(field),
                AdverseEventSeriousness::SeriousResultsInHospitalization(Some(e)) => {
                    e.get_field(field)
                }
                AdverseEventSeriousness::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventSeriousness::NonSerious(Some(e)) => e.get_field_mut(field),
                AdverseEventSeriousness::Serious(Some(e)) => e.get_field_mut(field),
                AdverseEventSeriousness::SeriousIsBirthDefect(Some(e)) => e.get_field_mut(field),
                AdverseEventSeriousness::SeriousIsLifeThreatening(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventSeriousness::SeriousRequiresPreventImpairment(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventSeriousness::SeriousResultsInDeath(Some(e)) => e.get_field_mut(field),
                AdverseEventSeriousness::SeriousResultsInDisability(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventSeriousness::SeriousResultsInHospitalization(Some(e)) => {
                    e.get_field_mut(field)
                }
                AdverseEventSeriousness::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AdverseEventSeverity {
    #[doc = "Mild"]
    #[code = "mild"]
    Mild(Option<Element>),
    #[doc = "Moderate"]
    #[code = "moderate"]
    Moderate(Option<Element>),
    #[doc = "Severe"]
    #[code = "severe"]
    Severe(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AdverseEventSeverity {
    fn default() -> Self {
        AdverseEventSeverity::Null(None)
    }
}
impl TryFrom<String> for AdverseEventSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "mild" => Ok(AdverseEventSeverity::Mild(None)),
            "moderate" => Ok(AdverseEventSeverity::Moderate(None)),
            "severe" => Ok(AdverseEventSeverity::Severe(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AdverseEventSeverity {
    fn into(self) -> Option<String> {
        match self {
            AdverseEventSeverity::Mild(_) => Some("mild".to_string()),
            AdverseEventSeverity::Moderate(_) => Some("moderate".to_string()),
            AdverseEventSeverity::Severe(_) => Some("severe".to_string()),
            AdverseEventSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for AdverseEventSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AdverseEventSeverity::Mild(Some(e)) => e.get_field(field),
                AdverseEventSeverity::Moderate(Some(e)) => e.get_field(field),
                AdverseEventSeverity::Severe(Some(e)) => e.get_field(field),
                AdverseEventSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AdverseEventSeverity::Mild(Some(e)) => e.get_field_mut(field),
                AdverseEventSeverity::Moderate(Some(e)) => e.get_field_mut(field),
                AdverseEventSeverity::Severe(Some(e)) => e.get_field_mut(field),
                AdverseEventSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AgeUnits {
    #[doc = "years"]
    #[code = "a"]
    A(Option<Element>),
    #[doc = "days"]
    #[code = "d"]
    D(Option<Element>),
    #[doc = "hours"]
    #[code = "h"]
    H(Option<Element>),
    #[doc = "minutes"]
    #[code = "min"]
    Min(Option<Element>),
    #[doc = "months"]
    #[code = "mo"]
    Mo(Option<Element>),
    #[doc = "weeks"]
    #[code = "wk"]
    Wk(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AgeUnits {
    fn default() -> Self {
        AgeUnits::Null(None)
    }
}
impl TryFrom<String> for AgeUnits {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a" => Ok(AgeUnits::A(None)),
            "d" => Ok(AgeUnits::D(None)),
            "h" => Ok(AgeUnits::H(None)),
            "min" => Ok(AgeUnits::Min(None)),
            "mo" => Ok(AgeUnits::Mo(None)),
            "wk" => Ok(AgeUnits::Wk(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AgeUnits {
    fn into(self) -> Option<String> {
        match self {
            AgeUnits::A(_) => Some("a".to_string()),
            AgeUnits::D(_) => Some("d".to_string()),
            AgeUnits::H(_) => Some("h".to_string()),
            AgeUnits::Min(_) => Some("min".to_string()),
            AgeUnits::Mo(_) => Some("mo".to_string()),
            AgeUnits::Wk(_) => Some("wk".to_string()),
            AgeUnits::Null(_) => None,
        }
    }
}
impl MetaValue for AgeUnits {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AgeUnits::A(Some(e)) => e.get_field(field),
                AgeUnits::D(Some(e)) => e.get_field(field),
                AgeUnits::H(Some(e)) => e.get_field(field),
                AgeUnits::Min(Some(e)) => e.get_field(field),
                AgeUnits::Mo(Some(e)) => e.get_field(field),
                AgeUnits::Wk(Some(e)) => e.get_field(field),
                AgeUnits::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AgeUnits::A(Some(e)) => e.get_field_mut(field),
                AgeUnits::D(Some(e)) => e.get_field_mut(field),
                AgeUnits::H(Some(e)) => e.get_field_mut(field),
                AgeUnits::Min(Some(e)) => e.get_field_mut(field),
                AgeUnits::Mo(Some(e)) => e.get_field_mut(field),
                AgeUnits::Wk(Some(e)) => e.get_field_mut(field),
                AgeUnits::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergIntolSubstanceExpRisk {
    #[doc = "Known Reaction Risk"]
    #[code = "known-reaction-risk"]
    KnownReactionRisk(Option<Element>),
    #[doc = "No Known Reaction Risk"]
    #[code = "no-known-reaction-risk"]
    NoKnownReactionRisk(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergIntolSubstanceExpRisk {
    fn default() -> Self {
        AllergIntolSubstanceExpRisk::Null(None)
    }
}
impl TryFrom<String> for AllergIntolSubstanceExpRisk {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "known-reaction-risk" => Ok(AllergIntolSubstanceExpRisk::KnownReactionRisk(None)),
            "no-known-reaction-risk" => Ok(AllergIntolSubstanceExpRisk::NoKnownReactionRisk(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergIntolSubstanceExpRisk {
    fn into(self) -> Option<String> {
        match self {
            AllergIntolSubstanceExpRisk::KnownReactionRisk(_) => {
                Some("known-reaction-risk".to_string())
            }
            AllergIntolSubstanceExpRisk::NoKnownReactionRisk(_) => {
                Some("no-known-reaction-risk".to_string())
            }
            AllergIntolSubstanceExpRisk::Null(_) => None,
        }
    }
}
impl MetaValue for AllergIntolSubstanceExpRisk {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergIntolSubstanceExpRisk::KnownReactionRisk(Some(e)) => e.get_field(field),
                AllergIntolSubstanceExpRisk::NoKnownReactionRisk(Some(e)) => e.get_field(field),
                AllergIntolSubstanceExpRisk::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergIntolSubstanceExpRisk::KnownReactionRisk(Some(e)) => e.get_field_mut(field),
                AllergIntolSubstanceExpRisk::NoKnownReactionRisk(Some(e)) => e.get_field_mut(field),
                AllergIntolSubstanceExpRisk::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergyIntoleranceCategory {
    #[doc = "Biologic"]
    #[code = "biologic"]
    Biologic(Option<Element>),
    #[doc = "Environment"]
    #[code = "environment"]
    Environment(Option<Element>),
    #[doc = "Food"]
    #[code = "food"]
    Food(Option<Element>),
    #[doc = "Medication"]
    #[code = "medication"]
    Medication(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergyIntoleranceCategory {
    fn default() -> Self {
        AllergyIntoleranceCategory::Null(None)
    }
}
impl TryFrom<String> for AllergyIntoleranceCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "biologic" => Ok(AllergyIntoleranceCategory::Biologic(None)),
            "environment" => Ok(AllergyIntoleranceCategory::Environment(None)),
            "food" => Ok(AllergyIntoleranceCategory::Food(None)),
            "medication" => Ok(AllergyIntoleranceCategory::Medication(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergyIntoleranceCategory {
    fn into(self) -> Option<String> {
        match self {
            AllergyIntoleranceCategory::Biologic(_) => Some("biologic".to_string()),
            AllergyIntoleranceCategory::Environment(_) => Some("environment".to_string()),
            AllergyIntoleranceCategory::Food(_) => Some("food".to_string()),
            AllergyIntoleranceCategory::Medication(_) => Some("medication".to_string()),
            AllergyIntoleranceCategory::Null(_) => None,
        }
    }
}
impl MetaValue for AllergyIntoleranceCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergyIntoleranceCategory::Biologic(Some(e)) => e.get_field(field),
                AllergyIntoleranceCategory::Environment(Some(e)) => e.get_field(field),
                AllergyIntoleranceCategory::Food(Some(e)) => e.get_field(field),
                AllergyIntoleranceCategory::Medication(Some(e)) => e.get_field(field),
                AllergyIntoleranceCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergyIntoleranceCategory::Biologic(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCategory::Environment(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCategory::Food(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCategory::Medication(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergyIntoleranceCriticality {
    #[doc = "High Risk"]
    #[code = "high"]
    High(Option<Element>),
    #[doc = "Low Risk"]
    #[code = "low"]
    Low(Option<Element>),
    #[doc = "Unable to Assess Risk"]
    #[code = "unable-to-assess"]
    UnableToAssess(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergyIntoleranceCriticality {
    fn default() -> Self {
        AllergyIntoleranceCriticality::Null(None)
    }
}
impl TryFrom<String> for AllergyIntoleranceCriticality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "high" => Ok(AllergyIntoleranceCriticality::High(None)),
            "low" => Ok(AllergyIntoleranceCriticality::Low(None)),
            "unable-to-assess" => Ok(AllergyIntoleranceCriticality::UnableToAssess(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergyIntoleranceCriticality {
    fn into(self) -> Option<String> {
        match self {
            AllergyIntoleranceCriticality::High(_) => Some("high".to_string()),
            AllergyIntoleranceCriticality::Low(_) => Some("low".to_string()),
            AllergyIntoleranceCriticality::UnableToAssess(_) => {
                Some("unable-to-assess".to_string())
            }
            AllergyIntoleranceCriticality::Null(_) => None,
        }
    }
}
impl MetaValue for AllergyIntoleranceCriticality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergyIntoleranceCriticality::High(Some(e)) => e.get_field(field),
                AllergyIntoleranceCriticality::Low(Some(e)) => e.get_field(field),
                AllergyIntoleranceCriticality::UnableToAssess(Some(e)) => e.get_field(field),
                AllergyIntoleranceCriticality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergyIntoleranceCriticality::High(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCriticality::Low(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCriticality::UnableToAssess(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceCriticality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergyIntoleranceType {
    #[doc = "Allergy"]
    #[code = "allergy"]
    Allergy(Option<Element>),
    #[doc = "Intolerance"]
    #[code = "intolerance"]
    Intolerance(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergyIntoleranceType {
    fn default() -> Self {
        AllergyIntoleranceType::Null(None)
    }
}
impl TryFrom<String> for AllergyIntoleranceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "allergy" => Ok(AllergyIntoleranceType::Allergy(None)),
            "intolerance" => Ok(AllergyIntoleranceType::Intolerance(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergyIntoleranceType {
    fn into(self) -> Option<String> {
        match self {
            AllergyIntoleranceType::Allergy(_) => Some("allergy".to_string()),
            AllergyIntoleranceType::Intolerance(_) => Some("intolerance".to_string()),
            AllergyIntoleranceType::Null(_) => None,
        }
    }
}
impl MetaValue for AllergyIntoleranceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergyIntoleranceType::Allergy(Some(e)) => e.get_field(field),
                AllergyIntoleranceType::Intolerance(Some(e)) => e.get_field(field),
                AllergyIntoleranceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergyIntoleranceType::Allergy(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceType::Intolerance(Some(e)) => e.get_field_mut(field),
                AllergyIntoleranceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergyintoleranceClinical {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergyintoleranceClinical {
    fn default() -> Self {
        AllergyintoleranceClinical::Null(None)
    }
}
impl TryFrom<String> for AllergyintoleranceClinical {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(AllergyintoleranceClinical::Active(None)),
            "inactive" => Ok(AllergyintoleranceClinical::Inactive(None)),
            "resolved" => Ok(AllergyintoleranceClinical::Resolved(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergyintoleranceClinical {
    fn into(self) -> Option<String> {
        match self {
            AllergyintoleranceClinical::Active(_) => Some("active".to_string()),
            AllergyintoleranceClinical::Inactive(_) => Some("inactive".to_string()),
            AllergyintoleranceClinical::Resolved(_) => Some("resolved".to_string()),
            AllergyintoleranceClinical::Null(_) => None,
        }
    }
}
impl MetaValue for AllergyintoleranceClinical {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergyintoleranceClinical::Active(Some(e)) => e.get_field(field),
                AllergyintoleranceClinical::Inactive(Some(e)) => e.get_field(field),
                AllergyintoleranceClinical::Resolved(Some(e)) => e.get_field(field),
                AllergyintoleranceClinical::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergyintoleranceClinical::Active(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceClinical::Inactive(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceClinical::Resolved(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceClinical::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AllergyintoleranceVerification {
    #[doc = "Confirmed"]
    #[code = "confirmed"]
    Confirmed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Refuted"]
    #[code = "refuted"]
    Refuted(Option<Element>),
    #[doc = "Unconfirmed"]
    #[code = "unconfirmed"]
    Unconfirmed(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AllergyintoleranceVerification {
    fn default() -> Self {
        AllergyintoleranceVerification::Null(None)
    }
}
impl TryFrom<String> for AllergyintoleranceVerification {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "confirmed" => Ok(AllergyintoleranceVerification::Confirmed(None)),
            "entered-in-error" => Ok(AllergyintoleranceVerification::EnteredInError(None)),
            "refuted" => Ok(AllergyintoleranceVerification::Refuted(None)),
            "unconfirmed" => Ok(AllergyintoleranceVerification::Unconfirmed(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AllergyintoleranceVerification {
    fn into(self) -> Option<String> {
        match self {
            AllergyintoleranceVerification::Confirmed(_) => Some("confirmed".to_string()),
            AllergyintoleranceVerification::EnteredInError(_) => {
                Some("entered-in-error".to_string())
            }
            AllergyintoleranceVerification::Refuted(_) => Some("refuted".to_string()),
            AllergyintoleranceVerification::Unconfirmed(_) => Some("unconfirmed".to_string()),
            AllergyintoleranceVerification::Null(_) => None,
        }
    }
}
impl MetaValue for AllergyintoleranceVerification {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AllergyintoleranceVerification::Confirmed(Some(e)) => e.get_field(field),
                AllergyintoleranceVerification::EnteredInError(Some(e)) => e.get_field(field),
                AllergyintoleranceVerification::Refuted(Some(e)) => e.get_field(field),
                AllergyintoleranceVerification::Unconfirmed(Some(e)) => e.get_field(field),
                AllergyintoleranceVerification::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AllergyintoleranceVerification::Confirmed(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceVerification::EnteredInError(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceVerification::Refuted(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceVerification::Unconfirmed(Some(e)) => e.get_field_mut(field),
                AllergyintoleranceVerification::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AnimalGenderstatus {
    #[doc = "Intact"]
    #[code = "intact"]
    Intact(Option<Element>),
    #[doc = "Neutered"]
    #[code = "neutered"]
    Neutered(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AnimalGenderstatus {
    fn default() -> Self {
        AnimalGenderstatus::Null(None)
    }
}
impl TryFrom<String> for AnimalGenderstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "intact" => Ok(AnimalGenderstatus::Intact(None)),
            "neutered" => Ok(AnimalGenderstatus::Neutered(None)),
            "unknown" => Ok(AnimalGenderstatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AnimalGenderstatus {
    fn into(self) -> Option<String> {
        match self {
            AnimalGenderstatus::Intact(_) => Some("intact".to_string()),
            AnimalGenderstatus::Neutered(_) => Some("neutered".to_string()),
            AnimalGenderstatus::Unknown(_) => Some("unknown".to_string()),
            AnimalGenderstatus::Null(_) => None,
        }
    }
}
impl MetaValue for AnimalGenderstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AnimalGenderstatus::Intact(Some(e)) => e.get_field(field),
                AnimalGenderstatus::Neutered(Some(e)) => e.get_field(field),
                AnimalGenderstatus::Unknown(Some(e)) => e.get_field(field),
                AnimalGenderstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AnimalGenderstatus::Intact(Some(e)) => e.get_field_mut(field),
                AnimalGenderstatus::Neutered(Some(e)) => e.get_field_mut(field),
                AnimalGenderstatus::Unknown(Some(e)) => e.get_field_mut(field),
                AnimalGenderstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AnimalSpecies {
    #[doc = "goat"]
    #[code = "125097000"]
    V125097000(Option<Element>),
    #[doc = "sheep"]
    #[code = "125099002"]
    V125099002(Option<Element>),
    #[doc = "mule"]
    #[code = "132950000"]
    V132950000(Option<Element>),
    #[doc = "goose"]
    #[code = "15778005"]
    V15778005(Option<Element>),
    #[doc = "cow"]
    #[code = "34618005"]
    V34618005(Option<Element>),
    #[doc = "horse"]
    #[code = "388445009"]
    V388445009(Option<Element>),
    #[doc = "duck"]
    #[code = "396620009"]
    V396620009(Option<Element>),
    #[doc = "turkey"]
    #[code = "425134008"]
    V425134008(Option<Element>),
    #[doc = "chicken"]
    #[code = "47290002"]
    V47290002(Option<Element>),
    #[doc = "donkey"]
    #[code = "85626006"]
    V85626006(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AnimalSpecies {
    fn default() -> Self {
        AnimalSpecies::Null(None)
    }
}
impl TryFrom<String> for AnimalSpecies {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "125097000" => Ok(AnimalSpecies::V125097000(None)),
            "125099002" => Ok(AnimalSpecies::V125099002(None)),
            "132950000" => Ok(AnimalSpecies::V132950000(None)),
            "15778005" => Ok(AnimalSpecies::V15778005(None)),
            "34618005" => Ok(AnimalSpecies::V34618005(None)),
            "388445009" => Ok(AnimalSpecies::V388445009(None)),
            "396620009" => Ok(AnimalSpecies::V396620009(None)),
            "425134008" => Ok(AnimalSpecies::V425134008(None)),
            "47290002" => Ok(AnimalSpecies::V47290002(None)),
            "85626006" => Ok(AnimalSpecies::V85626006(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AnimalSpecies {
    fn into(self) -> Option<String> {
        match self {
            AnimalSpecies::V125097000(_) => Some("125097000".to_string()),
            AnimalSpecies::V125099002(_) => Some("125099002".to_string()),
            AnimalSpecies::V132950000(_) => Some("132950000".to_string()),
            AnimalSpecies::V15778005(_) => Some("15778005".to_string()),
            AnimalSpecies::V34618005(_) => Some("34618005".to_string()),
            AnimalSpecies::V388445009(_) => Some("388445009".to_string()),
            AnimalSpecies::V396620009(_) => Some("396620009".to_string()),
            AnimalSpecies::V425134008(_) => Some("425134008".to_string()),
            AnimalSpecies::V47290002(_) => Some("47290002".to_string()),
            AnimalSpecies::V85626006(_) => Some("85626006".to_string()),
            AnimalSpecies::Null(_) => None,
        }
    }
}
impl MetaValue for AnimalSpecies {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AnimalSpecies::V125097000(Some(e)) => e.get_field(field),
                AnimalSpecies::V125099002(Some(e)) => e.get_field(field),
                AnimalSpecies::V132950000(Some(e)) => e.get_field(field),
                AnimalSpecies::V15778005(Some(e)) => e.get_field(field),
                AnimalSpecies::V34618005(Some(e)) => e.get_field(field),
                AnimalSpecies::V388445009(Some(e)) => e.get_field(field),
                AnimalSpecies::V396620009(Some(e)) => e.get_field(field),
                AnimalSpecies::V425134008(Some(e)) => e.get_field(field),
                AnimalSpecies::V47290002(Some(e)) => e.get_field(field),
                AnimalSpecies::V85626006(Some(e)) => e.get_field(field),
                AnimalSpecies::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AnimalSpecies::V125097000(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V125099002(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V132950000(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V15778005(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V34618005(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V388445009(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V396620009(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V425134008(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V47290002(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::V85626006(Some(e)) => e.get_field_mut(field),
                AnimalSpecies::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Appointmentstatus {
    #[doc = "Arrived"]
    #[code = "arrived"]
    Arrived(Option<Element>),
    #[doc = "Booked"]
    #[code = "booked"]
    Booked(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Checked In"]
    #[code = "checked-in"]
    CheckedIn(Option<Element>),
    #[doc = "Entered in error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Fulfilled"]
    #[code = "fulfilled"]
    Fulfilled(Option<Element>),
    #[doc = "No Show"]
    #[code = "noshow"]
    Noshow(Option<Element>),
    #[doc = "Pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "Proposed"]
    #[code = "proposed"]
    Proposed(Option<Element>),
    #[doc = "Waitlisted"]
    #[code = "waitlist"]
    Waitlist(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Appointmentstatus {
    fn default() -> Self {
        Appointmentstatus::Null(None)
    }
}
impl TryFrom<String> for Appointmentstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "arrived" => Ok(Appointmentstatus::Arrived(None)),
            "booked" => Ok(Appointmentstatus::Booked(None)),
            "cancelled" => Ok(Appointmentstatus::Cancelled(None)),
            "checked-in" => Ok(Appointmentstatus::CheckedIn(None)),
            "entered-in-error" => Ok(Appointmentstatus::EnteredInError(None)),
            "fulfilled" => Ok(Appointmentstatus::Fulfilled(None)),
            "noshow" => Ok(Appointmentstatus::Noshow(None)),
            "pending" => Ok(Appointmentstatus::Pending(None)),
            "proposed" => Ok(Appointmentstatus::Proposed(None)),
            "waitlist" => Ok(Appointmentstatus::Waitlist(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Appointmentstatus {
    fn into(self) -> Option<String> {
        match self {
            Appointmentstatus::Arrived(_) => Some("arrived".to_string()),
            Appointmentstatus::Booked(_) => Some("booked".to_string()),
            Appointmentstatus::Cancelled(_) => Some("cancelled".to_string()),
            Appointmentstatus::CheckedIn(_) => Some("checked-in".to_string()),
            Appointmentstatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            Appointmentstatus::Fulfilled(_) => Some("fulfilled".to_string()),
            Appointmentstatus::Noshow(_) => Some("noshow".to_string()),
            Appointmentstatus::Pending(_) => Some("pending".to_string()),
            Appointmentstatus::Proposed(_) => Some("proposed".to_string()),
            Appointmentstatus::Waitlist(_) => Some("waitlist".to_string()),
            Appointmentstatus::Null(_) => None,
        }
    }
}
impl MetaValue for Appointmentstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Appointmentstatus::Arrived(Some(e)) => e.get_field(field),
                Appointmentstatus::Booked(Some(e)) => e.get_field(field),
                Appointmentstatus::Cancelled(Some(e)) => e.get_field(field),
                Appointmentstatus::CheckedIn(Some(e)) => e.get_field(field),
                Appointmentstatus::EnteredInError(Some(e)) => e.get_field(field),
                Appointmentstatus::Fulfilled(Some(e)) => e.get_field(field),
                Appointmentstatus::Noshow(Some(e)) => e.get_field(field),
                Appointmentstatus::Pending(Some(e)) => e.get_field(field),
                Appointmentstatus::Proposed(Some(e)) => e.get_field(field),
                Appointmentstatus::Waitlist(Some(e)) => e.get_field(field),
                Appointmentstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Appointmentstatus::Arrived(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Booked(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Cancelled(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::CheckedIn(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Fulfilled(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Noshow(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Pending(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Proposed(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Waitlist(Some(e)) => e.get_field_mut(field),
                Appointmentstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AssertDirectionCodes {
    #[doc = "request"]
    #[code = "request"]
    Request(Option<Element>),
    #[doc = "response"]
    #[code = "response"]
    Response(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AssertDirectionCodes {
    fn default() -> Self {
        AssertDirectionCodes::Null(None)
    }
}
impl TryFrom<String> for AssertDirectionCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "request" => Ok(AssertDirectionCodes::Request(None)),
            "response" => Ok(AssertDirectionCodes::Response(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AssertDirectionCodes {
    fn into(self) -> Option<String> {
        match self {
            AssertDirectionCodes::Request(_) => Some("request".to_string()),
            AssertDirectionCodes::Response(_) => Some("response".to_string()),
            AssertDirectionCodes::Null(_) => None,
        }
    }
}
impl MetaValue for AssertDirectionCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AssertDirectionCodes::Request(Some(e)) => e.get_field(field),
                AssertDirectionCodes::Response(Some(e)) => e.get_field(field),
                AssertDirectionCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AssertDirectionCodes::Request(Some(e)) => e.get_field_mut(field),
                AssertDirectionCodes::Response(Some(e)) => e.get_field_mut(field),
                AssertDirectionCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AssertOperatorCodes {
    #[doc = "contains"]
    #[code = "contains"]
    Contains(Option<Element>),
    #[doc = "empty"]
    #[code = "empty"]
    Empty(Option<Element>),
    #[doc = "equals"]
    #[code = "equals"]
    Equals(Option<Element>),
    #[doc = "evaluate"]
    #[code = "eval"]
    Eval(Option<Element>),
    #[doc = "greaterThan"]
    #[code = "greaterThan"]
    GreaterThan(Option<Element>),
    #[doc = "in"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "lessThan"]
    #[code = "lessThan"]
    LessThan(Option<Element>),
    #[doc = "notContains"]
    #[code = "notContains"]
    NotContains(Option<Element>),
    #[doc = "notEmpty"]
    #[code = "notEmpty"]
    NotEmpty(Option<Element>),
    #[doc = "notEquals"]
    #[code = "notEquals"]
    NotEquals(Option<Element>),
    #[doc = "notIn"]
    #[code = "notIn"]
    NotIn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AssertOperatorCodes {
    fn default() -> Self {
        AssertOperatorCodes::Null(None)
    }
}
impl TryFrom<String> for AssertOperatorCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "contains" => Ok(AssertOperatorCodes::Contains(None)),
            "empty" => Ok(AssertOperatorCodes::Empty(None)),
            "equals" => Ok(AssertOperatorCodes::Equals(None)),
            "eval" => Ok(AssertOperatorCodes::Eval(None)),
            "greaterThan" => Ok(AssertOperatorCodes::GreaterThan(None)),
            "in" => Ok(AssertOperatorCodes::In(None)),
            "lessThan" => Ok(AssertOperatorCodes::LessThan(None)),
            "notContains" => Ok(AssertOperatorCodes::NotContains(None)),
            "notEmpty" => Ok(AssertOperatorCodes::NotEmpty(None)),
            "notEquals" => Ok(AssertOperatorCodes::NotEquals(None)),
            "notIn" => Ok(AssertOperatorCodes::NotIn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AssertOperatorCodes {
    fn into(self) -> Option<String> {
        match self {
            AssertOperatorCodes::Contains(_) => Some("contains".to_string()),
            AssertOperatorCodes::Empty(_) => Some("empty".to_string()),
            AssertOperatorCodes::Equals(_) => Some("equals".to_string()),
            AssertOperatorCodes::Eval(_) => Some("eval".to_string()),
            AssertOperatorCodes::GreaterThan(_) => Some("greaterThan".to_string()),
            AssertOperatorCodes::In(_) => Some("in".to_string()),
            AssertOperatorCodes::LessThan(_) => Some("lessThan".to_string()),
            AssertOperatorCodes::NotContains(_) => Some("notContains".to_string()),
            AssertOperatorCodes::NotEmpty(_) => Some("notEmpty".to_string()),
            AssertOperatorCodes::NotEquals(_) => Some("notEquals".to_string()),
            AssertOperatorCodes::NotIn(_) => Some("notIn".to_string()),
            AssertOperatorCodes::Null(_) => None,
        }
    }
}
impl MetaValue for AssertOperatorCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AssertOperatorCodes::Contains(Some(e)) => e.get_field(field),
                AssertOperatorCodes::Empty(Some(e)) => e.get_field(field),
                AssertOperatorCodes::Equals(Some(e)) => e.get_field(field),
                AssertOperatorCodes::Eval(Some(e)) => e.get_field(field),
                AssertOperatorCodes::GreaterThan(Some(e)) => e.get_field(field),
                AssertOperatorCodes::In(Some(e)) => e.get_field(field),
                AssertOperatorCodes::LessThan(Some(e)) => e.get_field(field),
                AssertOperatorCodes::NotContains(Some(e)) => e.get_field(field),
                AssertOperatorCodes::NotEmpty(Some(e)) => e.get_field(field),
                AssertOperatorCodes::NotEquals(Some(e)) => e.get_field(field),
                AssertOperatorCodes::NotIn(Some(e)) => e.get_field(field),
                AssertOperatorCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AssertOperatorCodes::Contains(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::Empty(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::Equals(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::Eval(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::GreaterThan(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::In(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::LessThan(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::NotContains(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::NotEmpty(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::NotEquals(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::NotIn(Some(e)) => e.get_field_mut(field),
                AssertOperatorCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AssertResponseCodeTypes {
    #[doc = "bad"]
    #[code = "bad"]
    Bad(Option<Element>),
    #[doc = "conflict"]
    #[code = "conflict"]
    Conflict(Option<Element>),
    #[doc = "created"]
    #[code = "created"]
    Created(Option<Element>),
    #[doc = "forbidden"]
    #[code = "forbidden"]
    Forbidden(Option<Element>),
    #[doc = "gone"]
    #[code = "gone"]
    Gone(Option<Element>),
    #[doc = "methodNotAllowed"]
    #[code = "methodNotAllowed"]
    MethodNotAllowed(Option<Element>),
    #[doc = "noContent"]
    #[code = "noContent"]
    NoContent(Option<Element>),
    #[doc = "notFound"]
    #[code = "notFound"]
    NotFound(Option<Element>),
    #[doc = "notModified"]
    #[code = "notModified"]
    NotModified(Option<Element>),
    #[doc = "okay"]
    #[code = "okay"]
    Okay(Option<Element>),
    #[doc = "preconditionFailed"]
    #[code = "preconditionFailed"]
    PreconditionFailed(Option<Element>),
    #[doc = "unprocessable"]
    #[code = "unprocessable"]
    Unprocessable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AssertResponseCodeTypes {
    fn default() -> Self {
        AssertResponseCodeTypes::Null(None)
    }
}
impl TryFrom<String> for AssertResponseCodeTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "bad" => Ok(AssertResponseCodeTypes::Bad(None)),
            "conflict" => Ok(AssertResponseCodeTypes::Conflict(None)),
            "created" => Ok(AssertResponseCodeTypes::Created(None)),
            "forbidden" => Ok(AssertResponseCodeTypes::Forbidden(None)),
            "gone" => Ok(AssertResponseCodeTypes::Gone(None)),
            "methodNotAllowed" => Ok(AssertResponseCodeTypes::MethodNotAllowed(None)),
            "noContent" => Ok(AssertResponseCodeTypes::NoContent(None)),
            "notFound" => Ok(AssertResponseCodeTypes::NotFound(None)),
            "notModified" => Ok(AssertResponseCodeTypes::NotModified(None)),
            "okay" => Ok(AssertResponseCodeTypes::Okay(None)),
            "preconditionFailed" => Ok(AssertResponseCodeTypes::PreconditionFailed(None)),
            "unprocessable" => Ok(AssertResponseCodeTypes::Unprocessable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AssertResponseCodeTypes {
    fn into(self) -> Option<String> {
        match self {
            AssertResponseCodeTypes::Bad(_) => Some("bad".to_string()),
            AssertResponseCodeTypes::Conflict(_) => Some("conflict".to_string()),
            AssertResponseCodeTypes::Created(_) => Some("created".to_string()),
            AssertResponseCodeTypes::Forbidden(_) => Some("forbidden".to_string()),
            AssertResponseCodeTypes::Gone(_) => Some("gone".to_string()),
            AssertResponseCodeTypes::MethodNotAllowed(_) => Some("methodNotAllowed".to_string()),
            AssertResponseCodeTypes::NoContent(_) => Some("noContent".to_string()),
            AssertResponseCodeTypes::NotFound(_) => Some("notFound".to_string()),
            AssertResponseCodeTypes::NotModified(_) => Some("notModified".to_string()),
            AssertResponseCodeTypes::Okay(_) => Some("okay".to_string()),
            AssertResponseCodeTypes::PreconditionFailed(_) => {
                Some("preconditionFailed".to_string())
            }
            AssertResponseCodeTypes::Unprocessable(_) => Some("unprocessable".to_string()),
            AssertResponseCodeTypes::Null(_) => None,
        }
    }
}
impl MetaValue for AssertResponseCodeTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AssertResponseCodeTypes::Bad(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Conflict(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Created(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Forbidden(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Gone(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::MethodNotAllowed(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::NoContent(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::NotFound(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::NotModified(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Okay(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::PreconditionFailed(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Unprocessable(Some(e)) => e.get_field(field),
                AssertResponseCodeTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AssertResponseCodeTypes::Bad(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Conflict(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Created(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Forbidden(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Gone(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::MethodNotAllowed(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::NoContent(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::NotFound(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::NotModified(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Okay(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::PreconditionFailed(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Unprocessable(Some(e)) => e.get_field_mut(field),
                AssertResponseCodeTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AssetAvailability {
    #[doc = "Lease"]
    #[code = "lease"]
    Lease(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AssetAvailability {
    fn default() -> Self {
        AssetAvailability::Null(None)
    }
}
impl TryFrom<String> for AssetAvailability {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "lease" => Ok(AssetAvailability::Lease(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AssetAvailability {
    fn into(self) -> Option<String> {
        match self {
            AssetAvailability::Lease(_) => Some("lease".to_string()),
            AssetAvailability::Null(_) => None,
        }
    }
}
impl MetaValue for AssetAvailability {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AssetAvailability::Lease(Some(e)) => e.get_field(field),
                AssetAvailability::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AssetAvailability::Lease(Some(e)) => e.get_field_mut(field),
                AssetAvailability::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AuditEventAction {
    #[doc = "Create"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "Delete"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Execute"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "Read/View/Print"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Update"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AuditEventAction {
    fn default() -> Self {
        AuditEventAction::Null(None)
    }
}
impl TryFrom<String> for AuditEventAction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C" => Ok(AuditEventAction::C(None)),
            "D" => Ok(AuditEventAction::D(None)),
            "E" => Ok(AuditEventAction::E(None)),
            "R" => Ok(AuditEventAction::R(None)),
            "U" => Ok(AuditEventAction::U(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AuditEventAction {
    fn into(self) -> Option<String> {
        match self {
            AuditEventAction::C(_) => Some("C".to_string()),
            AuditEventAction::D(_) => Some("D".to_string()),
            AuditEventAction::E(_) => Some("E".to_string()),
            AuditEventAction::R(_) => Some("R".to_string()),
            AuditEventAction::U(_) => Some("U".to_string()),
            AuditEventAction::Null(_) => None,
        }
    }
}
impl MetaValue for AuditEventAction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AuditEventAction::C(Some(e)) => e.get_field(field),
                AuditEventAction::D(Some(e)) => e.get_field(field),
                AuditEventAction::E(Some(e)) => e.get_field(field),
                AuditEventAction::R(Some(e)) => e.get_field(field),
                AuditEventAction::U(Some(e)) => e.get_field(field),
                AuditEventAction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AuditEventAction::C(Some(e)) => e.get_field_mut(field),
                AuditEventAction::D(Some(e)) => e.get_field_mut(field),
                AuditEventAction::E(Some(e)) => e.get_field_mut(field),
                AuditEventAction::R(Some(e)) => e.get_field_mut(field),
                AuditEventAction::U(Some(e)) => e.get_field_mut(field),
                AuditEventAction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AuditEventOutcome {
    #[doc = "Success"]
    #[code = "0"]
    V0(Option<Element>),
    #[doc = "Major failure"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "Minor failure"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Serious failure"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AuditEventOutcome {
    fn default() -> Self {
        AuditEventOutcome::Null(None)
    }
}
impl TryFrom<String> for AuditEventOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "0" => Ok(AuditEventOutcome::V0(None)),
            "12" => Ok(AuditEventOutcome::V12(None)),
            "4" => Ok(AuditEventOutcome::V4(None)),
            "8" => Ok(AuditEventOutcome::V8(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AuditEventOutcome {
    fn into(self) -> Option<String> {
        match self {
            AuditEventOutcome::V0(_) => Some("0".to_string()),
            AuditEventOutcome::V12(_) => Some("12".to_string()),
            AuditEventOutcome::V4(_) => Some("4".to_string()),
            AuditEventOutcome::V8(_) => Some("8".to_string()),
            AuditEventOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for AuditEventOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AuditEventOutcome::V0(Some(e)) => e.get_field(field),
                AuditEventOutcome::V12(Some(e)) => e.get_field(field),
                AuditEventOutcome::V4(Some(e)) => e.get_field(field),
                AuditEventOutcome::V8(Some(e)) => e.get_field(field),
                AuditEventOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AuditEventOutcome::V0(Some(e)) => e.get_field_mut(field),
                AuditEventOutcome::V12(Some(e)) => e.get_field_mut(field),
                AuditEventOutcome::V4(Some(e)) => e.get_field_mut(field),
                AuditEventOutcome::V8(Some(e)) => e.get_field_mut(field),
                AuditEventOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AuditEventSubType {
    #[code = "110120"]
    V110120(Option<Element>),
    #[code = "110121"]
    V110121(Option<Element>),
    #[code = "110122"]
    V110122(Option<Element>),
    #[code = "110123"]
    V110123(Option<Element>),
    #[code = "110124"]
    V110124(Option<Element>),
    #[code = "110125"]
    V110125(Option<Element>),
    #[code = "110126"]
    V110126(Option<Element>),
    #[code = "110127"]
    V110127(Option<Element>),
    #[code = "110128"]
    V110128(Option<Element>),
    #[code = "110129"]
    V110129(Option<Element>),
    #[code = "110130"]
    V110130(Option<Element>),
    #[code = "110131"]
    V110131(Option<Element>),
    #[code = "110132"]
    V110132(Option<Element>),
    #[code = "110133"]
    V110133(Option<Element>),
    #[code = "110134"]
    V110134(Option<Element>),
    #[code = "110135"]
    V110135(Option<Element>),
    #[code = "110136"]
    V110136(Option<Element>),
    #[code = "110137"]
    V110137(Option<Element>),
    #[code = "110138"]
    V110138(Option<Element>),
    #[code = "110139"]
    V110139(Option<Element>),
    #[code = "110140"]
    V110140(Option<Element>),
    #[code = "110141"]
    V110141(Option<Element>),
    #[code = "110142"]
    V110142(Option<Element>),
    #[doc = "batch"]
    #[code = "batch"]
    Batch(Option<Element>),
    #[doc = "capabilities"]
    #[code = "capabilities"]
    Capabilities(Option<Element>),
    #[doc = "create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "delete"]
    #[code = "delete"]
    Delete(Option<Element>),
    #[doc = "history"]
    #[code = "history"]
    History(Option<Element>),
    #[doc = "history-instance"]
    #[code = "history-instance"]
    HistoryInstance(Option<Element>),
    #[doc = "history-system"]
    #[code = "history-system"]
    HistorySystem(Option<Element>),
    #[doc = "history-type"]
    #[code = "history-type"]
    HistoryType(Option<Element>),
    #[doc = "operation"]
    #[code = "operation"]
    Operation(Option<Element>),
    #[doc = "patch"]
    #[code = "patch"]
    Patch(Option<Element>),
    #[doc = "read"]
    #[code = "read"]
    Read(Option<Element>),
    #[doc = "search"]
    #[code = "search"]
    Search(Option<Element>),
    #[doc = "search-system"]
    #[code = "search-system"]
    SearchSystem(Option<Element>),
    #[doc = "search-type"]
    #[code = "search-type"]
    SearchType(Option<Element>),
    #[doc = "transaction"]
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "update"]
    #[code = "update"]
    Update(Option<Element>),
    #[doc = "vread"]
    #[code = "vread"]
    Vread(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AuditEventSubType {
    fn default() -> Self {
        AuditEventSubType::Null(None)
    }
}
impl TryFrom<String> for AuditEventSubType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "110120" => Ok(AuditEventSubType::V110120(None)),
            "110121" => Ok(AuditEventSubType::V110121(None)),
            "110122" => Ok(AuditEventSubType::V110122(None)),
            "110123" => Ok(AuditEventSubType::V110123(None)),
            "110124" => Ok(AuditEventSubType::V110124(None)),
            "110125" => Ok(AuditEventSubType::V110125(None)),
            "110126" => Ok(AuditEventSubType::V110126(None)),
            "110127" => Ok(AuditEventSubType::V110127(None)),
            "110128" => Ok(AuditEventSubType::V110128(None)),
            "110129" => Ok(AuditEventSubType::V110129(None)),
            "110130" => Ok(AuditEventSubType::V110130(None)),
            "110131" => Ok(AuditEventSubType::V110131(None)),
            "110132" => Ok(AuditEventSubType::V110132(None)),
            "110133" => Ok(AuditEventSubType::V110133(None)),
            "110134" => Ok(AuditEventSubType::V110134(None)),
            "110135" => Ok(AuditEventSubType::V110135(None)),
            "110136" => Ok(AuditEventSubType::V110136(None)),
            "110137" => Ok(AuditEventSubType::V110137(None)),
            "110138" => Ok(AuditEventSubType::V110138(None)),
            "110139" => Ok(AuditEventSubType::V110139(None)),
            "110140" => Ok(AuditEventSubType::V110140(None)),
            "110141" => Ok(AuditEventSubType::V110141(None)),
            "110142" => Ok(AuditEventSubType::V110142(None)),
            "batch" => Ok(AuditEventSubType::Batch(None)),
            "capabilities" => Ok(AuditEventSubType::Capabilities(None)),
            "create" => Ok(AuditEventSubType::Create(None)),
            "delete" => Ok(AuditEventSubType::Delete(None)),
            "history" => Ok(AuditEventSubType::History(None)),
            "history-instance" => Ok(AuditEventSubType::HistoryInstance(None)),
            "history-system" => Ok(AuditEventSubType::HistorySystem(None)),
            "history-type" => Ok(AuditEventSubType::HistoryType(None)),
            "operation" => Ok(AuditEventSubType::Operation(None)),
            "patch" => Ok(AuditEventSubType::Patch(None)),
            "read" => Ok(AuditEventSubType::Read(None)),
            "search" => Ok(AuditEventSubType::Search(None)),
            "search-system" => Ok(AuditEventSubType::SearchSystem(None)),
            "search-type" => Ok(AuditEventSubType::SearchType(None)),
            "transaction" => Ok(AuditEventSubType::Transaction(None)),
            "update" => Ok(AuditEventSubType::Update(None)),
            "vread" => Ok(AuditEventSubType::Vread(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AuditEventSubType {
    fn into(self) -> Option<String> {
        match self {
            AuditEventSubType::V110120(_) => Some("110120".to_string()),
            AuditEventSubType::V110121(_) => Some("110121".to_string()),
            AuditEventSubType::V110122(_) => Some("110122".to_string()),
            AuditEventSubType::V110123(_) => Some("110123".to_string()),
            AuditEventSubType::V110124(_) => Some("110124".to_string()),
            AuditEventSubType::V110125(_) => Some("110125".to_string()),
            AuditEventSubType::V110126(_) => Some("110126".to_string()),
            AuditEventSubType::V110127(_) => Some("110127".to_string()),
            AuditEventSubType::V110128(_) => Some("110128".to_string()),
            AuditEventSubType::V110129(_) => Some("110129".to_string()),
            AuditEventSubType::V110130(_) => Some("110130".to_string()),
            AuditEventSubType::V110131(_) => Some("110131".to_string()),
            AuditEventSubType::V110132(_) => Some("110132".to_string()),
            AuditEventSubType::V110133(_) => Some("110133".to_string()),
            AuditEventSubType::V110134(_) => Some("110134".to_string()),
            AuditEventSubType::V110135(_) => Some("110135".to_string()),
            AuditEventSubType::V110136(_) => Some("110136".to_string()),
            AuditEventSubType::V110137(_) => Some("110137".to_string()),
            AuditEventSubType::V110138(_) => Some("110138".to_string()),
            AuditEventSubType::V110139(_) => Some("110139".to_string()),
            AuditEventSubType::V110140(_) => Some("110140".to_string()),
            AuditEventSubType::V110141(_) => Some("110141".to_string()),
            AuditEventSubType::V110142(_) => Some("110142".to_string()),
            AuditEventSubType::Batch(_) => Some("batch".to_string()),
            AuditEventSubType::Capabilities(_) => Some("capabilities".to_string()),
            AuditEventSubType::Create(_) => Some("create".to_string()),
            AuditEventSubType::Delete(_) => Some("delete".to_string()),
            AuditEventSubType::History(_) => Some("history".to_string()),
            AuditEventSubType::HistoryInstance(_) => Some("history-instance".to_string()),
            AuditEventSubType::HistorySystem(_) => Some("history-system".to_string()),
            AuditEventSubType::HistoryType(_) => Some("history-type".to_string()),
            AuditEventSubType::Operation(_) => Some("operation".to_string()),
            AuditEventSubType::Patch(_) => Some("patch".to_string()),
            AuditEventSubType::Read(_) => Some("read".to_string()),
            AuditEventSubType::Search(_) => Some("search".to_string()),
            AuditEventSubType::SearchSystem(_) => Some("search-system".to_string()),
            AuditEventSubType::SearchType(_) => Some("search-type".to_string()),
            AuditEventSubType::Transaction(_) => Some("transaction".to_string()),
            AuditEventSubType::Update(_) => Some("update".to_string()),
            AuditEventSubType::Vread(_) => Some("vread".to_string()),
            AuditEventSubType::Null(_) => None,
        }
    }
}
impl MetaValue for AuditEventSubType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AuditEventSubType::V110120(Some(e)) => e.get_field(field),
                AuditEventSubType::V110121(Some(e)) => e.get_field(field),
                AuditEventSubType::V110122(Some(e)) => e.get_field(field),
                AuditEventSubType::V110123(Some(e)) => e.get_field(field),
                AuditEventSubType::V110124(Some(e)) => e.get_field(field),
                AuditEventSubType::V110125(Some(e)) => e.get_field(field),
                AuditEventSubType::V110126(Some(e)) => e.get_field(field),
                AuditEventSubType::V110127(Some(e)) => e.get_field(field),
                AuditEventSubType::V110128(Some(e)) => e.get_field(field),
                AuditEventSubType::V110129(Some(e)) => e.get_field(field),
                AuditEventSubType::V110130(Some(e)) => e.get_field(field),
                AuditEventSubType::V110131(Some(e)) => e.get_field(field),
                AuditEventSubType::V110132(Some(e)) => e.get_field(field),
                AuditEventSubType::V110133(Some(e)) => e.get_field(field),
                AuditEventSubType::V110134(Some(e)) => e.get_field(field),
                AuditEventSubType::V110135(Some(e)) => e.get_field(field),
                AuditEventSubType::V110136(Some(e)) => e.get_field(field),
                AuditEventSubType::V110137(Some(e)) => e.get_field(field),
                AuditEventSubType::V110138(Some(e)) => e.get_field(field),
                AuditEventSubType::V110139(Some(e)) => e.get_field(field),
                AuditEventSubType::V110140(Some(e)) => e.get_field(field),
                AuditEventSubType::V110141(Some(e)) => e.get_field(field),
                AuditEventSubType::V110142(Some(e)) => e.get_field(field),
                AuditEventSubType::Batch(Some(e)) => e.get_field(field),
                AuditEventSubType::Capabilities(Some(e)) => e.get_field(field),
                AuditEventSubType::Create(Some(e)) => e.get_field(field),
                AuditEventSubType::Delete(Some(e)) => e.get_field(field),
                AuditEventSubType::History(Some(e)) => e.get_field(field),
                AuditEventSubType::HistoryInstance(Some(e)) => e.get_field(field),
                AuditEventSubType::HistorySystem(Some(e)) => e.get_field(field),
                AuditEventSubType::HistoryType(Some(e)) => e.get_field(field),
                AuditEventSubType::Operation(Some(e)) => e.get_field(field),
                AuditEventSubType::Patch(Some(e)) => e.get_field(field),
                AuditEventSubType::Read(Some(e)) => e.get_field(field),
                AuditEventSubType::Search(Some(e)) => e.get_field(field),
                AuditEventSubType::SearchSystem(Some(e)) => e.get_field(field),
                AuditEventSubType::SearchType(Some(e)) => e.get_field(field),
                AuditEventSubType::Transaction(Some(e)) => e.get_field(field),
                AuditEventSubType::Update(Some(e)) => e.get_field(field),
                AuditEventSubType::Vread(Some(e)) => e.get_field(field),
                AuditEventSubType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AuditEventSubType::V110120(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110121(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110122(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110123(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110124(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110125(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110126(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110127(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110128(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110129(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110130(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110131(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110132(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110133(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110134(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110135(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110136(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110137(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110138(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110139(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110140(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110141(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::V110142(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Batch(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Capabilities(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Create(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Delete(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::History(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::HistoryInstance(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::HistorySystem(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::HistoryType(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Operation(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Patch(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Read(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Search(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::SearchSystem(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::SearchType(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Transaction(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Update(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Vread(Some(e)) => e.get_field_mut(field),
                AuditEventSubType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AuditEventType {
    #[code = "110100"]
    V110100(Option<Element>),
    #[code = "110101"]
    V110101(Option<Element>),
    #[code = "110102"]
    V110102(Option<Element>),
    #[code = "110103"]
    V110103(Option<Element>),
    #[code = "110104"]
    V110104(Option<Element>),
    #[code = "110105"]
    V110105(Option<Element>),
    #[code = "110106"]
    V110106(Option<Element>),
    #[code = "110107"]
    V110107(Option<Element>),
    #[code = "110108"]
    V110108(Option<Element>),
    #[code = "110109"]
    V110109(Option<Element>),
    #[code = "110110"]
    V110110(Option<Element>),
    #[code = "110111"]
    V110111(Option<Element>),
    #[code = "110112"]
    V110112(Option<Element>),
    #[code = "110113"]
    V110113(Option<Element>),
    #[code = "110114"]
    V110114(Option<Element>),
    #[doc = "Access/View Record Lifecycle Event"]
    #[code = "access"]
    Access(Option<Element>),
    #[doc = "Amend (Update) Record Lifecycle Event"]
    #[code = "amend"]
    Amend(Option<Element>),
    #[doc = "Archive Record Lifecycle Event"]
    #[code = "archive"]
    Archive(Option<Element>),
    #[doc = "Attest Record Lifecycle Event"]
    #[code = "attest"]
    Attest(Option<Element>),
    #[doc = "Decrypt Record Lifecycle Event"]
    #[code = "decrypt"]
    Decrypt(Option<Element>),
    #[doc = "De-Identify (Anononymize) Record Lifecycle Event"]
    #[code = "deidentify"]
    Deidentify(Option<Element>),
    #[doc = "Deprecate Record Lifecycle Event"]
    #[code = "deprecate"]
    Deprecate(Option<Element>),
    #[doc = "Destroy/Delete Record Lifecycle Event"]
    #[code = "destroy"]
    Destroy(Option<Element>),
    #[doc = "Disclose Record Lifecycle Event"]
    #[code = "disclose"]
    Disclose(Option<Element>),
    #[doc = "Encrypt Record Lifecycle Event"]
    #[code = "encrypt"]
    Encrypt(Option<Element>),
    #[doc = "Extract Record Lifecycle Event"]
    #[code = "extract"]
    Extract(Option<Element>),
    #[doc = "Add Legal Hold Record Lifecycle Event"]
    #[code = "hold"]
    Hold(Option<Element>),
    #[doc = "Link Record Lifecycle Event"]
    #[code = "link"]
    Link(Option<Element>),
    #[doc = "Merge Record Lifecycle Event"]
    #[code = "merge"]
    Merge(Option<Element>),
    #[doc = "Originate/Retain Record Lifecycle Event"]
    #[code = "originate"]
    Originate(Option<Element>),
    #[doc = "Pseudonymize Record Lifecycle Event"]
    #[code = "pseudonymize"]
    Pseudonymize(Option<Element>),
    #[doc = "Re-activate Record Lifecycle Event"]
    #[code = "reactivate"]
    Reactivate(Option<Element>),
    #[doc = "Receive/Retain Record Lifecycle Event"]
    #[code = "receive"]
    Receive(Option<Element>),
    #[doc = "Re-identify Record Lifecycle Event"]
    #[code = "reidentify"]
    Reidentify(Option<Element>),
    #[doc = "Report (Output) Record Lifecycle Event"]
    #[code = "report"]
    Report(Option<Element>),
    #[doc = "RESTful Operation"]
    #[code = "rest"]
    Rest(Option<Element>),
    #[doc = "Restore Record Lifecycle Event"]
    #[code = "restore"]
    Restore(Option<Element>),
    #[doc = "Transform/Translate Record Lifecycle Event"]
    #[code = "transform"]
    Transform(Option<Element>),
    #[doc = "Transmit Record Lifecycle Event"]
    #[code = "transmit"]
    Transmit(Option<Element>),
    #[doc = "Remove Legal Hold Record Lifecycle Event"]
    #[code = "unhold"]
    Unhold(Option<Element>),
    #[doc = "Unlink Record Lifecycle Event"]
    #[code = "unlink"]
    Unlink(Option<Element>),
    #[doc = "Unmerge Record Lifecycle Event"]
    #[code = "unmerge"]
    Unmerge(Option<Element>),
    #[doc = "Verify Record Lifecycle Event"]
    #[code = "verify"]
    Verify(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AuditEventType {
    fn default() -> Self {
        AuditEventType::Null(None)
    }
}
impl TryFrom<String> for AuditEventType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "110100" => Ok(AuditEventType::V110100(None)),
            "110101" => Ok(AuditEventType::V110101(None)),
            "110102" => Ok(AuditEventType::V110102(None)),
            "110103" => Ok(AuditEventType::V110103(None)),
            "110104" => Ok(AuditEventType::V110104(None)),
            "110105" => Ok(AuditEventType::V110105(None)),
            "110106" => Ok(AuditEventType::V110106(None)),
            "110107" => Ok(AuditEventType::V110107(None)),
            "110108" => Ok(AuditEventType::V110108(None)),
            "110109" => Ok(AuditEventType::V110109(None)),
            "110110" => Ok(AuditEventType::V110110(None)),
            "110111" => Ok(AuditEventType::V110111(None)),
            "110112" => Ok(AuditEventType::V110112(None)),
            "110113" => Ok(AuditEventType::V110113(None)),
            "110114" => Ok(AuditEventType::V110114(None)),
            "access" => Ok(AuditEventType::Access(None)),
            "amend" => Ok(AuditEventType::Amend(None)),
            "archive" => Ok(AuditEventType::Archive(None)),
            "attest" => Ok(AuditEventType::Attest(None)),
            "decrypt" => Ok(AuditEventType::Decrypt(None)),
            "deidentify" => Ok(AuditEventType::Deidentify(None)),
            "deprecate" => Ok(AuditEventType::Deprecate(None)),
            "destroy" => Ok(AuditEventType::Destroy(None)),
            "disclose" => Ok(AuditEventType::Disclose(None)),
            "encrypt" => Ok(AuditEventType::Encrypt(None)),
            "extract" => Ok(AuditEventType::Extract(None)),
            "hold" => Ok(AuditEventType::Hold(None)),
            "link" => Ok(AuditEventType::Link(None)),
            "merge" => Ok(AuditEventType::Merge(None)),
            "originate" => Ok(AuditEventType::Originate(None)),
            "pseudonymize" => Ok(AuditEventType::Pseudonymize(None)),
            "reactivate" => Ok(AuditEventType::Reactivate(None)),
            "receive" => Ok(AuditEventType::Receive(None)),
            "reidentify" => Ok(AuditEventType::Reidentify(None)),
            "report" => Ok(AuditEventType::Report(None)),
            "rest" => Ok(AuditEventType::Rest(None)),
            "restore" => Ok(AuditEventType::Restore(None)),
            "transform" => Ok(AuditEventType::Transform(None)),
            "transmit" => Ok(AuditEventType::Transmit(None)),
            "unhold" => Ok(AuditEventType::Unhold(None)),
            "unlink" => Ok(AuditEventType::Unlink(None)),
            "unmerge" => Ok(AuditEventType::Unmerge(None)),
            "verify" => Ok(AuditEventType::Verify(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AuditEventType {
    fn into(self) -> Option<String> {
        match self {
            AuditEventType::V110100(_) => Some("110100".to_string()),
            AuditEventType::V110101(_) => Some("110101".to_string()),
            AuditEventType::V110102(_) => Some("110102".to_string()),
            AuditEventType::V110103(_) => Some("110103".to_string()),
            AuditEventType::V110104(_) => Some("110104".to_string()),
            AuditEventType::V110105(_) => Some("110105".to_string()),
            AuditEventType::V110106(_) => Some("110106".to_string()),
            AuditEventType::V110107(_) => Some("110107".to_string()),
            AuditEventType::V110108(_) => Some("110108".to_string()),
            AuditEventType::V110109(_) => Some("110109".to_string()),
            AuditEventType::V110110(_) => Some("110110".to_string()),
            AuditEventType::V110111(_) => Some("110111".to_string()),
            AuditEventType::V110112(_) => Some("110112".to_string()),
            AuditEventType::V110113(_) => Some("110113".to_string()),
            AuditEventType::V110114(_) => Some("110114".to_string()),
            AuditEventType::Access(_) => Some("access".to_string()),
            AuditEventType::Amend(_) => Some("amend".to_string()),
            AuditEventType::Archive(_) => Some("archive".to_string()),
            AuditEventType::Attest(_) => Some("attest".to_string()),
            AuditEventType::Decrypt(_) => Some("decrypt".to_string()),
            AuditEventType::Deidentify(_) => Some("deidentify".to_string()),
            AuditEventType::Deprecate(_) => Some("deprecate".to_string()),
            AuditEventType::Destroy(_) => Some("destroy".to_string()),
            AuditEventType::Disclose(_) => Some("disclose".to_string()),
            AuditEventType::Encrypt(_) => Some("encrypt".to_string()),
            AuditEventType::Extract(_) => Some("extract".to_string()),
            AuditEventType::Hold(_) => Some("hold".to_string()),
            AuditEventType::Link(_) => Some("link".to_string()),
            AuditEventType::Merge(_) => Some("merge".to_string()),
            AuditEventType::Originate(_) => Some("originate".to_string()),
            AuditEventType::Pseudonymize(_) => Some("pseudonymize".to_string()),
            AuditEventType::Reactivate(_) => Some("reactivate".to_string()),
            AuditEventType::Receive(_) => Some("receive".to_string()),
            AuditEventType::Reidentify(_) => Some("reidentify".to_string()),
            AuditEventType::Report(_) => Some("report".to_string()),
            AuditEventType::Rest(_) => Some("rest".to_string()),
            AuditEventType::Restore(_) => Some("restore".to_string()),
            AuditEventType::Transform(_) => Some("transform".to_string()),
            AuditEventType::Transmit(_) => Some("transmit".to_string()),
            AuditEventType::Unhold(_) => Some("unhold".to_string()),
            AuditEventType::Unlink(_) => Some("unlink".to_string()),
            AuditEventType::Unmerge(_) => Some("unmerge".to_string()),
            AuditEventType::Verify(_) => Some("verify".to_string()),
            AuditEventType::Null(_) => None,
        }
    }
}
impl MetaValue for AuditEventType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AuditEventType::V110100(Some(e)) => e.get_field(field),
                AuditEventType::V110101(Some(e)) => e.get_field(field),
                AuditEventType::V110102(Some(e)) => e.get_field(field),
                AuditEventType::V110103(Some(e)) => e.get_field(field),
                AuditEventType::V110104(Some(e)) => e.get_field(field),
                AuditEventType::V110105(Some(e)) => e.get_field(field),
                AuditEventType::V110106(Some(e)) => e.get_field(field),
                AuditEventType::V110107(Some(e)) => e.get_field(field),
                AuditEventType::V110108(Some(e)) => e.get_field(field),
                AuditEventType::V110109(Some(e)) => e.get_field(field),
                AuditEventType::V110110(Some(e)) => e.get_field(field),
                AuditEventType::V110111(Some(e)) => e.get_field(field),
                AuditEventType::V110112(Some(e)) => e.get_field(field),
                AuditEventType::V110113(Some(e)) => e.get_field(field),
                AuditEventType::V110114(Some(e)) => e.get_field(field),
                AuditEventType::Access(Some(e)) => e.get_field(field),
                AuditEventType::Amend(Some(e)) => e.get_field(field),
                AuditEventType::Archive(Some(e)) => e.get_field(field),
                AuditEventType::Attest(Some(e)) => e.get_field(field),
                AuditEventType::Decrypt(Some(e)) => e.get_field(field),
                AuditEventType::Deidentify(Some(e)) => e.get_field(field),
                AuditEventType::Deprecate(Some(e)) => e.get_field(field),
                AuditEventType::Destroy(Some(e)) => e.get_field(field),
                AuditEventType::Disclose(Some(e)) => e.get_field(field),
                AuditEventType::Encrypt(Some(e)) => e.get_field(field),
                AuditEventType::Extract(Some(e)) => e.get_field(field),
                AuditEventType::Hold(Some(e)) => e.get_field(field),
                AuditEventType::Link(Some(e)) => e.get_field(field),
                AuditEventType::Merge(Some(e)) => e.get_field(field),
                AuditEventType::Originate(Some(e)) => e.get_field(field),
                AuditEventType::Pseudonymize(Some(e)) => e.get_field(field),
                AuditEventType::Reactivate(Some(e)) => e.get_field(field),
                AuditEventType::Receive(Some(e)) => e.get_field(field),
                AuditEventType::Reidentify(Some(e)) => e.get_field(field),
                AuditEventType::Report(Some(e)) => e.get_field(field),
                AuditEventType::Rest(Some(e)) => e.get_field(field),
                AuditEventType::Restore(Some(e)) => e.get_field(field),
                AuditEventType::Transform(Some(e)) => e.get_field(field),
                AuditEventType::Transmit(Some(e)) => e.get_field(field),
                AuditEventType::Unhold(Some(e)) => e.get_field(field),
                AuditEventType::Unlink(Some(e)) => e.get_field(field),
                AuditEventType::Unmerge(Some(e)) => e.get_field(field),
                AuditEventType::Verify(Some(e)) => e.get_field(field),
                AuditEventType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AuditEventType::V110100(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110101(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110102(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110103(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110104(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110105(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110106(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110107(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110108(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110109(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110110(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110111(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110112(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110113(Some(e)) => e.get_field_mut(field),
                AuditEventType::V110114(Some(e)) => e.get_field_mut(field),
                AuditEventType::Access(Some(e)) => e.get_field_mut(field),
                AuditEventType::Amend(Some(e)) => e.get_field_mut(field),
                AuditEventType::Archive(Some(e)) => e.get_field_mut(field),
                AuditEventType::Attest(Some(e)) => e.get_field_mut(field),
                AuditEventType::Decrypt(Some(e)) => e.get_field_mut(field),
                AuditEventType::Deidentify(Some(e)) => e.get_field_mut(field),
                AuditEventType::Deprecate(Some(e)) => e.get_field_mut(field),
                AuditEventType::Destroy(Some(e)) => e.get_field_mut(field),
                AuditEventType::Disclose(Some(e)) => e.get_field_mut(field),
                AuditEventType::Encrypt(Some(e)) => e.get_field_mut(field),
                AuditEventType::Extract(Some(e)) => e.get_field_mut(field),
                AuditEventType::Hold(Some(e)) => e.get_field_mut(field),
                AuditEventType::Link(Some(e)) => e.get_field_mut(field),
                AuditEventType::Merge(Some(e)) => e.get_field_mut(field),
                AuditEventType::Originate(Some(e)) => e.get_field_mut(field),
                AuditEventType::Pseudonymize(Some(e)) => e.get_field_mut(field),
                AuditEventType::Reactivate(Some(e)) => e.get_field_mut(field),
                AuditEventType::Receive(Some(e)) => e.get_field_mut(field),
                AuditEventType::Reidentify(Some(e)) => e.get_field_mut(field),
                AuditEventType::Report(Some(e)) => e.get_field_mut(field),
                AuditEventType::Rest(Some(e)) => e.get_field_mut(field),
                AuditEventType::Restore(Some(e)) => e.get_field_mut(field),
                AuditEventType::Transform(Some(e)) => e.get_field_mut(field),
                AuditEventType::Transmit(Some(e)) => e.get_field_mut(field),
                AuditEventType::Unhold(Some(e)) => e.get_field_mut(field),
                AuditEventType::Unlink(Some(e)) => e.get_field_mut(field),
                AuditEventType::Unmerge(Some(e)) => e.get_field_mut(field),
                AuditEventType::Verify(Some(e)) => e.get_field_mut(field),
                AuditEventType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AuditSourceType {
    #[doc = "User Device"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Data Interface"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Web Server"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Application Server"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Database Server"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "Security Server"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "Network Device"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "Network Router"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "Other"]
    #[code = "9"]
    V9(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AuditSourceType {
    fn default() -> Self {
        AuditSourceType::Null(None)
    }
}
impl TryFrom<String> for AuditSourceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(AuditSourceType::V1(None)),
            "2" => Ok(AuditSourceType::V2(None)),
            "3" => Ok(AuditSourceType::V3(None)),
            "4" => Ok(AuditSourceType::V4(None)),
            "5" => Ok(AuditSourceType::V5(None)),
            "6" => Ok(AuditSourceType::V6(None)),
            "7" => Ok(AuditSourceType::V7(None)),
            "8" => Ok(AuditSourceType::V8(None)),
            "9" => Ok(AuditSourceType::V9(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AuditSourceType {
    fn into(self) -> Option<String> {
        match self {
            AuditSourceType::V1(_) => Some("1".to_string()),
            AuditSourceType::V2(_) => Some("2".to_string()),
            AuditSourceType::V3(_) => Some("3".to_string()),
            AuditSourceType::V4(_) => Some("4".to_string()),
            AuditSourceType::V5(_) => Some("5".to_string()),
            AuditSourceType::V6(_) => Some("6".to_string()),
            AuditSourceType::V7(_) => Some("7".to_string()),
            AuditSourceType::V8(_) => Some("8".to_string()),
            AuditSourceType::V9(_) => Some("9".to_string()),
            AuditSourceType::Null(_) => None,
        }
    }
}
impl MetaValue for AuditSourceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AuditSourceType::V1(Some(e)) => e.get_field(field),
                AuditSourceType::V2(Some(e)) => e.get_field(field),
                AuditSourceType::V3(Some(e)) => e.get_field(field),
                AuditSourceType::V4(Some(e)) => e.get_field(field),
                AuditSourceType::V5(Some(e)) => e.get_field(field),
                AuditSourceType::V6(Some(e)) => e.get_field(field),
                AuditSourceType::V7(Some(e)) => e.get_field(field),
                AuditSourceType::V8(Some(e)) => e.get_field(field),
                AuditSourceType::V9(Some(e)) => e.get_field(field),
                AuditSourceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AuditSourceType::V1(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V2(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V3(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V4(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V5(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V6(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V7(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V8(Some(e)) => e.get_field_mut(field),
                AuditSourceType::V9(Some(e)) => e.get_field_mut(field),
                AuditSourceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BasicResourceType {
    #[doc = "Account"]
    #[code = "account"]
    Account(Option<Element>),
    #[doc = "Invoice Adjudication"]
    #[code = "adjudicat"]
    Adjudicat(Option<Element>),
    #[doc = "Administrative Activity"]
    #[code = "adminact"]
    Adminact(Option<Element>),
    #[doc = "Adverse Event"]
    #[code = "advevent"]
    Advevent(Option<Element>),
    #[doc = "Appointment Request"]
    #[code = "aptmtreq"]
    Aptmtreq(Option<Element>),
    #[doc = "Consent"]
    #[code = "consent"]
    Consent(Option<Element>),
    #[doc = "Diet"]
    #[code = "diet"]
    Diet(Option<Element>),
    #[doc = "Exposure"]
    #[code = "exposure"]
    Exposure(Option<Element>),
    #[doc = "Investigation"]
    #[code = "investigation"]
    Investigation(Option<Element>),
    #[doc = "Invoice"]
    #[code = "invoice"]
    Invoice(Option<Element>),
    #[doc = "Predetermination"]
    #[code = "predetermine"]
    Predetermine(Option<Element>),
    #[doc = "Pre-determination Request"]
    #[code = "predetreq"]
    Predetreq(Option<Element>),
    #[doc = "Protocol"]
    #[code = "protocol"]
    Protocol(Option<Element>),
    #[doc = "Referral"]
    #[code = "referral"]
    Referral(Option<Element>),
    #[doc = "Study"]
    #[code = "study"]
    Study(Option<Element>),
    #[doc = "Transfer"]
    #[code = "transfer"]
    Transfer(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BasicResourceType {
    fn default() -> Self {
        BasicResourceType::Null(None)
    }
}
impl TryFrom<String> for BasicResourceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "account" => Ok(BasicResourceType::Account(None)),
            "adjudicat" => Ok(BasicResourceType::Adjudicat(None)),
            "adminact" => Ok(BasicResourceType::Adminact(None)),
            "advevent" => Ok(BasicResourceType::Advevent(None)),
            "aptmtreq" => Ok(BasicResourceType::Aptmtreq(None)),
            "consent" => Ok(BasicResourceType::Consent(None)),
            "diet" => Ok(BasicResourceType::Diet(None)),
            "exposure" => Ok(BasicResourceType::Exposure(None)),
            "investigation" => Ok(BasicResourceType::Investigation(None)),
            "invoice" => Ok(BasicResourceType::Invoice(None)),
            "predetermine" => Ok(BasicResourceType::Predetermine(None)),
            "predetreq" => Ok(BasicResourceType::Predetreq(None)),
            "protocol" => Ok(BasicResourceType::Protocol(None)),
            "referral" => Ok(BasicResourceType::Referral(None)),
            "study" => Ok(BasicResourceType::Study(None)),
            "transfer" => Ok(BasicResourceType::Transfer(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BasicResourceType {
    fn into(self) -> Option<String> {
        match self {
            BasicResourceType::Account(_) => Some("account".to_string()),
            BasicResourceType::Adjudicat(_) => Some("adjudicat".to_string()),
            BasicResourceType::Adminact(_) => Some("adminact".to_string()),
            BasicResourceType::Advevent(_) => Some("advevent".to_string()),
            BasicResourceType::Aptmtreq(_) => Some("aptmtreq".to_string()),
            BasicResourceType::Consent(_) => Some("consent".to_string()),
            BasicResourceType::Diet(_) => Some("diet".to_string()),
            BasicResourceType::Exposure(_) => Some("exposure".to_string()),
            BasicResourceType::Investigation(_) => Some("investigation".to_string()),
            BasicResourceType::Invoice(_) => Some("invoice".to_string()),
            BasicResourceType::Predetermine(_) => Some("predetermine".to_string()),
            BasicResourceType::Predetreq(_) => Some("predetreq".to_string()),
            BasicResourceType::Protocol(_) => Some("protocol".to_string()),
            BasicResourceType::Referral(_) => Some("referral".to_string()),
            BasicResourceType::Study(_) => Some("study".to_string()),
            BasicResourceType::Transfer(_) => Some("transfer".to_string()),
            BasicResourceType::Null(_) => None,
        }
    }
}
impl MetaValue for BasicResourceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BasicResourceType::Account(Some(e)) => e.get_field(field),
                BasicResourceType::Adjudicat(Some(e)) => e.get_field(field),
                BasicResourceType::Adminact(Some(e)) => e.get_field(field),
                BasicResourceType::Advevent(Some(e)) => e.get_field(field),
                BasicResourceType::Aptmtreq(Some(e)) => e.get_field(field),
                BasicResourceType::Consent(Some(e)) => e.get_field(field),
                BasicResourceType::Diet(Some(e)) => e.get_field(field),
                BasicResourceType::Exposure(Some(e)) => e.get_field(field),
                BasicResourceType::Investigation(Some(e)) => e.get_field(field),
                BasicResourceType::Invoice(Some(e)) => e.get_field(field),
                BasicResourceType::Predetermine(Some(e)) => e.get_field(field),
                BasicResourceType::Predetreq(Some(e)) => e.get_field(field),
                BasicResourceType::Protocol(Some(e)) => e.get_field(field),
                BasicResourceType::Referral(Some(e)) => e.get_field(field),
                BasicResourceType::Study(Some(e)) => e.get_field(field),
                BasicResourceType::Transfer(Some(e)) => e.get_field(field),
                BasicResourceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BasicResourceType::Account(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Adjudicat(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Adminact(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Advevent(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Aptmtreq(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Consent(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Diet(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Exposure(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Investigation(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Invoice(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Predetermine(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Predetreq(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Protocol(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Referral(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Study(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Transfer(Some(e)) => e.get_field_mut(field),
                BasicResourceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BenefitNetwork {
    #[doc = "In Network"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "Out of Network"]
    #[code = "out"]
    Out(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BenefitNetwork {
    fn default() -> Self {
        BenefitNetwork::Null(None)
    }
}
impl TryFrom<String> for BenefitNetwork {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "in" => Ok(BenefitNetwork::In(None)),
            "out" => Ok(BenefitNetwork::Out(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BenefitNetwork {
    fn into(self) -> Option<String> {
        match self {
            BenefitNetwork::In(_) => Some("in".to_string()),
            BenefitNetwork::Out(_) => Some("out".to_string()),
            BenefitNetwork::Null(_) => None,
        }
    }
}
impl MetaValue for BenefitNetwork {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BenefitNetwork::In(Some(e)) => e.get_field(field),
                BenefitNetwork::Out(Some(e)) => e.get_field(field),
                BenefitNetwork::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BenefitNetwork::In(Some(e)) => e.get_field_mut(field),
                BenefitNetwork::Out(Some(e)) => e.get_field_mut(field),
                BenefitNetwork::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BenefitTerm {
    #[doc = "Annual"]
    #[code = "annual"]
    Annual(Option<Element>),
    #[doc = "Day"]
    #[code = "day"]
    Day(Option<Element>),
    #[doc = "Lifetime"]
    #[code = "lifetime"]
    Lifetime(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BenefitTerm {
    fn default() -> Self {
        BenefitTerm::Null(None)
    }
}
impl TryFrom<String> for BenefitTerm {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "annual" => Ok(BenefitTerm::Annual(None)),
            "day" => Ok(BenefitTerm::Day(None)),
            "lifetime" => Ok(BenefitTerm::Lifetime(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BenefitTerm {
    fn into(self) -> Option<String> {
        match self {
            BenefitTerm::Annual(_) => Some("annual".to_string()),
            BenefitTerm::Day(_) => Some("day".to_string()),
            BenefitTerm::Lifetime(_) => Some("lifetime".to_string()),
            BenefitTerm::Null(_) => None,
        }
    }
}
impl MetaValue for BenefitTerm {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BenefitTerm::Annual(Some(e)) => e.get_field(field),
                BenefitTerm::Day(Some(e)) => e.get_field(field),
                BenefitTerm::Lifetime(Some(e)) => e.get_field(field),
                BenefitTerm::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BenefitTerm::Annual(Some(e)) => e.get_field_mut(field),
                BenefitTerm::Day(Some(e)) => e.get_field_mut(field),
                BenefitTerm::Lifetime(Some(e)) => e.get_field_mut(field),
                BenefitTerm::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BenefitType {
    #[doc = "Benefit"]
    #[code = "benefit"]
    Benefit(Option<Element>),
    #[doc = "Copayment per service"]
    #[code = "copay"]
    Copay(Option<Element>),
    #[doc = "Copayment maximum per service"]
    #[code = "copay-maximum"]
    CopayMaximum(Option<Element>),
    #[doc = "Copayment Percent per service"]
    #[code = "copay-percent"]
    CopayPercent(Option<Element>),
    #[doc = "Deductible"]
    #[code = "deductible"]
    Deductible(Option<Element>),
    #[doc = "Medical Primary Health Coverage"]
    #[code = "medical-primarycare"]
    MedicalPrimarycare(Option<Element>),
    #[doc = "Pharmacy Dispense Coverage"]
    #[code = "pharmacy-dispense"]
    PharmacyDispense(Option<Element>),
    #[doc = "Room"]
    #[code = "room"]
    Room(Option<Element>),
    #[doc = "Vision Contacts Coverage"]
    #[code = "vision-contacts"]
    VisionContacts(Option<Element>),
    #[doc = "Vision Exam"]
    #[code = "vision-exam"]
    VisionExam(Option<Element>),
    #[doc = "Vision Glasses"]
    #[code = "vision-glasses"]
    VisionGlasses(Option<Element>),
    #[doc = "Visit"]
    #[code = "visit"]
    Visit(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BenefitType {
    fn default() -> Self {
        BenefitType::Null(None)
    }
}
impl TryFrom<String> for BenefitType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "benefit" => Ok(BenefitType::Benefit(None)),
            "copay" => Ok(BenefitType::Copay(None)),
            "copay-maximum" => Ok(BenefitType::CopayMaximum(None)),
            "copay-percent" => Ok(BenefitType::CopayPercent(None)),
            "deductible" => Ok(BenefitType::Deductible(None)),
            "medical-primarycare" => Ok(BenefitType::MedicalPrimarycare(None)),
            "pharmacy-dispense" => Ok(BenefitType::PharmacyDispense(None)),
            "room" => Ok(BenefitType::Room(None)),
            "vision-contacts" => Ok(BenefitType::VisionContacts(None)),
            "vision-exam" => Ok(BenefitType::VisionExam(None)),
            "vision-glasses" => Ok(BenefitType::VisionGlasses(None)),
            "visit" => Ok(BenefitType::Visit(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BenefitType {
    fn into(self) -> Option<String> {
        match self {
            BenefitType::Benefit(_) => Some("benefit".to_string()),
            BenefitType::Copay(_) => Some("copay".to_string()),
            BenefitType::CopayMaximum(_) => Some("copay-maximum".to_string()),
            BenefitType::CopayPercent(_) => Some("copay-percent".to_string()),
            BenefitType::Deductible(_) => Some("deductible".to_string()),
            BenefitType::MedicalPrimarycare(_) => Some("medical-primarycare".to_string()),
            BenefitType::PharmacyDispense(_) => Some("pharmacy-dispense".to_string()),
            BenefitType::Room(_) => Some("room".to_string()),
            BenefitType::VisionContacts(_) => Some("vision-contacts".to_string()),
            BenefitType::VisionExam(_) => Some("vision-exam".to_string()),
            BenefitType::VisionGlasses(_) => Some("vision-glasses".to_string()),
            BenefitType::Visit(_) => Some("visit".to_string()),
            BenefitType::Null(_) => None,
        }
    }
}
impl MetaValue for BenefitType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BenefitType::Benefit(Some(e)) => e.get_field(field),
                BenefitType::Copay(Some(e)) => e.get_field(field),
                BenefitType::CopayMaximum(Some(e)) => e.get_field(field),
                BenefitType::CopayPercent(Some(e)) => e.get_field(field),
                BenefitType::Deductible(Some(e)) => e.get_field(field),
                BenefitType::MedicalPrimarycare(Some(e)) => e.get_field(field),
                BenefitType::PharmacyDispense(Some(e)) => e.get_field(field),
                BenefitType::Room(Some(e)) => e.get_field(field),
                BenefitType::VisionContacts(Some(e)) => e.get_field(field),
                BenefitType::VisionExam(Some(e)) => e.get_field(field),
                BenefitType::VisionGlasses(Some(e)) => e.get_field(field),
                BenefitType::Visit(Some(e)) => e.get_field(field),
                BenefitType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BenefitType::Benefit(Some(e)) => e.get_field_mut(field),
                BenefitType::Copay(Some(e)) => e.get_field_mut(field),
                BenefitType::CopayMaximum(Some(e)) => e.get_field_mut(field),
                BenefitType::CopayPercent(Some(e)) => e.get_field_mut(field),
                BenefitType::Deductible(Some(e)) => e.get_field_mut(field),
                BenefitType::MedicalPrimarycare(Some(e)) => e.get_field_mut(field),
                BenefitType::PharmacyDispense(Some(e)) => e.get_field_mut(field),
                BenefitType::Room(Some(e)) => e.get_field_mut(field),
                BenefitType::VisionContacts(Some(e)) => e.get_field_mut(field),
                BenefitType::VisionExam(Some(e)) => e.get_field_mut(field),
                BenefitType::VisionGlasses(Some(e)) => e.get_field_mut(field),
                BenefitType::Visit(Some(e)) => e.get_field_mut(field),
                BenefitType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BenefitUnit {
    #[doc = "Family"]
    #[code = "family"]
    Family(Option<Element>),
    #[doc = "Individual"]
    #[code = "individual"]
    Individual(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BenefitUnit {
    fn default() -> Self {
        BenefitUnit::Null(None)
    }
}
impl TryFrom<String> for BenefitUnit {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "family" => Ok(BenefitUnit::Family(None)),
            "individual" => Ok(BenefitUnit::Individual(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BenefitUnit {
    fn into(self) -> Option<String> {
        match self {
            BenefitUnit::Family(_) => Some("family".to_string()),
            BenefitUnit::Individual(_) => Some("individual".to_string()),
            BenefitUnit::Null(_) => None,
        }
    }
}
impl MetaValue for BenefitUnit {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BenefitUnit::Family(Some(e)) => e.get_field(field),
                BenefitUnit::Individual(Some(e)) => e.get_field(field),
                BenefitUnit::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BenefitUnit::Family(Some(e)) => e.get_field_mut(field),
                BenefitUnit::Individual(Some(e)) => e.get_field_mut(field),
                BenefitUnit::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BindingStrength {
    #[doc = "Example"]
    #[code = "example"]
    Example(Option<Element>),
    #[doc = "Extensible"]
    #[code = "extensible"]
    Extensible(Option<Element>),
    #[doc = "Preferred"]
    #[code = "preferred"]
    Preferred(Option<Element>),
    #[doc = "Required"]
    #[code = "required"]
    Required(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BindingStrength {
    fn default() -> Self {
        BindingStrength::Null(None)
    }
}
impl TryFrom<String> for BindingStrength {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "example" => Ok(BindingStrength::Example(None)),
            "extensible" => Ok(BindingStrength::Extensible(None)),
            "preferred" => Ok(BindingStrength::Preferred(None)),
            "required" => Ok(BindingStrength::Required(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BindingStrength {
    fn into(self) -> Option<String> {
        match self {
            BindingStrength::Example(_) => Some("example".to_string()),
            BindingStrength::Extensible(_) => Some("extensible".to_string()),
            BindingStrength::Preferred(_) => Some("preferred".to_string()),
            BindingStrength::Required(_) => Some("required".to_string()),
            BindingStrength::Null(_) => None,
        }
    }
}
impl MetaValue for BindingStrength {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BindingStrength::Example(Some(e)) => e.get_field(field),
                BindingStrength::Extensible(Some(e)) => e.get_field(field),
                BindingStrength::Preferred(Some(e)) => e.get_field(field),
                BindingStrength::Required(Some(e)) => e.get_field(field),
                BindingStrength::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BindingStrength::Example(Some(e)) => e.get_field_mut(field),
                BindingStrength::Extensible(Some(e)) => e.get_field_mut(field),
                BindingStrength::Preferred(Some(e)) => e.get_field_mut(field),
                BindingStrength::Required(Some(e)) => e.get_field_mut(field),
                BindingStrength::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BodysiteLaterality {
    #[doc = "Unilateral left"]
    #[code = "419161000"]
    V419161000(Option<Element>),
    #[doc = "Unilateral right"]
    #[code = "419465000"]
    V419465000(Option<Element>),
    #[doc = "Bilateral"]
    #[code = "51440002"]
    V51440002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BodysiteLaterality {
    fn default() -> Self {
        BodysiteLaterality::Null(None)
    }
}
impl TryFrom<String> for BodysiteLaterality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "419161000" => Ok(BodysiteLaterality::V419161000(None)),
            "419465000" => Ok(BodysiteLaterality::V419465000(None)),
            "51440002" => Ok(BodysiteLaterality::V51440002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BodysiteLaterality {
    fn into(self) -> Option<String> {
        match self {
            BodysiteLaterality::V419161000(_) => Some("419161000".to_string()),
            BodysiteLaterality::V419465000(_) => Some("419465000".to_string()),
            BodysiteLaterality::V51440002(_) => Some("51440002".to_string()),
            BodysiteLaterality::Null(_) => None,
        }
    }
}
impl MetaValue for BodysiteLaterality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BodysiteLaterality::V419161000(Some(e)) => e.get_field(field),
                BodysiteLaterality::V419465000(Some(e)) => e.get_field(field),
                BodysiteLaterality::V51440002(Some(e)) => e.get_field(field),
                BodysiteLaterality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BodysiteLaterality::V419161000(Some(e)) => e.get_field_mut(field),
                BodysiteLaterality::V419465000(Some(e)) => e.get_field_mut(field),
                BodysiteLaterality::V51440002(Some(e)) => e.get_field_mut(field),
                BodysiteLaterality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BodystructureRelativeLocation {
    #[doc = "Posterior"]
    #[code = "255551008"]
    V255551008(Option<Element>),
    #[doc = "Medial"]
    #[code = "255561001"]
    V255561001(Option<Element>),
    #[doc = "Inferior"]
    #[code = "261089000"]
    V261089000(Option<Element>),
    #[doc = "Lower"]
    #[code = "261122009"]
    V261122009(Option<Element>),
    #[doc = "Upper"]
    #[code = "261183002"]
    V261183002(Option<Element>),
    #[doc = "Superior"]
    #[code = "264217000"]
    V264217000(Option<Element>),
    #[doc = "Below"]
    #[code = "351726001"]
    V351726001(Option<Element>),
    #[doc = "Above"]
    #[code = "352730000"]
    V352730000(Option<Element>),
    #[doc = "Unilateral left"]
    #[code = "419161000"]
    V419161000(Option<Element>),
    #[doc = "Unilateral right"]
    #[code = "419465000"]
    V419465000(Option<Element>),
    #[doc = "Lateral"]
    #[code = "49370004"]
    V49370004(Option<Element>),
    #[doc = "Bilateral"]
    #[code = "51440002"]
    V51440002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BodystructureRelativeLocation {
    fn default() -> Self {
        BodystructureRelativeLocation::Null(None)
    }
}
impl TryFrom<String> for BodystructureRelativeLocation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "255551008" => Ok(BodystructureRelativeLocation::V255551008(None)),
            "255561001" => Ok(BodystructureRelativeLocation::V255561001(None)),
            "261089000" => Ok(BodystructureRelativeLocation::V261089000(None)),
            "261122009" => Ok(BodystructureRelativeLocation::V261122009(None)),
            "261183002" => Ok(BodystructureRelativeLocation::V261183002(None)),
            "264217000" => Ok(BodystructureRelativeLocation::V264217000(None)),
            "351726001" => Ok(BodystructureRelativeLocation::V351726001(None)),
            "352730000" => Ok(BodystructureRelativeLocation::V352730000(None)),
            "419161000" => Ok(BodystructureRelativeLocation::V419161000(None)),
            "419465000" => Ok(BodystructureRelativeLocation::V419465000(None)),
            "49370004" => Ok(BodystructureRelativeLocation::V49370004(None)),
            "51440002" => Ok(BodystructureRelativeLocation::V51440002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BodystructureRelativeLocation {
    fn into(self) -> Option<String> {
        match self {
            BodystructureRelativeLocation::V255551008(_) => Some("255551008".to_string()),
            BodystructureRelativeLocation::V255561001(_) => Some("255561001".to_string()),
            BodystructureRelativeLocation::V261089000(_) => Some("261089000".to_string()),
            BodystructureRelativeLocation::V261122009(_) => Some("261122009".to_string()),
            BodystructureRelativeLocation::V261183002(_) => Some("261183002".to_string()),
            BodystructureRelativeLocation::V264217000(_) => Some("264217000".to_string()),
            BodystructureRelativeLocation::V351726001(_) => Some("351726001".to_string()),
            BodystructureRelativeLocation::V352730000(_) => Some("352730000".to_string()),
            BodystructureRelativeLocation::V419161000(_) => Some("419161000".to_string()),
            BodystructureRelativeLocation::V419465000(_) => Some("419465000".to_string()),
            BodystructureRelativeLocation::V49370004(_) => Some("49370004".to_string()),
            BodystructureRelativeLocation::V51440002(_) => Some("51440002".to_string()),
            BodystructureRelativeLocation::Null(_) => None,
        }
    }
}
impl MetaValue for BodystructureRelativeLocation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BodystructureRelativeLocation::V255551008(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V255561001(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V261089000(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V261122009(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V261183002(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V264217000(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V351726001(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V352730000(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V419161000(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V419465000(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V49370004(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::V51440002(Some(e)) => e.get_field(field),
                BodystructureRelativeLocation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BodystructureRelativeLocation::V255551008(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V255561001(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V261089000(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V261122009(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V261183002(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V264217000(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V351726001(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V352730000(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V419161000(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V419465000(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V49370004(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::V51440002(Some(e)) => e.get_field_mut(field),
                BodystructureRelativeLocation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum BundleType {
    #[doc = "Batch"]
    #[code = "batch"]
    Batch(Option<Element>),
    #[doc = "Batch Response"]
    #[code = "batch-response"]
    BatchResponse(Option<Element>),
    #[doc = "Collection"]
    #[code = "collection"]
    Collection(Option<Element>),
    #[doc = "Document"]
    #[code = "document"]
    Document(Option<Element>),
    #[doc = "History List"]
    #[code = "history"]
    History(Option<Element>),
    #[doc = "Message"]
    #[code = "message"]
    Message(Option<Element>),
    #[doc = "Search Results"]
    #[code = "searchset"]
    Searchset(Option<Element>),
    #[doc = "Transaction"]
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "Transaction Response"]
    #[code = "transaction-response"]
    TransactionResponse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for BundleType {
    fn default() -> Self {
        BundleType::Null(None)
    }
}
impl TryFrom<String> for BundleType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "batch" => Ok(BundleType::Batch(None)),
            "batch-response" => Ok(BundleType::BatchResponse(None)),
            "collection" => Ok(BundleType::Collection(None)),
            "document" => Ok(BundleType::Document(None)),
            "history" => Ok(BundleType::History(None)),
            "message" => Ok(BundleType::Message(None)),
            "searchset" => Ok(BundleType::Searchset(None)),
            "transaction" => Ok(BundleType::Transaction(None)),
            "transaction-response" => Ok(BundleType::TransactionResponse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &BundleType {
    fn into(self) -> Option<String> {
        match self {
            BundleType::Batch(_) => Some("batch".to_string()),
            BundleType::BatchResponse(_) => Some("batch-response".to_string()),
            BundleType::Collection(_) => Some("collection".to_string()),
            BundleType::Document(_) => Some("document".to_string()),
            BundleType::History(_) => Some("history".to_string()),
            BundleType::Message(_) => Some("message".to_string()),
            BundleType::Searchset(_) => Some("searchset".to_string()),
            BundleType::Transaction(_) => Some("transaction".to_string()),
            BundleType::TransactionResponse(_) => Some("transaction-response".to_string()),
            BundleType::Null(_) => None,
        }
    }
}
impl MetaValue for BundleType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                BundleType::Batch(Some(e)) => e.get_field(field),
                BundleType::BatchResponse(Some(e)) => e.get_field(field),
                BundleType::Collection(Some(e)) => e.get_field(field),
                BundleType::Document(Some(e)) => e.get_field(field),
                BundleType::History(Some(e)) => e.get_field(field),
                BundleType::Message(Some(e)) => e.get_field(field),
                BundleType::Searchset(Some(e)) => e.get_field(field),
                BundleType::Transaction(Some(e)) => e.get_field(field),
                BundleType::TransactionResponse(Some(e)) => e.get_field(field),
                BundleType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                BundleType::Batch(Some(e)) => e.get_field_mut(field),
                BundleType::BatchResponse(Some(e)) => e.get_field_mut(field),
                BundleType::Collection(Some(e)) => e.get_field_mut(field),
                BundleType::Document(Some(e)) => e.get_field_mut(field),
                BundleType::History(Some(e)) => e.get_field_mut(field),
                BundleType::Message(Some(e)) => e.get_field_mut(field),
                BundleType::Searchset(Some(e)) => e.get_field_mut(field),
                BundleType::Transaction(Some(e)) => e.get_field_mut(field),
                BundleType::TransactionResponse(Some(e)) => e.get_field_mut(field),
                BundleType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum C80Facilitycodes {
    #[doc = "Hospital outpatient dental clinic"]
    #[code = "10206005"]
    V10206005(Option<Element>),
    #[doc = "Free-standing ambulatory surgery facility"]
    #[code = "10531005"]
    V10531005(Option<Element>),
    #[doc = "Ambulance-based care"]
    #[code = "11424001"]
    V11424001(Option<Element>),
    #[doc = "Hospital outpatient mental health center"]
    #[code = "14866005"]
    V14866005(Option<Element>),
    #[doc = "Free-standing radiology facility"]
    #[code = "1773006"]
    V1773006(Option<Element>),
    #[doc = "Hospital outpatient geriatric health center"]
    #[code = "1814000"]
    V1814000(Option<Element>),
    #[doc = "Fee-for-service private physicians' group office"]
    #[code = "19602009"]
    V19602009(Option<Element>),
    #[doc = "Substance abuse treatment center"]
    #[code = "20078004"]
    V20078004(Option<Element>),
    #[doc = "Hospital ship"]
    #[code = "2081004"]
    V2081004(Option<Element>),
    #[doc = "Hospital-prison"]
    #[code = "224687002"]
    V224687002(Option<Element>),
    #[doc = "Hospital outpatient gynecology clinic"]
    #[code = "22549003"]
    V22549003(Option<Element>),
    #[doc = "Hospital-community"]
    #[code = "225732001"]
    V225732001(Option<Element>),
    #[doc = "Hospital outpatient otorhinolaryngology clinic"]
    #[code = "23392004"]
    V23392004(Option<Element>),
    #[doc = "Sexually transmitted disease health center"]
    #[code = "25681007"]
    V25681007(Option<Element>),
    #[doc = "Sports facility"]
    #[code = "272501009"]
    V272501009(Option<Element>),
    #[doc = "Elderly assessment clinic"]
    #[code = "275576008"]
    V275576008(Option<Element>),
    #[doc = "Hospice facility"]
    #[code = "284546000"]
    V284546000(Option<Element>),
    #[doc = "Hospital outpatient infectious disease clinic"]
    #[code = "2849009"]
    V2849009(Option<Element>),
    #[doc = "Psychogeriatric day hospital"]
    #[code = "309898008"]
    V309898008(Option<Element>),
    #[doc = "Care of the elderly day hospital"]
    #[code = "309900005"]
    V309900005(Option<Element>),
    #[doc = "Private residential home"]
    #[code = "310205006"]
    V310205006(Option<Element>),
    #[doc = "Hospital outpatient family medicine clinic"]
    #[code = "31628002"]
    V31628002(Option<Element>),
    #[doc = "Hospital-long term care"]
    #[code = "32074000"]
    V32074000(Option<Element>),
    #[doc = "Hospital-based outpatient clinic or department--OTHER-NOT LISTED"]
    #[code = "33022008"]
    V33022008(Option<Element>),
    #[doc = "Hospital outpatient rheumatology clinic"]
    #[code = "331006"]
    V331006(Option<Element>),
    #[doc = "Ambulatory care site--OTHER--NOT LISTED"]
    #[code = "35971002"]
    V35971002(Option<Element>),
    #[doc = "Hospital outpatient allergy clinic"]
    #[code = "360957003"]
    V360957003(Option<Element>),
    #[doc = "Hospital outpatient immunology clinic"]
    #[code = "360966004"]
    V360966004(Option<Element>),
    #[doc = "Hospital-trauma center"]
    #[code = "36125001"]
    V36125001(Option<Element>),
    #[doc = "Hospital outpatient pain clinic"]
    #[code = "36293008"]
    V36293008(Option<Element>),
    #[doc = "Hospital outpatient pediatric clinic"]
    #[code = "3729002"]
    V3729002(Option<Element>),
    #[doc = "Hospital outpatient rehabilitation clinic"]
    #[code = "37546005"]
    V37546005(Option<Element>),
    #[doc = "Hospital outpatient dermatology clinic"]
    #[code = "37550003"]
    V37550003(Option<Element>),
    #[doc = "Hospital outpatient neurology clinic"]
    #[code = "38238005"]
    V38238005(Option<Element>),
    #[doc = "Private physicians' group office"]
    #[code = "39350007"]
    V39350007(Option<Element>),
    #[doc = "Independent ambulatory care provider site--OTHER--NOT LISTED"]
    #[code = "394759007"]
    V394759007(Option<Element>),
    #[doc = "Health encounter site--NOT LISTED"]
    #[code = "394777002"]
    V394777002(Option<Element>),
    #[doc = "Residential school infirmary"]
    #[code = "39913001"]
    V39913001(Option<Element>),
    #[doc = "Ambulatory surgery center"]
    #[code = "405607001"]
    V405607001(Option<Element>),
    #[doc = "Contained casualty setting"]
    #[code = "409519008"]
    V409519008(Option<Element>),
    #[doc = "Adult day care center"]
    #[code = "413456002"]
    V413456002(Option<Element>),
    #[doc = "Child day care center"]
    #[code = "413817003"]
    V413817003(Option<Element>),
    #[doc = "Free-standing geriatric health center"]
    #[code = "41844007"]
    V41844007(Option<Element>),
    #[doc = "Dialysis unit--hospital"]
    #[code = "418518002"]
    V418518002(Option<Element>),
    #[doc = "Residential institution"]
    #[code = "419955002"]
    V419955002(Option<Element>),
    #[doc = "Nursing home"]
    #[code = "42665001"]
    V42665001(Option<Element>),
    #[doc = "Hospital-military field"]
    #[code = "4322002"]
    V4322002(Option<Element>),
    #[doc = "Skilled nursing facility"]
    #[code = "45618002"]
    V45618002(Option<Element>),
    #[doc = "Free-standing laboratory facility"]
    #[code = "45899008"]
    V45899008(Option<Element>),
    #[doc = "Vaccination clinic"]
    #[code = "46224007"]
    V46224007(Option<Element>),
    #[doc = "Hospital-Veterans' Administration"]
    #[code = "48311003"]
    V48311003(Option<Element>),
    #[doc = "Hospital outpatient urology clinic"]
    #[code = "50569004"]
    V50569004(Option<Element>),
    #[doc = "Free-standing mental health center"]
    #[code = "51563005"]
    V51563005(Option<Element>),
    #[doc = "Hospital birthing center"]
    #[code = "52668009"]
    V52668009(Option<Element>),
    #[doc = "Hospital outpatient peripheral vascular clinic"]
    #[code = "5584006"]
    V5584006(Option<Element>),
    #[doc = "Hospital outpatient obstetrical clinic"]
    #[code = "56189001"]
    V56189001(Option<Element>),
    #[doc = "Hospital outpatient hematology clinic"]
    #[code = "56293002"]
    V56293002(Option<Element>),
    #[doc = "Hospital outpatient respiratory disease clinic"]
    #[code = "57159002"]
    V57159002(Option<Element>),
    #[doc = "Hospital outpatient gastroenterology clinic"]
    #[code = "58482006"]
    V58482006(Option<Element>),
    #[doc = "Traveler's aid clinic"]
    #[code = "59374000"]
    V59374000(Option<Element>),
    #[doc = "Hospital-psychiatric"]
    #[code = "62480006"]
    V62480006(Option<Element>),
    #[doc = "Local community health center"]
    #[code = "6827000"]
    V6827000(Option<Element>),
    #[doc = "Hospital ambulatory surgery facility"]
    #[code = "69362002"]
    V69362002(Option<Element>),
    #[doc = "Health maintenance organization"]
    #[code = "72311000"]
    V72311000(Option<Element>),
    #[doc = "Hospital outpatient endocrinology clinic"]
    #[code = "73644007"]
    V73644007(Option<Element>),
    #[doc = "Emergency department--hospital"]
    #[code = "73770003"]
    V73770003(Option<Element>),
    #[doc = "Rural health center"]
    #[code = "77931003"]
    V77931003(Option<Element>),
    #[doc = "Hospital outpatient orthopedics clinic"]
    #[code = "78001009"]
    V78001009(Option<Element>),
    #[doc = "Hospital outpatient ophthalmology clinic"]
    #[code = "78088001"]
    V78088001(Option<Element>),
    #[doc = "Hospital radiology facility"]
    #[code = "79491001"]
    V79491001(Option<Element>),
    #[doc = "Hospital-government"]
    #[code = "79993009"]
    V79993009(Option<Element>),
    #[doc = "Hospital-rehabilitation"]
    #[code = "80522000"]
    V80522000(Option<Element>),
    #[doc = "Walk-in clinic"]
    #[code = "81234003"]
    V81234003(Option<Element>),
    #[doc = "Hospital-children's"]
    #[code = "82242000"]
    V82242000(Option<Element>),
    #[doc = "Solo practice private office"]
    #[code = "83891005"]
    V83891005(Option<Element>),
    #[doc = "Hospital outpatient oncology clinic"]
    #[code = "89972002"]
    V89972002(Option<Element>),
    #[doc = "Helicopter-based care"]
    #[code = "901005"]
    V901005(Option<Element>),
    #[doc = "Hospital outpatient general surgery clinic"]
    #[code = "90484001"]
    V90484001(Option<Element>),
    #[doc = "Free-standing birthing center"]
    #[code = "91154008"]
    V91154008(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for C80Facilitycodes {
    fn default() -> Self {
        C80Facilitycodes::Null(None)
    }
}
impl TryFrom<String> for C80Facilitycodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "10206005" => Ok(C80Facilitycodes::V10206005(None)),
            "10531005" => Ok(C80Facilitycodes::V10531005(None)),
            "11424001" => Ok(C80Facilitycodes::V11424001(None)),
            "14866005" => Ok(C80Facilitycodes::V14866005(None)),
            "1773006" => Ok(C80Facilitycodes::V1773006(None)),
            "1814000" => Ok(C80Facilitycodes::V1814000(None)),
            "19602009" => Ok(C80Facilitycodes::V19602009(None)),
            "20078004" => Ok(C80Facilitycodes::V20078004(None)),
            "2081004" => Ok(C80Facilitycodes::V2081004(None)),
            "224687002" => Ok(C80Facilitycodes::V224687002(None)),
            "22549003" => Ok(C80Facilitycodes::V22549003(None)),
            "225732001" => Ok(C80Facilitycodes::V225732001(None)),
            "23392004" => Ok(C80Facilitycodes::V23392004(None)),
            "25681007" => Ok(C80Facilitycodes::V25681007(None)),
            "272501009" => Ok(C80Facilitycodes::V272501009(None)),
            "275576008" => Ok(C80Facilitycodes::V275576008(None)),
            "284546000" => Ok(C80Facilitycodes::V284546000(None)),
            "2849009" => Ok(C80Facilitycodes::V2849009(None)),
            "309898008" => Ok(C80Facilitycodes::V309898008(None)),
            "309900005" => Ok(C80Facilitycodes::V309900005(None)),
            "310205006" => Ok(C80Facilitycodes::V310205006(None)),
            "31628002" => Ok(C80Facilitycodes::V31628002(None)),
            "32074000" => Ok(C80Facilitycodes::V32074000(None)),
            "33022008" => Ok(C80Facilitycodes::V33022008(None)),
            "331006" => Ok(C80Facilitycodes::V331006(None)),
            "35971002" => Ok(C80Facilitycodes::V35971002(None)),
            "360957003" => Ok(C80Facilitycodes::V360957003(None)),
            "360966004" => Ok(C80Facilitycodes::V360966004(None)),
            "36125001" => Ok(C80Facilitycodes::V36125001(None)),
            "36293008" => Ok(C80Facilitycodes::V36293008(None)),
            "3729002" => Ok(C80Facilitycodes::V3729002(None)),
            "37546005" => Ok(C80Facilitycodes::V37546005(None)),
            "37550003" => Ok(C80Facilitycodes::V37550003(None)),
            "38238005" => Ok(C80Facilitycodes::V38238005(None)),
            "39350007" => Ok(C80Facilitycodes::V39350007(None)),
            "394759007" => Ok(C80Facilitycodes::V394759007(None)),
            "394777002" => Ok(C80Facilitycodes::V394777002(None)),
            "39913001" => Ok(C80Facilitycodes::V39913001(None)),
            "405607001" => Ok(C80Facilitycodes::V405607001(None)),
            "409519008" => Ok(C80Facilitycodes::V409519008(None)),
            "413456002" => Ok(C80Facilitycodes::V413456002(None)),
            "413817003" => Ok(C80Facilitycodes::V413817003(None)),
            "41844007" => Ok(C80Facilitycodes::V41844007(None)),
            "418518002" => Ok(C80Facilitycodes::V418518002(None)),
            "419955002" => Ok(C80Facilitycodes::V419955002(None)),
            "42665001" => Ok(C80Facilitycodes::V42665001(None)),
            "4322002" => Ok(C80Facilitycodes::V4322002(None)),
            "45618002" => Ok(C80Facilitycodes::V45618002(None)),
            "45899008" => Ok(C80Facilitycodes::V45899008(None)),
            "46224007" => Ok(C80Facilitycodes::V46224007(None)),
            "48311003" => Ok(C80Facilitycodes::V48311003(None)),
            "50569004" => Ok(C80Facilitycodes::V50569004(None)),
            "51563005" => Ok(C80Facilitycodes::V51563005(None)),
            "52668009" => Ok(C80Facilitycodes::V52668009(None)),
            "5584006" => Ok(C80Facilitycodes::V5584006(None)),
            "56189001" => Ok(C80Facilitycodes::V56189001(None)),
            "56293002" => Ok(C80Facilitycodes::V56293002(None)),
            "57159002" => Ok(C80Facilitycodes::V57159002(None)),
            "58482006" => Ok(C80Facilitycodes::V58482006(None)),
            "59374000" => Ok(C80Facilitycodes::V59374000(None)),
            "62480006" => Ok(C80Facilitycodes::V62480006(None)),
            "6827000" => Ok(C80Facilitycodes::V6827000(None)),
            "69362002" => Ok(C80Facilitycodes::V69362002(None)),
            "72311000" => Ok(C80Facilitycodes::V72311000(None)),
            "73644007" => Ok(C80Facilitycodes::V73644007(None)),
            "73770003" => Ok(C80Facilitycodes::V73770003(None)),
            "77931003" => Ok(C80Facilitycodes::V77931003(None)),
            "78001009" => Ok(C80Facilitycodes::V78001009(None)),
            "78088001" => Ok(C80Facilitycodes::V78088001(None)),
            "79491001" => Ok(C80Facilitycodes::V79491001(None)),
            "79993009" => Ok(C80Facilitycodes::V79993009(None)),
            "80522000" => Ok(C80Facilitycodes::V80522000(None)),
            "81234003" => Ok(C80Facilitycodes::V81234003(None)),
            "82242000" => Ok(C80Facilitycodes::V82242000(None)),
            "83891005" => Ok(C80Facilitycodes::V83891005(None)),
            "89972002" => Ok(C80Facilitycodes::V89972002(None)),
            "901005" => Ok(C80Facilitycodes::V901005(None)),
            "90484001" => Ok(C80Facilitycodes::V90484001(None)),
            "91154008" => Ok(C80Facilitycodes::V91154008(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &C80Facilitycodes {
    fn into(self) -> Option<String> {
        match self {
            C80Facilitycodes::V10206005(_) => Some("10206005".to_string()),
            C80Facilitycodes::V10531005(_) => Some("10531005".to_string()),
            C80Facilitycodes::V11424001(_) => Some("11424001".to_string()),
            C80Facilitycodes::V14866005(_) => Some("14866005".to_string()),
            C80Facilitycodes::V1773006(_) => Some("1773006".to_string()),
            C80Facilitycodes::V1814000(_) => Some("1814000".to_string()),
            C80Facilitycodes::V19602009(_) => Some("19602009".to_string()),
            C80Facilitycodes::V20078004(_) => Some("20078004".to_string()),
            C80Facilitycodes::V2081004(_) => Some("2081004".to_string()),
            C80Facilitycodes::V224687002(_) => Some("224687002".to_string()),
            C80Facilitycodes::V22549003(_) => Some("22549003".to_string()),
            C80Facilitycodes::V225732001(_) => Some("225732001".to_string()),
            C80Facilitycodes::V23392004(_) => Some("23392004".to_string()),
            C80Facilitycodes::V25681007(_) => Some("25681007".to_string()),
            C80Facilitycodes::V272501009(_) => Some("272501009".to_string()),
            C80Facilitycodes::V275576008(_) => Some("275576008".to_string()),
            C80Facilitycodes::V284546000(_) => Some("284546000".to_string()),
            C80Facilitycodes::V2849009(_) => Some("2849009".to_string()),
            C80Facilitycodes::V309898008(_) => Some("309898008".to_string()),
            C80Facilitycodes::V309900005(_) => Some("309900005".to_string()),
            C80Facilitycodes::V310205006(_) => Some("310205006".to_string()),
            C80Facilitycodes::V31628002(_) => Some("31628002".to_string()),
            C80Facilitycodes::V32074000(_) => Some("32074000".to_string()),
            C80Facilitycodes::V33022008(_) => Some("33022008".to_string()),
            C80Facilitycodes::V331006(_) => Some("331006".to_string()),
            C80Facilitycodes::V35971002(_) => Some("35971002".to_string()),
            C80Facilitycodes::V360957003(_) => Some("360957003".to_string()),
            C80Facilitycodes::V360966004(_) => Some("360966004".to_string()),
            C80Facilitycodes::V36125001(_) => Some("36125001".to_string()),
            C80Facilitycodes::V36293008(_) => Some("36293008".to_string()),
            C80Facilitycodes::V3729002(_) => Some("3729002".to_string()),
            C80Facilitycodes::V37546005(_) => Some("37546005".to_string()),
            C80Facilitycodes::V37550003(_) => Some("37550003".to_string()),
            C80Facilitycodes::V38238005(_) => Some("38238005".to_string()),
            C80Facilitycodes::V39350007(_) => Some("39350007".to_string()),
            C80Facilitycodes::V394759007(_) => Some("394759007".to_string()),
            C80Facilitycodes::V394777002(_) => Some("394777002".to_string()),
            C80Facilitycodes::V39913001(_) => Some("39913001".to_string()),
            C80Facilitycodes::V405607001(_) => Some("405607001".to_string()),
            C80Facilitycodes::V409519008(_) => Some("409519008".to_string()),
            C80Facilitycodes::V413456002(_) => Some("413456002".to_string()),
            C80Facilitycodes::V413817003(_) => Some("413817003".to_string()),
            C80Facilitycodes::V41844007(_) => Some("41844007".to_string()),
            C80Facilitycodes::V418518002(_) => Some("418518002".to_string()),
            C80Facilitycodes::V419955002(_) => Some("419955002".to_string()),
            C80Facilitycodes::V42665001(_) => Some("42665001".to_string()),
            C80Facilitycodes::V4322002(_) => Some("4322002".to_string()),
            C80Facilitycodes::V45618002(_) => Some("45618002".to_string()),
            C80Facilitycodes::V45899008(_) => Some("45899008".to_string()),
            C80Facilitycodes::V46224007(_) => Some("46224007".to_string()),
            C80Facilitycodes::V48311003(_) => Some("48311003".to_string()),
            C80Facilitycodes::V50569004(_) => Some("50569004".to_string()),
            C80Facilitycodes::V51563005(_) => Some("51563005".to_string()),
            C80Facilitycodes::V52668009(_) => Some("52668009".to_string()),
            C80Facilitycodes::V5584006(_) => Some("5584006".to_string()),
            C80Facilitycodes::V56189001(_) => Some("56189001".to_string()),
            C80Facilitycodes::V56293002(_) => Some("56293002".to_string()),
            C80Facilitycodes::V57159002(_) => Some("57159002".to_string()),
            C80Facilitycodes::V58482006(_) => Some("58482006".to_string()),
            C80Facilitycodes::V59374000(_) => Some("59374000".to_string()),
            C80Facilitycodes::V62480006(_) => Some("62480006".to_string()),
            C80Facilitycodes::V6827000(_) => Some("6827000".to_string()),
            C80Facilitycodes::V69362002(_) => Some("69362002".to_string()),
            C80Facilitycodes::V72311000(_) => Some("72311000".to_string()),
            C80Facilitycodes::V73644007(_) => Some("73644007".to_string()),
            C80Facilitycodes::V73770003(_) => Some("73770003".to_string()),
            C80Facilitycodes::V77931003(_) => Some("77931003".to_string()),
            C80Facilitycodes::V78001009(_) => Some("78001009".to_string()),
            C80Facilitycodes::V78088001(_) => Some("78088001".to_string()),
            C80Facilitycodes::V79491001(_) => Some("79491001".to_string()),
            C80Facilitycodes::V79993009(_) => Some("79993009".to_string()),
            C80Facilitycodes::V80522000(_) => Some("80522000".to_string()),
            C80Facilitycodes::V81234003(_) => Some("81234003".to_string()),
            C80Facilitycodes::V82242000(_) => Some("82242000".to_string()),
            C80Facilitycodes::V83891005(_) => Some("83891005".to_string()),
            C80Facilitycodes::V89972002(_) => Some("89972002".to_string()),
            C80Facilitycodes::V901005(_) => Some("901005".to_string()),
            C80Facilitycodes::V90484001(_) => Some("90484001".to_string()),
            C80Facilitycodes::V91154008(_) => Some("91154008".to_string()),
            C80Facilitycodes::Null(_) => None,
        }
    }
}
impl MetaValue for C80Facilitycodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                C80Facilitycodes::V10206005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V10531005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V11424001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V14866005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V1773006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V1814000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V19602009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V20078004(Some(e)) => e.get_field(field),
                C80Facilitycodes::V2081004(Some(e)) => e.get_field(field),
                C80Facilitycodes::V224687002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V22549003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V225732001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V23392004(Some(e)) => e.get_field(field),
                C80Facilitycodes::V25681007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V272501009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V275576008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V284546000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V2849009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V309898008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V309900005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V310205006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V31628002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V32074000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V33022008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V331006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V35971002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V360957003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V360966004(Some(e)) => e.get_field(field),
                C80Facilitycodes::V36125001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V36293008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V3729002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V37546005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V37550003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V38238005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V39350007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V394759007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V394777002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V39913001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V405607001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V409519008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V413456002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V413817003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V41844007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V418518002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V419955002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V42665001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V4322002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V45618002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V45899008(Some(e)) => e.get_field(field),
                C80Facilitycodes::V46224007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V48311003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V50569004(Some(e)) => e.get_field(field),
                C80Facilitycodes::V51563005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V52668009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V5584006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V56189001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V56293002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V57159002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V58482006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V59374000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V62480006(Some(e)) => e.get_field(field),
                C80Facilitycodes::V6827000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V69362002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V72311000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V73644007(Some(e)) => e.get_field(field),
                C80Facilitycodes::V73770003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V77931003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V78001009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V78088001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V79491001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V79993009(Some(e)) => e.get_field(field),
                C80Facilitycodes::V80522000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V81234003(Some(e)) => e.get_field(field),
                C80Facilitycodes::V82242000(Some(e)) => e.get_field(field),
                C80Facilitycodes::V83891005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V89972002(Some(e)) => e.get_field(field),
                C80Facilitycodes::V901005(Some(e)) => e.get_field(field),
                C80Facilitycodes::V90484001(Some(e)) => e.get_field(field),
                C80Facilitycodes::V91154008(Some(e)) => e.get_field(field),
                C80Facilitycodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                C80Facilitycodes::V10206005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V10531005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V11424001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V14866005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V1773006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V1814000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V19602009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V20078004(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V2081004(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V224687002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V22549003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V225732001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V23392004(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V25681007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V272501009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V275576008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V284546000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V2849009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V309898008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V309900005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V310205006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V31628002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V32074000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V33022008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V331006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V35971002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V360957003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V360966004(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V36125001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V36293008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V3729002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V37546005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V37550003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V38238005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V39350007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V394759007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V394777002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V39913001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V405607001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V409519008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V413456002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V413817003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V41844007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V418518002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V419955002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V42665001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V4322002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V45618002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V45899008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V46224007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V48311003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V50569004(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V51563005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V52668009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V5584006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V56189001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V56293002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V57159002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V58482006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V59374000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V62480006(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V6827000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V69362002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V72311000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V73644007(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V73770003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V77931003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V78001009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V78088001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V79491001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V79993009(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V80522000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V81234003(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V82242000(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V83891005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V89972002(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V901005(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V90484001(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::V91154008(Some(e)) => e.get_field_mut(field),
                C80Facilitycodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CapabilityStatementKind {
    #[doc = "Capability"]
    #[code = "capability"]
    Capability(Option<Element>),
    #[doc = "Instance"]
    #[code = "instance"]
    Instance(Option<Element>),
    #[doc = "Requirements"]
    #[code = "requirements"]
    Requirements(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CapabilityStatementKind {
    fn default() -> Self {
        CapabilityStatementKind::Null(None)
    }
}
impl TryFrom<String> for CapabilityStatementKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "capability" => Ok(CapabilityStatementKind::Capability(None)),
            "instance" => Ok(CapabilityStatementKind::Instance(None)),
            "requirements" => Ok(CapabilityStatementKind::Requirements(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CapabilityStatementKind {
    fn into(self) -> Option<String> {
        match self {
            CapabilityStatementKind::Capability(_) => Some("capability".to_string()),
            CapabilityStatementKind::Instance(_) => Some("instance".to_string()),
            CapabilityStatementKind::Requirements(_) => Some("requirements".to_string()),
            CapabilityStatementKind::Null(_) => None,
        }
    }
}
impl MetaValue for CapabilityStatementKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CapabilityStatementKind::Capability(Some(e)) => e.get_field(field),
                CapabilityStatementKind::Instance(Some(e)) => e.get_field(field),
                CapabilityStatementKind::Requirements(Some(e)) => e.get_field(field),
                CapabilityStatementKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CapabilityStatementKind::Capability(Some(e)) => e.get_field_mut(field),
                CapabilityStatementKind::Instance(Some(e)) => e.get_field_mut(field),
                CapabilityStatementKind::Requirements(Some(e)) => e.get_field_mut(field),
                CapabilityStatementKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CarePlanActivityKind {
    #[code = "Appointment"]
    Appointment(Option<Element>),
    #[code = "CommunicationRequest"]
    CommunicationRequest(Option<Element>),
    #[code = "DeviceRequest"]
    DeviceRequest(Option<Element>),
    #[code = "MedicationRequest"]
    MedicationRequest(Option<Element>),
    #[code = "NutritionOrder"]
    NutritionOrder(Option<Element>),
    #[code = "ServiceRequest"]
    ServiceRequest(Option<Element>),
    #[code = "Task"]
    Task(Option<Element>),
    #[code = "VisionPrescription"]
    VisionPrescription(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CarePlanActivityKind {
    fn default() -> Self {
        CarePlanActivityKind::Null(None)
    }
}
impl TryFrom<String> for CarePlanActivityKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Appointment" => Ok(CarePlanActivityKind::Appointment(None)),
            "CommunicationRequest" => Ok(CarePlanActivityKind::CommunicationRequest(None)),
            "DeviceRequest" => Ok(CarePlanActivityKind::DeviceRequest(None)),
            "MedicationRequest" => Ok(CarePlanActivityKind::MedicationRequest(None)),
            "NutritionOrder" => Ok(CarePlanActivityKind::NutritionOrder(None)),
            "ServiceRequest" => Ok(CarePlanActivityKind::ServiceRequest(None)),
            "Task" => Ok(CarePlanActivityKind::Task(None)),
            "VisionPrescription" => Ok(CarePlanActivityKind::VisionPrescription(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CarePlanActivityKind {
    fn into(self) -> Option<String> {
        match self {
            CarePlanActivityKind::Appointment(_) => Some("Appointment".to_string()),
            CarePlanActivityKind::CommunicationRequest(_) => {
                Some("CommunicationRequest".to_string())
            }
            CarePlanActivityKind::DeviceRequest(_) => Some("DeviceRequest".to_string()),
            CarePlanActivityKind::MedicationRequest(_) => Some("MedicationRequest".to_string()),
            CarePlanActivityKind::NutritionOrder(_) => Some("NutritionOrder".to_string()),
            CarePlanActivityKind::ServiceRequest(_) => Some("ServiceRequest".to_string()),
            CarePlanActivityKind::Task(_) => Some("Task".to_string()),
            CarePlanActivityKind::VisionPrescription(_) => Some("VisionPrescription".to_string()),
            CarePlanActivityKind::Null(_) => None,
        }
    }
}
impl MetaValue for CarePlanActivityKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CarePlanActivityKind::Appointment(Some(e)) => e.get_field(field),
                CarePlanActivityKind::CommunicationRequest(Some(e)) => e.get_field(field),
                CarePlanActivityKind::DeviceRequest(Some(e)) => e.get_field(field),
                CarePlanActivityKind::MedicationRequest(Some(e)) => e.get_field(field),
                CarePlanActivityKind::NutritionOrder(Some(e)) => e.get_field(field),
                CarePlanActivityKind::ServiceRequest(Some(e)) => e.get_field(field),
                CarePlanActivityKind::Task(Some(e)) => e.get_field(field),
                CarePlanActivityKind::VisionPrescription(Some(e)) => e.get_field(field),
                CarePlanActivityKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CarePlanActivityKind::Appointment(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::CommunicationRequest(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::DeviceRequest(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::MedicationRequest(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::NutritionOrder(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::ServiceRequest(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::Task(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::VisionPrescription(Some(e)) => e.get_field_mut(field),
                CarePlanActivityKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CarePlanActivityStatus {
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Not Started"]
    #[code = "not-started"]
    NotStarted(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Scheduled"]
    #[code = "scheduled"]
    Scheduled(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CarePlanActivityStatus {
    fn default() -> Self {
        CarePlanActivityStatus::Null(None)
    }
}
impl TryFrom<String> for CarePlanActivityStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cancelled" => Ok(CarePlanActivityStatus::Cancelled(None)),
            "completed" => Ok(CarePlanActivityStatus::Completed(None)),
            "entered-in-error" => Ok(CarePlanActivityStatus::EnteredInError(None)),
            "in-progress" => Ok(CarePlanActivityStatus::InProgress(None)),
            "not-started" => Ok(CarePlanActivityStatus::NotStarted(None)),
            "on-hold" => Ok(CarePlanActivityStatus::OnHold(None)),
            "scheduled" => Ok(CarePlanActivityStatus::Scheduled(None)),
            "stopped" => Ok(CarePlanActivityStatus::Stopped(None)),
            "unknown" => Ok(CarePlanActivityStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CarePlanActivityStatus {
    fn into(self) -> Option<String> {
        match self {
            CarePlanActivityStatus::Cancelled(_) => Some("cancelled".to_string()),
            CarePlanActivityStatus::Completed(_) => Some("completed".to_string()),
            CarePlanActivityStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            CarePlanActivityStatus::InProgress(_) => Some("in-progress".to_string()),
            CarePlanActivityStatus::NotStarted(_) => Some("not-started".to_string()),
            CarePlanActivityStatus::OnHold(_) => Some("on-hold".to_string()),
            CarePlanActivityStatus::Scheduled(_) => Some("scheduled".to_string()),
            CarePlanActivityStatus::Stopped(_) => Some("stopped".to_string()),
            CarePlanActivityStatus::Unknown(_) => Some("unknown".to_string()),
            CarePlanActivityStatus::Null(_) => None,
        }
    }
}
impl MetaValue for CarePlanActivityStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CarePlanActivityStatus::Cancelled(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::Completed(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::EnteredInError(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::InProgress(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::NotStarted(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::OnHold(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::Scheduled(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::Stopped(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::Unknown(Some(e)) => e.get_field(field),
                CarePlanActivityStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CarePlanActivityStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::Completed(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::InProgress(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::NotStarted(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::OnHold(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::Scheduled(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::Stopped(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::Unknown(Some(e)) => e.get_field_mut(field),
                CarePlanActivityStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CarePlanIntent {
    #[code = "option"]
    Option(Option<Element>),
    #[code = "order"]
    Order(Option<Element>),
    #[code = "plan"]
    Plan(Option<Element>),
    #[code = "proposal"]
    Proposal(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CarePlanIntent {
    fn default() -> Self {
        CarePlanIntent::Null(None)
    }
}
impl TryFrom<String> for CarePlanIntent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "option" => Ok(CarePlanIntent::Option(None)),
            "order" => Ok(CarePlanIntent::Order(None)),
            "plan" => Ok(CarePlanIntent::Plan(None)),
            "proposal" => Ok(CarePlanIntent::Proposal(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CarePlanIntent {
    fn into(self) -> Option<String> {
        match self {
            CarePlanIntent::Option(_) => Some("option".to_string()),
            CarePlanIntent::Order(_) => Some("order".to_string()),
            CarePlanIntent::Plan(_) => Some("plan".to_string()),
            CarePlanIntent::Proposal(_) => Some("proposal".to_string()),
            CarePlanIntent::Null(_) => None,
        }
    }
}
impl MetaValue for CarePlanIntent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CarePlanIntent::Option(Some(e)) => e.get_field(field),
                CarePlanIntent::Order(Some(e)) => e.get_field(field),
                CarePlanIntent::Plan(Some(e)) => e.get_field(field),
                CarePlanIntent::Proposal(Some(e)) => e.get_field(field),
                CarePlanIntent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CarePlanIntent::Option(Some(e)) => e.get_field_mut(field),
                CarePlanIntent::Order(Some(e)) => e.get_field_mut(field),
                CarePlanIntent::Plan(Some(e)) => e.get_field_mut(field),
                CarePlanIntent::Proposal(Some(e)) => e.get_field_mut(field),
                CarePlanIntent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CareTeamStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Proposed"]
    #[code = "proposed"]
    Proposed(Option<Element>),
    #[doc = "Suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CareTeamStatus {
    fn default() -> Self {
        CareTeamStatus::Null(None)
    }
}
impl TryFrom<String> for CareTeamStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(CareTeamStatus::Active(None)),
            "entered-in-error" => Ok(CareTeamStatus::EnteredInError(None)),
            "inactive" => Ok(CareTeamStatus::Inactive(None)),
            "proposed" => Ok(CareTeamStatus::Proposed(None)),
            "suspended" => Ok(CareTeamStatus::Suspended(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CareTeamStatus {
    fn into(self) -> Option<String> {
        match self {
            CareTeamStatus::Active(_) => Some("active".to_string()),
            CareTeamStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            CareTeamStatus::Inactive(_) => Some("inactive".to_string()),
            CareTeamStatus::Proposed(_) => Some("proposed".to_string()),
            CareTeamStatus::Suspended(_) => Some("suspended".to_string()),
            CareTeamStatus::Null(_) => None,
        }
    }
}
impl MetaValue for CareTeamStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CareTeamStatus::Active(Some(e)) => e.get_field(field),
                CareTeamStatus::EnteredInError(Some(e)) => e.get_field(field),
                CareTeamStatus::Inactive(Some(e)) => e.get_field(field),
                CareTeamStatus::Proposed(Some(e)) => e.get_field(field),
                CareTeamStatus::Suspended(Some(e)) => e.get_field(field),
                CareTeamStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CareTeamStatus::Active(Some(e)) => e.get_field_mut(field),
                CareTeamStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                CareTeamStatus::Inactive(Some(e)) => e.get_field_mut(field),
                CareTeamStatus::Proposed(Some(e)) => e.get_field_mut(field),
                CareTeamStatus::Suspended(Some(e)) => e.get_field_mut(field),
                CareTeamStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CatalogType {
    #[doc = "Device Catalog"]
    #[code = "device"]
    Device(Option<Element>),
    #[doc = "Medication Catalog"]
    #[code = "medication"]
    Medication(Option<Element>),
    #[doc = "Protocol List"]
    #[code = "protocol"]
    Protocol(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CatalogType {
    fn default() -> Self {
        CatalogType::Null(None)
    }
}
impl TryFrom<String> for CatalogType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "device" => Ok(CatalogType::Device(None)),
            "medication" => Ok(CatalogType::Medication(None)),
            "protocol" => Ok(CatalogType::Protocol(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CatalogType {
    fn into(self) -> Option<String> {
        match self {
            CatalogType::Device(_) => Some("device".to_string()),
            CatalogType::Medication(_) => Some("medication".to_string()),
            CatalogType::Protocol(_) => Some("protocol".to_string()),
            CatalogType::Null(_) => None,
        }
    }
}
impl MetaValue for CatalogType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CatalogType::Device(Some(e)) => e.get_field(field),
                CatalogType::Medication(Some(e)) => e.get_field(field),
                CatalogType::Protocol(Some(e)) => e.get_field(field),
                CatalogType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CatalogType::Device(Some(e)) => e.get_field_mut(field),
                CatalogType::Medication(Some(e)) => e.get_field_mut(field),
                CatalogType::Protocol(Some(e)) => e.get_field_mut(field),
                CatalogType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CdshooksIndicator {
    #[doc = "The response is critical and indicates the workflow should not be allowed to proceed"]
    #[code = "critical"]
    Critical(Option<Element>),
    #[doc = "The response is informational"]
    #[code = "info"]
    Info(Option<Element>),
    #[doc = "The response is a warning"]
    #[code = "warning"]
    Warning(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CdshooksIndicator {
    fn default() -> Self {
        CdshooksIndicator::Null(None)
    }
}
impl TryFrom<String> for CdshooksIndicator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "critical" => Ok(CdshooksIndicator::Critical(None)),
            "info" => Ok(CdshooksIndicator::Info(None)),
            "warning" => Ok(CdshooksIndicator::Warning(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CdshooksIndicator {
    fn into(self) -> Option<String> {
        match self {
            CdshooksIndicator::Critical(_) => Some("critical".to_string()),
            CdshooksIndicator::Info(_) => Some("info".to_string()),
            CdshooksIndicator::Warning(_) => Some("warning".to_string()),
            CdshooksIndicator::Null(_) => None,
        }
    }
}
impl MetaValue for CdshooksIndicator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CdshooksIndicator::Critical(Some(e)) => e.get_field(field),
                CdshooksIndicator::Info(Some(e)) => e.get_field(field),
                CdshooksIndicator::Warning(Some(e)) => e.get_field(field),
                CdshooksIndicator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CdshooksIndicator::Critical(Some(e)) => e.get_field_mut(field),
                CdshooksIndicator::Info(Some(e)) => e.get_field_mut(field),
                CdshooksIndicator::Warning(Some(e)) => e.get_field_mut(field),
                CdshooksIndicator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CertaintySubcomponentRating {
    #[doc = "absent"]
    #[code = "absent"]
    Absent(Option<Element>),
    #[doc = "critical concern"]
    #[code = "critical-concern"]
    CriticalConcern(Option<Element>),
    #[doc = "reduce rating: -1"]
    #[code = "downcode1"]
    Downcode1(Option<Element>),
    #[doc = "reduce rating: -2"]
    #[code = "downcode2"]
    Downcode2(Option<Element>),
    #[doc = "reduce rating: -3"]
    #[code = "downcode3"]
    Downcode3(Option<Element>),
    #[doc = "no change to rating"]
    #[code = "no-change"]
    NoChange(Option<Element>),
    #[doc = "no serious concern"]
    #[code = "no-concern"]
    NoConcern(Option<Element>),
    #[doc = "present"]
    #[code = "present"]
    Present(Option<Element>),
    #[doc = "serious concern"]
    #[code = "serious-concern"]
    SeriousConcern(Option<Element>),
    #[doc = "increase rating: +1"]
    #[code = "upcode1"]
    Upcode1(Option<Element>),
    #[doc = "increase rating: +2"]
    #[code = "upcode2"]
    Upcode2(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CertaintySubcomponentRating {
    fn default() -> Self {
        CertaintySubcomponentRating::Null(None)
    }
}
impl TryFrom<String> for CertaintySubcomponentRating {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "absent" => Ok(CertaintySubcomponentRating::Absent(None)),
            "critical-concern" => Ok(CertaintySubcomponentRating::CriticalConcern(None)),
            "downcode1" => Ok(CertaintySubcomponentRating::Downcode1(None)),
            "downcode2" => Ok(CertaintySubcomponentRating::Downcode2(None)),
            "downcode3" => Ok(CertaintySubcomponentRating::Downcode3(None)),
            "no-change" => Ok(CertaintySubcomponentRating::NoChange(None)),
            "no-concern" => Ok(CertaintySubcomponentRating::NoConcern(None)),
            "present" => Ok(CertaintySubcomponentRating::Present(None)),
            "serious-concern" => Ok(CertaintySubcomponentRating::SeriousConcern(None)),
            "upcode1" => Ok(CertaintySubcomponentRating::Upcode1(None)),
            "upcode2" => Ok(CertaintySubcomponentRating::Upcode2(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CertaintySubcomponentRating {
    fn into(self) -> Option<String> {
        match self {
            CertaintySubcomponentRating::Absent(_) => Some("absent".to_string()),
            CertaintySubcomponentRating::CriticalConcern(_) => Some("critical-concern".to_string()),
            CertaintySubcomponentRating::Downcode1(_) => Some("downcode1".to_string()),
            CertaintySubcomponentRating::Downcode2(_) => Some("downcode2".to_string()),
            CertaintySubcomponentRating::Downcode3(_) => Some("downcode3".to_string()),
            CertaintySubcomponentRating::NoChange(_) => Some("no-change".to_string()),
            CertaintySubcomponentRating::NoConcern(_) => Some("no-concern".to_string()),
            CertaintySubcomponentRating::Present(_) => Some("present".to_string()),
            CertaintySubcomponentRating::SeriousConcern(_) => Some("serious-concern".to_string()),
            CertaintySubcomponentRating::Upcode1(_) => Some("upcode1".to_string()),
            CertaintySubcomponentRating::Upcode2(_) => Some("upcode2".to_string()),
            CertaintySubcomponentRating::Null(_) => None,
        }
    }
}
impl MetaValue for CertaintySubcomponentRating {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CertaintySubcomponentRating::Absent(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::CriticalConcern(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Downcode1(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Downcode2(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Downcode3(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::NoChange(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::NoConcern(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Present(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::SeriousConcern(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Upcode1(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Upcode2(Some(e)) => e.get_field(field),
                CertaintySubcomponentRating::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CertaintySubcomponentRating::Absent(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::CriticalConcern(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Downcode1(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Downcode2(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Downcode3(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::NoChange(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::NoConcern(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Present(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::SeriousConcern(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Upcode1(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Upcode2(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentRating::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CertaintySubcomponentType {
    #[doc = "Dose response gradient"]
    #[code = "DoseResponseGradient"]
    DoseResponseGradient(Option<Element>),
    #[doc = "Imprecision"]
    #[code = "Imprecision"]
    Imprecision(Option<Element>),
    #[doc = "Inconsistency"]
    #[code = "Inconsistency"]
    Inconsistency(Option<Element>),
    #[doc = "Indirectness"]
    #[code = "Indirectness"]
    Indirectness(Option<Element>),
    #[doc = "Large effect"]
    #[code = "LargeEffect"]
    LargeEffect(Option<Element>),
    #[doc = "Plausible confounding"]
    #[code = "PlausibleConfounding"]
    PlausibleConfounding(Option<Element>),
    #[doc = "Publication bias"]
    #[code = "PublicationBias"]
    PublicationBias(Option<Element>),
    #[doc = "Risk of bias"]
    #[code = "RiskOfBias"]
    RiskOfBias(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CertaintySubcomponentType {
    fn default() -> Self {
        CertaintySubcomponentType::Null(None)
    }
}
impl TryFrom<String> for CertaintySubcomponentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DoseResponseGradient" => Ok(CertaintySubcomponentType::DoseResponseGradient(None)),
            "Imprecision" => Ok(CertaintySubcomponentType::Imprecision(None)),
            "Inconsistency" => Ok(CertaintySubcomponentType::Inconsistency(None)),
            "Indirectness" => Ok(CertaintySubcomponentType::Indirectness(None)),
            "LargeEffect" => Ok(CertaintySubcomponentType::LargeEffect(None)),
            "PlausibleConfounding" => Ok(CertaintySubcomponentType::PlausibleConfounding(None)),
            "PublicationBias" => Ok(CertaintySubcomponentType::PublicationBias(None)),
            "RiskOfBias" => Ok(CertaintySubcomponentType::RiskOfBias(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CertaintySubcomponentType {
    fn into(self) -> Option<String> {
        match self {
            CertaintySubcomponentType::DoseResponseGradient(_) => {
                Some("DoseResponseGradient".to_string())
            }
            CertaintySubcomponentType::Imprecision(_) => Some("Imprecision".to_string()),
            CertaintySubcomponentType::Inconsistency(_) => Some("Inconsistency".to_string()),
            CertaintySubcomponentType::Indirectness(_) => Some("Indirectness".to_string()),
            CertaintySubcomponentType::LargeEffect(_) => Some("LargeEffect".to_string()),
            CertaintySubcomponentType::PlausibleConfounding(_) => {
                Some("PlausibleConfounding".to_string())
            }
            CertaintySubcomponentType::PublicationBias(_) => Some("PublicationBias".to_string()),
            CertaintySubcomponentType::RiskOfBias(_) => Some("RiskOfBias".to_string()),
            CertaintySubcomponentType::Null(_) => None,
        }
    }
}
impl MetaValue for CertaintySubcomponentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CertaintySubcomponentType::DoseResponseGradient(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::Imprecision(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::Inconsistency(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::Indirectness(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::LargeEffect(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::PlausibleConfounding(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::PublicationBias(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::RiskOfBias(Some(e)) => e.get_field(field),
                CertaintySubcomponentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CertaintySubcomponentType::DoseResponseGradient(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::Imprecision(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::Inconsistency(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::Indirectness(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::LargeEffect(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::PlausibleConfounding(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::PublicationBias(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::RiskOfBias(Some(e)) => e.get_field_mut(field),
                CertaintySubcomponentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ChargeitemBillingcodes {
    #[doc = "Unvorhergesehene Inanspruchnahme"]
    #[code = "1100"]
    V1100(Option<Element>),
    #[doc = "Notfallpauschale"]
    #[code = "1210"]
    V1210(Option<Element>),
    #[doc = "Grundpauschale"]
    #[code = "1320"]
    V1320(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ChargeitemBillingcodes {
    fn default() -> Self {
        ChargeitemBillingcodes::Null(None)
    }
}
impl TryFrom<String> for ChargeitemBillingcodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1100" => Ok(ChargeitemBillingcodes::V1100(None)),
            "1210" => Ok(ChargeitemBillingcodes::V1210(None)),
            "1320" => Ok(ChargeitemBillingcodes::V1320(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ChargeitemBillingcodes {
    fn into(self) -> Option<String> {
        match self {
            ChargeitemBillingcodes::V1100(_) => Some("1100".to_string()),
            ChargeitemBillingcodes::V1210(_) => Some("1210".to_string()),
            ChargeitemBillingcodes::V1320(_) => Some("1320".to_string()),
            ChargeitemBillingcodes::Null(_) => None,
        }
    }
}
impl MetaValue for ChargeitemBillingcodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ChargeitemBillingcodes::V1100(Some(e)) => e.get_field(field),
                ChargeitemBillingcodes::V1210(Some(e)) => e.get_field(field),
                ChargeitemBillingcodes::V1320(Some(e)) => e.get_field(field),
                ChargeitemBillingcodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ChargeitemBillingcodes::V1100(Some(e)) => e.get_field_mut(field),
                ChargeitemBillingcodes::V1210(Some(e)) => e.get_field_mut(field),
                ChargeitemBillingcodes::V1320(Some(e)) => e.get_field_mut(field),
                ChargeitemBillingcodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ChargeitemStatus {
    #[doc = "Aborted"]
    #[code = "aborted"]
    Aborted(Option<Element>),
    #[doc = "Billable"]
    #[code = "billable"]
    Billable(Option<Element>),
    #[doc = "Billed"]
    #[code = "billed"]
    Billed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Not billable"]
    #[code = "not-billable"]
    NotBillable(Option<Element>),
    #[doc = "Planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ChargeitemStatus {
    fn default() -> Self {
        ChargeitemStatus::Null(None)
    }
}
impl TryFrom<String> for ChargeitemStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aborted" => Ok(ChargeitemStatus::Aborted(None)),
            "billable" => Ok(ChargeitemStatus::Billable(None)),
            "billed" => Ok(ChargeitemStatus::Billed(None)),
            "entered-in-error" => Ok(ChargeitemStatus::EnteredInError(None)),
            "not-billable" => Ok(ChargeitemStatus::NotBillable(None)),
            "planned" => Ok(ChargeitemStatus::Planned(None)),
            "unknown" => Ok(ChargeitemStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ChargeitemStatus {
    fn into(self) -> Option<String> {
        match self {
            ChargeitemStatus::Aborted(_) => Some("aborted".to_string()),
            ChargeitemStatus::Billable(_) => Some("billable".to_string()),
            ChargeitemStatus::Billed(_) => Some("billed".to_string()),
            ChargeitemStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ChargeitemStatus::NotBillable(_) => Some("not-billable".to_string()),
            ChargeitemStatus::Planned(_) => Some("planned".to_string()),
            ChargeitemStatus::Unknown(_) => Some("unknown".to_string()),
            ChargeitemStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ChargeitemStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ChargeitemStatus::Aborted(Some(e)) => e.get_field(field),
                ChargeitemStatus::Billable(Some(e)) => e.get_field(field),
                ChargeitemStatus::Billed(Some(e)) => e.get_field(field),
                ChargeitemStatus::EnteredInError(Some(e)) => e.get_field(field),
                ChargeitemStatus::NotBillable(Some(e)) => e.get_field(field),
                ChargeitemStatus::Planned(Some(e)) => e.get_field(field),
                ChargeitemStatus::Unknown(Some(e)) => e.get_field(field),
                ChargeitemStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ChargeitemStatus::Aborted(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::Billable(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::Billed(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::NotBillable(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::Planned(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::Unknown(Some(e)) => e.get_field_mut(field),
                ChargeitemStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ChoiceListOrientation {
    #[doc = "Horizontal"]
    #[code = "horizontal"]
    Horizontal(Option<Element>),
    #[doc = "Vertical"]
    #[code = "vertical"]
    Vertical(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ChoiceListOrientation {
    fn default() -> Self {
        ChoiceListOrientation::Null(None)
    }
}
impl TryFrom<String> for ChoiceListOrientation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "horizontal" => Ok(ChoiceListOrientation::Horizontal(None)),
            "vertical" => Ok(ChoiceListOrientation::Vertical(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ChoiceListOrientation {
    fn into(self) -> Option<String> {
        match self {
            ChoiceListOrientation::Horizontal(_) => Some("horizontal".to_string()),
            ChoiceListOrientation::Vertical(_) => Some("vertical".to_string()),
            ChoiceListOrientation::Null(_) => None,
        }
    }
}
impl MetaValue for ChoiceListOrientation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ChoiceListOrientation::Horizontal(Some(e)) => e.get_field(field),
                ChoiceListOrientation::Vertical(Some(e)) => e.get_field(field),
                ChoiceListOrientation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ChoiceListOrientation::Horizontal(Some(e)) => e.get_field_mut(field),
                ChoiceListOrientation::Vertical(Some(e)) => e.get_field_mut(field),
                ChoiceListOrientation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ChromosomeHuman {
    #[doc = "chromosome 1"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "chromosome 10"]
    #[code = "10"]
    V10(Option<Element>),
    #[doc = "chromosome 11"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "chromosome 12"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "chromosome 13"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "chromosome 14"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "chromosome 15"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "chromosome 16"]
    #[code = "16"]
    V16(Option<Element>),
    #[doc = "chromosome 17"]
    #[code = "17"]
    V17(Option<Element>),
    #[doc = "chromosome 18"]
    #[code = "18"]
    V18(Option<Element>),
    #[doc = "chromosome 19"]
    #[code = "19"]
    V19(Option<Element>),
    #[doc = "chromosome 2"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "chromosome 20"]
    #[code = "20"]
    V20(Option<Element>),
    #[doc = "chromosome 21"]
    #[code = "21"]
    V21(Option<Element>),
    #[doc = "chromosome 22"]
    #[code = "22"]
    V22(Option<Element>),
    #[doc = "chromosome 3"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "chromosome 4"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "chromosome 5"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "chromosome 6"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "chromosome 7"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "chromosome 8"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "chromosome 9"]
    #[code = "9"]
    V9(Option<Element>),
    #[doc = "chromosome X"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "chromosome Y"]
    #[code = "Y"]
    Y(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ChromosomeHuman {
    fn default() -> Self {
        ChromosomeHuman::Null(None)
    }
}
impl TryFrom<String> for ChromosomeHuman {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(ChromosomeHuman::V1(None)),
            "10" => Ok(ChromosomeHuman::V10(None)),
            "11" => Ok(ChromosomeHuman::V11(None)),
            "12" => Ok(ChromosomeHuman::V12(None)),
            "13" => Ok(ChromosomeHuman::V13(None)),
            "14" => Ok(ChromosomeHuman::V14(None)),
            "15" => Ok(ChromosomeHuman::V15(None)),
            "16" => Ok(ChromosomeHuman::V16(None)),
            "17" => Ok(ChromosomeHuman::V17(None)),
            "18" => Ok(ChromosomeHuman::V18(None)),
            "19" => Ok(ChromosomeHuman::V19(None)),
            "2" => Ok(ChromosomeHuman::V2(None)),
            "20" => Ok(ChromosomeHuman::V20(None)),
            "21" => Ok(ChromosomeHuman::V21(None)),
            "22" => Ok(ChromosomeHuman::V22(None)),
            "3" => Ok(ChromosomeHuman::V3(None)),
            "4" => Ok(ChromosomeHuman::V4(None)),
            "5" => Ok(ChromosomeHuman::V5(None)),
            "6" => Ok(ChromosomeHuman::V6(None)),
            "7" => Ok(ChromosomeHuman::V7(None)),
            "8" => Ok(ChromosomeHuman::V8(None)),
            "9" => Ok(ChromosomeHuman::V9(None)),
            "X" => Ok(ChromosomeHuman::X(None)),
            "Y" => Ok(ChromosomeHuman::Y(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ChromosomeHuman {
    fn into(self) -> Option<String> {
        match self {
            ChromosomeHuman::V1(_) => Some("1".to_string()),
            ChromosomeHuman::V10(_) => Some("10".to_string()),
            ChromosomeHuman::V11(_) => Some("11".to_string()),
            ChromosomeHuman::V12(_) => Some("12".to_string()),
            ChromosomeHuman::V13(_) => Some("13".to_string()),
            ChromosomeHuman::V14(_) => Some("14".to_string()),
            ChromosomeHuman::V15(_) => Some("15".to_string()),
            ChromosomeHuman::V16(_) => Some("16".to_string()),
            ChromosomeHuman::V17(_) => Some("17".to_string()),
            ChromosomeHuman::V18(_) => Some("18".to_string()),
            ChromosomeHuman::V19(_) => Some("19".to_string()),
            ChromosomeHuman::V2(_) => Some("2".to_string()),
            ChromosomeHuman::V20(_) => Some("20".to_string()),
            ChromosomeHuman::V21(_) => Some("21".to_string()),
            ChromosomeHuman::V22(_) => Some("22".to_string()),
            ChromosomeHuman::V3(_) => Some("3".to_string()),
            ChromosomeHuman::V4(_) => Some("4".to_string()),
            ChromosomeHuman::V5(_) => Some("5".to_string()),
            ChromosomeHuman::V6(_) => Some("6".to_string()),
            ChromosomeHuman::V7(_) => Some("7".to_string()),
            ChromosomeHuman::V8(_) => Some("8".to_string()),
            ChromosomeHuman::V9(_) => Some("9".to_string()),
            ChromosomeHuman::X(_) => Some("X".to_string()),
            ChromosomeHuman::Y(_) => Some("Y".to_string()),
            ChromosomeHuman::Null(_) => None,
        }
    }
}
impl MetaValue for ChromosomeHuman {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ChromosomeHuman::V1(Some(e)) => e.get_field(field),
                ChromosomeHuman::V10(Some(e)) => e.get_field(field),
                ChromosomeHuman::V11(Some(e)) => e.get_field(field),
                ChromosomeHuman::V12(Some(e)) => e.get_field(field),
                ChromosomeHuman::V13(Some(e)) => e.get_field(field),
                ChromosomeHuman::V14(Some(e)) => e.get_field(field),
                ChromosomeHuman::V15(Some(e)) => e.get_field(field),
                ChromosomeHuman::V16(Some(e)) => e.get_field(field),
                ChromosomeHuman::V17(Some(e)) => e.get_field(field),
                ChromosomeHuman::V18(Some(e)) => e.get_field(field),
                ChromosomeHuman::V19(Some(e)) => e.get_field(field),
                ChromosomeHuman::V2(Some(e)) => e.get_field(field),
                ChromosomeHuman::V20(Some(e)) => e.get_field(field),
                ChromosomeHuman::V21(Some(e)) => e.get_field(field),
                ChromosomeHuman::V22(Some(e)) => e.get_field(field),
                ChromosomeHuman::V3(Some(e)) => e.get_field(field),
                ChromosomeHuman::V4(Some(e)) => e.get_field(field),
                ChromosomeHuman::V5(Some(e)) => e.get_field(field),
                ChromosomeHuman::V6(Some(e)) => e.get_field(field),
                ChromosomeHuman::V7(Some(e)) => e.get_field(field),
                ChromosomeHuman::V8(Some(e)) => e.get_field(field),
                ChromosomeHuman::V9(Some(e)) => e.get_field(field),
                ChromosomeHuman::X(Some(e)) => e.get_field(field),
                ChromosomeHuman::Y(Some(e)) => e.get_field(field),
                ChromosomeHuman::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ChromosomeHuman::V1(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V10(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V11(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V12(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V13(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V14(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V15(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V16(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V17(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V18(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V19(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V2(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V20(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V21(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V22(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V3(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V4(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V5(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V6(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V7(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V8(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::V9(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::X(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::Y(Some(e)) => e.get_field_mut(field),
                ChromosomeHuman::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimCareteamrole {
    #[doc = "Assisting Provider"]
    #[code = "assist"]
    Assist(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Primary provider"]
    #[code = "primary"]
    Primary(Option<Element>),
    #[doc = "Supervising Provider"]
    #[code = "supervisor"]
    Supervisor(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimCareteamrole {
    fn default() -> Self {
        ClaimCareteamrole::Null(None)
    }
}
impl TryFrom<String> for ClaimCareteamrole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "assist" => Ok(ClaimCareteamrole::Assist(None)),
            "other" => Ok(ClaimCareteamrole::Other(None)),
            "primary" => Ok(ClaimCareteamrole::Primary(None)),
            "supervisor" => Ok(ClaimCareteamrole::Supervisor(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimCareteamrole {
    fn into(self) -> Option<String> {
        match self {
            ClaimCareteamrole::Assist(_) => Some("assist".to_string()),
            ClaimCareteamrole::Other(_) => Some("other".to_string()),
            ClaimCareteamrole::Primary(_) => Some("primary".to_string()),
            ClaimCareteamrole::Supervisor(_) => Some("supervisor".to_string()),
            ClaimCareteamrole::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimCareteamrole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimCareteamrole::Assist(Some(e)) => e.get_field(field),
                ClaimCareteamrole::Other(Some(e)) => e.get_field(field),
                ClaimCareteamrole::Primary(Some(e)) => e.get_field(field),
                ClaimCareteamrole::Supervisor(Some(e)) => e.get_field(field),
                ClaimCareteamrole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimCareteamrole::Assist(Some(e)) => e.get_field_mut(field),
                ClaimCareteamrole::Other(Some(e)) => e.get_field_mut(field),
                ClaimCareteamrole::Primary(Some(e)) => e.get_field_mut(field),
                ClaimCareteamrole::Supervisor(Some(e)) => e.get_field_mut(field),
                ClaimCareteamrole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimException {
    #[doc = "Disabled"]
    #[code = "disabled"]
    Disabled(Option<Element>),
    #[doc = "Student (Fulltime)"]
    #[code = "student"]
    Student(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimException {
    fn default() -> Self {
        ClaimException::Null(None)
    }
}
impl TryFrom<String> for ClaimException {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "disabled" => Ok(ClaimException::Disabled(None)),
            "student" => Ok(ClaimException::Student(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimException {
    fn into(self) -> Option<String> {
        match self {
            ClaimException::Disabled(_) => Some("disabled".to_string()),
            ClaimException::Student(_) => Some("student".to_string()),
            ClaimException::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimException {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimException::Disabled(Some(e)) => e.get_field(field),
                ClaimException::Student(Some(e)) => e.get_field(field),
                ClaimException::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimException::Disabled(Some(e)) => e.get_field_mut(field),
                ClaimException::Student(Some(e)) => e.get_field_mut(field),
                ClaimException::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimInformationcategory {
    #[doc = "Attachment"]
    #[code = "attachment"]
    Attachment(Option<Element>),
    #[doc = "Discharge"]
    #[code = "discharge"]
    Discharge(Option<Element>),
    #[doc = "EmploymentImpacted"]
    #[code = "employmentimpacted"]
    Employmentimpacted(Option<Element>),
    #[doc = "Exception"]
    #[code = "exception"]
    Exception(Option<Element>),
    #[doc = "External Caause"]
    #[code = "externalcause"]
    Externalcause(Option<Element>),
    #[doc = "Hospitalized"]
    #[code = "hospitalized"]
    Hospitalized(Option<Element>),
    #[doc = "Information"]
    #[code = "info"]
    Info(Option<Element>),
    #[doc = "Materials Forwarded"]
    #[code = "material"]
    Material(Option<Element>),
    #[doc = "Missing Tooth"]
    #[code = "missingtooth"]
    Missingtooth(Option<Element>),
    #[doc = "Onset"]
    #[code = "onset"]
    Onset(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Patient Reason for Visit"]
    #[code = "patientreasonforvisit"]
    Patientreasonforvisit(Option<Element>),
    #[doc = "Prosthesis"]
    #[code = "prosthesis"]
    Prosthesis(Option<Element>),
    #[doc = "Related Services"]
    #[code = "related"]
    Related(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimInformationcategory {
    fn default() -> Self {
        ClaimInformationcategory::Null(None)
    }
}
impl TryFrom<String> for ClaimInformationcategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "attachment" => Ok(ClaimInformationcategory::Attachment(None)),
            "discharge" => Ok(ClaimInformationcategory::Discharge(None)),
            "employmentimpacted" => Ok(ClaimInformationcategory::Employmentimpacted(None)),
            "exception" => Ok(ClaimInformationcategory::Exception(None)),
            "externalcause" => Ok(ClaimInformationcategory::Externalcause(None)),
            "hospitalized" => Ok(ClaimInformationcategory::Hospitalized(None)),
            "info" => Ok(ClaimInformationcategory::Info(None)),
            "material" => Ok(ClaimInformationcategory::Material(None)),
            "missingtooth" => Ok(ClaimInformationcategory::Missingtooth(None)),
            "onset" => Ok(ClaimInformationcategory::Onset(None)),
            "other" => Ok(ClaimInformationcategory::Other(None)),
            "patientreasonforvisit" => Ok(ClaimInformationcategory::Patientreasonforvisit(None)),
            "prosthesis" => Ok(ClaimInformationcategory::Prosthesis(None)),
            "related" => Ok(ClaimInformationcategory::Related(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimInformationcategory {
    fn into(self) -> Option<String> {
        match self {
            ClaimInformationcategory::Attachment(_) => Some("attachment".to_string()),
            ClaimInformationcategory::Discharge(_) => Some("discharge".to_string()),
            ClaimInformationcategory::Employmentimpacted(_) => {
                Some("employmentimpacted".to_string())
            }
            ClaimInformationcategory::Exception(_) => Some("exception".to_string()),
            ClaimInformationcategory::Externalcause(_) => Some("externalcause".to_string()),
            ClaimInformationcategory::Hospitalized(_) => Some("hospitalized".to_string()),
            ClaimInformationcategory::Info(_) => Some("info".to_string()),
            ClaimInformationcategory::Material(_) => Some("material".to_string()),
            ClaimInformationcategory::Missingtooth(_) => Some("missingtooth".to_string()),
            ClaimInformationcategory::Onset(_) => Some("onset".to_string()),
            ClaimInformationcategory::Other(_) => Some("other".to_string()),
            ClaimInformationcategory::Patientreasonforvisit(_) => {
                Some("patientreasonforvisit".to_string())
            }
            ClaimInformationcategory::Prosthesis(_) => Some("prosthesis".to_string()),
            ClaimInformationcategory::Related(_) => Some("related".to_string()),
            ClaimInformationcategory::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimInformationcategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimInformationcategory::Attachment(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Discharge(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Employmentimpacted(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Exception(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Externalcause(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Hospitalized(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Info(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Material(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Missingtooth(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Onset(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Other(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Patientreasonforvisit(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Prosthesis(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Related(Some(e)) => e.get_field(field),
                ClaimInformationcategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimInformationcategory::Attachment(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Discharge(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Employmentimpacted(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Exception(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Externalcause(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Hospitalized(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Info(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Material(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Missingtooth(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Onset(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Other(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Patientreasonforvisit(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Prosthesis(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Related(Some(e)) => e.get_field_mut(field),
                ClaimInformationcategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimModifiers {
    #[doc = "Repair of prior service or installation"]
    #[code = "a"]
    A(Option<Element>),
    #[doc = "Temporary service or installation"]
    #[code = "b"]
    B(Option<Element>),
    #[doc = "TMJ treatment"]
    #[code = "c"]
    C(Option<Element>),
    #[doc = "Implant or associated with an implant"]
    #[code = "e"]
    E(Option<Element>),
    #[doc = "Rush or Outside of office hours"]
    #[code = "rooh"]
    Rooh(Option<Element>),
    #[doc = "None"]
    #[code = "x"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimModifiers {
    fn default() -> Self {
        ClaimModifiers::Null(None)
    }
}
impl TryFrom<String> for ClaimModifiers {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a" => Ok(ClaimModifiers::A(None)),
            "b" => Ok(ClaimModifiers::B(None)),
            "c" => Ok(ClaimModifiers::C(None)),
            "e" => Ok(ClaimModifiers::E(None)),
            "rooh" => Ok(ClaimModifiers::Rooh(None)),
            "x" => Ok(ClaimModifiers::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimModifiers {
    fn into(self) -> Option<String> {
        match self {
            ClaimModifiers::A(_) => Some("a".to_string()),
            ClaimModifiers::B(_) => Some("b".to_string()),
            ClaimModifiers::C(_) => Some("c".to_string()),
            ClaimModifiers::E(_) => Some("e".to_string()),
            ClaimModifiers::Rooh(_) => Some("rooh".to_string()),
            ClaimModifiers::X(_) => Some("x".to_string()),
            ClaimModifiers::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimModifiers {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimModifiers::A(Some(e)) => e.get_field(field),
                ClaimModifiers::B(Some(e)) => e.get_field(field),
                ClaimModifiers::C(Some(e)) => e.get_field(field),
                ClaimModifiers::E(Some(e)) => e.get_field(field),
                ClaimModifiers::Rooh(Some(e)) => e.get_field(field),
                ClaimModifiers::X(Some(e)) => e.get_field(field),
                ClaimModifiers::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimModifiers::A(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::B(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::C(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::E(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::Rooh(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::X(Some(e)) => e.get_field_mut(field),
                ClaimModifiers::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimSubtype {
    #[doc = "Emergency Claim"]
    #[code = "emergency"]
    Emergency(Option<Element>),
    #[doc = "Orthodontic Claim"]
    #[code = "ortho"]
    Ortho(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimSubtype {
    fn default() -> Self {
        ClaimSubtype::Null(None)
    }
}
impl TryFrom<String> for ClaimSubtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "emergency" => Ok(ClaimSubtype::Emergency(None)),
            "ortho" => Ok(ClaimSubtype::Ortho(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimSubtype {
    fn into(self) -> Option<String> {
        match self {
            ClaimSubtype::Emergency(_) => Some("emergency".to_string()),
            ClaimSubtype::Ortho(_) => Some("ortho".to_string()),
            ClaimSubtype::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimSubtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimSubtype::Emergency(Some(e)) => e.get_field(field),
                ClaimSubtype::Ortho(Some(e)) => e.get_field(field),
                ClaimSubtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimSubtype::Emergency(Some(e)) => e.get_field_mut(field),
                ClaimSubtype::Ortho(Some(e)) => e.get_field_mut(field),
                ClaimSubtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimType {
    #[doc = "Institutional"]
    #[code = "institutional"]
    Institutional(Option<Element>),
    #[doc = "Oral"]
    #[code = "oral"]
    Oral(Option<Element>),
    #[doc = "Pharmacy"]
    #[code = "pharmacy"]
    Pharmacy(Option<Element>),
    #[doc = "Professional"]
    #[code = "professional"]
    Professional(Option<Element>),
    #[doc = "Vision"]
    #[code = "vision"]
    Vision(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimType {
    fn default() -> Self {
        ClaimType::Null(None)
    }
}
impl TryFrom<String> for ClaimType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "institutional" => Ok(ClaimType::Institutional(None)),
            "oral" => Ok(ClaimType::Oral(None)),
            "pharmacy" => Ok(ClaimType::Pharmacy(None)),
            "professional" => Ok(ClaimType::Professional(None)),
            "vision" => Ok(ClaimType::Vision(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimType {
    fn into(self) -> Option<String> {
        match self {
            ClaimType::Institutional(_) => Some("institutional".to_string()),
            ClaimType::Oral(_) => Some("oral".to_string()),
            ClaimType::Pharmacy(_) => Some("pharmacy".to_string()),
            ClaimType::Professional(_) => Some("professional".to_string()),
            ClaimType::Vision(_) => Some("vision".to_string()),
            ClaimType::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimType::Institutional(Some(e)) => e.get_field(field),
                ClaimType::Oral(Some(e)) => e.get_field(field),
                ClaimType::Pharmacy(Some(e)) => e.get_field(field),
                ClaimType::Professional(Some(e)) => e.get_field(field),
                ClaimType::Vision(Some(e)) => e.get_field(field),
                ClaimType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimType::Institutional(Some(e)) => e.get_field_mut(field),
                ClaimType::Oral(Some(e)) => e.get_field_mut(field),
                ClaimType::Pharmacy(Some(e)) => e.get_field_mut(field),
                ClaimType::Professional(Some(e)) => e.get_field_mut(field),
                ClaimType::Vision(Some(e)) => e.get_field_mut(field),
                ClaimType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClaimUse {
    #[doc = "Claim"]
    #[code = "claim"]
    Claim(Option<Element>),
    #[doc = "Preauthorization"]
    #[code = "preauthorization"]
    Preauthorization(Option<Element>),
    #[doc = "Predetermination"]
    #[code = "predetermination"]
    Predetermination(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClaimUse {
    fn default() -> Self {
        ClaimUse::Null(None)
    }
}
impl TryFrom<String> for ClaimUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "claim" => Ok(ClaimUse::Claim(None)),
            "preauthorization" => Ok(ClaimUse::Preauthorization(None)),
            "predetermination" => Ok(ClaimUse::Predetermination(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClaimUse {
    fn into(self) -> Option<String> {
        match self {
            ClaimUse::Claim(_) => Some("claim".to_string()),
            ClaimUse::Preauthorization(_) => Some("preauthorization".to_string()),
            ClaimUse::Predetermination(_) => Some("predetermination".to_string()),
            ClaimUse::Null(_) => None,
        }
    }
}
impl MetaValue for ClaimUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClaimUse::Claim(Some(e)) => e.get_field(field),
                ClaimUse::Preauthorization(Some(e)) => e.get_field(field),
                ClaimUse::Predetermination(Some(e)) => e.get_field(field),
                ClaimUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClaimUse::Claim(Some(e)) => e.get_field_mut(field),
                ClaimUse::Preauthorization(Some(e)) => e.get_field_mut(field),
                ClaimUse::Predetermination(Some(e)) => e.get_field_mut(field),
                ClaimUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClinicalimpressionStatus {
    #[code = "completed"]
    Completed(Option<Element>),
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClinicalimpressionStatus {
    fn default() -> Self {
        ClinicalimpressionStatus::Null(None)
    }
}
impl TryFrom<String> for ClinicalimpressionStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(ClinicalimpressionStatus::Completed(None)),
            "entered-in-error" => Ok(ClinicalimpressionStatus::EnteredInError(None)),
            "in-progress" => Ok(ClinicalimpressionStatus::InProgress(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClinicalimpressionStatus {
    fn into(self) -> Option<String> {
        match self {
            ClinicalimpressionStatus::Completed(_) => Some("completed".to_string()),
            ClinicalimpressionStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ClinicalimpressionStatus::InProgress(_) => Some("in-progress".to_string()),
            ClinicalimpressionStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ClinicalimpressionStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClinicalimpressionStatus::Completed(Some(e)) => e.get_field(field),
                ClinicalimpressionStatus::EnteredInError(Some(e)) => e.get_field(field),
                ClinicalimpressionStatus::InProgress(Some(e)) => e.get_field(field),
                ClinicalimpressionStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClinicalimpressionStatus::Completed(Some(e)) => e.get_field_mut(field),
                ClinicalimpressionStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ClinicalimpressionStatus::InProgress(Some(e)) => e.get_field_mut(field),
                ClinicalimpressionStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CodeSearchSupport {
    #[doc = "Implicit Codes"]
    #[code = "all"]
    All(Option<Element>),
    #[doc = "Explicit Codes"]
    #[code = "explicit"]
    Explicit(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CodeSearchSupport {
    fn default() -> Self {
        CodeSearchSupport::Null(None)
    }
}
impl TryFrom<String> for CodeSearchSupport {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all" => Ok(CodeSearchSupport::All(None)),
            "explicit" => Ok(CodeSearchSupport::Explicit(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CodeSearchSupport {
    fn into(self) -> Option<String> {
        match self {
            CodeSearchSupport::All(_) => Some("all".to_string()),
            CodeSearchSupport::Explicit(_) => Some("explicit".to_string()),
            CodeSearchSupport::Null(_) => None,
        }
    }
}
impl MetaValue for CodeSearchSupport {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CodeSearchSupport::All(Some(e)) => e.get_field(field),
                CodeSearchSupport::Explicit(Some(e)) => e.get_field(field),
                CodeSearchSupport::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CodeSearchSupport::All(Some(e)) => e.get_field_mut(field),
                CodeSearchSupport::Explicit(Some(e)) => e.get_field_mut(field),
                CodeSearchSupport::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CodesystemAltcodeKind {
    #[doc = "Alternate Code"]
    #[code = "alternate"]
    Alternate(Option<Element>),
    #[doc = "Case Insensitive"]
    #[code = "case-insensitive"]
    CaseInsensitive(Option<Element>),
    #[doc = "Case Sensitive"]
    #[code = "case-sensitive"]
    CaseSensitive(Option<Element>),
    #[doc = "Deprecated"]
    #[code = "deprecated"]
    Deprecated(Option<Element>),
    #[doc = "Expression"]
    #[code = "expression"]
    Expression(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CodesystemAltcodeKind {
    fn default() -> Self {
        CodesystemAltcodeKind::Null(None)
    }
}
impl TryFrom<String> for CodesystemAltcodeKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alternate" => Ok(CodesystemAltcodeKind::Alternate(None)),
            "case-insensitive" => Ok(CodesystemAltcodeKind::CaseInsensitive(None)),
            "case-sensitive" => Ok(CodesystemAltcodeKind::CaseSensitive(None)),
            "deprecated" => Ok(CodesystemAltcodeKind::Deprecated(None)),
            "expression" => Ok(CodesystemAltcodeKind::Expression(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CodesystemAltcodeKind {
    fn into(self) -> Option<String> {
        match self {
            CodesystemAltcodeKind::Alternate(_) => Some("alternate".to_string()),
            CodesystemAltcodeKind::CaseInsensitive(_) => Some("case-insensitive".to_string()),
            CodesystemAltcodeKind::CaseSensitive(_) => Some("case-sensitive".to_string()),
            CodesystemAltcodeKind::Deprecated(_) => Some("deprecated".to_string()),
            CodesystemAltcodeKind::Expression(_) => Some("expression".to_string()),
            CodesystemAltcodeKind::Null(_) => None,
        }
    }
}
impl MetaValue for CodesystemAltcodeKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CodesystemAltcodeKind::Alternate(Some(e)) => e.get_field(field),
                CodesystemAltcodeKind::CaseInsensitive(Some(e)) => e.get_field(field),
                CodesystemAltcodeKind::CaseSensitive(Some(e)) => e.get_field(field),
                CodesystemAltcodeKind::Deprecated(Some(e)) => e.get_field(field),
                CodesystemAltcodeKind::Expression(Some(e)) => e.get_field(field),
                CodesystemAltcodeKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CodesystemAltcodeKind::Alternate(Some(e)) => e.get_field_mut(field),
                CodesystemAltcodeKind::CaseInsensitive(Some(e)) => e.get_field_mut(field),
                CodesystemAltcodeKind::CaseSensitive(Some(e)) => e.get_field_mut(field),
                CodesystemAltcodeKind::Deprecated(Some(e)) => e.get_field_mut(field),
                CodesystemAltcodeKind::Expression(Some(e)) => e.get_field_mut(field),
                CodesystemAltcodeKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CodesystemContentMode {
    #[doc = "Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "Example"]
    #[code = "example"]
    Example(Option<Element>),
    #[doc = "Fragment"]
    #[code = "fragment"]
    Fragment(Option<Element>),
    #[doc = "Not Present"]
    #[code = "not-present"]
    NotPresent(Option<Element>),
    #[doc = "Supplement"]
    #[code = "supplement"]
    Supplement(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CodesystemContentMode {
    fn default() -> Self {
        CodesystemContentMode::Null(None)
    }
}
impl TryFrom<String> for CodesystemContentMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(CodesystemContentMode::Complete(None)),
            "example" => Ok(CodesystemContentMode::Example(None)),
            "fragment" => Ok(CodesystemContentMode::Fragment(None)),
            "not-present" => Ok(CodesystemContentMode::NotPresent(None)),
            "supplement" => Ok(CodesystemContentMode::Supplement(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CodesystemContentMode {
    fn into(self) -> Option<String> {
        match self {
            CodesystemContentMode::Complete(_) => Some("complete".to_string()),
            CodesystemContentMode::Example(_) => Some("example".to_string()),
            CodesystemContentMode::Fragment(_) => Some("fragment".to_string()),
            CodesystemContentMode::NotPresent(_) => Some("not-present".to_string()),
            CodesystemContentMode::Supplement(_) => Some("supplement".to_string()),
            CodesystemContentMode::Null(_) => None,
        }
    }
}
impl MetaValue for CodesystemContentMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CodesystemContentMode::Complete(Some(e)) => e.get_field(field),
                CodesystemContentMode::Example(Some(e)) => e.get_field(field),
                CodesystemContentMode::Fragment(Some(e)) => e.get_field(field),
                CodesystemContentMode::NotPresent(Some(e)) => e.get_field(field),
                CodesystemContentMode::Supplement(Some(e)) => e.get_field(field),
                CodesystemContentMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CodesystemContentMode::Complete(Some(e)) => e.get_field_mut(field),
                CodesystemContentMode::Example(Some(e)) => e.get_field_mut(field),
                CodesystemContentMode::Fragment(Some(e)) => e.get_field_mut(field),
                CodesystemContentMode::NotPresent(Some(e)) => e.get_field_mut(field),
                CodesystemContentMode::Supplement(Some(e)) => e.get_field_mut(field),
                CodesystemContentMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CodesystemHierarchyMeaning {
    #[doc = "Classified With"]
    #[code = "classified-with"]
    ClassifiedWith(Option<Element>),
    #[doc = "Grouped By"]
    #[code = "grouped-by"]
    GroupedBy(Option<Element>),
    #[doc = "Is-A"]
    #[code = "is-a"]
    IsA(Option<Element>),
    #[doc = "Part Of"]
    #[code = "part-of"]
    PartOf(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CodesystemHierarchyMeaning {
    fn default() -> Self {
        CodesystemHierarchyMeaning::Null(None)
    }
}
impl TryFrom<String> for CodesystemHierarchyMeaning {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "classified-with" => Ok(CodesystemHierarchyMeaning::ClassifiedWith(None)),
            "grouped-by" => Ok(CodesystemHierarchyMeaning::GroupedBy(None)),
            "is-a" => Ok(CodesystemHierarchyMeaning::IsA(None)),
            "part-of" => Ok(CodesystemHierarchyMeaning::PartOf(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CodesystemHierarchyMeaning {
    fn into(self) -> Option<String> {
        match self {
            CodesystemHierarchyMeaning::ClassifiedWith(_) => Some("classified-with".to_string()),
            CodesystemHierarchyMeaning::GroupedBy(_) => Some("grouped-by".to_string()),
            CodesystemHierarchyMeaning::IsA(_) => Some("is-a".to_string()),
            CodesystemHierarchyMeaning::PartOf(_) => Some("part-of".to_string()),
            CodesystemHierarchyMeaning::Null(_) => None,
        }
    }
}
impl MetaValue for CodesystemHierarchyMeaning {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CodesystemHierarchyMeaning::ClassifiedWith(Some(e)) => e.get_field(field),
                CodesystemHierarchyMeaning::GroupedBy(Some(e)) => e.get_field(field),
                CodesystemHierarchyMeaning::IsA(Some(e)) => e.get_field(field),
                CodesystemHierarchyMeaning::PartOf(Some(e)) => e.get_field(field),
                CodesystemHierarchyMeaning::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CodesystemHierarchyMeaning::ClassifiedWith(Some(e)) => e.get_field_mut(field),
                CodesystemHierarchyMeaning::GroupedBy(Some(e)) => e.get_field_mut(field),
                CodesystemHierarchyMeaning::IsA(Some(e)) => e.get_field_mut(field),
                CodesystemHierarchyMeaning::PartOf(Some(e)) => e.get_field_mut(field),
                CodesystemHierarchyMeaning::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CommonTags {
    #[doc = "Actionable"]
    #[code = "actionable"]
    Actionable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CommonTags {
    fn default() -> Self {
        CommonTags::Null(None)
    }
}
impl TryFrom<String> for CommonTags {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "actionable" => Ok(CommonTags::Actionable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CommonTags {
    fn into(self) -> Option<String> {
        match self {
            CommonTags::Actionable(_) => Some("actionable".to_string()),
            CommonTags::Null(_) => None,
        }
    }
}
impl MetaValue for CommonTags {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CommonTags::Actionable(Some(e)) => e.get_field(field),
                CommonTags::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CommonTags::Actionable(Some(e)) => e.get_field_mut(field),
                CommonTags::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CommunicationCategory {
    #[doc = "Alert"]
    #[code = "alert"]
    Alert(Option<Element>),
    #[doc = "Instruction"]
    #[code = "instruction"]
    Instruction(Option<Element>),
    #[doc = "Notification"]
    #[code = "notification"]
    Notification(Option<Element>),
    #[doc = "Reminder"]
    #[code = "reminder"]
    Reminder(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CommunicationCategory {
    fn default() -> Self {
        CommunicationCategory::Null(None)
    }
}
impl TryFrom<String> for CommunicationCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alert" => Ok(CommunicationCategory::Alert(None)),
            "instruction" => Ok(CommunicationCategory::Instruction(None)),
            "notification" => Ok(CommunicationCategory::Notification(None)),
            "reminder" => Ok(CommunicationCategory::Reminder(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CommunicationCategory {
    fn into(self) -> Option<String> {
        match self {
            CommunicationCategory::Alert(_) => Some("alert".to_string()),
            CommunicationCategory::Instruction(_) => Some("instruction".to_string()),
            CommunicationCategory::Notification(_) => Some("notification".to_string()),
            CommunicationCategory::Reminder(_) => Some("reminder".to_string()),
            CommunicationCategory::Null(_) => None,
        }
    }
}
impl MetaValue for CommunicationCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CommunicationCategory::Alert(Some(e)) => e.get_field(field),
                CommunicationCategory::Instruction(Some(e)) => e.get_field(field),
                CommunicationCategory::Notification(Some(e)) => e.get_field(field),
                CommunicationCategory::Reminder(Some(e)) => e.get_field(field),
                CommunicationCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CommunicationCategory::Alert(Some(e)) => e.get_field_mut(field),
                CommunicationCategory::Instruction(Some(e)) => e.get_field_mut(field),
                CommunicationCategory::Notification(Some(e)) => e.get_field_mut(field),
                CommunicationCategory::Reminder(Some(e)) => e.get_field_mut(field),
                CommunicationCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CommunicationNotDoneReason {
    #[doc = "Family Objection"]
    #[code = "family-objection"]
    FamilyObjection(Option<Element>),
    #[doc = "Invalid Phone Number"]
    #[code = "invalid-phone-number"]
    InvalidPhoneNumber(Option<Element>),
    #[doc = "Patient Objection"]
    #[code = "patient-objection"]
    PatientObjection(Option<Element>),
    #[doc = "Recipient Unavailable"]
    #[code = "recipient-unavailable"]
    RecipientUnavailable(Option<Element>),
    #[doc = "System Error"]
    #[code = "system-error"]
    SystemError(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CommunicationNotDoneReason {
    fn default() -> Self {
        CommunicationNotDoneReason::Null(None)
    }
}
impl TryFrom<String> for CommunicationNotDoneReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "family-objection" => Ok(CommunicationNotDoneReason::FamilyObjection(None)),
            "invalid-phone-number" => Ok(CommunicationNotDoneReason::InvalidPhoneNumber(None)),
            "patient-objection" => Ok(CommunicationNotDoneReason::PatientObjection(None)),
            "recipient-unavailable" => Ok(CommunicationNotDoneReason::RecipientUnavailable(None)),
            "system-error" => Ok(CommunicationNotDoneReason::SystemError(None)),
            "unknown" => Ok(CommunicationNotDoneReason::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CommunicationNotDoneReason {
    fn into(self) -> Option<String> {
        match self {
            CommunicationNotDoneReason::FamilyObjection(_) => Some("family-objection".to_string()),
            CommunicationNotDoneReason::InvalidPhoneNumber(_) => {
                Some("invalid-phone-number".to_string())
            }
            CommunicationNotDoneReason::PatientObjection(_) => {
                Some("patient-objection".to_string())
            }
            CommunicationNotDoneReason::RecipientUnavailable(_) => {
                Some("recipient-unavailable".to_string())
            }
            CommunicationNotDoneReason::SystemError(_) => Some("system-error".to_string()),
            CommunicationNotDoneReason::Unknown(_) => Some("unknown".to_string()),
            CommunicationNotDoneReason::Null(_) => None,
        }
    }
}
impl MetaValue for CommunicationNotDoneReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CommunicationNotDoneReason::FamilyObjection(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::InvalidPhoneNumber(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::PatientObjection(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::RecipientUnavailable(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::SystemError(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::Unknown(Some(e)) => e.get_field(field),
                CommunicationNotDoneReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CommunicationNotDoneReason::FamilyObjection(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::InvalidPhoneNumber(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::PatientObjection(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::RecipientUnavailable(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::SystemError(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::Unknown(Some(e)) => e.get_field_mut(field),
                CommunicationNotDoneReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CommunicationTopic {
    #[doc = "Appointment Reminder"]
    #[code = "appointment-reminder"]
    AppointmentReminder(Option<Element>),
    #[doc = "Phone Consult"]
    #[code = "phone-consult"]
    PhoneConsult(Option<Element>),
    #[doc = "Prescription Refill Request"]
    #[code = "prescription-refill-request"]
    PrescriptionRefillRequest(Option<Element>),
    #[doc = "Progress Update"]
    #[code = "progress-update"]
    ProgressUpdate(Option<Element>),
    #[doc = "Report Labs"]
    #[code = "report-labs"]
    ReportLabs(Option<Element>),
    #[doc = "Summary Report"]
    #[code = "summary-report"]
    SummaryReport(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CommunicationTopic {
    fn default() -> Self {
        CommunicationTopic::Null(None)
    }
}
impl TryFrom<String> for CommunicationTopic {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "appointment-reminder" => Ok(CommunicationTopic::AppointmentReminder(None)),
            "phone-consult" => Ok(CommunicationTopic::PhoneConsult(None)),
            "prescription-refill-request" => {
                Ok(CommunicationTopic::PrescriptionRefillRequest(None))
            }
            "progress-update" => Ok(CommunicationTopic::ProgressUpdate(None)),
            "report-labs" => Ok(CommunicationTopic::ReportLabs(None)),
            "summary-report" => Ok(CommunicationTopic::SummaryReport(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CommunicationTopic {
    fn into(self) -> Option<String> {
        match self {
            CommunicationTopic::AppointmentReminder(_) => Some("appointment-reminder".to_string()),
            CommunicationTopic::PhoneConsult(_) => Some("phone-consult".to_string()),
            CommunicationTopic::PrescriptionRefillRequest(_) => {
                Some("prescription-refill-request".to_string())
            }
            CommunicationTopic::ProgressUpdate(_) => Some("progress-update".to_string()),
            CommunicationTopic::ReportLabs(_) => Some("report-labs".to_string()),
            CommunicationTopic::SummaryReport(_) => Some("summary-report".to_string()),
            CommunicationTopic::Null(_) => None,
        }
    }
}
impl MetaValue for CommunicationTopic {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CommunicationTopic::AppointmentReminder(Some(e)) => e.get_field(field),
                CommunicationTopic::PhoneConsult(Some(e)) => e.get_field(field),
                CommunicationTopic::PrescriptionRefillRequest(Some(e)) => e.get_field(field),
                CommunicationTopic::ProgressUpdate(Some(e)) => e.get_field(field),
                CommunicationTopic::ReportLabs(Some(e)) => e.get_field(field),
                CommunicationTopic::SummaryReport(Some(e)) => e.get_field(field),
                CommunicationTopic::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CommunicationTopic::AppointmentReminder(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::PhoneConsult(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::PrescriptionRefillRequest(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::ProgressUpdate(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::ReportLabs(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::SummaryReport(Some(e)) => e.get_field_mut(field),
                CommunicationTopic::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CompartmentType {
    #[doc = "Device"]
    #[code = "Device"]
    Device(Option<Element>),
    #[doc = "Encounter"]
    #[code = "Encounter"]
    Encounter(Option<Element>),
    #[doc = "Patient"]
    #[code = "Patient"]
    Patient(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "Practitioner"]
    Practitioner(Option<Element>),
    #[doc = "RelatedPerson"]
    #[code = "RelatedPerson"]
    RelatedPerson(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CompartmentType {
    fn default() -> Self {
        CompartmentType::Null(None)
    }
}
impl TryFrom<String> for CompartmentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Device" => Ok(CompartmentType::Device(None)),
            "Encounter" => Ok(CompartmentType::Encounter(None)),
            "Patient" => Ok(CompartmentType::Patient(None)),
            "Practitioner" => Ok(CompartmentType::Practitioner(None)),
            "RelatedPerson" => Ok(CompartmentType::RelatedPerson(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CompartmentType {
    fn into(self) -> Option<String> {
        match self {
            CompartmentType::Device(_) => Some("Device".to_string()),
            CompartmentType::Encounter(_) => Some("Encounter".to_string()),
            CompartmentType::Patient(_) => Some("Patient".to_string()),
            CompartmentType::Practitioner(_) => Some("Practitioner".to_string()),
            CompartmentType::RelatedPerson(_) => Some("RelatedPerson".to_string()),
            CompartmentType::Null(_) => None,
        }
    }
}
impl MetaValue for CompartmentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CompartmentType::Device(Some(e)) => e.get_field(field),
                CompartmentType::Encounter(Some(e)) => e.get_field(field),
                CompartmentType::Patient(Some(e)) => e.get_field(field),
                CompartmentType::Practitioner(Some(e)) => e.get_field(field),
                CompartmentType::RelatedPerson(Some(e)) => e.get_field(field),
                CompartmentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CompartmentType::Device(Some(e)) => e.get_field_mut(field),
                CompartmentType::Encounter(Some(e)) => e.get_field_mut(field),
                CompartmentType::Patient(Some(e)) => e.get_field_mut(field),
                CompartmentType::Practitioner(Some(e)) => e.get_field_mut(field),
                CompartmentType::RelatedPerson(Some(e)) => e.get_field_mut(field),
                CompartmentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CompositeMeasureScoring {
    #[doc = "All-or-nothing"]
    #[code = "all-or-nothing"]
    AllOrNothing(Option<Element>),
    #[doc = "Linear"]
    #[code = "linear"]
    Linear(Option<Element>),
    #[doc = "Opportunity"]
    #[code = "opportunity"]
    Opportunity(Option<Element>),
    #[doc = "Weighted"]
    #[code = "weighted"]
    Weighted(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CompositeMeasureScoring {
    fn default() -> Self {
        CompositeMeasureScoring::Null(None)
    }
}
impl TryFrom<String> for CompositeMeasureScoring {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all-or-nothing" => Ok(CompositeMeasureScoring::AllOrNothing(None)),
            "linear" => Ok(CompositeMeasureScoring::Linear(None)),
            "opportunity" => Ok(CompositeMeasureScoring::Opportunity(None)),
            "weighted" => Ok(CompositeMeasureScoring::Weighted(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CompositeMeasureScoring {
    fn into(self) -> Option<String> {
        match self {
            CompositeMeasureScoring::AllOrNothing(_) => Some("all-or-nothing".to_string()),
            CompositeMeasureScoring::Linear(_) => Some("linear".to_string()),
            CompositeMeasureScoring::Opportunity(_) => Some("opportunity".to_string()),
            CompositeMeasureScoring::Weighted(_) => Some("weighted".to_string()),
            CompositeMeasureScoring::Null(_) => None,
        }
    }
}
impl MetaValue for CompositeMeasureScoring {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CompositeMeasureScoring::AllOrNothing(Some(e)) => e.get_field(field),
                CompositeMeasureScoring::Linear(Some(e)) => e.get_field(field),
                CompositeMeasureScoring::Opportunity(Some(e)) => e.get_field(field),
                CompositeMeasureScoring::Weighted(Some(e)) => e.get_field(field),
                CompositeMeasureScoring::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CompositeMeasureScoring::AllOrNothing(Some(e)) => e.get_field_mut(field),
                CompositeMeasureScoring::Linear(Some(e)) => e.get_field_mut(field),
                CompositeMeasureScoring::Opportunity(Some(e)) => e.get_field_mut(field),
                CompositeMeasureScoring::Weighted(Some(e)) => e.get_field_mut(field),
                CompositeMeasureScoring::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CompositionAltcodeKind {
    #[doc = "Alternate Code"]
    #[code = "alternate"]
    Alternate(Option<Element>),
    #[doc = "Case Insensitive"]
    #[code = "case-insensitive"]
    CaseInsensitive(Option<Element>),
    #[doc = "Case Sensitive"]
    #[code = "case-sensitive"]
    CaseSensitive(Option<Element>),
    #[doc = "Deprecated"]
    #[code = "deprecated"]
    Deprecated(Option<Element>),
    #[doc = "Expression"]
    #[code = "expression"]
    Expression(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CompositionAltcodeKind {
    fn default() -> Self {
        CompositionAltcodeKind::Null(None)
    }
}
impl TryFrom<String> for CompositionAltcodeKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alternate" => Ok(CompositionAltcodeKind::Alternate(None)),
            "case-insensitive" => Ok(CompositionAltcodeKind::CaseInsensitive(None)),
            "case-sensitive" => Ok(CompositionAltcodeKind::CaseSensitive(None)),
            "deprecated" => Ok(CompositionAltcodeKind::Deprecated(None)),
            "expression" => Ok(CompositionAltcodeKind::Expression(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CompositionAltcodeKind {
    fn into(self) -> Option<String> {
        match self {
            CompositionAltcodeKind::Alternate(_) => Some("alternate".to_string()),
            CompositionAltcodeKind::CaseInsensitive(_) => Some("case-insensitive".to_string()),
            CompositionAltcodeKind::CaseSensitive(_) => Some("case-sensitive".to_string()),
            CompositionAltcodeKind::Deprecated(_) => Some("deprecated".to_string()),
            CompositionAltcodeKind::Expression(_) => Some("expression".to_string()),
            CompositionAltcodeKind::Null(_) => None,
        }
    }
}
impl MetaValue for CompositionAltcodeKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CompositionAltcodeKind::Alternate(Some(e)) => e.get_field(field),
                CompositionAltcodeKind::CaseInsensitive(Some(e)) => e.get_field(field),
                CompositionAltcodeKind::CaseSensitive(Some(e)) => e.get_field(field),
                CompositionAltcodeKind::Deprecated(Some(e)) => e.get_field(field),
                CompositionAltcodeKind::Expression(Some(e)) => e.get_field(field),
                CompositionAltcodeKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CompositionAltcodeKind::Alternate(Some(e)) => e.get_field_mut(field),
                CompositionAltcodeKind::CaseInsensitive(Some(e)) => e.get_field_mut(field),
                CompositionAltcodeKind::CaseSensitive(Some(e)) => e.get_field_mut(field),
                CompositionAltcodeKind::Deprecated(Some(e)) => e.get_field_mut(field),
                CompositionAltcodeKind::Expression(Some(e)) => e.get_field_mut(field),
                CompositionAltcodeKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CompositionAttestationMode {
    #[doc = "Legal"]
    #[code = "legal"]
    Legal(Option<Element>),
    #[doc = "Official"]
    #[code = "official"]
    Official(Option<Element>),
    #[doc = "Personal"]
    #[code = "personal"]
    Personal(Option<Element>),
    #[doc = "Professional"]
    #[code = "professional"]
    Professional(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CompositionAttestationMode {
    fn default() -> Self {
        CompositionAttestationMode::Null(None)
    }
}
impl TryFrom<String> for CompositionAttestationMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "legal" => Ok(CompositionAttestationMode::Legal(None)),
            "official" => Ok(CompositionAttestationMode::Official(None)),
            "personal" => Ok(CompositionAttestationMode::Personal(None)),
            "professional" => Ok(CompositionAttestationMode::Professional(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CompositionAttestationMode {
    fn into(self) -> Option<String> {
        match self {
            CompositionAttestationMode::Legal(_) => Some("legal".to_string()),
            CompositionAttestationMode::Official(_) => Some("official".to_string()),
            CompositionAttestationMode::Personal(_) => Some("personal".to_string()),
            CompositionAttestationMode::Professional(_) => Some("professional".to_string()),
            CompositionAttestationMode::Null(_) => None,
        }
    }
}
impl MetaValue for CompositionAttestationMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CompositionAttestationMode::Legal(Some(e)) => e.get_field(field),
                CompositionAttestationMode::Official(Some(e)) => e.get_field(field),
                CompositionAttestationMode::Personal(Some(e)) => e.get_field(field),
                CompositionAttestationMode::Professional(Some(e)) => e.get_field(field),
                CompositionAttestationMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CompositionAttestationMode::Legal(Some(e)) => e.get_field_mut(field),
                CompositionAttestationMode::Official(Some(e)) => e.get_field_mut(field),
                CompositionAttestationMode::Personal(Some(e)) => e.get_field_mut(field),
                CompositionAttestationMode::Professional(Some(e)) => e.get_field_mut(field),
                CompositionAttestationMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CompositionStatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Final"]
    #[code = "final"]
    Final(Option<Element>),
    #[doc = "Preliminary"]
    #[code = "preliminary"]
    Preliminary(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CompositionStatus {
    fn default() -> Self {
        CompositionStatus::Null(None)
    }
}
impl TryFrom<String> for CompositionStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(CompositionStatus::Amended(None)),
            "entered-in-error" => Ok(CompositionStatus::EnteredInError(None)),
            "final" => Ok(CompositionStatus::Final(None)),
            "preliminary" => Ok(CompositionStatus::Preliminary(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CompositionStatus {
    fn into(self) -> Option<String> {
        match self {
            CompositionStatus::Amended(_) => Some("amended".to_string()),
            CompositionStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            CompositionStatus::Final(_) => Some("final".to_string()),
            CompositionStatus::Preliminary(_) => Some("preliminary".to_string()),
            CompositionStatus::Null(_) => None,
        }
    }
}
impl MetaValue for CompositionStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CompositionStatus::Amended(Some(e)) => e.get_field(field),
                CompositionStatus::EnteredInError(Some(e)) => e.get_field(field),
                CompositionStatus::Final(Some(e)) => e.get_field(field),
                CompositionStatus::Preliminary(Some(e)) => e.get_field(field),
                CompositionStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CompositionStatus::Amended(Some(e)) => e.get_field_mut(field),
                CompositionStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                CompositionStatus::Final(Some(e)) => e.get_field_mut(field),
                CompositionStatus::Preliminary(Some(e)) => e.get_field_mut(field),
                CompositionStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConceptMapEquivalence {
    #[doc = "Disjoint"]
    #[code = "disjoint"]
    Disjoint(Option<Element>),
    #[doc = "Equal"]
    #[code = "equal"]
    Equal(Option<Element>),
    #[doc = "Equivalent"]
    #[code = "equivalent"]
    Equivalent(Option<Element>),
    #[doc = "Inexact"]
    #[code = "inexact"]
    Inexact(Option<Element>),
    #[doc = "Narrower"]
    #[code = "narrower"]
    Narrower(Option<Element>),
    #[doc = "Related To"]
    #[code = "relatedto"]
    Relatedto(Option<Element>),
    #[doc = "Specializes"]
    #[code = "specializes"]
    Specializes(Option<Element>),
    #[doc = "Subsumes"]
    #[code = "subsumes"]
    Subsumes(Option<Element>),
    #[doc = "Unmatched"]
    #[code = "unmatched"]
    Unmatched(Option<Element>),
    #[doc = "Wider"]
    #[code = "wider"]
    Wider(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConceptMapEquivalence {
    fn default() -> Self {
        ConceptMapEquivalence::Null(None)
    }
}
impl TryFrom<String> for ConceptMapEquivalence {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "disjoint" => Ok(ConceptMapEquivalence::Disjoint(None)),
            "equal" => Ok(ConceptMapEquivalence::Equal(None)),
            "equivalent" => Ok(ConceptMapEquivalence::Equivalent(None)),
            "inexact" => Ok(ConceptMapEquivalence::Inexact(None)),
            "narrower" => Ok(ConceptMapEquivalence::Narrower(None)),
            "relatedto" => Ok(ConceptMapEquivalence::Relatedto(None)),
            "specializes" => Ok(ConceptMapEquivalence::Specializes(None)),
            "subsumes" => Ok(ConceptMapEquivalence::Subsumes(None)),
            "unmatched" => Ok(ConceptMapEquivalence::Unmatched(None)),
            "wider" => Ok(ConceptMapEquivalence::Wider(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConceptMapEquivalence {
    fn into(self) -> Option<String> {
        match self {
            ConceptMapEquivalence::Disjoint(_) => Some("disjoint".to_string()),
            ConceptMapEquivalence::Equal(_) => Some("equal".to_string()),
            ConceptMapEquivalence::Equivalent(_) => Some("equivalent".to_string()),
            ConceptMapEquivalence::Inexact(_) => Some("inexact".to_string()),
            ConceptMapEquivalence::Narrower(_) => Some("narrower".to_string()),
            ConceptMapEquivalence::Relatedto(_) => Some("relatedto".to_string()),
            ConceptMapEquivalence::Specializes(_) => Some("specializes".to_string()),
            ConceptMapEquivalence::Subsumes(_) => Some("subsumes".to_string()),
            ConceptMapEquivalence::Unmatched(_) => Some("unmatched".to_string()),
            ConceptMapEquivalence::Wider(_) => Some("wider".to_string()),
            ConceptMapEquivalence::Null(_) => None,
        }
    }
}
impl MetaValue for ConceptMapEquivalence {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConceptMapEquivalence::Disjoint(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Equal(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Equivalent(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Inexact(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Narrower(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Relatedto(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Specializes(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Subsumes(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Unmatched(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Wider(Some(e)) => e.get_field(field),
                ConceptMapEquivalence::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConceptMapEquivalence::Disjoint(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Equal(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Equivalent(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Inexact(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Narrower(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Relatedto(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Specializes(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Subsumes(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Unmatched(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Wider(Some(e)) => e.get_field_mut(field),
                ConceptMapEquivalence::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConceptPropertyType {
    #[doc = "Coding (external reference)"]
    #[code = "Coding"]
    Coding(Option<Element>),
    #[doc = "boolean"]
    #[code = "boolean"]
    Boolean(Option<Element>),
    #[doc = "code (internal reference)"]
    #[code = "code"]
    Code(Option<Element>),
    #[doc = "dateTime"]
    #[code = "dateTime"]
    DateTime(Option<Element>),
    #[doc = "decimal"]
    #[code = "decimal"]
    Decimal(Option<Element>),
    #[doc = "integer"]
    #[code = "integer"]
    Integer(Option<Element>),
    #[doc = "string"]
    #[code = "string"]
    String(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConceptPropertyType {
    fn default() -> Self {
        ConceptPropertyType::Null(None)
    }
}
impl TryFrom<String> for ConceptPropertyType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Coding" => Ok(ConceptPropertyType::Coding(None)),
            "boolean" => Ok(ConceptPropertyType::Boolean(None)),
            "code" => Ok(ConceptPropertyType::Code(None)),
            "dateTime" => Ok(ConceptPropertyType::DateTime(None)),
            "decimal" => Ok(ConceptPropertyType::Decimal(None)),
            "integer" => Ok(ConceptPropertyType::Integer(None)),
            "string" => Ok(ConceptPropertyType::String(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConceptPropertyType {
    fn into(self) -> Option<String> {
        match self {
            ConceptPropertyType::Coding(_) => Some("Coding".to_string()),
            ConceptPropertyType::Boolean(_) => Some("boolean".to_string()),
            ConceptPropertyType::Code(_) => Some("code".to_string()),
            ConceptPropertyType::DateTime(_) => Some("dateTime".to_string()),
            ConceptPropertyType::Decimal(_) => Some("decimal".to_string()),
            ConceptPropertyType::Integer(_) => Some("integer".to_string()),
            ConceptPropertyType::String(_) => Some("string".to_string()),
            ConceptPropertyType::Null(_) => None,
        }
    }
}
impl MetaValue for ConceptPropertyType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConceptPropertyType::Coding(Some(e)) => e.get_field(field),
                ConceptPropertyType::Boolean(Some(e)) => e.get_field(field),
                ConceptPropertyType::Code(Some(e)) => e.get_field(field),
                ConceptPropertyType::DateTime(Some(e)) => e.get_field(field),
                ConceptPropertyType::Decimal(Some(e)) => e.get_field(field),
                ConceptPropertyType::Integer(Some(e)) => e.get_field(field),
                ConceptPropertyType::String(Some(e)) => e.get_field(field),
                ConceptPropertyType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConceptPropertyType::Coding(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::Boolean(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::Code(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::DateTime(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::Decimal(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::Integer(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::String(Some(e)) => e.get_field_mut(field),
                ConceptPropertyType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConceptSubsumptionOutcome {
    #[doc = "Equivalent"]
    #[code = "equivalent"]
    Equivalent(Option<Element>),
    #[doc = "Not-Subsumed"]
    #[code = "not-subsumed"]
    NotSubsumed(Option<Element>),
    #[doc = "Subsumed-By"]
    #[code = "subsumed-by"]
    SubsumedBy(Option<Element>),
    #[doc = "Subsumes"]
    #[code = "subsumes"]
    Subsumes(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConceptSubsumptionOutcome {
    fn default() -> Self {
        ConceptSubsumptionOutcome::Null(None)
    }
}
impl TryFrom<String> for ConceptSubsumptionOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "equivalent" => Ok(ConceptSubsumptionOutcome::Equivalent(None)),
            "not-subsumed" => Ok(ConceptSubsumptionOutcome::NotSubsumed(None)),
            "subsumed-by" => Ok(ConceptSubsumptionOutcome::SubsumedBy(None)),
            "subsumes" => Ok(ConceptSubsumptionOutcome::Subsumes(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConceptSubsumptionOutcome {
    fn into(self) -> Option<String> {
        match self {
            ConceptSubsumptionOutcome::Equivalent(_) => Some("equivalent".to_string()),
            ConceptSubsumptionOutcome::NotSubsumed(_) => Some("not-subsumed".to_string()),
            ConceptSubsumptionOutcome::SubsumedBy(_) => Some("subsumed-by".to_string()),
            ConceptSubsumptionOutcome::Subsumes(_) => Some("subsumes".to_string()),
            ConceptSubsumptionOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for ConceptSubsumptionOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConceptSubsumptionOutcome::Equivalent(Some(e)) => e.get_field(field),
                ConceptSubsumptionOutcome::NotSubsumed(Some(e)) => e.get_field(field),
                ConceptSubsumptionOutcome::SubsumedBy(Some(e)) => e.get_field(field),
                ConceptSubsumptionOutcome::Subsumes(Some(e)) => e.get_field(field),
                ConceptSubsumptionOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConceptSubsumptionOutcome::Equivalent(Some(e)) => e.get_field_mut(field),
                ConceptSubsumptionOutcome::NotSubsumed(Some(e)) => e.get_field_mut(field),
                ConceptSubsumptionOutcome::SubsumedBy(Some(e)) => e.get_field_mut(field),
                ConceptSubsumptionOutcome::Subsumes(Some(e)) => e.get_field_mut(field),
                ConceptSubsumptionOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConceptmapUnmappedMode {
    #[doc = "Fixed Code"]
    #[code = "fixed"]
    Fixed(Option<Element>),
    #[doc = "Other Map"]
    #[code = "other-map"]
    OtherMap(Option<Element>),
    #[doc = "Provided Code"]
    #[code = "provided"]
    Provided(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConceptmapUnmappedMode {
    fn default() -> Self {
        ConceptmapUnmappedMode::Null(None)
    }
}
impl TryFrom<String> for ConceptmapUnmappedMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fixed" => Ok(ConceptmapUnmappedMode::Fixed(None)),
            "other-map" => Ok(ConceptmapUnmappedMode::OtherMap(None)),
            "provided" => Ok(ConceptmapUnmappedMode::Provided(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConceptmapUnmappedMode {
    fn into(self) -> Option<String> {
        match self {
            ConceptmapUnmappedMode::Fixed(_) => Some("fixed".to_string()),
            ConceptmapUnmappedMode::OtherMap(_) => Some("other-map".to_string()),
            ConceptmapUnmappedMode::Provided(_) => Some("provided".to_string()),
            ConceptmapUnmappedMode::Null(_) => None,
        }
    }
}
impl MetaValue for ConceptmapUnmappedMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConceptmapUnmappedMode::Fixed(Some(e)) => e.get_field(field),
                ConceptmapUnmappedMode::OtherMap(Some(e)) => e.get_field(field),
                ConceptmapUnmappedMode::Provided(Some(e)) => e.get_field(field),
                ConceptmapUnmappedMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConceptmapUnmappedMode::Fixed(Some(e)) => e.get_field_mut(field),
                ConceptmapUnmappedMode::OtherMap(Some(e)) => e.get_field_mut(field),
                ConceptmapUnmappedMode::Provided(Some(e)) => e.get_field_mut(field),
                ConceptmapUnmappedMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionCategory {
    #[doc = "Encounter Diagnosis"]
    #[code = "encounter-diagnosis"]
    EncounterDiagnosis(Option<Element>),
    #[doc = "Problem List Item"]
    #[code = "problem-list-item"]
    ProblemListItem(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionCategory {
    fn default() -> Self {
        ConditionCategory::Null(None)
    }
}
impl TryFrom<String> for ConditionCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "encounter-diagnosis" => Ok(ConditionCategory::EncounterDiagnosis(None)),
            "problem-list-item" => Ok(ConditionCategory::ProblemListItem(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionCategory {
    fn into(self) -> Option<String> {
        match self {
            ConditionCategory::EncounterDiagnosis(_) => Some("encounter-diagnosis".to_string()),
            ConditionCategory::ProblemListItem(_) => Some("problem-list-item".to_string()),
            ConditionCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionCategory::EncounterDiagnosis(Some(e)) => e.get_field(field),
                ConditionCategory::ProblemListItem(Some(e)) => e.get_field(field),
                ConditionCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionCategory::EncounterDiagnosis(Some(e)) => e.get_field_mut(field),
                ConditionCategory::ProblemListItem(Some(e)) => e.get_field_mut(field),
                ConditionCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionClinical {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Recurrence"]
    #[code = "recurrence"]
    Recurrence(Option<Element>),
    #[doc = "Relapse"]
    #[code = "relapse"]
    Relapse(Option<Element>),
    #[doc = "Remission"]
    #[code = "remission"]
    Remission(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionClinical {
    fn default() -> Self {
        ConditionClinical::Null(None)
    }
}
impl TryFrom<String> for ConditionClinical {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(ConditionClinical::Active(None)),
            "inactive" => Ok(ConditionClinical::Inactive(None)),
            "recurrence" => Ok(ConditionClinical::Recurrence(None)),
            "relapse" => Ok(ConditionClinical::Relapse(None)),
            "remission" => Ok(ConditionClinical::Remission(None)),
            "resolved" => Ok(ConditionClinical::Resolved(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionClinical {
    fn into(self) -> Option<String> {
        match self {
            ConditionClinical::Active(_) => Some("active".to_string()),
            ConditionClinical::Inactive(_) => Some("inactive".to_string()),
            ConditionClinical::Recurrence(_) => Some("recurrence".to_string()),
            ConditionClinical::Relapse(_) => Some("relapse".to_string()),
            ConditionClinical::Remission(_) => Some("remission".to_string()),
            ConditionClinical::Resolved(_) => Some("resolved".to_string()),
            ConditionClinical::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionClinical {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionClinical::Active(Some(e)) => e.get_field(field),
                ConditionClinical::Inactive(Some(e)) => e.get_field(field),
                ConditionClinical::Recurrence(Some(e)) => e.get_field(field),
                ConditionClinical::Relapse(Some(e)) => e.get_field(field),
                ConditionClinical::Remission(Some(e)) => e.get_field(field),
                ConditionClinical::Resolved(Some(e)) => e.get_field(field),
                ConditionClinical::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionClinical::Active(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Inactive(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Recurrence(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Relapse(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Remission(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Resolved(Some(e)) => e.get_field_mut(field),
                ConditionClinical::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionSeverity {
    #[code = "24484000"]
    V24484000(Option<Element>),
    #[code = "255604002"]
    V255604002(Option<Element>),
    #[code = "6736007"]
    V6736007(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionSeverity {
    fn default() -> Self {
        ConditionSeverity::Null(None)
    }
}
impl TryFrom<String> for ConditionSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "24484000" => Ok(ConditionSeverity::V24484000(None)),
            "255604002" => Ok(ConditionSeverity::V255604002(None)),
            "6736007" => Ok(ConditionSeverity::V6736007(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionSeverity {
    fn into(self) -> Option<String> {
        match self {
            ConditionSeverity::V24484000(_) => Some("24484000".to_string()),
            ConditionSeverity::V255604002(_) => Some("255604002".to_string()),
            ConditionSeverity::V6736007(_) => Some("6736007".to_string()),
            ConditionSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionSeverity::V24484000(Some(e)) => e.get_field(field),
                ConditionSeverity::V255604002(Some(e)) => e.get_field(field),
                ConditionSeverity::V6736007(Some(e)) => e.get_field(field),
                ConditionSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionSeverity::V24484000(Some(e)) => e.get_field_mut(field),
                ConditionSeverity::V255604002(Some(e)) => e.get_field_mut(field),
                ConditionSeverity::V6736007(Some(e)) => e.get_field_mut(field),
                ConditionSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionState {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionState {
    fn default() -> Self {
        ConditionState::Null(None)
    }
}
impl TryFrom<String> for ConditionState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(ConditionState::Active(None)),
            "inactive" => Ok(ConditionState::Inactive(None)),
            "resolved" => Ok(ConditionState::Resolved(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionState {
    fn into(self) -> Option<String> {
        match self {
            ConditionState::Active(_) => Some("active".to_string()),
            ConditionState::Inactive(_) => Some("inactive".to_string()),
            ConditionState::Resolved(_) => Some("resolved".to_string()),
            ConditionState::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionState::Active(Some(e)) => e.get_field(field),
                ConditionState::Inactive(Some(e)) => e.get_field(field),
                ConditionState::Resolved(Some(e)) => e.get_field(field),
                ConditionState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionState::Active(Some(e)) => e.get_field_mut(field),
                ConditionState::Inactive(Some(e)) => e.get_field_mut(field),
                ConditionState::Resolved(Some(e)) => e.get_field_mut(field),
                ConditionState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionVerStatus {
    #[doc = "Confirmed"]
    #[code = "confirmed"]
    Confirmed(Option<Element>),
    #[doc = "Differential"]
    #[code = "differential"]
    Differential(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Provisional"]
    #[code = "provisional"]
    Provisional(Option<Element>),
    #[doc = "Refuted"]
    #[code = "refuted"]
    Refuted(Option<Element>),
    #[doc = "Unconfirmed"]
    #[code = "unconfirmed"]
    Unconfirmed(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionVerStatus {
    fn default() -> Self {
        ConditionVerStatus::Null(None)
    }
}
impl TryFrom<String> for ConditionVerStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "confirmed" => Ok(ConditionVerStatus::Confirmed(None)),
            "differential" => Ok(ConditionVerStatus::Differential(None)),
            "entered-in-error" => Ok(ConditionVerStatus::EnteredInError(None)),
            "provisional" => Ok(ConditionVerStatus::Provisional(None)),
            "refuted" => Ok(ConditionVerStatus::Refuted(None)),
            "unconfirmed" => Ok(ConditionVerStatus::Unconfirmed(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionVerStatus {
    fn into(self) -> Option<String> {
        match self {
            ConditionVerStatus::Confirmed(_) => Some("confirmed".to_string()),
            ConditionVerStatus::Differential(_) => Some("differential".to_string()),
            ConditionVerStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ConditionVerStatus::Provisional(_) => Some("provisional".to_string()),
            ConditionVerStatus::Refuted(_) => Some("refuted".to_string()),
            ConditionVerStatus::Unconfirmed(_) => Some("unconfirmed".to_string()),
            ConditionVerStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionVerStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionVerStatus::Confirmed(Some(e)) => e.get_field(field),
                ConditionVerStatus::Differential(Some(e)) => e.get_field(field),
                ConditionVerStatus::EnteredInError(Some(e)) => e.get_field(field),
                ConditionVerStatus::Provisional(Some(e)) => e.get_field(field),
                ConditionVerStatus::Refuted(Some(e)) => e.get_field(field),
                ConditionVerStatus::Unconfirmed(Some(e)) => e.get_field(field),
                ConditionVerStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionVerStatus::Confirmed(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::Differential(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::Provisional(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::Refuted(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::Unconfirmed(Some(e)) => e.get_field_mut(field),
                ConditionVerStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionalDeleteStatus {
    #[doc = "Multiple Deletes Supported"]
    #[code = "multiple"]
    Multiple(Option<Element>),
    #[doc = "Not Supported"]
    #[code = "not-supported"]
    NotSupported(Option<Element>),
    #[doc = "Single Deletes Supported"]
    #[code = "single"]
    Single(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionalDeleteStatus {
    fn default() -> Self {
        ConditionalDeleteStatus::Null(None)
    }
}
impl TryFrom<String> for ConditionalDeleteStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "multiple" => Ok(ConditionalDeleteStatus::Multiple(None)),
            "not-supported" => Ok(ConditionalDeleteStatus::NotSupported(None)),
            "single" => Ok(ConditionalDeleteStatus::Single(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionalDeleteStatus {
    fn into(self) -> Option<String> {
        match self {
            ConditionalDeleteStatus::Multiple(_) => Some("multiple".to_string()),
            ConditionalDeleteStatus::NotSupported(_) => Some("not-supported".to_string()),
            ConditionalDeleteStatus::Single(_) => Some("single".to_string()),
            ConditionalDeleteStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionalDeleteStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionalDeleteStatus::Multiple(Some(e)) => e.get_field(field),
                ConditionalDeleteStatus::NotSupported(Some(e)) => e.get_field(field),
                ConditionalDeleteStatus::Single(Some(e)) => e.get_field(field),
                ConditionalDeleteStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionalDeleteStatus::Multiple(Some(e)) => e.get_field_mut(field),
                ConditionalDeleteStatus::NotSupported(Some(e)) => e.get_field_mut(field),
                ConditionalDeleteStatus::Single(Some(e)) => e.get_field_mut(field),
                ConditionalDeleteStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConditionalReadStatus {
    #[doc = "Full Support"]
    #[code = "full-support"]
    FullSupport(Option<Element>),
    #[doc = "If-Modified-Since"]
    #[code = "modified-since"]
    ModifiedSince(Option<Element>),
    #[doc = "If-None-Match"]
    #[code = "not-match"]
    NotMatch(Option<Element>),
    #[doc = "Not Supported"]
    #[code = "not-supported"]
    NotSupported(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConditionalReadStatus {
    fn default() -> Self {
        ConditionalReadStatus::Null(None)
    }
}
impl TryFrom<String> for ConditionalReadStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "full-support" => Ok(ConditionalReadStatus::FullSupport(None)),
            "modified-since" => Ok(ConditionalReadStatus::ModifiedSince(None)),
            "not-match" => Ok(ConditionalReadStatus::NotMatch(None)),
            "not-supported" => Ok(ConditionalReadStatus::NotSupported(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConditionalReadStatus {
    fn into(self) -> Option<String> {
        match self {
            ConditionalReadStatus::FullSupport(_) => Some("full-support".to_string()),
            ConditionalReadStatus::ModifiedSince(_) => Some("modified-since".to_string()),
            ConditionalReadStatus::NotMatch(_) => Some("not-match".to_string()),
            ConditionalReadStatus::NotSupported(_) => Some("not-supported".to_string()),
            ConditionalReadStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ConditionalReadStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConditionalReadStatus::FullSupport(Some(e)) => e.get_field(field),
                ConditionalReadStatus::ModifiedSince(Some(e)) => e.get_field(field),
                ConditionalReadStatus::NotMatch(Some(e)) => e.get_field(field),
                ConditionalReadStatus::NotSupported(Some(e)) => e.get_field(field),
                ConditionalReadStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConditionalReadStatus::FullSupport(Some(e)) => e.get_field_mut(field),
                ConditionalReadStatus::ModifiedSince(Some(e)) => e.get_field_mut(field),
                ConditionalReadStatus::NotMatch(Some(e)) => e.get_field_mut(field),
                ConditionalReadStatus::NotSupported(Some(e)) => e.get_field_mut(field),
                ConditionalReadStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConformanceExpectation {
    #[doc = "MAY"]
    #[code = "MAY"]
    MAY(Option<Element>),
    #[doc = "SHALL"]
    #[code = "SHALL"]
    SHALL(Option<Element>),
    #[doc = "SHOULD"]
    #[code = "SHOULD"]
    SHOULD(Option<Element>),
    #[doc = "SHOULD-NOT"]
    #[code = "SHOULD-NOT"]
    SHOULDNOT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConformanceExpectation {
    fn default() -> Self {
        ConformanceExpectation::Null(None)
    }
}
impl TryFrom<String> for ConformanceExpectation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "MAY" => Ok(ConformanceExpectation::MAY(None)),
            "SHALL" => Ok(ConformanceExpectation::SHALL(None)),
            "SHOULD" => Ok(ConformanceExpectation::SHOULD(None)),
            "SHOULD-NOT" => Ok(ConformanceExpectation::SHOULDNOT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConformanceExpectation {
    fn into(self) -> Option<String> {
        match self {
            ConformanceExpectation::MAY(_) => Some("MAY".to_string()),
            ConformanceExpectation::SHALL(_) => Some("SHALL".to_string()),
            ConformanceExpectation::SHOULD(_) => Some("SHOULD".to_string()),
            ConformanceExpectation::SHOULDNOT(_) => Some("SHOULD-NOT".to_string()),
            ConformanceExpectation::Null(_) => None,
        }
    }
}
impl MetaValue for ConformanceExpectation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConformanceExpectation::MAY(Some(e)) => e.get_field(field),
                ConformanceExpectation::SHALL(Some(e)) => e.get_field(field),
                ConformanceExpectation::SHOULD(Some(e)) => e.get_field(field),
                ConformanceExpectation::SHOULDNOT(Some(e)) => e.get_field(field),
                ConformanceExpectation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConformanceExpectation::MAY(Some(e)) => e.get_field_mut(field),
                ConformanceExpectation::SHALL(Some(e)) => e.get_field_mut(field),
                ConformanceExpectation::SHOULD(Some(e)) => e.get_field_mut(field),
                ConformanceExpectation::SHOULDNOT(Some(e)) => e.get_field_mut(field),
                ConformanceExpectation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentAction {
    #[doc = "Access"]
    #[code = "access"]
    Access(Option<Element>),
    #[doc = "Collect"]
    #[code = "collect"]
    Collect(Option<Element>),
    #[doc = "Access and Correct"]
    #[code = "correct"]
    Correct(Option<Element>),
    #[doc = "Disclose"]
    #[code = "disclose"]
    Disclose(Option<Element>),
    #[doc = "Use"]
    #[code = "use"]
    Use(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentAction {
    fn default() -> Self {
        ConsentAction::Null(None)
    }
}
impl TryFrom<String> for ConsentAction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "access" => Ok(ConsentAction::Access(None)),
            "collect" => Ok(ConsentAction::Collect(None)),
            "correct" => Ok(ConsentAction::Correct(None)),
            "disclose" => Ok(ConsentAction::Disclose(None)),
            "use" => Ok(ConsentAction::Use(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentAction {
    fn into(self) -> Option<String> {
        match self {
            ConsentAction::Access(_) => Some("access".to_string()),
            ConsentAction::Collect(_) => Some("collect".to_string()),
            ConsentAction::Correct(_) => Some("correct".to_string()),
            ConsentAction::Disclose(_) => Some("disclose".to_string()),
            ConsentAction::Use(_) => Some("use".to_string()),
            ConsentAction::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentAction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentAction::Access(Some(e)) => e.get_field(field),
                ConsentAction::Collect(Some(e)) => e.get_field(field),
                ConsentAction::Correct(Some(e)) => e.get_field(field),
                ConsentAction::Disclose(Some(e)) => e.get_field(field),
                ConsentAction::Use(Some(e)) => e.get_field(field),
                ConsentAction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentAction::Access(Some(e)) => e.get_field_mut(field),
                ConsentAction::Collect(Some(e)) => e.get_field_mut(field),
                ConsentAction::Correct(Some(e)) => e.get_field_mut(field),
                ConsentAction::Disclose(Some(e)) => e.get_field_mut(field),
                ConsentAction::Use(Some(e)) => e.get_field_mut(field),
                ConsentAction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentDataMeaning {
    #[doc = "AuthoredBy"]
    #[code = "authoredby"]
    Authoredby(Option<Element>),
    #[doc = "Dependents"]
    #[code = "dependents"]
    Dependents(Option<Element>),
    #[doc = "Instance"]
    #[code = "instance"]
    Instance(Option<Element>),
    #[doc = "Related"]
    #[code = "related"]
    Related(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentDataMeaning {
    fn default() -> Self {
        ConsentDataMeaning::Null(None)
    }
}
impl TryFrom<String> for ConsentDataMeaning {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "authoredby" => Ok(ConsentDataMeaning::Authoredby(None)),
            "dependents" => Ok(ConsentDataMeaning::Dependents(None)),
            "instance" => Ok(ConsentDataMeaning::Instance(None)),
            "related" => Ok(ConsentDataMeaning::Related(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentDataMeaning {
    fn into(self) -> Option<String> {
        match self {
            ConsentDataMeaning::Authoredby(_) => Some("authoredby".to_string()),
            ConsentDataMeaning::Dependents(_) => Some("dependents".to_string()),
            ConsentDataMeaning::Instance(_) => Some("instance".to_string()),
            ConsentDataMeaning::Related(_) => Some("related".to_string()),
            ConsentDataMeaning::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentDataMeaning {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentDataMeaning::Authoredby(Some(e)) => e.get_field(field),
                ConsentDataMeaning::Dependents(Some(e)) => e.get_field(field),
                ConsentDataMeaning::Instance(Some(e)) => e.get_field(field),
                ConsentDataMeaning::Related(Some(e)) => e.get_field(field),
                ConsentDataMeaning::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentDataMeaning::Authoredby(Some(e)) => e.get_field_mut(field),
                ConsentDataMeaning::Dependents(Some(e)) => e.get_field_mut(field),
                ConsentDataMeaning::Instance(Some(e)) => e.get_field_mut(field),
                ConsentDataMeaning::Related(Some(e)) => e.get_field_mut(field),
                ConsentDataMeaning::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentPerformer {
    #[doc = "Consenter"]
    #[code = "consenter"]
    Consenter(Option<Element>),
    #[doc = "Delegatee"]
    #[code = "delegatee"]
    Delegatee(Option<Element>),
    #[doc = "Delegator"]
    #[code = "delegator"]
    Delegator(Option<Element>),
    #[doc = "Grantee"]
    #[code = "grantee"]
    Grantee(Option<Element>),
    #[doc = "Grantor"]
    #[code = "grantor"]
    Grantor(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentPerformer {
    fn default() -> Self {
        ConsentPerformer::Null(None)
    }
}
impl TryFrom<String> for ConsentPerformer {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "consenter" => Ok(ConsentPerformer::Consenter(None)),
            "delegatee" => Ok(ConsentPerformer::Delegatee(None)),
            "delegator" => Ok(ConsentPerformer::Delegator(None)),
            "grantee" => Ok(ConsentPerformer::Grantee(None)),
            "grantor" => Ok(ConsentPerformer::Grantor(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentPerformer {
    fn into(self) -> Option<String> {
        match self {
            ConsentPerformer::Consenter(_) => Some("consenter".to_string()),
            ConsentPerformer::Delegatee(_) => Some("delegatee".to_string()),
            ConsentPerformer::Delegator(_) => Some("delegator".to_string()),
            ConsentPerformer::Grantee(_) => Some("grantee".to_string()),
            ConsentPerformer::Grantor(_) => Some("grantor".to_string()),
            ConsentPerformer::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentPerformer {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentPerformer::Consenter(Some(e)) => e.get_field(field),
                ConsentPerformer::Delegatee(Some(e)) => e.get_field(field),
                ConsentPerformer::Delegator(Some(e)) => e.get_field(field),
                ConsentPerformer::Grantee(Some(e)) => e.get_field(field),
                ConsentPerformer::Grantor(Some(e)) => e.get_field(field),
                ConsentPerformer::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentPerformer::Consenter(Some(e)) => e.get_field_mut(field),
                ConsentPerformer::Delegatee(Some(e)) => e.get_field_mut(field),
                ConsentPerformer::Delegator(Some(e)) => e.get_field_mut(field),
                ConsentPerformer::Grantee(Some(e)) => e.get_field_mut(field),
                ConsentPerformer::Grantor(Some(e)) => e.get_field_mut(field),
                ConsentPerformer::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentPolicy {
    #[doc = "AT ELGA Opt-in Consent"]
    #[code = "at-elga"]
    AtElga(Option<Element>),
    #[doc = "Common Rule Informed Consent"]
    #[code = "cric"]
    Cric(Option<Element>),
    #[doc = "Michigan behavior and mental health consent"]
    #[code = "dch-3927"]
    Dch3927(Option<Element>),
    #[doc = "Population origins and ancestry research consent"]
    #[code = "ga4gh"]
    Ga4gh(Option<Element>),
    #[doc = "HIPAA Authorization"]
    #[code = "hipaa-auth"]
    HipaaAuth(Option<Element>),
    #[doc = "HIPAA Notice of Privacy Practices"]
    #[code = "hipaa-npp"]
    HipaaNpp(Option<Element>),
    #[doc = "HIPAA Research Authorization"]
    #[code = "hipaa-research"]
    HipaaResearch(Option<Element>),
    #[doc = "HIPAA Restrictions"]
    #[code = "hipaa-restrictions"]
    HipaaRestrictions(Option<Element>),
    #[doc = "HIPAA Self-Pay Restriction"]
    #[code = "hipaa-self-pay"]
    HipaaSelfPay(Option<Element>),
    #[doc = "Illinois Consent by Minors to Medical Procedures"]
    #[code = "illinois-minor-procedure"]
    IllinoisMinorProcedure(Option<Element>),
    #[doc = "Michigan MDHHS-5515 Consent to Share Behavioral Health Information for Care Coordination Purposes"]
    #[code = "mdhhs-5515"]
    Mdhhs5515(Option<Element>),
    #[doc = "NCI Cancer Clinical Trial consent"]
    #[code = "nci"]
    Nci(Option<Element>),
    #[doc = "NIH Authorization for the Release of Medical Information"]
    #[code = "nih-527"]
    Nih527(Option<Element>),
    #[doc = "NIH Global Rare Disease Patient Registry and Data Repository consent"]
    #[code = "nih-grdr"]
    NihGrdr(Option<Element>),
    #[doc = "HHS NIH HIPAA Research Authorization"]
    #[code = "nih-hipaa"]
    NihHipaa(Option<Element>),
    #[doc = "NL LSP Permission"]
    #[code = "nl-lsp"]
    NlLsp(Option<Element>),
    #[doc = "New York State Surgical and Invasive Procedure Protocol"]
    #[code = "nyssipp"]
    Nyssipp(Option<Element>),
    #[doc = "Squaxin Indian behavioral health and HIPAA consent"]
    #[code = "squaxin"]
    Squaxin(Option<Element>),
    #[doc = "SSA Authorization to Disclose"]
    #[code = "ssa-827"]
    Ssa827(Option<Element>),
    #[doc = "VA Form 10-0484"]
    #[code = "va-10-0484"]
    Va100484(Option<Element>),
    #[doc = "VA Form 10-0485"]
    #[code = "va-10-0485"]
    Va100485(Option<Element>),
    #[doc = "VA Form 10-10-10116"]
    #[code = "va-10-10116"]
    Va1010116(Option<Element>),
    #[doc = "VA Form 10-5345"]
    #[code = "va-10-5345"]
    Va105345(Option<Element>),
    #[doc = "VA Form 10-5345a"]
    #[code = "va-10-5345a"]
    Va105345a(Option<Element>),
    #[doc = "VA Form 10-5345a-MHV"]
    #[code = "va-10-5345a-mhv"]
    Va105345aMhv(Option<Element>),
    #[doc = "VA Form 21-4142"]
    #[code = "va-21-4142"]
    Va214142(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentPolicy {
    fn default() -> Self {
        ConsentPolicy::Null(None)
    }
}
impl TryFrom<String> for ConsentPolicy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "at-elga" => Ok(ConsentPolicy::AtElga(None)),
            "cric" => Ok(ConsentPolicy::Cric(None)),
            "dch-3927" => Ok(ConsentPolicy::Dch3927(None)),
            "ga4gh" => Ok(ConsentPolicy::Ga4gh(None)),
            "hipaa-auth" => Ok(ConsentPolicy::HipaaAuth(None)),
            "hipaa-npp" => Ok(ConsentPolicy::HipaaNpp(None)),
            "hipaa-research" => Ok(ConsentPolicy::HipaaResearch(None)),
            "hipaa-restrictions" => Ok(ConsentPolicy::HipaaRestrictions(None)),
            "hipaa-self-pay" => Ok(ConsentPolicy::HipaaSelfPay(None)),
            "illinois-minor-procedure" => Ok(ConsentPolicy::IllinoisMinorProcedure(None)),
            "mdhhs-5515" => Ok(ConsentPolicy::Mdhhs5515(None)),
            "nci" => Ok(ConsentPolicy::Nci(None)),
            "nih-527" => Ok(ConsentPolicy::Nih527(None)),
            "nih-grdr" => Ok(ConsentPolicy::NihGrdr(None)),
            "nih-hipaa" => Ok(ConsentPolicy::NihHipaa(None)),
            "nl-lsp" => Ok(ConsentPolicy::NlLsp(None)),
            "nyssipp" => Ok(ConsentPolicy::Nyssipp(None)),
            "squaxin" => Ok(ConsentPolicy::Squaxin(None)),
            "ssa-827" => Ok(ConsentPolicy::Ssa827(None)),
            "va-10-0484" => Ok(ConsentPolicy::Va100484(None)),
            "va-10-0485" => Ok(ConsentPolicy::Va100485(None)),
            "va-10-10116" => Ok(ConsentPolicy::Va1010116(None)),
            "va-10-5345" => Ok(ConsentPolicy::Va105345(None)),
            "va-10-5345a" => Ok(ConsentPolicy::Va105345a(None)),
            "va-10-5345a-mhv" => Ok(ConsentPolicy::Va105345aMhv(None)),
            "va-21-4142" => Ok(ConsentPolicy::Va214142(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentPolicy {
    fn into(self) -> Option<String> {
        match self {
            ConsentPolicy::AtElga(_) => Some("at-elga".to_string()),
            ConsentPolicy::Cric(_) => Some("cric".to_string()),
            ConsentPolicy::Dch3927(_) => Some("dch-3927".to_string()),
            ConsentPolicy::Ga4gh(_) => Some("ga4gh".to_string()),
            ConsentPolicy::HipaaAuth(_) => Some("hipaa-auth".to_string()),
            ConsentPolicy::HipaaNpp(_) => Some("hipaa-npp".to_string()),
            ConsentPolicy::HipaaResearch(_) => Some("hipaa-research".to_string()),
            ConsentPolicy::HipaaRestrictions(_) => Some("hipaa-restrictions".to_string()),
            ConsentPolicy::HipaaSelfPay(_) => Some("hipaa-self-pay".to_string()),
            ConsentPolicy::IllinoisMinorProcedure(_) => {
                Some("illinois-minor-procedure".to_string())
            }
            ConsentPolicy::Mdhhs5515(_) => Some("mdhhs-5515".to_string()),
            ConsentPolicy::Nci(_) => Some("nci".to_string()),
            ConsentPolicy::Nih527(_) => Some("nih-527".to_string()),
            ConsentPolicy::NihGrdr(_) => Some("nih-grdr".to_string()),
            ConsentPolicy::NihHipaa(_) => Some("nih-hipaa".to_string()),
            ConsentPolicy::NlLsp(_) => Some("nl-lsp".to_string()),
            ConsentPolicy::Nyssipp(_) => Some("nyssipp".to_string()),
            ConsentPolicy::Squaxin(_) => Some("squaxin".to_string()),
            ConsentPolicy::Ssa827(_) => Some("ssa-827".to_string()),
            ConsentPolicy::Va100484(_) => Some("va-10-0484".to_string()),
            ConsentPolicy::Va100485(_) => Some("va-10-0485".to_string()),
            ConsentPolicy::Va1010116(_) => Some("va-10-10116".to_string()),
            ConsentPolicy::Va105345(_) => Some("va-10-5345".to_string()),
            ConsentPolicy::Va105345a(_) => Some("va-10-5345a".to_string()),
            ConsentPolicy::Va105345aMhv(_) => Some("va-10-5345a-mhv".to_string()),
            ConsentPolicy::Va214142(_) => Some("va-21-4142".to_string()),
            ConsentPolicy::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentPolicy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentPolicy::AtElga(Some(e)) => e.get_field(field),
                ConsentPolicy::Cric(Some(e)) => e.get_field(field),
                ConsentPolicy::Dch3927(Some(e)) => e.get_field(field),
                ConsentPolicy::Ga4gh(Some(e)) => e.get_field(field),
                ConsentPolicy::HipaaAuth(Some(e)) => e.get_field(field),
                ConsentPolicy::HipaaNpp(Some(e)) => e.get_field(field),
                ConsentPolicy::HipaaResearch(Some(e)) => e.get_field(field),
                ConsentPolicy::HipaaRestrictions(Some(e)) => e.get_field(field),
                ConsentPolicy::HipaaSelfPay(Some(e)) => e.get_field(field),
                ConsentPolicy::IllinoisMinorProcedure(Some(e)) => e.get_field(field),
                ConsentPolicy::Mdhhs5515(Some(e)) => e.get_field(field),
                ConsentPolicy::Nci(Some(e)) => e.get_field(field),
                ConsentPolicy::Nih527(Some(e)) => e.get_field(field),
                ConsentPolicy::NihGrdr(Some(e)) => e.get_field(field),
                ConsentPolicy::NihHipaa(Some(e)) => e.get_field(field),
                ConsentPolicy::NlLsp(Some(e)) => e.get_field(field),
                ConsentPolicy::Nyssipp(Some(e)) => e.get_field(field),
                ConsentPolicy::Squaxin(Some(e)) => e.get_field(field),
                ConsentPolicy::Ssa827(Some(e)) => e.get_field(field),
                ConsentPolicy::Va100484(Some(e)) => e.get_field(field),
                ConsentPolicy::Va100485(Some(e)) => e.get_field(field),
                ConsentPolicy::Va1010116(Some(e)) => e.get_field(field),
                ConsentPolicy::Va105345(Some(e)) => e.get_field(field),
                ConsentPolicy::Va105345a(Some(e)) => e.get_field(field),
                ConsentPolicy::Va105345aMhv(Some(e)) => e.get_field(field),
                ConsentPolicy::Va214142(Some(e)) => e.get_field(field),
                ConsentPolicy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentPolicy::AtElga(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Cric(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Dch3927(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Ga4gh(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::HipaaAuth(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::HipaaNpp(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::HipaaResearch(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::HipaaRestrictions(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::HipaaSelfPay(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::IllinoisMinorProcedure(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Mdhhs5515(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Nci(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Nih527(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::NihGrdr(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::NihHipaa(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::NlLsp(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Nyssipp(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Squaxin(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Ssa827(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va100484(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va100485(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va1010116(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va105345(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va105345a(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va105345aMhv(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Va214142(Some(e)) => e.get_field_mut(field),
                ConsentPolicy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentProvisionType {
    #[doc = "Opt Out"]
    #[code = "deny"]
    Deny(Option<Element>),
    #[doc = "Opt In"]
    #[code = "permit"]
    Permit(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentProvisionType {
    fn default() -> Self {
        ConsentProvisionType::Null(None)
    }
}
impl TryFrom<String> for ConsentProvisionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "deny" => Ok(ConsentProvisionType::Deny(None)),
            "permit" => Ok(ConsentProvisionType::Permit(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentProvisionType {
    fn into(self) -> Option<String> {
        match self {
            ConsentProvisionType::Deny(_) => Some("deny".to_string()),
            ConsentProvisionType::Permit(_) => Some("permit".to_string()),
            ConsentProvisionType::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentProvisionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentProvisionType::Deny(Some(e)) => e.get_field(field),
                ConsentProvisionType::Permit(Some(e)) => e.get_field(field),
                ConsentProvisionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentProvisionType::Deny(Some(e)) => e.get_field_mut(field),
                ConsentProvisionType::Permit(Some(e)) => e.get_field_mut(field),
                ConsentProvisionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentScope {
    #[doc = "Advanced Care Directive"]
    #[code = "adr"]
    Adr(Option<Element>),
    #[doc = "Privacy Consent"]
    #[code = "patient-privacy"]
    PatientPrivacy(Option<Element>),
    #[doc = "Research"]
    #[code = "research"]
    Research(Option<Element>),
    #[doc = "Treatment"]
    #[code = "treatment"]
    Treatment(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentScope {
    fn default() -> Self {
        ConsentScope::Null(None)
    }
}
impl TryFrom<String> for ConsentScope {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "adr" => Ok(ConsentScope::Adr(None)),
            "patient-privacy" => Ok(ConsentScope::PatientPrivacy(None)),
            "research" => Ok(ConsentScope::Research(None)),
            "treatment" => Ok(ConsentScope::Treatment(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentScope {
    fn into(self) -> Option<String> {
        match self {
            ConsentScope::Adr(_) => Some("adr".to_string()),
            ConsentScope::PatientPrivacy(_) => Some("patient-privacy".to_string()),
            ConsentScope::Research(_) => Some("research".to_string()),
            ConsentScope::Treatment(_) => Some("treatment".to_string()),
            ConsentScope::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentScope {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentScope::Adr(Some(e)) => e.get_field(field),
                ConsentScope::PatientPrivacy(Some(e)) => e.get_field(field),
                ConsentScope::Research(Some(e)) => e.get_field(field),
                ConsentScope::Treatment(Some(e)) => e.get_field(field),
                ConsentScope::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentScope::Adr(Some(e)) => e.get_field_mut(field),
                ConsentScope::PatientPrivacy(Some(e)) => e.get_field_mut(field),
                ConsentScope::Research(Some(e)) => e.get_field_mut(field),
                ConsentScope::Treatment(Some(e)) => e.get_field_mut(field),
                ConsentScope::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsentStateCodes {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Pending"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Proposed"]
    #[code = "proposed"]
    Proposed(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsentStateCodes {
    fn default() -> Self {
        ConsentStateCodes::Null(None)
    }
}
impl TryFrom<String> for ConsentStateCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(ConsentStateCodes::Active(None)),
            "draft" => Ok(ConsentStateCodes::Draft(None)),
            "entered-in-error" => Ok(ConsentStateCodes::EnteredInError(None)),
            "inactive" => Ok(ConsentStateCodes::Inactive(None)),
            "proposed" => Ok(ConsentStateCodes::Proposed(None)),
            "rejected" => Ok(ConsentStateCodes::Rejected(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsentStateCodes {
    fn into(self) -> Option<String> {
        match self {
            ConsentStateCodes::Active(_) => Some("active".to_string()),
            ConsentStateCodes::Draft(_) => Some("draft".to_string()),
            ConsentStateCodes::EnteredInError(_) => Some("entered-in-error".to_string()),
            ConsentStateCodes::Inactive(_) => Some("inactive".to_string()),
            ConsentStateCodes::Proposed(_) => Some("proposed".to_string()),
            ConsentStateCodes::Rejected(_) => Some("rejected".to_string()),
            ConsentStateCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ConsentStateCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsentStateCodes::Active(Some(e)) => e.get_field(field),
                ConsentStateCodes::Draft(Some(e)) => e.get_field(field),
                ConsentStateCodes::EnteredInError(Some(e)) => e.get_field(field),
                ConsentStateCodes::Inactive(Some(e)) => e.get_field(field),
                ConsentStateCodes::Proposed(Some(e)) => e.get_field(field),
                ConsentStateCodes::Rejected(Some(e)) => e.get_field(field),
                ConsentStateCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsentStateCodes::Active(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::Draft(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::EnteredInError(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::Inactive(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::Proposed(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::Rejected(Some(e)) => e.get_field_mut(field),
                ConsentStateCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConsistencyType {
    #[doc = "nectar thick liquid"]
    #[code = "439021000124105"]
    V439021000124105(Option<Element>),
    #[doc = "honey thick liquid"]
    #[code = "439031000124108"]
    V439031000124108(Option<Element>),
    #[doc = "spoon thick liquid"]
    #[code = "439041000124103"]
    V439041000124103(Option<Element>),
    #[doc = "thin liquid"]
    #[code = "439081000124109"]
    V439081000124109(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConsistencyType {
    fn default() -> Self {
        ConsistencyType::Null(None)
    }
}
impl TryFrom<String> for ConsistencyType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "439021000124105" => Ok(ConsistencyType::V439021000124105(None)),
            "439031000124108" => Ok(ConsistencyType::V439031000124108(None)),
            "439041000124103" => Ok(ConsistencyType::V439041000124103(None)),
            "439081000124109" => Ok(ConsistencyType::V439081000124109(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConsistencyType {
    fn into(self) -> Option<String> {
        match self {
            ConsistencyType::V439021000124105(_) => Some("439021000124105".to_string()),
            ConsistencyType::V439031000124108(_) => Some("439031000124108".to_string()),
            ConsistencyType::V439041000124103(_) => Some("439041000124103".to_string()),
            ConsistencyType::V439081000124109(_) => Some("439081000124109".to_string()),
            ConsistencyType::Null(_) => None,
        }
    }
}
impl MetaValue for ConsistencyType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConsistencyType::V439021000124105(Some(e)) => e.get_field(field),
                ConsistencyType::V439031000124108(Some(e)) => e.get_field(field),
                ConsistencyType::V439041000124103(Some(e)) => e.get_field(field),
                ConsistencyType::V439081000124109(Some(e)) => e.get_field(field),
                ConsistencyType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConsistencyType::V439021000124105(Some(e)) => e.get_field_mut(field),
                ConsistencyType::V439031000124108(Some(e)) => e.get_field_mut(field),
                ConsistencyType::V439041000124103(Some(e)) => e.get_field_mut(field),
                ConsistencyType::V439081000124109(Some(e)) => e.get_field_mut(field),
                ConsistencyType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ConstraintSeverity {
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Warning"]
    #[code = "warning"]
    Warning(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ConstraintSeverity {
    fn default() -> Self {
        ConstraintSeverity::Null(None)
    }
}
impl TryFrom<String> for ConstraintSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "error" => Ok(ConstraintSeverity::Error(None)),
            "warning" => Ok(ConstraintSeverity::Warning(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ConstraintSeverity {
    fn into(self) -> Option<String> {
        match self {
            ConstraintSeverity::Error(_) => Some("error".to_string()),
            ConstraintSeverity::Warning(_) => Some("warning".to_string()),
            ConstraintSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for ConstraintSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ConstraintSeverity::Error(Some(e)) => e.get_field(field),
                ConstraintSeverity::Warning(Some(e)) => e.get_field(field),
                ConstraintSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ConstraintSeverity::Error(Some(e)) => e.get_field_mut(field),
                ConstraintSeverity::Warning(Some(e)) => e.get_field_mut(field),
                ConstraintSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContactPointSystem {
    #[doc = "Email"]
    #[code = "email"]
    Email(Option<Element>),
    #[doc = "Fax"]
    #[code = "fax"]
    Fax(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Pager"]
    #[code = "pager"]
    Pager(Option<Element>),
    #[doc = "Phone"]
    #[code = "phone"]
    Phone(Option<Element>),
    #[doc = "SMS"]
    #[code = "sms"]
    Sms(Option<Element>),
    #[doc = "URL"]
    #[code = "url"]
    Url(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContactPointSystem {
    fn default() -> Self {
        ContactPointSystem::Null(None)
    }
}
impl TryFrom<String> for ContactPointSystem {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "email" => Ok(ContactPointSystem::Email(None)),
            "fax" => Ok(ContactPointSystem::Fax(None)),
            "other" => Ok(ContactPointSystem::Other(None)),
            "pager" => Ok(ContactPointSystem::Pager(None)),
            "phone" => Ok(ContactPointSystem::Phone(None)),
            "sms" => Ok(ContactPointSystem::Sms(None)),
            "url" => Ok(ContactPointSystem::Url(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContactPointSystem {
    fn into(self) -> Option<String> {
        match self {
            ContactPointSystem::Email(_) => Some("email".to_string()),
            ContactPointSystem::Fax(_) => Some("fax".to_string()),
            ContactPointSystem::Other(_) => Some("other".to_string()),
            ContactPointSystem::Pager(_) => Some("pager".to_string()),
            ContactPointSystem::Phone(_) => Some("phone".to_string()),
            ContactPointSystem::Sms(_) => Some("sms".to_string()),
            ContactPointSystem::Url(_) => Some("url".to_string()),
            ContactPointSystem::Null(_) => None,
        }
    }
}
impl MetaValue for ContactPointSystem {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContactPointSystem::Email(Some(e)) => e.get_field(field),
                ContactPointSystem::Fax(Some(e)) => e.get_field(field),
                ContactPointSystem::Other(Some(e)) => e.get_field(field),
                ContactPointSystem::Pager(Some(e)) => e.get_field(field),
                ContactPointSystem::Phone(Some(e)) => e.get_field(field),
                ContactPointSystem::Sms(Some(e)) => e.get_field(field),
                ContactPointSystem::Url(Some(e)) => e.get_field(field),
                ContactPointSystem::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContactPointSystem::Email(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Fax(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Other(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Pager(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Phone(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Sms(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Url(Some(e)) => e.get_field_mut(field),
                ContactPointSystem::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContactPointUse {
    #[doc = "Home"]
    #[code = "home"]
    Home(Option<Element>),
    #[doc = "Mobile"]
    #[code = "mobile"]
    Mobile(Option<Element>),
    #[doc = "Old"]
    #[code = "old"]
    Old(Option<Element>),
    #[doc = "Temp"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "Work"]
    #[code = "work"]
    Work(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContactPointUse {
    fn default() -> Self {
        ContactPointUse::Null(None)
    }
}
impl TryFrom<String> for ContactPointUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "home" => Ok(ContactPointUse::Home(None)),
            "mobile" => Ok(ContactPointUse::Mobile(None)),
            "old" => Ok(ContactPointUse::Old(None)),
            "temp" => Ok(ContactPointUse::Temp(None)),
            "work" => Ok(ContactPointUse::Work(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContactPointUse {
    fn into(self) -> Option<String> {
        match self {
            ContactPointUse::Home(_) => Some("home".to_string()),
            ContactPointUse::Mobile(_) => Some("mobile".to_string()),
            ContactPointUse::Old(_) => Some("old".to_string()),
            ContactPointUse::Temp(_) => Some("temp".to_string()),
            ContactPointUse::Work(_) => Some("work".to_string()),
            ContactPointUse::Null(_) => None,
        }
    }
}
impl MetaValue for ContactPointUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContactPointUse::Home(Some(e)) => e.get_field(field),
                ContactPointUse::Mobile(Some(e)) => e.get_field(field),
                ContactPointUse::Old(Some(e)) => e.get_field(field),
                ContactPointUse::Temp(Some(e)) => e.get_field(field),
                ContactPointUse::Work(Some(e)) => e.get_field(field),
                ContactPointUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContactPointUse::Home(Some(e)) => e.get_field_mut(field),
                ContactPointUse::Mobile(Some(e)) => e.get_field_mut(field),
                ContactPointUse::Old(Some(e)) => e.get_field_mut(field),
                ContactPointUse::Temp(Some(e)) => e.get_field_mut(field),
                ContactPointUse::Work(Some(e)) => e.get_field_mut(field),
                ContactPointUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContactentityType {
    #[doc = "Administrative"]
    #[code = "ADMIN"]
    ADMIN(Option<Element>),
    #[doc = "Billing"]
    #[code = "BILL"]
    BILL(Option<Element>),
    #[doc = "Human Resource"]
    #[code = "HR"]
    HR(Option<Element>),
    #[doc = "Patient"]
    #[code = "PATINF"]
    PATINF(Option<Element>),
    #[doc = "Payor"]
    #[code = "PAYOR"]
    PAYOR(Option<Element>),
    #[doc = "Press"]
    #[code = "PRESS"]
    PRESS(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContactentityType {
    fn default() -> Self {
        ContactentityType::Null(None)
    }
}
impl TryFrom<String> for ContactentityType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADMIN" => Ok(ContactentityType::ADMIN(None)),
            "BILL" => Ok(ContactentityType::BILL(None)),
            "HR" => Ok(ContactentityType::HR(None)),
            "PATINF" => Ok(ContactentityType::PATINF(None)),
            "PAYOR" => Ok(ContactentityType::PAYOR(None)),
            "PRESS" => Ok(ContactentityType::PRESS(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContactentityType {
    fn into(self) -> Option<String> {
        match self {
            ContactentityType::ADMIN(_) => Some("ADMIN".to_string()),
            ContactentityType::BILL(_) => Some("BILL".to_string()),
            ContactentityType::HR(_) => Some("HR".to_string()),
            ContactentityType::PATINF(_) => Some("PATINF".to_string()),
            ContactentityType::PAYOR(_) => Some("PAYOR".to_string()),
            ContactentityType::PRESS(_) => Some("PRESS".to_string()),
            ContactentityType::Null(_) => None,
        }
    }
}
impl MetaValue for ContactentityType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContactentityType::ADMIN(Some(e)) => e.get_field(field),
                ContactentityType::BILL(Some(e)) => e.get_field(field),
                ContactentityType::HR(Some(e)) => e.get_field(field),
                ContactentityType::PATINF(Some(e)) => e.get_field(field),
                ContactentityType::PAYOR(Some(e)) => e.get_field(field),
                ContactentityType::PRESS(Some(e)) => e.get_field(field),
                ContactentityType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContactentityType::ADMIN(Some(e)) => e.get_field_mut(field),
                ContactentityType::BILL(Some(e)) => e.get_field_mut(field),
                ContactentityType::HR(Some(e)) => e.get_field_mut(field),
                ContactentityType::PATINF(Some(e)) => e.get_field_mut(field),
                ContactentityType::PAYOR(Some(e)) => e.get_field_mut(field),
                ContactentityType::PRESS(Some(e)) => e.get_field_mut(field),
                ContactentityType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContainerCap {
    #[doc = "black cap"]
    #[code = "black"]
    Black(Option<Element>),
    #[doc = "brown cap"]
    #[code = "brown"]
    Brown(Option<Element>),
    #[doc = "dark yellow cap"]
    #[code = "dark-yellow"]
    DarkYellow(Option<Element>),
    #[doc = "green cap"]
    #[code = "green"]
    Green(Option<Element>),
    #[doc = "grey cap"]
    #[code = "grey"]
    Grey(Option<Element>),
    #[doc = "lavender cap"]
    #[code = "lavender"]
    Lavender(Option<Element>),
    #[doc = "light blue cap"]
    #[code = "light-blue"]
    LightBlue(Option<Element>),
    #[doc = "light green cap"]
    #[code = "light-green"]
    LightGreen(Option<Element>),
    #[doc = "pink cap"]
    #[code = "pink"]
    Pink(Option<Element>),
    #[doc = "red cap"]
    #[code = "red"]
    Red(Option<Element>),
    #[doc = "white cap"]
    #[code = "white"]
    White(Option<Element>),
    #[doc = "yellow cap"]
    #[code = "yellow"]
    Yellow(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContainerCap {
    fn default() -> Self {
        ContainerCap::Null(None)
    }
}
impl TryFrom<String> for ContainerCap {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "black" => Ok(ContainerCap::Black(None)),
            "brown" => Ok(ContainerCap::Brown(None)),
            "dark-yellow" => Ok(ContainerCap::DarkYellow(None)),
            "green" => Ok(ContainerCap::Green(None)),
            "grey" => Ok(ContainerCap::Grey(None)),
            "lavender" => Ok(ContainerCap::Lavender(None)),
            "light-blue" => Ok(ContainerCap::LightBlue(None)),
            "light-green" => Ok(ContainerCap::LightGreen(None)),
            "pink" => Ok(ContainerCap::Pink(None)),
            "red" => Ok(ContainerCap::Red(None)),
            "white" => Ok(ContainerCap::White(None)),
            "yellow" => Ok(ContainerCap::Yellow(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContainerCap {
    fn into(self) -> Option<String> {
        match self {
            ContainerCap::Black(_) => Some("black".to_string()),
            ContainerCap::Brown(_) => Some("brown".to_string()),
            ContainerCap::DarkYellow(_) => Some("dark-yellow".to_string()),
            ContainerCap::Green(_) => Some("green".to_string()),
            ContainerCap::Grey(_) => Some("grey".to_string()),
            ContainerCap::Lavender(_) => Some("lavender".to_string()),
            ContainerCap::LightBlue(_) => Some("light-blue".to_string()),
            ContainerCap::LightGreen(_) => Some("light-green".to_string()),
            ContainerCap::Pink(_) => Some("pink".to_string()),
            ContainerCap::Red(_) => Some("red".to_string()),
            ContainerCap::White(_) => Some("white".to_string()),
            ContainerCap::Yellow(_) => Some("yellow".to_string()),
            ContainerCap::Null(_) => None,
        }
    }
}
impl MetaValue for ContainerCap {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContainerCap::Black(Some(e)) => e.get_field(field),
                ContainerCap::Brown(Some(e)) => e.get_field(field),
                ContainerCap::DarkYellow(Some(e)) => e.get_field(field),
                ContainerCap::Green(Some(e)) => e.get_field(field),
                ContainerCap::Grey(Some(e)) => e.get_field(field),
                ContainerCap::Lavender(Some(e)) => e.get_field(field),
                ContainerCap::LightBlue(Some(e)) => e.get_field(field),
                ContainerCap::LightGreen(Some(e)) => e.get_field(field),
                ContainerCap::Pink(Some(e)) => e.get_field(field),
                ContainerCap::Red(Some(e)) => e.get_field(field),
                ContainerCap::White(Some(e)) => e.get_field(field),
                ContainerCap::Yellow(Some(e)) => e.get_field(field),
                ContainerCap::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContainerCap::Black(Some(e)) => e.get_field_mut(field),
                ContainerCap::Brown(Some(e)) => e.get_field_mut(field),
                ContainerCap::DarkYellow(Some(e)) => e.get_field_mut(field),
                ContainerCap::Green(Some(e)) => e.get_field_mut(field),
                ContainerCap::Grey(Some(e)) => e.get_field_mut(field),
                ContainerCap::Lavender(Some(e)) => e.get_field_mut(field),
                ContainerCap::LightBlue(Some(e)) => e.get_field_mut(field),
                ContainerCap::LightGreen(Some(e)) => e.get_field_mut(field),
                ContainerCap::Pink(Some(e)) => e.get_field_mut(field),
                ContainerCap::Red(Some(e)) => e.get_field_mut(field),
                ContainerCap::White(Some(e)) => e.get_field_mut(field),
                ContainerCap::Yellow(Some(e)) => e.get_field_mut(field),
                ContainerCap::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContainerMaterial {
    #[doc = "glass"]
    #[code = "32039001"]
    V32039001(Option<Element>),
    #[doc = "metal"]
    #[code = "425620007"]
    V425620007(Option<Element>),
    #[doc = "plastic"]
    #[code = "61088005"]
    V61088005(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContainerMaterial {
    fn default() -> Self {
        ContainerMaterial::Null(None)
    }
}
impl TryFrom<String> for ContainerMaterial {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "32039001" => Ok(ContainerMaterial::V32039001(None)),
            "425620007" => Ok(ContainerMaterial::V425620007(None)),
            "61088005" => Ok(ContainerMaterial::V61088005(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContainerMaterial {
    fn into(self) -> Option<String> {
        match self {
            ContainerMaterial::V32039001(_) => Some("32039001".to_string()),
            ContainerMaterial::V425620007(_) => Some("425620007".to_string()),
            ContainerMaterial::V61088005(_) => Some("61088005".to_string()),
            ContainerMaterial::Null(_) => None,
        }
    }
}
impl MetaValue for ContainerMaterial {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContainerMaterial::V32039001(Some(e)) => e.get_field(field),
                ContainerMaterial::V425620007(Some(e)) => e.get_field(field),
                ContainerMaterial::V61088005(Some(e)) => e.get_field(field),
                ContainerMaterial::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContainerMaterial::V32039001(Some(e)) => e.get_field_mut(field),
                ContainerMaterial::V425620007(Some(e)) => e.get_field_mut(field),
                ContainerMaterial::V61088005(Some(e)) => e.get_field_mut(field),
                ContainerMaterial::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractAction {
    #[doc = "Action A"]
    #[code = "action-a"]
    ActionA(Option<Element>),
    #[doc = "Action B"]
    #[code = "action-b"]
    ActionB(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractAction {
    fn default() -> Self {
        ContractAction::Null(None)
    }
}
impl TryFrom<String> for ContractAction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "action-a" => Ok(ContractAction::ActionA(None)),
            "action-b" => Ok(ContractAction::ActionB(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractAction {
    fn into(self) -> Option<String> {
        match self {
            ContractAction::ActionA(_) => Some("action-a".to_string()),
            ContractAction::ActionB(_) => Some("action-b".to_string()),
            ContractAction::Null(_) => None,
        }
    }
}
impl MetaValue for ContractAction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractAction::ActionA(Some(e)) => e.get_field(field),
                ContractAction::ActionB(Some(e)) => e.get_field(field),
                ContractAction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractAction::ActionA(Some(e)) => e.get_field_mut(field),
                ContractAction::ActionB(Some(e)) => e.get_field_mut(field),
                ContractAction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractActionstatus {
    #[doc = "Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractActionstatus {
    fn default() -> Self {
        ContractActionstatus::Null(None)
    }
}
impl TryFrom<String> for ContractActionstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(ContractActionstatus::Complete(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractActionstatus {
    fn into(self) -> Option<String> {
        match self {
            ContractActionstatus::Complete(_) => Some("complete".to_string()),
            ContractActionstatus::Null(_) => None,
        }
    }
}
impl MetaValue for ContractActionstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractActionstatus::Complete(Some(e)) => e.get_field(field),
                ContractActionstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractActionstatus::Complete(Some(e)) => e.get_field_mut(field),
                ContractActionstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractActorrole {
    #[doc = "Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "practitioner"]
    Practitioner(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractActorrole {
    fn default() -> Self {
        ContractActorrole::Null(None)
    }
}
impl TryFrom<String> for ContractActorrole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "patient" => Ok(ContractActorrole::Patient(None)),
            "practitioner" => Ok(ContractActorrole::Practitioner(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractActorrole {
    fn into(self) -> Option<String> {
        match self {
            ContractActorrole::Patient(_) => Some("patient".to_string()),
            ContractActorrole::Practitioner(_) => Some("practitioner".to_string()),
            ContractActorrole::Null(_) => None,
        }
    }
}
impl MetaValue for ContractActorrole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractActorrole::Patient(Some(e)) => e.get_field(field),
                ContractActorrole::Practitioner(Some(e)) => e.get_field(field),
                ContractActorrole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractActorrole::Patient(Some(e)) => e.get_field_mut(field),
                ContractActorrole::Practitioner(Some(e)) => e.get_field_mut(field),
                ContractActorrole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractAssetcontext {
    #[doc = "Custodian"]
    #[code = "custodian"]
    Custodian(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractAssetcontext {
    fn default() -> Self {
        ContractAssetcontext::Null(None)
    }
}
impl TryFrom<String> for ContractAssetcontext {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "custodian" => Ok(ContractAssetcontext::Custodian(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractAssetcontext {
    fn into(self) -> Option<String> {
        match self {
            ContractAssetcontext::Custodian(_) => Some("custodian".to_string()),
            ContractAssetcontext::Null(_) => None,
        }
    }
}
impl MetaValue for ContractAssetcontext {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractAssetcontext::Custodian(Some(e)) => e.get_field(field),
                ContractAssetcontext::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractAssetcontext::Custodian(Some(e)) => e.get_field_mut(field),
                ContractAssetcontext::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractAssetscope {
    #[doc = "Thing"]
    #[code = "thing"]
    Thing(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractAssetscope {
    fn default() -> Self {
        ContractAssetscope::Null(None)
    }
}
impl TryFrom<String> for ContractAssetscope {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "thing" => Ok(ContractAssetscope::Thing(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractAssetscope {
    fn into(self) -> Option<String> {
        match self {
            ContractAssetscope::Thing(_) => Some("thing".to_string()),
            ContractAssetscope::Null(_) => None,
        }
    }
}
impl MetaValue for ContractAssetscope {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractAssetscope::Thing(Some(e)) => e.get_field(field),
                ContractAssetscope::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractAssetscope::Thing(Some(e)) => e.get_field_mut(field),
                ContractAssetscope::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractAssetsubtype {
    #[doc = "Participation"]
    #[code = "participation"]
    Participation(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractAssetsubtype {
    fn default() -> Self {
        ContractAssetsubtype::Null(None)
    }
}
impl TryFrom<String> for ContractAssetsubtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "participation" => Ok(ContractAssetsubtype::Participation(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractAssetsubtype {
    fn into(self) -> Option<String> {
        match self {
            ContractAssetsubtype::Participation(_) => Some("participation".to_string()),
            ContractAssetsubtype::Null(_) => None,
        }
    }
}
impl MetaValue for ContractAssetsubtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractAssetsubtype::Participation(Some(e)) => e.get_field(field),
                ContractAssetsubtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractAssetsubtype::Participation(Some(e)) => e.get_field_mut(field),
                ContractAssetsubtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractAssettype {
    #[doc = "Participation"]
    #[code = "participation"]
    Participation(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractAssettype {
    fn default() -> Self {
        ContractAssettype::Null(None)
    }
}
impl TryFrom<String> for ContractAssettype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "participation" => Ok(ContractAssettype::Participation(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractAssettype {
    fn into(self) -> Option<String> {
        match self {
            ContractAssettype::Participation(_) => Some("participation".to_string()),
            ContractAssettype::Null(_) => None,
        }
    }
}
impl MetaValue for ContractAssettype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractAssettype::Participation(Some(e)) => e.get_field(field),
                ContractAssettype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractAssettype::Participation(Some(e)) => e.get_field_mut(field),
                ContractAssettype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractContentDerivative {
    #[doc = "Content Registration"]
    #[code = "registration"]
    Registration(Option<Element>),
    #[doc = "Content Retrieval"]
    #[code = "retrieval"]
    Retrieval(Option<Element>),
    #[doc = "Shareable Content"]
    #[code = "shareable"]
    Shareable(Option<Element>),
    #[doc = "Content Statement"]
    #[code = "statement"]
    Statement(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractContentDerivative {
    fn default() -> Self {
        ContractContentDerivative::Null(None)
    }
}
impl TryFrom<String> for ContractContentDerivative {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "registration" => Ok(ContractContentDerivative::Registration(None)),
            "retrieval" => Ok(ContractContentDerivative::Retrieval(None)),
            "shareable" => Ok(ContractContentDerivative::Shareable(None)),
            "statement" => Ok(ContractContentDerivative::Statement(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractContentDerivative {
    fn into(self) -> Option<String> {
        match self {
            ContractContentDerivative::Registration(_) => Some("registration".to_string()),
            ContractContentDerivative::Retrieval(_) => Some("retrieval".to_string()),
            ContractContentDerivative::Shareable(_) => Some("shareable".to_string()),
            ContractContentDerivative::Statement(_) => Some("statement".to_string()),
            ContractContentDerivative::Null(_) => None,
        }
    }
}
impl MetaValue for ContractContentDerivative {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractContentDerivative::Registration(Some(e)) => e.get_field(field),
                ContractContentDerivative::Retrieval(Some(e)) => e.get_field(field),
                ContractContentDerivative::Shareable(Some(e)) => e.get_field(field),
                ContractContentDerivative::Statement(Some(e)) => e.get_field(field),
                ContractContentDerivative::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractContentDerivative::Registration(Some(e)) => e.get_field_mut(field),
                ContractContentDerivative::Retrieval(Some(e)) => e.get_field_mut(field),
                ContractContentDerivative::Shareable(Some(e)) => e.get_field_mut(field),
                ContractContentDerivative::Statement(Some(e)) => e.get_field_mut(field),
                ContractContentDerivative::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractDataMeaning {
    #[doc = "AuthoredBy"]
    #[code = "authoredby"]
    Authoredby(Option<Element>),
    #[doc = "Dependents"]
    #[code = "dependents"]
    Dependents(Option<Element>),
    #[doc = "Instance"]
    #[code = "instance"]
    Instance(Option<Element>),
    #[doc = "Related"]
    #[code = "related"]
    Related(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractDataMeaning {
    fn default() -> Self {
        ContractDataMeaning::Null(None)
    }
}
impl TryFrom<String> for ContractDataMeaning {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "authoredby" => Ok(ContractDataMeaning::Authoredby(None)),
            "dependents" => Ok(ContractDataMeaning::Dependents(None)),
            "instance" => Ok(ContractDataMeaning::Instance(None)),
            "related" => Ok(ContractDataMeaning::Related(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractDataMeaning {
    fn into(self) -> Option<String> {
        match self {
            ContractDataMeaning::Authoredby(_) => Some("authoredby".to_string()),
            ContractDataMeaning::Dependents(_) => Some("dependents".to_string()),
            ContractDataMeaning::Instance(_) => Some("instance".to_string()),
            ContractDataMeaning::Related(_) => Some("related".to_string()),
            ContractDataMeaning::Null(_) => None,
        }
    }
}
impl MetaValue for ContractDataMeaning {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractDataMeaning::Authoredby(Some(e)) => e.get_field(field),
                ContractDataMeaning::Dependents(Some(e)) => e.get_field(field),
                ContractDataMeaning::Instance(Some(e)) => e.get_field(field),
                ContractDataMeaning::Related(Some(e)) => e.get_field(field),
                ContractDataMeaning::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractDataMeaning::Authoredby(Some(e)) => e.get_field_mut(field),
                ContractDataMeaning::Dependents(Some(e)) => e.get_field_mut(field),
                ContractDataMeaning::Instance(Some(e)) => e.get_field_mut(field),
                ContractDataMeaning::Related(Some(e)) => e.get_field_mut(field),
                ContractDataMeaning::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractDecisionMode {
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractDecisionMode {
    fn default() -> Self {
        ContractDecisionMode::Null(None)
    }
}
impl TryFrom<String> for ContractDecisionMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "policy" => Ok(ContractDecisionMode::Policy(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractDecisionMode {
    fn into(self) -> Option<String> {
        match self {
            ContractDecisionMode::Policy(_) => Some("policy".to_string()),
            ContractDecisionMode::Null(_) => None,
        }
    }
}
impl MetaValue for ContractDecisionMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractDecisionMode::Policy(Some(e)) => e.get_field(field),
                ContractDecisionMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractDecisionMode::Policy(Some(e)) => e.get_field_mut(field),
                ContractDecisionMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractDefinitionSubtype {
    #[doc = "Temporary Value"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractDefinitionSubtype {
    fn default() -> Self {
        ContractDefinitionSubtype::Null(None)
    }
}
impl TryFrom<String> for ContractDefinitionSubtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "temp" => Ok(ContractDefinitionSubtype::Temp(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractDefinitionSubtype {
    fn into(self) -> Option<String> {
        match self {
            ContractDefinitionSubtype::Temp(_) => Some("temp".to_string()),
            ContractDefinitionSubtype::Null(_) => None,
        }
    }
}
impl MetaValue for ContractDefinitionSubtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractDefinitionSubtype::Temp(Some(e)) => e.get_field(field),
                ContractDefinitionSubtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractDefinitionSubtype::Temp(Some(e)) => e.get_field_mut(field),
                ContractDefinitionSubtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractDefinitionType {
    #[doc = "Temporary Value"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractDefinitionType {
    fn default() -> Self {
        ContractDefinitionType::Null(None)
    }
}
impl TryFrom<String> for ContractDefinitionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "temp" => Ok(ContractDefinitionType::Temp(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractDefinitionType {
    fn into(self) -> Option<String> {
        match self {
            ContractDefinitionType::Temp(_) => Some("temp".to_string()),
            ContractDefinitionType::Null(_) => None,
        }
    }
}
impl MetaValue for ContractDefinitionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractDefinitionType::Temp(Some(e)) => e.get_field(field),
                ContractDefinitionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractDefinitionType::Temp(Some(e)) => e.get_field_mut(field),
                ContractDefinitionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractExpirationType {
    #[doc = "Breach"]
    #[code = "breach"]
    Breach(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractExpirationType {
    fn default() -> Self {
        ContractExpirationType::Null(None)
    }
}
impl TryFrom<String> for ContractExpirationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "breach" => Ok(ContractExpirationType::Breach(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractExpirationType {
    fn into(self) -> Option<String> {
        match self {
            ContractExpirationType::Breach(_) => Some("breach".to_string()),
            ContractExpirationType::Null(_) => None,
        }
    }
}
impl MetaValue for ContractExpirationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractExpirationType::Breach(Some(e)) => e.get_field(field),
                ContractExpirationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractExpirationType::Breach(Some(e)) => e.get_field_mut(field),
                ContractExpirationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractLegalstate {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Appended"]
    #[code = "appended"]
    Appended(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Disputed"]
    #[code = "disputed"]
    Disputed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Executable"]
    #[code = "executable"]
    Executable(Option<Element>),
    #[doc = "Executed"]
    #[code = "executed"]
    Executed(Option<Element>),
    #[doc = "Negotiable"]
    #[code = "negotiable"]
    Negotiable(Option<Element>),
    #[doc = "Offered"]
    #[code = "offered"]
    Offered(Option<Element>),
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "Renewed"]
    #[code = "renewed"]
    Renewed(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "Revoked"]
    #[code = "revoked"]
    Revoked(Option<Element>),
    #[doc = "Terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractLegalstate {
    fn default() -> Self {
        ContractLegalstate::Null(None)
    }
}
impl TryFrom<String> for ContractLegalstate {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(ContractLegalstate::Amended(None)),
            "appended" => Ok(ContractLegalstate::Appended(None)),
            "cancelled" => Ok(ContractLegalstate::Cancelled(None)),
            "disputed" => Ok(ContractLegalstate::Disputed(None)),
            "entered-in-error" => Ok(ContractLegalstate::EnteredInError(None)),
            "executable" => Ok(ContractLegalstate::Executable(None)),
            "executed" => Ok(ContractLegalstate::Executed(None)),
            "negotiable" => Ok(ContractLegalstate::Negotiable(None)),
            "offered" => Ok(ContractLegalstate::Offered(None)),
            "policy" => Ok(ContractLegalstate::Policy(None)),
            "rejected" => Ok(ContractLegalstate::Rejected(None)),
            "renewed" => Ok(ContractLegalstate::Renewed(None)),
            "resolved" => Ok(ContractLegalstate::Resolved(None)),
            "revoked" => Ok(ContractLegalstate::Revoked(None)),
            "terminated" => Ok(ContractLegalstate::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractLegalstate {
    fn into(self) -> Option<String> {
        match self {
            ContractLegalstate::Amended(_) => Some("amended".to_string()),
            ContractLegalstate::Appended(_) => Some("appended".to_string()),
            ContractLegalstate::Cancelled(_) => Some("cancelled".to_string()),
            ContractLegalstate::Disputed(_) => Some("disputed".to_string()),
            ContractLegalstate::EnteredInError(_) => Some("entered-in-error".to_string()),
            ContractLegalstate::Executable(_) => Some("executable".to_string()),
            ContractLegalstate::Executed(_) => Some("executed".to_string()),
            ContractLegalstate::Negotiable(_) => Some("negotiable".to_string()),
            ContractLegalstate::Offered(_) => Some("offered".to_string()),
            ContractLegalstate::Policy(_) => Some("policy".to_string()),
            ContractLegalstate::Rejected(_) => Some("rejected".to_string()),
            ContractLegalstate::Renewed(_) => Some("renewed".to_string()),
            ContractLegalstate::Resolved(_) => Some("resolved".to_string()),
            ContractLegalstate::Revoked(_) => Some("revoked".to_string()),
            ContractLegalstate::Terminated(_) => Some("terminated".to_string()),
            ContractLegalstate::Null(_) => None,
        }
    }
}
impl MetaValue for ContractLegalstate {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractLegalstate::Amended(Some(e)) => e.get_field(field),
                ContractLegalstate::Appended(Some(e)) => e.get_field(field),
                ContractLegalstate::Cancelled(Some(e)) => e.get_field(field),
                ContractLegalstate::Disputed(Some(e)) => e.get_field(field),
                ContractLegalstate::EnteredInError(Some(e)) => e.get_field(field),
                ContractLegalstate::Executable(Some(e)) => e.get_field(field),
                ContractLegalstate::Executed(Some(e)) => e.get_field(field),
                ContractLegalstate::Negotiable(Some(e)) => e.get_field(field),
                ContractLegalstate::Offered(Some(e)) => e.get_field(field),
                ContractLegalstate::Policy(Some(e)) => e.get_field(field),
                ContractLegalstate::Rejected(Some(e)) => e.get_field(field),
                ContractLegalstate::Renewed(Some(e)) => e.get_field(field),
                ContractLegalstate::Resolved(Some(e)) => e.get_field(field),
                ContractLegalstate::Revoked(Some(e)) => e.get_field(field),
                ContractLegalstate::Terminated(Some(e)) => e.get_field(field),
                ContractLegalstate::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractLegalstate::Amended(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Appended(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Cancelled(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Disputed(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::EnteredInError(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Executable(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Executed(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Negotiable(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Offered(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Policy(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Rejected(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Renewed(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Resolved(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Revoked(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Terminated(Some(e)) => e.get_field_mut(field),
                ContractLegalstate::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractPartyRole {
    #[doc = "FLunky"]
    #[code = "flunky"]
    Flunky(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractPartyRole {
    fn default() -> Self {
        ContractPartyRole::Null(None)
    }
}
impl TryFrom<String> for ContractPartyRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "flunky" => Ok(ContractPartyRole::Flunky(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractPartyRole {
    fn into(self) -> Option<String> {
        match self {
            ContractPartyRole::Flunky(_) => Some("flunky".to_string()),
            ContractPartyRole::Null(_) => None,
        }
    }
}
impl MetaValue for ContractPartyRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractPartyRole::Flunky(Some(e)) => e.get_field(field),
                ContractPartyRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractPartyRole::Flunky(Some(e)) => e.get_field_mut(field),
                ContractPartyRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractPublicationstatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Appended"]
    #[code = "appended"]
    Appended(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Disputed"]
    #[code = "disputed"]
    Disputed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Executable"]
    #[code = "executable"]
    Executable(Option<Element>),
    #[doc = "Executed"]
    #[code = "executed"]
    Executed(Option<Element>),
    #[doc = "Negotiable"]
    #[code = "negotiable"]
    Negotiable(Option<Element>),
    #[doc = "Offered"]
    #[code = "offered"]
    Offered(Option<Element>),
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "Renewed"]
    #[code = "renewed"]
    Renewed(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "Revoked"]
    #[code = "revoked"]
    Revoked(Option<Element>),
    #[doc = "Terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractPublicationstatus {
    fn default() -> Self {
        ContractPublicationstatus::Null(None)
    }
}
impl TryFrom<String> for ContractPublicationstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(ContractPublicationstatus::Amended(None)),
            "appended" => Ok(ContractPublicationstatus::Appended(None)),
            "cancelled" => Ok(ContractPublicationstatus::Cancelled(None)),
            "disputed" => Ok(ContractPublicationstatus::Disputed(None)),
            "entered-in-error" => Ok(ContractPublicationstatus::EnteredInError(None)),
            "executable" => Ok(ContractPublicationstatus::Executable(None)),
            "executed" => Ok(ContractPublicationstatus::Executed(None)),
            "negotiable" => Ok(ContractPublicationstatus::Negotiable(None)),
            "offered" => Ok(ContractPublicationstatus::Offered(None)),
            "policy" => Ok(ContractPublicationstatus::Policy(None)),
            "rejected" => Ok(ContractPublicationstatus::Rejected(None)),
            "renewed" => Ok(ContractPublicationstatus::Renewed(None)),
            "resolved" => Ok(ContractPublicationstatus::Resolved(None)),
            "revoked" => Ok(ContractPublicationstatus::Revoked(None)),
            "terminated" => Ok(ContractPublicationstatus::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractPublicationstatus {
    fn into(self) -> Option<String> {
        match self {
            ContractPublicationstatus::Amended(_) => Some("amended".to_string()),
            ContractPublicationstatus::Appended(_) => Some("appended".to_string()),
            ContractPublicationstatus::Cancelled(_) => Some("cancelled".to_string()),
            ContractPublicationstatus::Disputed(_) => Some("disputed".to_string()),
            ContractPublicationstatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ContractPublicationstatus::Executable(_) => Some("executable".to_string()),
            ContractPublicationstatus::Executed(_) => Some("executed".to_string()),
            ContractPublicationstatus::Negotiable(_) => Some("negotiable".to_string()),
            ContractPublicationstatus::Offered(_) => Some("offered".to_string()),
            ContractPublicationstatus::Policy(_) => Some("policy".to_string()),
            ContractPublicationstatus::Rejected(_) => Some("rejected".to_string()),
            ContractPublicationstatus::Renewed(_) => Some("renewed".to_string()),
            ContractPublicationstatus::Resolved(_) => Some("resolved".to_string()),
            ContractPublicationstatus::Revoked(_) => Some("revoked".to_string()),
            ContractPublicationstatus::Terminated(_) => Some("terminated".to_string()),
            ContractPublicationstatus::Null(_) => None,
        }
    }
}
impl MetaValue for ContractPublicationstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractPublicationstatus::Amended(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Appended(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Cancelled(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Disputed(Some(e)) => e.get_field(field),
                ContractPublicationstatus::EnteredInError(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Executable(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Executed(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Negotiable(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Offered(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Policy(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Rejected(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Renewed(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Resolved(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Revoked(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Terminated(Some(e)) => e.get_field(field),
                ContractPublicationstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractPublicationstatus::Amended(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Appended(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Cancelled(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Disputed(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Executable(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Executed(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Negotiable(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Offered(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Policy(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Rejected(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Renewed(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Resolved(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Revoked(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Terminated(Some(e)) => e.get_field_mut(field),
                ContractPublicationstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractScope {
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractScope {
    fn default() -> Self {
        ContractScope::Null(None)
    }
}
impl TryFrom<String> for ContractScope {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "policy" => Ok(ContractScope::Policy(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractScope {
    fn into(self) -> Option<String> {
        match self {
            ContractScope::Policy(_) => Some("policy".to_string()),
            ContractScope::Null(_) => None,
        }
    }
}
impl MetaValue for ContractScope {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractScope::Policy(Some(e)) => e.get_field(field),
                ContractScope::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractScope::Policy(Some(e)) => e.get_field_mut(field),
                ContractScope::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractSecurityCategory {
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractSecurityCategory {
    fn default() -> Self {
        ContractSecurityCategory::Null(None)
    }
}
impl TryFrom<String> for ContractSecurityCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "policy" => Ok(ContractSecurityCategory::Policy(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractSecurityCategory {
    fn into(self) -> Option<String> {
        match self {
            ContractSecurityCategory::Policy(_) => Some("policy".to_string()),
            ContractSecurityCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ContractSecurityCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractSecurityCategory::Policy(Some(e)) => e.get_field(field),
                ContractSecurityCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractSecurityCategory::Policy(Some(e)) => e.get_field_mut(field),
                ContractSecurityCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractSecurityClassification {
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractSecurityClassification {
    fn default() -> Self {
        ContractSecurityClassification::Null(None)
    }
}
impl TryFrom<String> for ContractSecurityClassification {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "policy" => Ok(ContractSecurityClassification::Policy(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractSecurityClassification {
    fn into(self) -> Option<String> {
        match self {
            ContractSecurityClassification::Policy(_) => Some("policy".to_string()),
            ContractSecurityClassification::Null(_) => None,
        }
    }
}
impl MetaValue for ContractSecurityClassification {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractSecurityClassification::Policy(Some(e)) => e.get_field(field),
                ContractSecurityClassification::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractSecurityClassification::Policy(Some(e)) => e.get_field_mut(field),
                ContractSecurityClassification::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractSecurityControl {
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractSecurityControl {
    fn default() -> Self {
        ContractSecurityControl::Null(None)
    }
}
impl TryFrom<String> for ContractSecurityControl {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "policy" => Ok(ContractSecurityControl::Policy(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractSecurityControl {
    fn into(self) -> Option<String> {
        match self {
            ContractSecurityControl::Policy(_) => Some("policy".to_string()),
            ContractSecurityControl::Null(_) => None,
        }
    }
}
impl MetaValue for ContractSecurityControl {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractSecurityControl::Policy(Some(e)) => e.get_field(field),
                ContractSecurityControl::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractSecurityControl::Policy(Some(e)) => e.get_field_mut(field),
                ContractSecurityControl::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractSignerType {
    #[doc = "Affiliate"]
    #[code = "AFFL"]
    AFFL(Option<Element>),
    #[doc = "Agent"]
    #[code = "AGNT"]
    AGNT(Option<Element>),
    #[doc = "Amender"]
    #[code = "AMENDER"]
    AMENDER(Option<Element>),
    #[doc = "Assigned Entity"]
    #[code = "ASSIGNED"]
    ASSIGNED(Option<Element>),
    #[doc = "Author"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "Authenticator"]
    #[code = "AUTHN"]
    AUTHN(Option<Element>),
    #[doc = "Citizen"]
    #[code = "CIT"]
    CIT(Option<Element>),
    #[doc = "Claimant"]
    #[code = "CLAIMANT"]
    CLAIMANT(Option<Element>),
    #[doc = "Co-Author"]
    #[code = "COAUTH"]
    COAUTH(Option<Element>),
    #[doc = "Consenter"]
    #[code = "CONSENTER"]
    CONSENTER(Option<Element>),
    #[doc = "Consent Witness"]
    #[code = "CONSWIT"]
    CONSWIT(Option<Element>),
    #[doc = "Contact"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "Co-Participant"]
    #[code = "COPART"]
    COPART(Option<Element>),
    #[doc = "Covered Party"]
    #[code = "COVPTY"]
    COVPTY(Option<Element>),
    #[doc = "Delegatee"]
    #[code = "DELEGATEE"]
    DELEGATEE(Option<Element>),
    #[doc = "Dependent"]
    #[code = "DEPEND"]
    DEPEND(Option<Element>),
    #[doc = "Durable Power of Attorney"]
    #[code = "DPOWATT"]
    DPOWATT(Option<Element>),
    #[doc = "Emergency Contact"]
    #[code = "EMGCON"]
    EMGCON(Option<Element>),
    #[doc = "Event Witness"]
    #[code = "EVTWIT"]
    EVTWIT(Option<Element>),
    #[doc = "Executor of Estate"]
    #[code = "EXCEST"]
    EXCEST(Option<Element>),
    #[doc = "Grantee"]
    #[code = "GRANTEE"]
    GRANTEE(Option<Element>),
    #[doc = "Grantor"]
    #[code = "GRANTOR"]
    GRANTOR(Option<Element>),
    #[doc = "Guardian ad lidem"]
    #[code = "GUADLTM"]
    GUADLTM(Option<Element>),
    #[doc = "Guarantor"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "Guardian"]
    #[code = "GUARD"]
    GUARD(Option<Element>),
    #[doc = "Healthcare Power of Attorney"]
    #[code = "HPOWATT"]
    HPOWATT(Option<Element>),
    #[doc = "Healthcare Provider"]
    #[code = "HPROV"]
    HPROV(Option<Element>),
    #[doc = "Informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "Investigation Subject"]
    #[code = "INSBJ"]
    INSBJ(Option<Element>),
    #[doc = "Interpreter"]
    #[code = "INTPRT"]
    INTPRT(Option<Element>),
    #[doc = "Legal Authenticator"]
    #[code = "LEGAUTHN"]
    LEGAUTHN(Option<Element>),
    #[doc = "Named Insured"]
    #[code = "NMDINS"]
    NMDINS(Option<Element>),
    #[doc = "Next of Kin"]
    #[code = "NOK"]
    NOK(Option<Element>),
    #[doc = "Notary"]
    #[code = "NOTARY"]
    NOTARY(Option<Element>),
    #[doc = "Patient"]
    #[code = "PAT"]
    PAT(Option<Element>),
    #[doc = "Power of Attorney"]
    #[code = "POWATT"]
    POWATT(Option<Element>),
    #[doc = "Primary Author"]
    #[code = "PRIMAUTH"]
    PRIMAUTH(Option<Element>),
    #[doc = "Primary Responsible Party "]
    #[code = "PRIRECIP"]
    PRIRECIP(Option<Element>),
    #[doc = "Recipient"]
    #[code = "RECIP"]
    RECIP(Option<Element>),
    #[doc = "Responsible Party"]
    #[code = "RESPRSN"]
    RESPRSN(Option<Element>),
    #[doc = "Reviewer"]
    #[code = "REVIEWER"]
    REVIEWER(Option<Element>),
    #[doc = "Source"]
    #[code = "SOURCE"]
    SOURCE(Option<Element>),
    #[doc = "Special Power of Attorney"]
    #[code = "SPOWATT"]
    SPOWATT(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "Validator"]
    #[code = "VALID"]
    VALID(Option<Element>),
    #[doc = "Verifier"]
    #[code = "VERF"]
    VERF(Option<Element>),
    #[doc = "Witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "Delegator"]
    #[code = "delegator"]
    Delegator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractSignerType {
    fn default() -> Self {
        ContractSignerType::Null(None)
    }
}
impl TryFrom<String> for ContractSignerType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AFFL" => Ok(ContractSignerType::AFFL(None)),
            "AGNT" => Ok(ContractSignerType::AGNT(None)),
            "AMENDER" => Ok(ContractSignerType::AMENDER(None)),
            "ASSIGNED" => Ok(ContractSignerType::ASSIGNED(None)),
            "AUT" => Ok(ContractSignerType::AUT(None)),
            "AUTHN" => Ok(ContractSignerType::AUTHN(None)),
            "CIT" => Ok(ContractSignerType::CIT(None)),
            "CLAIMANT" => Ok(ContractSignerType::CLAIMANT(None)),
            "COAUTH" => Ok(ContractSignerType::COAUTH(None)),
            "CONSENTER" => Ok(ContractSignerType::CONSENTER(None)),
            "CONSWIT" => Ok(ContractSignerType::CONSWIT(None)),
            "CONT" => Ok(ContractSignerType::CONT(None)),
            "COPART" => Ok(ContractSignerType::COPART(None)),
            "COVPTY" => Ok(ContractSignerType::COVPTY(None)),
            "DELEGATEE" => Ok(ContractSignerType::DELEGATEE(None)),
            "DEPEND" => Ok(ContractSignerType::DEPEND(None)),
            "DPOWATT" => Ok(ContractSignerType::DPOWATT(None)),
            "EMGCON" => Ok(ContractSignerType::EMGCON(None)),
            "EVTWIT" => Ok(ContractSignerType::EVTWIT(None)),
            "EXCEST" => Ok(ContractSignerType::EXCEST(None)),
            "GRANTEE" => Ok(ContractSignerType::GRANTEE(None)),
            "GRANTOR" => Ok(ContractSignerType::GRANTOR(None)),
            "GUADLTM" => Ok(ContractSignerType::GUADLTM(None)),
            "GUAR" => Ok(ContractSignerType::GUAR(None)),
            "GUARD" => Ok(ContractSignerType::GUARD(None)),
            "HPOWATT" => Ok(ContractSignerType::HPOWATT(None)),
            "HPROV" => Ok(ContractSignerType::HPROV(None)),
            "INF" => Ok(ContractSignerType::INF(None)),
            "INSBJ" => Ok(ContractSignerType::INSBJ(None)),
            "INTPRT" => Ok(ContractSignerType::INTPRT(None)),
            "LEGAUTHN" => Ok(ContractSignerType::LEGAUTHN(None)),
            "NMDINS" => Ok(ContractSignerType::NMDINS(None)),
            "NOK" => Ok(ContractSignerType::NOK(None)),
            "NOTARY" => Ok(ContractSignerType::NOTARY(None)),
            "PAT" => Ok(ContractSignerType::PAT(None)),
            "POWATT" => Ok(ContractSignerType::POWATT(None)),
            "PRIMAUTH" => Ok(ContractSignerType::PRIMAUTH(None)),
            "PRIRECIP" => Ok(ContractSignerType::PRIRECIP(None)),
            "RECIP" => Ok(ContractSignerType::RECIP(None)),
            "RESPRSN" => Ok(ContractSignerType::RESPRSN(None)),
            "REVIEWER" => Ok(ContractSignerType::REVIEWER(None)),
            "SOURCE" => Ok(ContractSignerType::SOURCE(None)),
            "SPOWATT" => Ok(ContractSignerType::SPOWATT(None)),
            "TRANS" => Ok(ContractSignerType::TRANS(None)),
            "VALID" => Ok(ContractSignerType::VALID(None)),
            "VERF" => Ok(ContractSignerType::VERF(None)),
            "WIT" => Ok(ContractSignerType::WIT(None)),
            "delegator" => Ok(ContractSignerType::Delegator(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractSignerType {
    fn into(self) -> Option<String> {
        match self {
            ContractSignerType::AFFL(_) => Some("AFFL".to_string()),
            ContractSignerType::AGNT(_) => Some("AGNT".to_string()),
            ContractSignerType::AMENDER(_) => Some("AMENDER".to_string()),
            ContractSignerType::ASSIGNED(_) => Some("ASSIGNED".to_string()),
            ContractSignerType::AUT(_) => Some("AUT".to_string()),
            ContractSignerType::AUTHN(_) => Some("AUTHN".to_string()),
            ContractSignerType::CIT(_) => Some("CIT".to_string()),
            ContractSignerType::CLAIMANT(_) => Some("CLAIMANT".to_string()),
            ContractSignerType::COAUTH(_) => Some("COAUTH".to_string()),
            ContractSignerType::CONSENTER(_) => Some("CONSENTER".to_string()),
            ContractSignerType::CONSWIT(_) => Some("CONSWIT".to_string()),
            ContractSignerType::CONT(_) => Some("CONT".to_string()),
            ContractSignerType::COPART(_) => Some("COPART".to_string()),
            ContractSignerType::COVPTY(_) => Some("COVPTY".to_string()),
            ContractSignerType::DELEGATEE(_) => Some("DELEGATEE".to_string()),
            ContractSignerType::DEPEND(_) => Some("DEPEND".to_string()),
            ContractSignerType::DPOWATT(_) => Some("DPOWATT".to_string()),
            ContractSignerType::EMGCON(_) => Some("EMGCON".to_string()),
            ContractSignerType::EVTWIT(_) => Some("EVTWIT".to_string()),
            ContractSignerType::EXCEST(_) => Some("EXCEST".to_string()),
            ContractSignerType::GRANTEE(_) => Some("GRANTEE".to_string()),
            ContractSignerType::GRANTOR(_) => Some("GRANTOR".to_string()),
            ContractSignerType::GUADLTM(_) => Some("GUADLTM".to_string()),
            ContractSignerType::GUAR(_) => Some("GUAR".to_string()),
            ContractSignerType::GUARD(_) => Some("GUARD".to_string()),
            ContractSignerType::HPOWATT(_) => Some("HPOWATT".to_string()),
            ContractSignerType::HPROV(_) => Some("HPROV".to_string()),
            ContractSignerType::INF(_) => Some("INF".to_string()),
            ContractSignerType::INSBJ(_) => Some("INSBJ".to_string()),
            ContractSignerType::INTPRT(_) => Some("INTPRT".to_string()),
            ContractSignerType::LEGAUTHN(_) => Some("LEGAUTHN".to_string()),
            ContractSignerType::NMDINS(_) => Some("NMDINS".to_string()),
            ContractSignerType::NOK(_) => Some("NOK".to_string()),
            ContractSignerType::NOTARY(_) => Some("NOTARY".to_string()),
            ContractSignerType::PAT(_) => Some("PAT".to_string()),
            ContractSignerType::POWATT(_) => Some("POWATT".to_string()),
            ContractSignerType::PRIMAUTH(_) => Some("PRIMAUTH".to_string()),
            ContractSignerType::PRIRECIP(_) => Some("PRIRECIP".to_string()),
            ContractSignerType::RECIP(_) => Some("RECIP".to_string()),
            ContractSignerType::RESPRSN(_) => Some("RESPRSN".to_string()),
            ContractSignerType::REVIEWER(_) => Some("REVIEWER".to_string()),
            ContractSignerType::SOURCE(_) => Some("SOURCE".to_string()),
            ContractSignerType::SPOWATT(_) => Some("SPOWATT".to_string()),
            ContractSignerType::TRANS(_) => Some("TRANS".to_string()),
            ContractSignerType::VALID(_) => Some("VALID".to_string()),
            ContractSignerType::VERF(_) => Some("VERF".to_string()),
            ContractSignerType::WIT(_) => Some("WIT".to_string()),
            ContractSignerType::Delegator(_) => Some("delegator".to_string()),
            ContractSignerType::Null(_) => None,
        }
    }
}
impl MetaValue for ContractSignerType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractSignerType::AFFL(Some(e)) => e.get_field(field),
                ContractSignerType::AGNT(Some(e)) => e.get_field(field),
                ContractSignerType::AMENDER(Some(e)) => e.get_field(field),
                ContractSignerType::ASSIGNED(Some(e)) => e.get_field(field),
                ContractSignerType::AUT(Some(e)) => e.get_field(field),
                ContractSignerType::AUTHN(Some(e)) => e.get_field(field),
                ContractSignerType::CIT(Some(e)) => e.get_field(field),
                ContractSignerType::CLAIMANT(Some(e)) => e.get_field(field),
                ContractSignerType::COAUTH(Some(e)) => e.get_field(field),
                ContractSignerType::CONSENTER(Some(e)) => e.get_field(field),
                ContractSignerType::CONSWIT(Some(e)) => e.get_field(field),
                ContractSignerType::CONT(Some(e)) => e.get_field(field),
                ContractSignerType::COPART(Some(e)) => e.get_field(field),
                ContractSignerType::COVPTY(Some(e)) => e.get_field(field),
                ContractSignerType::DELEGATEE(Some(e)) => e.get_field(field),
                ContractSignerType::DEPEND(Some(e)) => e.get_field(field),
                ContractSignerType::DPOWATT(Some(e)) => e.get_field(field),
                ContractSignerType::EMGCON(Some(e)) => e.get_field(field),
                ContractSignerType::EVTWIT(Some(e)) => e.get_field(field),
                ContractSignerType::EXCEST(Some(e)) => e.get_field(field),
                ContractSignerType::GRANTEE(Some(e)) => e.get_field(field),
                ContractSignerType::GRANTOR(Some(e)) => e.get_field(field),
                ContractSignerType::GUADLTM(Some(e)) => e.get_field(field),
                ContractSignerType::GUAR(Some(e)) => e.get_field(field),
                ContractSignerType::GUARD(Some(e)) => e.get_field(field),
                ContractSignerType::HPOWATT(Some(e)) => e.get_field(field),
                ContractSignerType::HPROV(Some(e)) => e.get_field(field),
                ContractSignerType::INF(Some(e)) => e.get_field(field),
                ContractSignerType::INSBJ(Some(e)) => e.get_field(field),
                ContractSignerType::INTPRT(Some(e)) => e.get_field(field),
                ContractSignerType::LEGAUTHN(Some(e)) => e.get_field(field),
                ContractSignerType::NMDINS(Some(e)) => e.get_field(field),
                ContractSignerType::NOK(Some(e)) => e.get_field(field),
                ContractSignerType::NOTARY(Some(e)) => e.get_field(field),
                ContractSignerType::PAT(Some(e)) => e.get_field(field),
                ContractSignerType::POWATT(Some(e)) => e.get_field(field),
                ContractSignerType::PRIMAUTH(Some(e)) => e.get_field(field),
                ContractSignerType::PRIRECIP(Some(e)) => e.get_field(field),
                ContractSignerType::RECIP(Some(e)) => e.get_field(field),
                ContractSignerType::RESPRSN(Some(e)) => e.get_field(field),
                ContractSignerType::REVIEWER(Some(e)) => e.get_field(field),
                ContractSignerType::SOURCE(Some(e)) => e.get_field(field),
                ContractSignerType::SPOWATT(Some(e)) => e.get_field(field),
                ContractSignerType::TRANS(Some(e)) => e.get_field(field),
                ContractSignerType::VALID(Some(e)) => e.get_field(field),
                ContractSignerType::VERF(Some(e)) => e.get_field(field),
                ContractSignerType::WIT(Some(e)) => e.get_field(field),
                ContractSignerType::Delegator(Some(e)) => e.get_field(field),
                ContractSignerType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractSignerType::AFFL(Some(e)) => e.get_field_mut(field),
                ContractSignerType::AGNT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::AMENDER(Some(e)) => e.get_field_mut(field),
                ContractSignerType::ASSIGNED(Some(e)) => e.get_field_mut(field),
                ContractSignerType::AUT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::AUTHN(Some(e)) => e.get_field_mut(field),
                ContractSignerType::CIT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::CLAIMANT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::COAUTH(Some(e)) => e.get_field_mut(field),
                ContractSignerType::CONSENTER(Some(e)) => e.get_field_mut(field),
                ContractSignerType::CONSWIT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::CONT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::COPART(Some(e)) => e.get_field_mut(field),
                ContractSignerType::COVPTY(Some(e)) => e.get_field_mut(field),
                ContractSignerType::DELEGATEE(Some(e)) => e.get_field_mut(field),
                ContractSignerType::DEPEND(Some(e)) => e.get_field_mut(field),
                ContractSignerType::DPOWATT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::EMGCON(Some(e)) => e.get_field_mut(field),
                ContractSignerType::EVTWIT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::EXCEST(Some(e)) => e.get_field_mut(field),
                ContractSignerType::GRANTEE(Some(e)) => e.get_field_mut(field),
                ContractSignerType::GRANTOR(Some(e)) => e.get_field_mut(field),
                ContractSignerType::GUADLTM(Some(e)) => e.get_field_mut(field),
                ContractSignerType::GUAR(Some(e)) => e.get_field_mut(field),
                ContractSignerType::GUARD(Some(e)) => e.get_field_mut(field),
                ContractSignerType::HPOWATT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::HPROV(Some(e)) => e.get_field_mut(field),
                ContractSignerType::INF(Some(e)) => e.get_field_mut(field),
                ContractSignerType::INSBJ(Some(e)) => e.get_field_mut(field),
                ContractSignerType::INTPRT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::LEGAUTHN(Some(e)) => e.get_field_mut(field),
                ContractSignerType::NMDINS(Some(e)) => e.get_field_mut(field),
                ContractSignerType::NOK(Some(e)) => e.get_field_mut(field),
                ContractSignerType::NOTARY(Some(e)) => e.get_field_mut(field),
                ContractSignerType::PAT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::POWATT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::PRIMAUTH(Some(e)) => e.get_field_mut(field),
                ContractSignerType::PRIRECIP(Some(e)) => e.get_field_mut(field),
                ContractSignerType::RECIP(Some(e)) => e.get_field_mut(field),
                ContractSignerType::RESPRSN(Some(e)) => e.get_field_mut(field),
                ContractSignerType::REVIEWER(Some(e)) => e.get_field_mut(field),
                ContractSignerType::SOURCE(Some(e)) => e.get_field_mut(field),
                ContractSignerType::SPOWATT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::TRANS(Some(e)) => e.get_field_mut(field),
                ContractSignerType::VALID(Some(e)) => e.get_field_mut(field),
                ContractSignerType::VERF(Some(e)) => e.get_field_mut(field),
                ContractSignerType::WIT(Some(e)) => e.get_field_mut(field),
                ContractSignerType::Delegator(Some(e)) => e.get_field_mut(field),
                ContractSignerType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractStatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Appended"]
    #[code = "appended"]
    Appended(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Disputed"]
    #[code = "disputed"]
    Disputed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Executable"]
    #[code = "executable"]
    Executable(Option<Element>),
    #[doc = "Executed"]
    #[code = "executed"]
    Executed(Option<Element>),
    #[doc = "Negotiable"]
    #[code = "negotiable"]
    Negotiable(Option<Element>),
    #[doc = "Offered"]
    #[code = "offered"]
    Offered(Option<Element>),
    #[doc = "Policy"]
    #[code = "policy"]
    Policy(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "Renewed"]
    #[code = "renewed"]
    Renewed(Option<Element>),
    #[doc = "Resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "Revoked"]
    #[code = "revoked"]
    Revoked(Option<Element>),
    #[doc = "Terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractStatus {
    fn default() -> Self {
        ContractStatus::Null(None)
    }
}
impl TryFrom<String> for ContractStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(ContractStatus::Amended(None)),
            "appended" => Ok(ContractStatus::Appended(None)),
            "cancelled" => Ok(ContractStatus::Cancelled(None)),
            "disputed" => Ok(ContractStatus::Disputed(None)),
            "entered-in-error" => Ok(ContractStatus::EnteredInError(None)),
            "executable" => Ok(ContractStatus::Executable(None)),
            "executed" => Ok(ContractStatus::Executed(None)),
            "negotiable" => Ok(ContractStatus::Negotiable(None)),
            "offered" => Ok(ContractStatus::Offered(None)),
            "policy" => Ok(ContractStatus::Policy(None)),
            "rejected" => Ok(ContractStatus::Rejected(None)),
            "renewed" => Ok(ContractStatus::Renewed(None)),
            "resolved" => Ok(ContractStatus::Resolved(None)),
            "revoked" => Ok(ContractStatus::Revoked(None)),
            "terminated" => Ok(ContractStatus::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractStatus {
    fn into(self) -> Option<String> {
        match self {
            ContractStatus::Amended(_) => Some("amended".to_string()),
            ContractStatus::Appended(_) => Some("appended".to_string()),
            ContractStatus::Cancelled(_) => Some("cancelled".to_string()),
            ContractStatus::Disputed(_) => Some("disputed".to_string()),
            ContractStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ContractStatus::Executable(_) => Some("executable".to_string()),
            ContractStatus::Executed(_) => Some("executed".to_string()),
            ContractStatus::Negotiable(_) => Some("negotiable".to_string()),
            ContractStatus::Offered(_) => Some("offered".to_string()),
            ContractStatus::Policy(_) => Some("policy".to_string()),
            ContractStatus::Rejected(_) => Some("rejected".to_string()),
            ContractStatus::Renewed(_) => Some("renewed".to_string()),
            ContractStatus::Resolved(_) => Some("resolved".to_string()),
            ContractStatus::Revoked(_) => Some("revoked".to_string()),
            ContractStatus::Terminated(_) => Some("terminated".to_string()),
            ContractStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ContractStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractStatus::Amended(Some(e)) => e.get_field(field),
                ContractStatus::Appended(Some(e)) => e.get_field(field),
                ContractStatus::Cancelled(Some(e)) => e.get_field(field),
                ContractStatus::Disputed(Some(e)) => e.get_field(field),
                ContractStatus::EnteredInError(Some(e)) => e.get_field(field),
                ContractStatus::Executable(Some(e)) => e.get_field(field),
                ContractStatus::Executed(Some(e)) => e.get_field(field),
                ContractStatus::Negotiable(Some(e)) => e.get_field(field),
                ContractStatus::Offered(Some(e)) => e.get_field(field),
                ContractStatus::Policy(Some(e)) => e.get_field(field),
                ContractStatus::Rejected(Some(e)) => e.get_field(field),
                ContractStatus::Renewed(Some(e)) => e.get_field(field),
                ContractStatus::Resolved(Some(e)) => e.get_field(field),
                ContractStatus::Revoked(Some(e)) => e.get_field(field),
                ContractStatus::Terminated(Some(e)) => e.get_field(field),
                ContractStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractStatus::Amended(Some(e)) => e.get_field_mut(field),
                ContractStatus::Appended(Some(e)) => e.get_field_mut(field),
                ContractStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                ContractStatus::Disputed(Some(e)) => e.get_field_mut(field),
                ContractStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ContractStatus::Executable(Some(e)) => e.get_field_mut(field),
                ContractStatus::Executed(Some(e)) => e.get_field_mut(field),
                ContractStatus::Negotiable(Some(e)) => e.get_field_mut(field),
                ContractStatus::Offered(Some(e)) => e.get_field_mut(field),
                ContractStatus::Policy(Some(e)) => e.get_field_mut(field),
                ContractStatus::Rejected(Some(e)) => e.get_field_mut(field),
                ContractStatus::Renewed(Some(e)) => e.get_field_mut(field),
                ContractStatus::Resolved(Some(e)) => e.get_field_mut(field),
                ContractStatus::Revoked(Some(e)) => e.get_field_mut(field),
                ContractStatus::Terminated(Some(e)) => e.get_field_mut(field),
                ContractStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractSubtype {
    #[doc = "Disclosure-CA"]
    #[code = "disclosure-ca"]
    DisclosureCa(Option<Element>),
    #[doc = "Disclosure-US"]
    #[code = "disclosure-us"]
    DisclosureUs(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractSubtype {
    fn default() -> Self {
        ContractSubtype::Null(None)
    }
}
impl TryFrom<String> for ContractSubtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "disclosure-ca" => Ok(ContractSubtype::DisclosureCa(None)),
            "disclosure-us" => Ok(ContractSubtype::DisclosureUs(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractSubtype {
    fn into(self) -> Option<String> {
        match self {
            ContractSubtype::DisclosureCa(_) => Some("disclosure-ca".to_string()),
            ContractSubtype::DisclosureUs(_) => Some("disclosure-us".to_string()),
            ContractSubtype::Null(_) => None,
        }
    }
}
impl MetaValue for ContractSubtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractSubtype::DisclosureCa(Some(e)) => e.get_field(field),
                ContractSubtype::DisclosureUs(Some(e)) => e.get_field(field),
                ContractSubtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractSubtype::DisclosureCa(Some(e)) => e.get_field_mut(field),
                ContractSubtype::DisclosureUs(Some(e)) => e.get_field_mut(field),
                ContractSubtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractTermSubtype {
    #[doc = "Condition"]
    #[code = "condition"]
    Condition(Option<Element>),
    #[doc = "Innominate"]
    #[code = "innominate"]
    Innominate(Option<Element>),
    #[doc = "Warranty"]
    #[code = "warranty"]
    Warranty(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractTermSubtype {
    fn default() -> Self {
        ContractTermSubtype::Null(None)
    }
}
impl TryFrom<String> for ContractTermSubtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "condition" => Ok(ContractTermSubtype::Condition(None)),
            "innominate" => Ok(ContractTermSubtype::Innominate(None)),
            "warranty" => Ok(ContractTermSubtype::Warranty(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractTermSubtype {
    fn into(self) -> Option<String> {
        match self {
            ContractTermSubtype::Condition(_) => Some("condition".to_string()),
            ContractTermSubtype::Innominate(_) => Some("innominate".to_string()),
            ContractTermSubtype::Warranty(_) => Some("warranty".to_string()),
            ContractTermSubtype::Null(_) => None,
        }
    }
}
impl MetaValue for ContractTermSubtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractTermSubtype::Condition(Some(e)) => e.get_field(field),
                ContractTermSubtype::Innominate(Some(e)) => e.get_field(field),
                ContractTermSubtype::Warranty(Some(e)) => e.get_field(field),
                ContractTermSubtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractTermSubtype::Condition(Some(e)) => e.get_field_mut(field),
                ContractTermSubtype::Innominate(Some(e)) => e.get_field_mut(field),
                ContractTermSubtype::Warranty(Some(e)) => e.get_field_mut(field),
                ContractTermSubtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractTermType {
    #[doc = "Statutory"]
    #[code = "statutory"]
    Statutory(Option<Element>),
    #[doc = "Subject To"]
    #[code = "subject-to"]
    SubjectTo(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractTermType {
    fn default() -> Self {
        ContractTermType::Null(None)
    }
}
impl TryFrom<String> for ContractTermType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "statutory" => Ok(ContractTermType::Statutory(None)),
            "subject-to" => Ok(ContractTermType::SubjectTo(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractTermType {
    fn into(self) -> Option<String> {
        match self {
            ContractTermType::Statutory(_) => Some("statutory".to_string()),
            ContractTermType::SubjectTo(_) => Some("subject-to".to_string()),
            ContractTermType::Null(_) => None,
        }
    }
}
impl MetaValue for ContractTermType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractTermType::Statutory(Some(e)) => e.get_field(field),
                ContractTermType::SubjectTo(Some(e)) => e.get_field(field),
                ContractTermType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractTermType::Statutory(Some(e)) => e.get_field_mut(field),
                ContractTermType::SubjectTo(Some(e)) => e.get_field_mut(field),
                ContractTermType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContractType {
    #[doc = "Consent"]
    #[code = "consent"]
    Consent(Option<Element>),
    #[doc = "Disclosure"]
    #[code = "disclosure"]
    Disclosure(Option<Element>),
    #[doc = "Health Insurance"]
    #[code = "healthinsurance"]
    Healthinsurance(Option<Element>),
    #[doc = "Privacy"]
    #[code = "privacy"]
    Privacy(Option<Element>),
    #[doc = "Supply Contract"]
    #[code = "supply"]
    Supply(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContractType {
    fn default() -> Self {
        ContractType::Null(None)
    }
}
impl TryFrom<String> for ContractType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "consent" => Ok(ContractType::Consent(None)),
            "disclosure" => Ok(ContractType::Disclosure(None)),
            "healthinsurance" => Ok(ContractType::Healthinsurance(None)),
            "privacy" => Ok(ContractType::Privacy(None)),
            "supply" => Ok(ContractType::Supply(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContractType {
    fn into(self) -> Option<String> {
        match self {
            ContractType::Consent(_) => Some("consent".to_string()),
            ContractType::Disclosure(_) => Some("disclosure".to_string()),
            ContractType::Healthinsurance(_) => Some("healthinsurance".to_string()),
            ContractType::Privacy(_) => Some("privacy".to_string()),
            ContractType::Supply(_) => Some("supply".to_string()),
            ContractType::Null(_) => None,
        }
    }
}
impl MetaValue for ContractType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContractType::Consent(Some(e)) => e.get_field(field),
                ContractType::Disclosure(Some(e)) => e.get_field(field),
                ContractType::Healthinsurance(Some(e)) => e.get_field(field),
                ContractType::Privacy(Some(e)) => e.get_field(field),
                ContractType::Supply(Some(e)) => e.get_field(field),
                ContractType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContractType::Consent(Some(e)) => e.get_field_mut(field),
                ContractType::Disclosure(Some(e)) => e.get_field_mut(field),
                ContractType::Healthinsurance(Some(e)) => e.get_field_mut(field),
                ContractType::Privacy(Some(e)) => e.get_field_mut(field),
                ContractType::Supply(Some(e)) => e.get_field_mut(field),
                ContractType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ContributorType {
    #[doc = "Author"]
    #[code = "author"]
    Author(Option<Element>),
    #[doc = "Editor"]
    #[code = "editor"]
    Editor(Option<Element>),
    #[doc = "Endorser"]
    #[code = "endorser"]
    Endorser(Option<Element>),
    #[doc = "Reviewer"]
    #[code = "reviewer"]
    Reviewer(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ContributorType {
    fn default() -> Self {
        ContributorType::Null(None)
    }
}
impl TryFrom<String> for ContributorType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "author" => Ok(ContributorType::Author(None)),
            "editor" => Ok(ContributorType::Editor(None)),
            "endorser" => Ok(ContributorType::Endorser(None)),
            "reviewer" => Ok(ContributorType::Reviewer(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ContributorType {
    fn into(self) -> Option<String> {
        match self {
            ContributorType::Author(_) => Some("author".to_string()),
            ContributorType::Editor(_) => Some("editor".to_string()),
            ContributorType::Endorser(_) => Some("endorser".to_string()),
            ContributorType::Reviewer(_) => Some("reviewer".to_string()),
            ContributorType::Null(_) => None,
        }
    }
}
impl MetaValue for ContributorType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ContributorType::Author(Some(e)) => e.get_field(field),
                ContributorType::Editor(Some(e)) => e.get_field(field),
                ContributorType::Endorser(Some(e)) => e.get_field(field),
                ContributorType::Reviewer(Some(e)) => e.get_field(field),
                ContributorType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ContributorType::Author(Some(e)) => e.get_field_mut(field),
                ContributorType::Editor(Some(e)) => e.get_field_mut(field),
                ContributorType::Endorser(Some(e)) => e.get_field_mut(field),
                ContributorType::Reviewer(Some(e)) => e.get_field_mut(field),
                ContributorType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CopyNumberEvent {
    #[doc = "amplification"]
    #[code = "amp"]
    Amp(Option<Element>),
    #[doc = "deletion"]
    #[code = "del"]
    Del(Option<Element>),
    #[doc = "loss of function"]
    #[code = "lof"]
    Lof(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CopyNumberEvent {
    fn default() -> Self {
        CopyNumberEvent::Null(None)
    }
}
impl TryFrom<String> for CopyNumberEvent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amp" => Ok(CopyNumberEvent::Amp(None)),
            "del" => Ok(CopyNumberEvent::Del(None)),
            "lof" => Ok(CopyNumberEvent::Lof(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CopyNumberEvent {
    fn into(self) -> Option<String> {
        match self {
            CopyNumberEvent::Amp(_) => Some("amp".to_string()),
            CopyNumberEvent::Del(_) => Some("del".to_string()),
            CopyNumberEvent::Lof(_) => Some("lof".to_string()),
            CopyNumberEvent::Null(_) => None,
        }
    }
}
impl MetaValue for CopyNumberEvent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CopyNumberEvent::Amp(Some(e)) => e.get_field(field),
                CopyNumberEvent::Del(Some(e)) => e.get_field(field),
                CopyNumberEvent::Lof(Some(e)) => e.get_field(field),
                CopyNumberEvent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CopyNumberEvent::Amp(Some(e)) => e.get_field_mut(field),
                CopyNumberEvent::Del(Some(e)) => e.get_field_mut(field),
                CopyNumberEvent::Lof(Some(e)) => e.get_field_mut(field),
                CopyNumberEvent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CoverageClass {
    #[doc = "Class"]
    #[code = "class"]
    Class(Option<Element>),
    #[doc = "Group"]
    #[code = "group"]
    Group(Option<Element>),
    #[doc = "Plan"]
    #[code = "plan"]
    Plan(Option<Element>),
    #[doc = "RX BIN"]
    #[code = "rxbin"]
    Rxbin(Option<Element>),
    #[doc = "RX Group"]
    #[code = "rxgroup"]
    Rxgroup(Option<Element>),
    #[doc = "RX Id"]
    #[code = "rxid"]
    Rxid(Option<Element>),
    #[doc = "RX PCN"]
    #[code = "rxpcn"]
    Rxpcn(Option<Element>),
    #[doc = "Sequence"]
    #[code = "sequence"]
    Sequence(Option<Element>),
    #[doc = "SubClass"]
    #[code = "subclass"]
    Subclass(Option<Element>),
    #[doc = "SubGroup"]
    #[code = "subgroup"]
    Subgroup(Option<Element>),
    #[doc = "SubPlan"]
    #[code = "subplan"]
    Subplan(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CoverageClass {
    fn default() -> Self {
        CoverageClass::Null(None)
    }
}
impl TryFrom<String> for CoverageClass {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "class" => Ok(CoverageClass::Class(None)),
            "group" => Ok(CoverageClass::Group(None)),
            "plan" => Ok(CoverageClass::Plan(None)),
            "rxbin" => Ok(CoverageClass::Rxbin(None)),
            "rxgroup" => Ok(CoverageClass::Rxgroup(None)),
            "rxid" => Ok(CoverageClass::Rxid(None)),
            "rxpcn" => Ok(CoverageClass::Rxpcn(None)),
            "sequence" => Ok(CoverageClass::Sequence(None)),
            "subclass" => Ok(CoverageClass::Subclass(None)),
            "subgroup" => Ok(CoverageClass::Subgroup(None)),
            "subplan" => Ok(CoverageClass::Subplan(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CoverageClass {
    fn into(self) -> Option<String> {
        match self {
            CoverageClass::Class(_) => Some("class".to_string()),
            CoverageClass::Group(_) => Some("group".to_string()),
            CoverageClass::Plan(_) => Some("plan".to_string()),
            CoverageClass::Rxbin(_) => Some("rxbin".to_string()),
            CoverageClass::Rxgroup(_) => Some("rxgroup".to_string()),
            CoverageClass::Rxid(_) => Some("rxid".to_string()),
            CoverageClass::Rxpcn(_) => Some("rxpcn".to_string()),
            CoverageClass::Sequence(_) => Some("sequence".to_string()),
            CoverageClass::Subclass(_) => Some("subclass".to_string()),
            CoverageClass::Subgroup(_) => Some("subgroup".to_string()),
            CoverageClass::Subplan(_) => Some("subplan".to_string()),
            CoverageClass::Null(_) => None,
        }
    }
}
impl MetaValue for CoverageClass {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CoverageClass::Class(Some(e)) => e.get_field(field),
                CoverageClass::Group(Some(e)) => e.get_field(field),
                CoverageClass::Plan(Some(e)) => e.get_field(field),
                CoverageClass::Rxbin(Some(e)) => e.get_field(field),
                CoverageClass::Rxgroup(Some(e)) => e.get_field(field),
                CoverageClass::Rxid(Some(e)) => e.get_field(field),
                CoverageClass::Rxpcn(Some(e)) => e.get_field(field),
                CoverageClass::Sequence(Some(e)) => e.get_field(field),
                CoverageClass::Subclass(Some(e)) => e.get_field(field),
                CoverageClass::Subgroup(Some(e)) => e.get_field(field),
                CoverageClass::Subplan(Some(e)) => e.get_field(field),
                CoverageClass::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CoverageClass::Class(Some(e)) => e.get_field_mut(field),
                CoverageClass::Group(Some(e)) => e.get_field_mut(field),
                CoverageClass::Plan(Some(e)) => e.get_field_mut(field),
                CoverageClass::Rxbin(Some(e)) => e.get_field_mut(field),
                CoverageClass::Rxgroup(Some(e)) => e.get_field_mut(field),
                CoverageClass::Rxid(Some(e)) => e.get_field_mut(field),
                CoverageClass::Rxpcn(Some(e)) => e.get_field_mut(field),
                CoverageClass::Sequence(Some(e)) => e.get_field_mut(field),
                CoverageClass::Subclass(Some(e)) => e.get_field_mut(field),
                CoverageClass::Subgroup(Some(e)) => e.get_field_mut(field),
                CoverageClass::Subplan(Some(e)) => e.get_field_mut(field),
                CoverageClass::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CoverageCopayType {
    #[doc = "Copay Amount"]
    #[code = "copay"]
    Copay(Option<Element>),
    #[doc = "Copay Percentage"]
    #[code = "copaypct"]
    Copaypct(Option<Element>),
    #[doc = "Deductible"]
    #[code = "deductible"]
    Deductible(Option<Element>),
    #[doc = "Emergency"]
    #[code = "emergency"]
    Emergency(Option<Element>),
    #[doc = "GP Office Visit"]
    #[code = "gpvisit"]
    Gpvisit(Option<Element>),
    #[doc = "Inpatient Hospital"]
    #[code = "inpthosp"]
    Inpthosp(Option<Element>),
    #[doc = "Maximum out of pocket"]
    #[code = "maxoutofpocket"]
    Maxoutofpocket(Option<Element>),
    #[doc = "Specialist Office Visit"]
    #[code = "spvisit"]
    Spvisit(Option<Element>),
    #[doc = "Tele-visit"]
    #[code = "televisit"]
    Televisit(Option<Element>),
    #[doc = "Urgent Care"]
    #[code = "urgentcare"]
    Urgentcare(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CoverageCopayType {
    fn default() -> Self {
        CoverageCopayType::Null(None)
    }
}
impl TryFrom<String> for CoverageCopayType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "copay" => Ok(CoverageCopayType::Copay(None)),
            "copaypct" => Ok(CoverageCopayType::Copaypct(None)),
            "deductible" => Ok(CoverageCopayType::Deductible(None)),
            "emergency" => Ok(CoverageCopayType::Emergency(None)),
            "gpvisit" => Ok(CoverageCopayType::Gpvisit(None)),
            "inpthosp" => Ok(CoverageCopayType::Inpthosp(None)),
            "maxoutofpocket" => Ok(CoverageCopayType::Maxoutofpocket(None)),
            "spvisit" => Ok(CoverageCopayType::Spvisit(None)),
            "televisit" => Ok(CoverageCopayType::Televisit(None)),
            "urgentcare" => Ok(CoverageCopayType::Urgentcare(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CoverageCopayType {
    fn into(self) -> Option<String> {
        match self {
            CoverageCopayType::Copay(_) => Some("copay".to_string()),
            CoverageCopayType::Copaypct(_) => Some("copaypct".to_string()),
            CoverageCopayType::Deductible(_) => Some("deductible".to_string()),
            CoverageCopayType::Emergency(_) => Some("emergency".to_string()),
            CoverageCopayType::Gpvisit(_) => Some("gpvisit".to_string()),
            CoverageCopayType::Inpthosp(_) => Some("inpthosp".to_string()),
            CoverageCopayType::Maxoutofpocket(_) => Some("maxoutofpocket".to_string()),
            CoverageCopayType::Spvisit(_) => Some("spvisit".to_string()),
            CoverageCopayType::Televisit(_) => Some("televisit".to_string()),
            CoverageCopayType::Urgentcare(_) => Some("urgentcare".to_string()),
            CoverageCopayType::Null(_) => None,
        }
    }
}
impl MetaValue for CoverageCopayType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CoverageCopayType::Copay(Some(e)) => e.get_field(field),
                CoverageCopayType::Copaypct(Some(e)) => e.get_field(field),
                CoverageCopayType::Deductible(Some(e)) => e.get_field(field),
                CoverageCopayType::Emergency(Some(e)) => e.get_field(field),
                CoverageCopayType::Gpvisit(Some(e)) => e.get_field(field),
                CoverageCopayType::Inpthosp(Some(e)) => e.get_field(field),
                CoverageCopayType::Maxoutofpocket(Some(e)) => e.get_field(field),
                CoverageCopayType::Spvisit(Some(e)) => e.get_field(field),
                CoverageCopayType::Televisit(Some(e)) => e.get_field(field),
                CoverageCopayType::Urgentcare(Some(e)) => e.get_field(field),
                CoverageCopayType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CoverageCopayType::Copay(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Copaypct(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Deductible(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Emergency(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Gpvisit(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Inpthosp(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Maxoutofpocket(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Spvisit(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Televisit(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Urgentcare(Some(e)) => e.get_field_mut(field),
                CoverageCopayType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CoverageFinancialException {
    #[doc = "Foster child"]
    #[code = "foster"]
    Foster(Option<Element>),
    #[doc = "Retired"]
    #[code = "retired"]
    Retired(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CoverageFinancialException {
    fn default() -> Self {
        CoverageFinancialException::Null(None)
    }
}
impl TryFrom<String> for CoverageFinancialException {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "foster" => Ok(CoverageFinancialException::Foster(None)),
            "retired" => Ok(CoverageFinancialException::Retired(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CoverageFinancialException {
    fn into(self) -> Option<String> {
        match self {
            CoverageFinancialException::Foster(_) => Some("foster".to_string()),
            CoverageFinancialException::Retired(_) => Some("retired".to_string()),
            CoverageFinancialException::Null(_) => None,
        }
    }
}
impl MetaValue for CoverageFinancialException {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CoverageFinancialException::Foster(Some(e)) => e.get_field(field),
                CoverageFinancialException::Retired(Some(e)) => e.get_field(field),
                CoverageFinancialException::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CoverageFinancialException::Foster(Some(e)) => e.get_field_mut(field),
                CoverageFinancialException::Retired(Some(e)) => e.get_field_mut(field),
                CoverageFinancialException::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CoverageSelfpay {
    #[doc = "Pay"]
    #[code = "pay"]
    Pay(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CoverageSelfpay {
    fn default() -> Self {
        CoverageSelfpay::Null(None)
    }
}
impl TryFrom<String> for CoverageSelfpay {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "pay" => Ok(CoverageSelfpay::Pay(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CoverageSelfpay {
    fn into(self) -> Option<String> {
        match self {
            CoverageSelfpay::Pay(_) => Some("pay".to_string()),
            CoverageSelfpay::Null(_) => None,
        }
    }
}
impl MetaValue for CoverageSelfpay {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CoverageSelfpay::Pay(Some(e)) => e.get_field(field),
                CoverageSelfpay::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CoverageSelfpay::Pay(Some(e)) => e.get_field_mut(field),
                CoverageSelfpay::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum CoverageeligibilityresponseExAuthSupport {
    #[doc = "Accident Report"]
    #[code = "accidentreport"]
    Accidentreport(Option<Element>),
    #[doc = "Diagnostic Image Order"]
    #[code = "diagnosticimageorder"]
    Diagnosticimageorder(Option<Element>),
    #[doc = "Diagnostic Image Report"]
    #[code = "diagnosticimagereport"]
    Diagnosticimagereport(Option<Element>),
    #[doc = "Lab Order"]
    #[code = "laborder"]
    Laborder(Option<Element>),
    #[doc = "Lab Report"]
    #[code = "labreport"]
    Labreport(Option<Element>),
    #[doc = "Model"]
    #[code = "model"]
    Model(Option<Element>),
    #[doc = "Picture"]
    #[code = "picture"]
    Picture(Option<Element>),
    #[doc = "Professional Report"]
    #[code = "professionalreport"]
    Professionalreport(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for CoverageeligibilityresponseExAuthSupport {
    fn default() -> Self {
        CoverageeligibilityresponseExAuthSupport::Null(None)
    }
}
impl TryFrom<String> for CoverageeligibilityresponseExAuthSupport {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "accidentreport" => Ok(CoverageeligibilityresponseExAuthSupport::Accidentreport(
                None,
            )),
            "diagnosticimageorder" => {
                Ok(CoverageeligibilityresponseExAuthSupport::Diagnosticimageorder(None))
            }
            "diagnosticimagereport" => {
                Ok(CoverageeligibilityresponseExAuthSupport::Diagnosticimagereport(None))
            }
            "laborder" => Ok(CoverageeligibilityresponseExAuthSupport::Laborder(None)),
            "labreport" => Ok(CoverageeligibilityresponseExAuthSupport::Labreport(None)),
            "model" => Ok(CoverageeligibilityresponseExAuthSupport::Model(None)),
            "picture" => Ok(CoverageeligibilityresponseExAuthSupport::Picture(None)),
            "professionalreport" => {
                Ok(CoverageeligibilityresponseExAuthSupport::Professionalreport(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &CoverageeligibilityresponseExAuthSupport {
    fn into(self) -> Option<String> {
        match self {
            CoverageeligibilityresponseExAuthSupport::Accidentreport(_) => {
                Some("accidentreport".to_string())
            }
            CoverageeligibilityresponseExAuthSupport::Diagnosticimageorder(_) => {
                Some("diagnosticimageorder".to_string())
            }
            CoverageeligibilityresponseExAuthSupport::Diagnosticimagereport(_) => {
                Some("diagnosticimagereport".to_string())
            }
            CoverageeligibilityresponseExAuthSupport::Laborder(_) => Some("laborder".to_string()),
            CoverageeligibilityresponseExAuthSupport::Labreport(_) => Some("labreport".to_string()),
            CoverageeligibilityresponseExAuthSupport::Model(_) => Some("model".to_string()),
            CoverageeligibilityresponseExAuthSupport::Picture(_) => Some("picture".to_string()),
            CoverageeligibilityresponseExAuthSupport::Professionalreport(_) => {
                Some("professionalreport".to_string())
            }
            CoverageeligibilityresponseExAuthSupport::Null(_) => None,
        }
    }
}
impl MetaValue for CoverageeligibilityresponseExAuthSupport {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                CoverageeligibilityresponseExAuthSupport::Accidentreport(Some(e)) => {
                    e.get_field(field)
                }
                CoverageeligibilityresponseExAuthSupport::Diagnosticimageorder(Some(e)) => {
                    e.get_field(field)
                }
                CoverageeligibilityresponseExAuthSupport::Diagnosticimagereport(Some(e)) => {
                    e.get_field(field)
                }
                CoverageeligibilityresponseExAuthSupport::Laborder(Some(e)) => e.get_field(field),
                CoverageeligibilityresponseExAuthSupport::Labreport(Some(e)) => e.get_field(field),
                CoverageeligibilityresponseExAuthSupport::Model(Some(e)) => e.get_field(field),
                CoverageeligibilityresponseExAuthSupport::Picture(Some(e)) => e.get_field(field),
                CoverageeligibilityresponseExAuthSupport::Professionalreport(Some(e)) => {
                    e.get_field(field)
                }
                CoverageeligibilityresponseExAuthSupport::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                CoverageeligibilityresponseExAuthSupport::Accidentreport(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Diagnosticimageorder(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Diagnosticimagereport(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Laborder(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Labreport(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Model(Some(e)) => e.get_field_mut(field),
                CoverageeligibilityresponseExAuthSupport::Picture(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Professionalreport(Some(e)) => {
                    e.get_field_mut(field)
                }
                CoverageeligibilityresponseExAuthSupport::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DataAbsentReason {
    #[doc = "As Text"]
    #[code = "as-text"]
    AsText(Option<Element>),
    #[doc = "Asked But Declined"]
    #[code = "asked-declined"]
    AskedDeclined(Option<Element>),
    #[doc = "Asked But Unknown"]
    #[code = "asked-unknown"]
    AskedUnknown(Option<Element>),
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Masked"]
    #[code = "masked"]
    Masked(Option<Element>),
    #[doc = "Negative Infinity (NINF)"]
    #[code = "negative-infinity"]
    NegativeInfinity(Option<Element>),
    #[doc = "Not a Number (NaN)"]
    #[code = "not-a-number"]
    NotANumber(Option<Element>),
    #[doc = "Not Applicable"]
    #[code = "not-applicable"]
    NotApplicable(Option<Element>),
    #[doc = "Not Asked"]
    #[code = "not-asked"]
    NotAsked(Option<Element>),
    #[doc = "Not Performed"]
    #[code = "not-performed"]
    NotPerformed(Option<Element>),
    #[doc = "Not Permitted"]
    #[code = "not-permitted"]
    NotPermitted(Option<Element>),
    #[doc = "Positive Infinity (PINF)"]
    #[code = "positive-infinity"]
    PositiveInfinity(Option<Element>),
    #[doc = "Temporarily Unknown"]
    #[code = "temp-unknown"]
    TempUnknown(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "Unsupported"]
    #[code = "unsupported"]
    Unsupported(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DataAbsentReason {
    fn default() -> Self {
        DataAbsentReason::Null(None)
    }
}
impl TryFrom<String> for DataAbsentReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "as-text" => Ok(DataAbsentReason::AsText(None)),
            "asked-declined" => Ok(DataAbsentReason::AskedDeclined(None)),
            "asked-unknown" => Ok(DataAbsentReason::AskedUnknown(None)),
            "error" => Ok(DataAbsentReason::Error(None)),
            "masked" => Ok(DataAbsentReason::Masked(None)),
            "negative-infinity" => Ok(DataAbsentReason::NegativeInfinity(None)),
            "not-a-number" => Ok(DataAbsentReason::NotANumber(None)),
            "not-applicable" => Ok(DataAbsentReason::NotApplicable(None)),
            "not-asked" => Ok(DataAbsentReason::NotAsked(None)),
            "not-performed" => Ok(DataAbsentReason::NotPerformed(None)),
            "not-permitted" => Ok(DataAbsentReason::NotPermitted(None)),
            "positive-infinity" => Ok(DataAbsentReason::PositiveInfinity(None)),
            "temp-unknown" => Ok(DataAbsentReason::TempUnknown(None)),
            "unknown" => Ok(DataAbsentReason::Unknown(None)),
            "unsupported" => Ok(DataAbsentReason::Unsupported(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DataAbsentReason {
    fn into(self) -> Option<String> {
        match self {
            DataAbsentReason::AsText(_) => Some("as-text".to_string()),
            DataAbsentReason::AskedDeclined(_) => Some("asked-declined".to_string()),
            DataAbsentReason::AskedUnknown(_) => Some("asked-unknown".to_string()),
            DataAbsentReason::Error(_) => Some("error".to_string()),
            DataAbsentReason::Masked(_) => Some("masked".to_string()),
            DataAbsentReason::NegativeInfinity(_) => Some("negative-infinity".to_string()),
            DataAbsentReason::NotANumber(_) => Some("not-a-number".to_string()),
            DataAbsentReason::NotApplicable(_) => Some("not-applicable".to_string()),
            DataAbsentReason::NotAsked(_) => Some("not-asked".to_string()),
            DataAbsentReason::NotPerformed(_) => Some("not-performed".to_string()),
            DataAbsentReason::NotPermitted(_) => Some("not-permitted".to_string()),
            DataAbsentReason::PositiveInfinity(_) => Some("positive-infinity".to_string()),
            DataAbsentReason::TempUnknown(_) => Some("temp-unknown".to_string()),
            DataAbsentReason::Unknown(_) => Some("unknown".to_string()),
            DataAbsentReason::Unsupported(_) => Some("unsupported".to_string()),
            DataAbsentReason::Null(_) => None,
        }
    }
}
impl MetaValue for DataAbsentReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DataAbsentReason::AsText(Some(e)) => e.get_field(field),
                DataAbsentReason::AskedDeclined(Some(e)) => e.get_field(field),
                DataAbsentReason::AskedUnknown(Some(e)) => e.get_field(field),
                DataAbsentReason::Error(Some(e)) => e.get_field(field),
                DataAbsentReason::Masked(Some(e)) => e.get_field(field),
                DataAbsentReason::NegativeInfinity(Some(e)) => e.get_field(field),
                DataAbsentReason::NotANumber(Some(e)) => e.get_field(field),
                DataAbsentReason::NotApplicable(Some(e)) => e.get_field(field),
                DataAbsentReason::NotAsked(Some(e)) => e.get_field(field),
                DataAbsentReason::NotPerformed(Some(e)) => e.get_field(field),
                DataAbsentReason::NotPermitted(Some(e)) => e.get_field(field),
                DataAbsentReason::PositiveInfinity(Some(e)) => e.get_field(field),
                DataAbsentReason::TempUnknown(Some(e)) => e.get_field(field),
                DataAbsentReason::Unknown(Some(e)) => e.get_field(field),
                DataAbsentReason::Unsupported(Some(e)) => e.get_field(field),
                DataAbsentReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DataAbsentReason::AsText(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::AskedDeclined(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::AskedUnknown(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::Error(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::Masked(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NegativeInfinity(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NotANumber(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NotApplicable(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NotAsked(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NotPerformed(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::NotPermitted(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::PositiveInfinity(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::TempUnknown(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::Unknown(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::Unsupported(Some(e)) => e.get_field_mut(field),
                DataAbsentReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DataTypes {
    #[doc = "Address"]
    #[code = "Address"]
    Address(Option<Element>),
    #[doc = "Age"]
    #[code = "Age"]
    Age(Option<Element>),
    #[doc = "Annotation"]
    #[code = "Annotation"]
    Annotation(Option<Element>),
    #[doc = "Attachment"]
    #[code = "Attachment"]
    Attachment(Option<Element>),
    #[doc = "BackboneElement"]
    #[code = "BackboneElement"]
    BackboneElement(Option<Element>),
    #[doc = "CodeableConcept"]
    #[code = "CodeableConcept"]
    CodeableConcept(Option<Element>),
    #[doc = "Coding"]
    #[code = "Coding"]
    Coding(Option<Element>),
    #[doc = "ContactDetail"]
    #[code = "ContactDetail"]
    ContactDetail(Option<Element>),
    #[doc = "ContactPoint"]
    #[code = "ContactPoint"]
    ContactPoint(Option<Element>),
    #[doc = "Contributor"]
    #[code = "Contributor"]
    Contributor(Option<Element>),
    #[doc = "Count"]
    #[code = "Count"]
    Count(Option<Element>),
    #[doc = "DataRequirement"]
    #[code = "DataRequirement"]
    DataRequirement(Option<Element>),
    #[doc = "Distance"]
    #[code = "Distance"]
    Distance(Option<Element>),
    #[doc = "Dosage"]
    #[code = "Dosage"]
    Dosage(Option<Element>),
    #[doc = "Duration"]
    #[code = "Duration"]
    Duration(Option<Element>),
    #[doc = "Element"]
    #[code = "Element"]
    Element(Option<Element>),
    #[doc = "ElementDefinition"]
    #[code = "ElementDefinition"]
    ElementDefinition(Option<Element>),
    #[doc = "Expression"]
    #[code = "Expression"]
    Expression(Option<Element>),
    #[doc = "Extension"]
    #[code = "Extension"]
    Extension(Option<Element>),
    #[doc = "HumanName"]
    #[code = "HumanName"]
    HumanName(Option<Element>),
    #[doc = "Identifier"]
    #[code = "Identifier"]
    Identifier(Option<Element>),
    #[doc = "MarketingStatus"]
    #[code = "MarketingStatus"]
    MarketingStatus(Option<Element>),
    #[doc = "Meta"]
    #[code = "Meta"]
    Meta(Option<Element>),
    #[doc = "Money"]
    #[code = "Money"]
    Money(Option<Element>),
    #[doc = "MoneyQuantity"]
    #[code = "MoneyQuantity"]
    MoneyQuantity(Option<Element>),
    #[doc = "Narrative"]
    #[code = "Narrative"]
    Narrative(Option<Element>),
    #[doc = "ParameterDefinition"]
    #[code = "ParameterDefinition"]
    ParameterDefinition(Option<Element>),
    #[doc = "Period"]
    #[code = "Period"]
    Period(Option<Element>),
    #[doc = "Population"]
    #[code = "Population"]
    Population(Option<Element>),
    #[doc = "ProdCharacteristic"]
    #[code = "ProdCharacteristic"]
    ProdCharacteristic(Option<Element>),
    #[doc = "ProductShelfLife"]
    #[code = "ProductShelfLife"]
    ProductShelfLife(Option<Element>),
    #[doc = "Quantity"]
    #[code = "Quantity"]
    Quantity(Option<Element>),
    #[doc = "Range"]
    #[code = "Range"]
    Range(Option<Element>),
    #[doc = "Ratio"]
    #[code = "Ratio"]
    Ratio(Option<Element>),
    #[doc = "Reference"]
    #[code = "Reference"]
    Reference(Option<Element>),
    #[doc = "RelatedArtifact"]
    #[code = "RelatedArtifact"]
    RelatedArtifact(Option<Element>),
    #[doc = "SampledData"]
    #[code = "SampledData"]
    SampledData(Option<Element>),
    #[doc = "Signature"]
    #[code = "Signature"]
    Signature(Option<Element>),
    #[doc = "SimpleQuantity"]
    #[code = "SimpleQuantity"]
    SimpleQuantity(Option<Element>),
    #[doc = "SubstanceAmount"]
    #[code = "SubstanceAmount"]
    SubstanceAmount(Option<Element>),
    #[doc = "Timing"]
    #[code = "Timing"]
    Timing(Option<Element>),
    #[doc = "TriggerDefinition"]
    #[code = "TriggerDefinition"]
    TriggerDefinition(Option<Element>),
    #[doc = "UsageContext"]
    #[code = "UsageContext"]
    UsageContext(Option<Element>),
    #[doc = "base64Binary"]
    #[code = "base64Binary"]
    Base64Binary(Option<Element>),
    #[doc = "boolean"]
    #[code = "boolean"]
    Boolean(Option<Element>),
    #[doc = "canonical"]
    #[code = "canonical"]
    Canonical(Option<Element>),
    #[doc = "code"]
    #[code = "code"]
    Code(Option<Element>),
    #[doc = "date"]
    #[code = "date"]
    Date(Option<Element>),
    #[doc = "dateTime"]
    #[code = "dateTime"]
    DateTime(Option<Element>),
    #[doc = "decimal"]
    #[code = "decimal"]
    Decimal(Option<Element>),
    #[doc = "id"]
    #[code = "id"]
    Id(Option<Element>),
    #[doc = "instant"]
    #[code = "instant"]
    Instant(Option<Element>),
    #[doc = "integer"]
    #[code = "integer"]
    Integer(Option<Element>),
    #[doc = "markdown"]
    #[code = "markdown"]
    Markdown(Option<Element>),
    #[doc = "oid"]
    #[code = "oid"]
    Oid(Option<Element>),
    #[doc = "positiveInt"]
    #[code = "positiveInt"]
    PositiveInt(Option<Element>),
    #[doc = "string"]
    #[code = "string"]
    String(Option<Element>),
    #[doc = "time"]
    #[code = "time"]
    Time(Option<Element>),
    #[doc = "unsignedInt"]
    #[code = "unsignedInt"]
    UnsignedInt(Option<Element>),
    #[doc = "uri"]
    #[code = "uri"]
    Uri(Option<Element>),
    #[doc = "url"]
    #[code = "url"]
    Url(Option<Element>),
    #[doc = "uuid"]
    #[code = "uuid"]
    Uuid(Option<Element>),
    #[doc = "XHTML"]
    #[code = "xhtml"]
    Xhtml(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DataTypes {
    fn default() -> Self {
        DataTypes::Null(None)
    }
}
impl TryFrom<String> for DataTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Address" => Ok(DataTypes::Address(None)),
            "Age" => Ok(DataTypes::Age(None)),
            "Annotation" => Ok(DataTypes::Annotation(None)),
            "Attachment" => Ok(DataTypes::Attachment(None)),
            "BackboneElement" => Ok(DataTypes::BackboneElement(None)),
            "CodeableConcept" => Ok(DataTypes::CodeableConcept(None)),
            "Coding" => Ok(DataTypes::Coding(None)),
            "ContactDetail" => Ok(DataTypes::ContactDetail(None)),
            "ContactPoint" => Ok(DataTypes::ContactPoint(None)),
            "Contributor" => Ok(DataTypes::Contributor(None)),
            "Count" => Ok(DataTypes::Count(None)),
            "DataRequirement" => Ok(DataTypes::DataRequirement(None)),
            "Distance" => Ok(DataTypes::Distance(None)),
            "Dosage" => Ok(DataTypes::Dosage(None)),
            "Duration" => Ok(DataTypes::Duration(None)),
            "Element" => Ok(DataTypes::Element(None)),
            "ElementDefinition" => Ok(DataTypes::ElementDefinition(None)),
            "Expression" => Ok(DataTypes::Expression(None)),
            "Extension" => Ok(DataTypes::Extension(None)),
            "HumanName" => Ok(DataTypes::HumanName(None)),
            "Identifier" => Ok(DataTypes::Identifier(None)),
            "MarketingStatus" => Ok(DataTypes::MarketingStatus(None)),
            "Meta" => Ok(DataTypes::Meta(None)),
            "Money" => Ok(DataTypes::Money(None)),
            "MoneyQuantity" => Ok(DataTypes::MoneyQuantity(None)),
            "Narrative" => Ok(DataTypes::Narrative(None)),
            "ParameterDefinition" => Ok(DataTypes::ParameterDefinition(None)),
            "Period" => Ok(DataTypes::Period(None)),
            "Population" => Ok(DataTypes::Population(None)),
            "ProdCharacteristic" => Ok(DataTypes::ProdCharacteristic(None)),
            "ProductShelfLife" => Ok(DataTypes::ProductShelfLife(None)),
            "Quantity" => Ok(DataTypes::Quantity(None)),
            "Range" => Ok(DataTypes::Range(None)),
            "Ratio" => Ok(DataTypes::Ratio(None)),
            "Reference" => Ok(DataTypes::Reference(None)),
            "RelatedArtifact" => Ok(DataTypes::RelatedArtifact(None)),
            "SampledData" => Ok(DataTypes::SampledData(None)),
            "Signature" => Ok(DataTypes::Signature(None)),
            "SimpleQuantity" => Ok(DataTypes::SimpleQuantity(None)),
            "SubstanceAmount" => Ok(DataTypes::SubstanceAmount(None)),
            "Timing" => Ok(DataTypes::Timing(None)),
            "TriggerDefinition" => Ok(DataTypes::TriggerDefinition(None)),
            "UsageContext" => Ok(DataTypes::UsageContext(None)),
            "base64Binary" => Ok(DataTypes::Base64Binary(None)),
            "boolean" => Ok(DataTypes::Boolean(None)),
            "canonical" => Ok(DataTypes::Canonical(None)),
            "code" => Ok(DataTypes::Code(None)),
            "date" => Ok(DataTypes::Date(None)),
            "dateTime" => Ok(DataTypes::DateTime(None)),
            "decimal" => Ok(DataTypes::Decimal(None)),
            "id" => Ok(DataTypes::Id(None)),
            "instant" => Ok(DataTypes::Instant(None)),
            "integer" => Ok(DataTypes::Integer(None)),
            "markdown" => Ok(DataTypes::Markdown(None)),
            "oid" => Ok(DataTypes::Oid(None)),
            "positiveInt" => Ok(DataTypes::PositiveInt(None)),
            "string" => Ok(DataTypes::String(None)),
            "time" => Ok(DataTypes::Time(None)),
            "unsignedInt" => Ok(DataTypes::UnsignedInt(None)),
            "uri" => Ok(DataTypes::Uri(None)),
            "url" => Ok(DataTypes::Url(None)),
            "uuid" => Ok(DataTypes::Uuid(None)),
            "xhtml" => Ok(DataTypes::Xhtml(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DataTypes {
    fn into(self) -> Option<String> {
        match self {
            DataTypes::Address(_) => Some("Address".to_string()),
            DataTypes::Age(_) => Some("Age".to_string()),
            DataTypes::Annotation(_) => Some("Annotation".to_string()),
            DataTypes::Attachment(_) => Some("Attachment".to_string()),
            DataTypes::BackboneElement(_) => Some("BackboneElement".to_string()),
            DataTypes::CodeableConcept(_) => Some("CodeableConcept".to_string()),
            DataTypes::Coding(_) => Some("Coding".to_string()),
            DataTypes::ContactDetail(_) => Some("ContactDetail".to_string()),
            DataTypes::ContactPoint(_) => Some("ContactPoint".to_string()),
            DataTypes::Contributor(_) => Some("Contributor".to_string()),
            DataTypes::Count(_) => Some("Count".to_string()),
            DataTypes::DataRequirement(_) => Some("DataRequirement".to_string()),
            DataTypes::Distance(_) => Some("Distance".to_string()),
            DataTypes::Dosage(_) => Some("Dosage".to_string()),
            DataTypes::Duration(_) => Some("Duration".to_string()),
            DataTypes::Element(_) => Some("Element".to_string()),
            DataTypes::ElementDefinition(_) => Some("ElementDefinition".to_string()),
            DataTypes::Expression(_) => Some("Expression".to_string()),
            DataTypes::Extension(_) => Some("Extension".to_string()),
            DataTypes::HumanName(_) => Some("HumanName".to_string()),
            DataTypes::Identifier(_) => Some("Identifier".to_string()),
            DataTypes::MarketingStatus(_) => Some("MarketingStatus".to_string()),
            DataTypes::Meta(_) => Some("Meta".to_string()),
            DataTypes::Money(_) => Some("Money".to_string()),
            DataTypes::MoneyQuantity(_) => Some("MoneyQuantity".to_string()),
            DataTypes::Narrative(_) => Some("Narrative".to_string()),
            DataTypes::ParameterDefinition(_) => Some("ParameterDefinition".to_string()),
            DataTypes::Period(_) => Some("Period".to_string()),
            DataTypes::Population(_) => Some("Population".to_string()),
            DataTypes::ProdCharacteristic(_) => Some("ProdCharacteristic".to_string()),
            DataTypes::ProductShelfLife(_) => Some("ProductShelfLife".to_string()),
            DataTypes::Quantity(_) => Some("Quantity".to_string()),
            DataTypes::Range(_) => Some("Range".to_string()),
            DataTypes::Ratio(_) => Some("Ratio".to_string()),
            DataTypes::Reference(_) => Some("Reference".to_string()),
            DataTypes::RelatedArtifact(_) => Some("RelatedArtifact".to_string()),
            DataTypes::SampledData(_) => Some("SampledData".to_string()),
            DataTypes::Signature(_) => Some("Signature".to_string()),
            DataTypes::SimpleQuantity(_) => Some("SimpleQuantity".to_string()),
            DataTypes::SubstanceAmount(_) => Some("SubstanceAmount".to_string()),
            DataTypes::Timing(_) => Some("Timing".to_string()),
            DataTypes::TriggerDefinition(_) => Some("TriggerDefinition".to_string()),
            DataTypes::UsageContext(_) => Some("UsageContext".to_string()),
            DataTypes::Base64Binary(_) => Some("base64Binary".to_string()),
            DataTypes::Boolean(_) => Some("boolean".to_string()),
            DataTypes::Canonical(_) => Some("canonical".to_string()),
            DataTypes::Code(_) => Some("code".to_string()),
            DataTypes::Date(_) => Some("date".to_string()),
            DataTypes::DateTime(_) => Some("dateTime".to_string()),
            DataTypes::Decimal(_) => Some("decimal".to_string()),
            DataTypes::Id(_) => Some("id".to_string()),
            DataTypes::Instant(_) => Some("instant".to_string()),
            DataTypes::Integer(_) => Some("integer".to_string()),
            DataTypes::Markdown(_) => Some("markdown".to_string()),
            DataTypes::Oid(_) => Some("oid".to_string()),
            DataTypes::PositiveInt(_) => Some("positiveInt".to_string()),
            DataTypes::String(_) => Some("string".to_string()),
            DataTypes::Time(_) => Some("time".to_string()),
            DataTypes::UnsignedInt(_) => Some("unsignedInt".to_string()),
            DataTypes::Uri(_) => Some("uri".to_string()),
            DataTypes::Url(_) => Some("url".to_string()),
            DataTypes::Uuid(_) => Some("uuid".to_string()),
            DataTypes::Xhtml(_) => Some("xhtml".to_string()),
            DataTypes::Null(_) => None,
        }
    }
}
impl MetaValue for DataTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DataTypes::Address(Some(e)) => e.get_field(field),
                DataTypes::Age(Some(e)) => e.get_field(field),
                DataTypes::Annotation(Some(e)) => e.get_field(field),
                DataTypes::Attachment(Some(e)) => e.get_field(field),
                DataTypes::BackboneElement(Some(e)) => e.get_field(field),
                DataTypes::CodeableConcept(Some(e)) => e.get_field(field),
                DataTypes::Coding(Some(e)) => e.get_field(field),
                DataTypes::ContactDetail(Some(e)) => e.get_field(field),
                DataTypes::ContactPoint(Some(e)) => e.get_field(field),
                DataTypes::Contributor(Some(e)) => e.get_field(field),
                DataTypes::Count(Some(e)) => e.get_field(field),
                DataTypes::DataRequirement(Some(e)) => e.get_field(field),
                DataTypes::Distance(Some(e)) => e.get_field(field),
                DataTypes::Dosage(Some(e)) => e.get_field(field),
                DataTypes::Duration(Some(e)) => e.get_field(field),
                DataTypes::Element(Some(e)) => e.get_field(field),
                DataTypes::ElementDefinition(Some(e)) => e.get_field(field),
                DataTypes::Expression(Some(e)) => e.get_field(field),
                DataTypes::Extension(Some(e)) => e.get_field(field),
                DataTypes::HumanName(Some(e)) => e.get_field(field),
                DataTypes::Identifier(Some(e)) => e.get_field(field),
                DataTypes::MarketingStatus(Some(e)) => e.get_field(field),
                DataTypes::Meta(Some(e)) => e.get_field(field),
                DataTypes::Money(Some(e)) => e.get_field(field),
                DataTypes::MoneyQuantity(Some(e)) => e.get_field(field),
                DataTypes::Narrative(Some(e)) => e.get_field(field),
                DataTypes::ParameterDefinition(Some(e)) => e.get_field(field),
                DataTypes::Period(Some(e)) => e.get_field(field),
                DataTypes::Population(Some(e)) => e.get_field(field),
                DataTypes::ProdCharacteristic(Some(e)) => e.get_field(field),
                DataTypes::ProductShelfLife(Some(e)) => e.get_field(field),
                DataTypes::Quantity(Some(e)) => e.get_field(field),
                DataTypes::Range(Some(e)) => e.get_field(field),
                DataTypes::Ratio(Some(e)) => e.get_field(field),
                DataTypes::Reference(Some(e)) => e.get_field(field),
                DataTypes::RelatedArtifact(Some(e)) => e.get_field(field),
                DataTypes::SampledData(Some(e)) => e.get_field(field),
                DataTypes::Signature(Some(e)) => e.get_field(field),
                DataTypes::SimpleQuantity(Some(e)) => e.get_field(field),
                DataTypes::SubstanceAmount(Some(e)) => e.get_field(field),
                DataTypes::Timing(Some(e)) => e.get_field(field),
                DataTypes::TriggerDefinition(Some(e)) => e.get_field(field),
                DataTypes::UsageContext(Some(e)) => e.get_field(field),
                DataTypes::Base64Binary(Some(e)) => e.get_field(field),
                DataTypes::Boolean(Some(e)) => e.get_field(field),
                DataTypes::Canonical(Some(e)) => e.get_field(field),
                DataTypes::Code(Some(e)) => e.get_field(field),
                DataTypes::Date(Some(e)) => e.get_field(field),
                DataTypes::DateTime(Some(e)) => e.get_field(field),
                DataTypes::Decimal(Some(e)) => e.get_field(field),
                DataTypes::Id(Some(e)) => e.get_field(field),
                DataTypes::Instant(Some(e)) => e.get_field(field),
                DataTypes::Integer(Some(e)) => e.get_field(field),
                DataTypes::Markdown(Some(e)) => e.get_field(field),
                DataTypes::Oid(Some(e)) => e.get_field(field),
                DataTypes::PositiveInt(Some(e)) => e.get_field(field),
                DataTypes::String(Some(e)) => e.get_field(field),
                DataTypes::Time(Some(e)) => e.get_field(field),
                DataTypes::UnsignedInt(Some(e)) => e.get_field(field),
                DataTypes::Uri(Some(e)) => e.get_field(field),
                DataTypes::Url(Some(e)) => e.get_field(field),
                DataTypes::Uuid(Some(e)) => e.get_field(field),
                DataTypes::Xhtml(Some(e)) => e.get_field(field),
                DataTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DataTypes::Address(Some(e)) => e.get_field_mut(field),
                DataTypes::Age(Some(e)) => e.get_field_mut(field),
                DataTypes::Annotation(Some(e)) => e.get_field_mut(field),
                DataTypes::Attachment(Some(e)) => e.get_field_mut(field),
                DataTypes::BackboneElement(Some(e)) => e.get_field_mut(field),
                DataTypes::CodeableConcept(Some(e)) => e.get_field_mut(field),
                DataTypes::Coding(Some(e)) => e.get_field_mut(field),
                DataTypes::ContactDetail(Some(e)) => e.get_field_mut(field),
                DataTypes::ContactPoint(Some(e)) => e.get_field_mut(field),
                DataTypes::Contributor(Some(e)) => e.get_field_mut(field),
                DataTypes::Count(Some(e)) => e.get_field_mut(field),
                DataTypes::DataRequirement(Some(e)) => e.get_field_mut(field),
                DataTypes::Distance(Some(e)) => e.get_field_mut(field),
                DataTypes::Dosage(Some(e)) => e.get_field_mut(field),
                DataTypes::Duration(Some(e)) => e.get_field_mut(field),
                DataTypes::Element(Some(e)) => e.get_field_mut(field),
                DataTypes::ElementDefinition(Some(e)) => e.get_field_mut(field),
                DataTypes::Expression(Some(e)) => e.get_field_mut(field),
                DataTypes::Extension(Some(e)) => e.get_field_mut(field),
                DataTypes::HumanName(Some(e)) => e.get_field_mut(field),
                DataTypes::Identifier(Some(e)) => e.get_field_mut(field),
                DataTypes::MarketingStatus(Some(e)) => e.get_field_mut(field),
                DataTypes::Meta(Some(e)) => e.get_field_mut(field),
                DataTypes::Money(Some(e)) => e.get_field_mut(field),
                DataTypes::MoneyQuantity(Some(e)) => e.get_field_mut(field),
                DataTypes::Narrative(Some(e)) => e.get_field_mut(field),
                DataTypes::ParameterDefinition(Some(e)) => e.get_field_mut(field),
                DataTypes::Period(Some(e)) => e.get_field_mut(field),
                DataTypes::Population(Some(e)) => e.get_field_mut(field),
                DataTypes::ProdCharacteristic(Some(e)) => e.get_field_mut(field),
                DataTypes::ProductShelfLife(Some(e)) => e.get_field_mut(field),
                DataTypes::Quantity(Some(e)) => e.get_field_mut(field),
                DataTypes::Range(Some(e)) => e.get_field_mut(field),
                DataTypes::Ratio(Some(e)) => e.get_field_mut(field),
                DataTypes::Reference(Some(e)) => e.get_field_mut(field),
                DataTypes::RelatedArtifact(Some(e)) => e.get_field_mut(field),
                DataTypes::SampledData(Some(e)) => e.get_field_mut(field),
                DataTypes::Signature(Some(e)) => e.get_field_mut(field),
                DataTypes::SimpleQuantity(Some(e)) => e.get_field_mut(field),
                DataTypes::SubstanceAmount(Some(e)) => e.get_field_mut(field),
                DataTypes::Timing(Some(e)) => e.get_field_mut(field),
                DataTypes::TriggerDefinition(Some(e)) => e.get_field_mut(field),
                DataTypes::UsageContext(Some(e)) => e.get_field_mut(field),
                DataTypes::Base64Binary(Some(e)) => e.get_field_mut(field),
                DataTypes::Boolean(Some(e)) => e.get_field_mut(field),
                DataTypes::Canonical(Some(e)) => e.get_field_mut(field),
                DataTypes::Code(Some(e)) => e.get_field_mut(field),
                DataTypes::Date(Some(e)) => e.get_field_mut(field),
                DataTypes::DateTime(Some(e)) => e.get_field_mut(field),
                DataTypes::Decimal(Some(e)) => e.get_field_mut(field),
                DataTypes::Id(Some(e)) => e.get_field_mut(field),
                DataTypes::Instant(Some(e)) => e.get_field_mut(field),
                DataTypes::Integer(Some(e)) => e.get_field_mut(field),
                DataTypes::Markdown(Some(e)) => e.get_field_mut(field),
                DataTypes::Oid(Some(e)) => e.get_field_mut(field),
                DataTypes::PositiveInt(Some(e)) => e.get_field_mut(field),
                DataTypes::String(Some(e)) => e.get_field_mut(field),
                DataTypes::Time(Some(e)) => e.get_field_mut(field),
                DataTypes::UnsignedInt(Some(e)) => e.get_field_mut(field),
                DataTypes::Uri(Some(e)) => e.get_field_mut(field),
                DataTypes::Url(Some(e)) => e.get_field_mut(field),
                DataTypes::Uuid(Some(e)) => e.get_field_mut(field),
                DataTypes::Xhtml(Some(e)) => e.get_field_mut(field),
                DataTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DaysOfWeek {
    #[doc = "Friday"]
    #[code = "fri"]
    Fri(Option<Element>),
    #[doc = "Monday"]
    #[code = "mon"]
    Mon(Option<Element>),
    #[doc = "Saturday"]
    #[code = "sat"]
    Sat(Option<Element>),
    #[doc = "Sunday"]
    #[code = "sun"]
    Sun(Option<Element>),
    #[doc = "Thursday"]
    #[code = "thu"]
    Thu(Option<Element>),
    #[doc = "Tuesday"]
    #[code = "tue"]
    Tue(Option<Element>),
    #[doc = "Wednesday"]
    #[code = "wed"]
    Wed(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DaysOfWeek {
    fn default() -> Self {
        DaysOfWeek::Null(None)
    }
}
impl TryFrom<String> for DaysOfWeek {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fri" => Ok(DaysOfWeek::Fri(None)),
            "mon" => Ok(DaysOfWeek::Mon(None)),
            "sat" => Ok(DaysOfWeek::Sat(None)),
            "sun" => Ok(DaysOfWeek::Sun(None)),
            "thu" => Ok(DaysOfWeek::Thu(None)),
            "tue" => Ok(DaysOfWeek::Tue(None)),
            "wed" => Ok(DaysOfWeek::Wed(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DaysOfWeek {
    fn into(self) -> Option<String> {
        match self {
            DaysOfWeek::Fri(_) => Some("fri".to_string()),
            DaysOfWeek::Mon(_) => Some("mon".to_string()),
            DaysOfWeek::Sat(_) => Some("sat".to_string()),
            DaysOfWeek::Sun(_) => Some("sun".to_string()),
            DaysOfWeek::Thu(_) => Some("thu".to_string()),
            DaysOfWeek::Tue(_) => Some("tue".to_string()),
            DaysOfWeek::Wed(_) => Some("wed".to_string()),
            DaysOfWeek::Null(_) => None,
        }
    }
}
impl MetaValue for DaysOfWeek {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DaysOfWeek::Fri(Some(e)) => e.get_field(field),
                DaysOfWeek::Mon(Some(e)) => e.get_field(field),
                DaysOfWeek::Sat(Some(e)) => e.get_field(field),
                DaysOfWeek::Sun(Some(e)) => e.get_field(field),
                DaysOfWeek::Thu(Some(e)) => e.get_field(field),
                DaysOfWeek::Tue(Some(e)) => e.get_field(field),
                DaysOfWeek::Wed(Some(e)) => e.get_field(field),
                DaysOfWeek::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DaysOfWeek::Fri(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Mon(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Sat(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Sun(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Thu(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Tue(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Wed(Some(e)) => e.get_field_mut(field),
                DaysOfWeek::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DefinitionResourceTypes {
    #[doc = "ActivityDefinition"]
    #[code = "ActivityDefinition"]
    ActivityDefinition(Option<Element>),
    #[doc = "EventDefinition"]
    #[code = "EventDefinition"]
    EventDefinition(Option<Element>),
    #[doc = "Measure"]
    #[code = "Measure"]
    Measure(Option<Element>),
    #[doc = "OperationDefinition"]
    #[code = "OperationDefinition"]
    OperationDefinition(Option<Element>),
    #[doc = "PlanDefinition"]
    #[code = "PlanDefinition"]
    PlanDefinition(Option<Element>),
    #[doc = "Questionnaire"]
    #[code = "Questionnaire"]
    Questionnaire(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DefinitionResourceTypes {
    fn default() -> Self {
        DefinitionResourceTypes::Null(None)
    }
}
impl TryFrom<String> for DefinitionResourceTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ActivityDefinition" => Ok(DefinitionResourceTypes::ActivityDefinition(None)),
            "EventDefinition" => Ok(DefinitionResourceTypes::EventDefinition(None)),
            "Measure" => Ok(DefinitionResourceTypes::Measure(None)),
            "OperationDefinition" => Ok(DefinitionResourceTypes::OperationDefinition(None)),
            "PlanDefinition" => Ok(DefinitionResourceTypes::PlanDefinition(None)),
            "Questionnaire" => Ok(DefinitionResourceTypes::Questionnaire(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DefinitionResourceTypes {
    fn into(self) -> Option<String> {
        match self {
            DefinitionResourceTypes::ActivityDefinition(_) => {
                Some("ActivityDefinition".to_string())
            }
            DefinitionResourceTypes::EventDefinition(_) => Some("EventDefinition".to_string()),
            DefinitionResourceTypes::Measure(_) => Some("Measure".to_string()),
            DefinitionResourceTypes::OperationDefinition(_) => {
                Some("OperationDefinition".to_string())
            }
            DefinitionResourceTypes::PlanDefinition(_) => Some("PlanDefinition".to_string()),
            DefinitionResourceTypes::Questionnaire(_) => Some("Questionnaire".to_string()),
            DefinitionResourceTypes::Null(_) => None,
        }
    }
}
impl MetaValue for DefinitionResourceTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DefinitionResourceTypes::ActivityDefinition(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::EventDefinition(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::Measure(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::OperationDefinition(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::PlanDefinition(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::Questionnaire(Some(e)) => e.get_field(field),
                DefinitionResourceTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DefinitionResourceTypes::ActivityDefinition(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::EventDefinition(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::Measure(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::OperationDefinition(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::PlanDefinition(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::Questionnaire(Some(e)) => e.get_field_mut(field),
                DefinitionResourceTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DefinitionStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "Withdrawn"]
    #[code = "withdrawn"]
    Withdrawn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DefinitionStatus {
    fn default() -> Self {
        DefinitionStatus::Null(None)
    }
}
impl TryFrom<String> for DefinitionStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(DefinitionStatus::Active(None)),
            "draft" => Ok(DefinitionStatus::Draft(None)),
            "unknown" => Ok(DefinitionStatus::Unknown(None)),
            "withdrawn" => Ok(DefinitionStatus::Withdrawn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DefinitionStatus {
    fn into(self) -> Option<String> {
        match self {
            DefinitionStatus::Active(_) => Some("active".to_string()),
            DefinitionStatus::Draft(_) => Some("draft".to_string()),
            DefinitionStatus::Unknown(_) => Some("unknown".to_string()),
            DefinitionStatus::Withdrawn(_) => Some("withdrawn".to_string()),
            DefinitionStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DefinitionStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DefinitionStatus::Active(Some(e)) => e.get_field(field),
                DefinitionStatus::Draft(Some(e)) => e.get_field(field),
                DefinitionStatus::Unknown(Some(e)) => e.get_field(field),
                DefinitionStatus::Withdrawn(Some(e)) => e.get_field(field),
                DefinitionStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DefinitionStatus::Active(Some(e)) => e.get_field_mut(field),
                DefinitionStatus::Draft(Some(e)) => e.get_field_mut(field),
                DefinitionStatus::Unknown(Some(e)) => e.get_field_mut(field),
                DefinitionStatus::Withdrawn(Some(e)) => e.get_field_mut(field),
                DefinitionStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DefinitionTopic {
    #[doc = "Assessment"]
    #[code = "assessment"]
    Assessment(Option<Element>),
    #[doc = "Education"]
    #[code = "education"]
    Education(Option<Element>),
    #[doc = "Treatment"]
    #[code = "treatment"]
    Treatment(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DefinitionTopic {
    fn default() -> Self {
        DefinitionTopic::Null(None)
    }
}
impl TryFrom<String> for DefinitionTopic {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "assessment" => Ok(DefinitionTopic::Assessment(None)),
            "education" => Ok(DefinitionTopic::Education(None)),
            "treatment" => Ok(DefinitionTopic::Treatment(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DefinitionTopic {
    fn into(self) -> Option<String> {
        match self {
            DefinitionTopic::Assessment(_) => Some("assessment".to_string()),
            DefinitionTopic::Education(_) => Some("education".to_string()),
            DefinitionTopic::Treatment(_) => Some("treatment".to_string()),
            DefinitionTopic::Null(_) => None,
        }
    }
}
impl MetaValue for DefinitionTopic {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DefinitionTopic::Assessment(Some(e)) => e.get_field(field),
                DefinitionTopic::Education(Some(e)) => e.get_field(field),
                DefinitionTopic::Treatment(Some(e)) => e.get_field(field),
                DefinitionTopic::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DefinitionTopic::Assessment(Some(e)) => e.get_field_mut(field),
                DefinitionTopic::Education(Some(e)) => e.get_field_mut(field),
                DefinitionTopic::Treatment(Some(e)) => e.get_field_mut(field),
                DefinitionTopic::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DefinitionUse {
    #[doc = "Domain Analysis Model"]
    #[code = "archetype"]
    Archetype(Option<Element>),
    #[doc = "Custom Resource"]
    #[code = "custom-resource"]
    CustomResource(Option<Element>),
    #[doc = "Domain Analysis Model"]
    #[code = "dam"]
    Dam(Option<Element>),
    #[doc = "FHIR Structure"]
    #[code = "fhir-structure"]
    FhirStructure(Option<Element>),
    #[doc = "Template"]
    #[code = "template"]
    Template(Option<Element>),
    #[doc = "Wire Format"]
    #[code = "wire-format"]
    WireFormat(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DefinitionUse {
    fn default() -> Self {
        DefinitionUse::Null(None)
    }
}
impl TryFrom<String> for DefinitionUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "archetype" => Ok(DefinitionUse::Archetype(None)),
            "custom-resource" => Ok(DefinitionUse::CustomResource(None)),
            "dam" => Ok(DefinitionUse::Dam(None)),
            "fhir-structure" => Ok(DefinitionUse::FhirStructure(None)),
            "template" => Ok(DefinitionUse::Template(None)),
            "wire-format" => Ok(DefinitionUse::WireFormat(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DefinitionUse {
    fn into(self) -> Option<String> {
        match self {
            DefinitionUse::Archetype(_) => Some("archetype".to_string()),
            DefinitionUse::CustomResource(_) => Some("custom-resource".to_string()),
            DefinitionUse::Dam(_) => Some("dam".to_string()),
            DefinitionUse::FhirStructure(_) => Some("fhir-structure".to_string()),
            DefinitionUse::Template(_) => Some("template".to_string()),
            DefinitionUse::WireFormat(_) => Some("wire-format".to_string()),
            DefinitionUse::Null(_) => None,
        }
    }
}
impl MetaValue for DefinitionUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DefinitionUse::Archetype(Some(e)) => e.get_field(field),
                DefinitionUse::CustomResource(Some(e)) => e.get_field(field),
                DefinitionUse::Dam(Some(e)) => e.get_field(field),
                DefinitionUse::FhirStructure(Some(e)) => e.get_field(field),
                DefinitionUse::Template(Some(e)) => e.get_field(field),
                DefinitionUse::WireFormat(Some(e)) => e.get_field(field),
                DefinitionUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DefinitionUse::Archetype(Some(e)) => e.get_field_mut(field),
                DefinitionUse::CustomResource(Some(e)) => e.get_field_mut(field),
                DefinitionUse::Dam(Some(e)) => e.get_field_mut(field),
                DefinitionUse::FhirStructure(Some(e)) => e.get_field_mut(field),
                DefinitionUse::Template(Some(e)) => e.get_field_mut(field),
                DefinitionUse::WireFormat(Some(e)) => e.get_field_mut(field),
                DefinitionUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DesignationUse {
    #[code = "900000000000003001"]
    V900000000000003001(Option<Element>),
    #[code = "900000000000013009"]
    V900000000000013009(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DesignationUse {
    fn default() -> Self {
        DesignationUse::Null(None)
    }
}
impl TryFrom<String> for DesignationUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "900000000000003001" => Ok(DesignationUse::V900000000000003001(None)),
            "900000000000013009" => Ok(DesignationUse::V900000000000013009(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DesignationUse {
    fn into(self) -> Option<String> {
        match self {
            DesignationUse::V900000000000003001(_) => Some("900000000000003001".to_string()),
            DesignationUse::V900000000000013009(_) => Some("900000000000013009".to_string()),
            DesignationUse::Null(_) => None,
        }
    }
}
impl MetaValue for DesignationUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DesignationUse::V900000000000003001(Some(e)) => e.get_field(field),
                DesignationUse::V900000000000013009(Some(e)) => e.get_field(field),
                DesignationUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DesignationUse::V900000000000003001(Some(e)) => e.get_field_mut(field),
                DesignationUse::V900000000000013009(Some(e)) => e.get_field_mut(field),
                DesignationUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DetectedissueSeverity {
    #[doc = "High"]
    #[code = "high"]
    High(Option<Element>),
    #[doc = "Low"]
    #[code = "low"]
    Low(Option<Element>),
    #[doc = "Moderate"]
    #[code = "moderate"]
    Moderate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DetectedissueSeverity {
    fn default() -> Self {
        DetectedissueSeverity::Null(None)
    }
}
impl TryFrom<String> for DetectedissueSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "high" => Ok(DetectedissueSeverity::High(None)),
            "low" => Ok(DetectedissueSeverity::Low(None)),
            "moderate" => Ok(DetectedissueSeverity::Moderate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DetectedissueSeverity {
    fn into(self) -> Option<String> {
        match self {
            DetectedissueSeverity::High(_) => Some("high".to_string()),
            DetectedissueSeverity::Low(_) => Some("low".to_string()),
            DetectedissueSeverity::Moderate(_) => Some("moderate".to_string()),
            DetectedissueSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for DetectedissueSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DetectedissueSeverity::High(Some(e)) => e.get_field(field),
                DetectedissueSeverity::Low(Some(e)) => e.get_field(field),
                DetectedissueSeverity::Moderate(Some(e)) => e.get_field(field),
                DetectedissueSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DetectedissueSeverity::High(Some(e)) => e.get_field_mut(field),
                DetectedissueSeverity::Low(Some(e)) => e.get_field_mut(field),
                DetectedissueSeverity::Moderate(Some(e)) => e.get_field_mut(field),
                DetectedissueSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceComponentProperty {
    #[doc = "MDC_REG_CERT_DATA_CONTINUA_CERT_DEV_LIST"]
    #[code = "532353"]
    V532353(Option<Element>),
    #[doc = "MDC_REG_CERT_DATA_CONTINUA_REG_STATUS"]
    #[code = "532354"]
    V532354(Option<Element>),
    #[doc = "MDC_REG_CERT_DATA_CONTINUA_PHG_CERT_LIST"]
    #[code = "532355"]
    V532355(Option<Element>),
    #[doc = "MDC_TIME_CAP_STATE"]
    #[code = "68219"]
    V68219(Option<Element>),
    #[doc = "MDC_TIME_SYNC_PROTOCOL"]
    #[code = "68220"]
    V68220(Option<Element>),
    #[doc = "MDC_TIME_SYNC_ACCURACY"]
    #[code = "68221"]
    V68221(Option<Element>),
    #[doc = "MDC_TIME_RES_ABS"]
    #[code = "68222"]
    V68222(Option<Element>),
    #[doc = "MDC_TIME_RES_REL"]
    #[code = "68223"]
    V68223(Option<Element>),
    #[doc = "MDC_TIME_RES_REL_HI_RES"]
    #[code = "68224"]
    V68224(Option<Element>),
    #[doc = "MDC_TIME_RES_BO"]
    #[code = "68226"]
    V68226(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceComponentProperty {
    fn default() -> Self {
        DeviceComponentProperty::Null(None)
    }
}
impl TryFrom<String> for DeviceComponentProperty {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "532353" => Ok(DeviceComponentProperty::V532353(None)),
            "532354" => Ok(DeviceComponentProperty::V532354(None)),
            "532355" => Ok(DeviceComponentProperty::V532355(None)),
            "68219" => Ok(DeviceComponentProperty::V68219(None)),
            "68220" => Ok(DeviceComponentProperty::V68220(None)),
            "68221" => Ok(DeviceComponentProperty::V68221(None)),
            "68222" => Ok(DeviceComponentProperty::V68222(None)),
            "68223" => Ok(DeviceComponentProperty::V68223(None)),
            "68224" => Ok(DeviceComponentProperty::V68224(None)),
            "68226" => Ok(DeviceComponentProperty::V68226(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceComponentProperty {
    fn into(self) -> Option<String> {
        match self {
            DeviceComponentProperty::V532353(_) => Some("532353".to_string()),
            DeviceComponentProperty::V532354(_) => Some("532354".to_string()),
            DeviceComponentProperty::V532355(_) => Some("532355".to_string()),
            DeviceComponentProperty::V68219(_) => Some("68219".to_string()),
            DeviceComponentProperty::V68220(_) => Some("68220".to_string()),
            DeviceComponentProperty::V68221(_) => Some("68221".to_string()),
            DeviceComponentProperty::V68222(_) => Some("68222".to_string()),
            DeviceComponentProperty::V68223(_) => Some("68223".to_string()),
            DeviceComponentProperty::V68224(_) => Some("68224".to_string()),
            DeviceComponentProperty::V68226(_) => Some("68226".to_string()),
            DeviceComponentProperty::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceComponentProperty {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceComponentProperty::V532353(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V532354(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V532355(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68219(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68220(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68221(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68222(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68223(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68224(Some(e)) => e.get_field(field),
                DeviceComponentProperty::V68226(Some(e)) => e.get_field(field),
                DeviceComponentProperty::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceComponentProperty::V532353(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V532354(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V532355(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68219(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68220(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68221(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68222(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68223(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68224(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::V68226(Some(e)) => e.get_field_mut(field),
                DeviceComponentProperty::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceDefinitionStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceDefinitionStatus {
    fn default() -> Self {
        DeviceDefinitionStatus::Null(None)
    }
}
impl TryFrom<String> for DeviceDefinitionStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(DeviceDefinitionStatus::Active(None)),
            "entered-in-error" => Ok(DeviceDefinitionStatus::EnteredInError(None)),
            "inactive" => Ok(DeviceDefinitionStatus::Inactive(None)),
            "unknown" => Ok(DeviceDefinitionStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceDefinitionStatus {
    fn into(self) -> Option<String> {
        match self {
            DeviceDefinitionStatus::Active(_) => Some("active".to_string()),
            DeviceDefinitionStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            DeviceDefinitionStatus::Inactive(_) => Some("inactive".to_string()),
            DeviceDefinitionStatus::Unknown(_) => Some("unknown".to_string()),
            DeviceDefinitionStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceDefinitionStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceDefinitionStatus::Active(Some(e)) => e.get_field(field),
                DeviceDefinitionStatus::EnteredInError(Some(e)) => e.get_field(field),
                DeviceDefinitionStatus::Inactive(Some(e)) => e.get_field(field),
                DeviceDefinitionStatus::Unknown(Some(e)) => e.get_field(field),
                DeviceDefinitionStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceDefinitionStatus::Active(Some(e)) => e.get_field_mut(field),
                DeviceDefinitionStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                DeviceDefinitionStatus::Inactive(Some(e)) => e.get_field_mut(field),
                DeviceDefinitionStatus::Unknown(Some(e)) => e.get_field_mut(field),
                DeviceDefinitionStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceNametype {
    #[doc = "Manufacturer name"]
    #[code = "manufacturer-name"]
    ManufacturerName(Option<Element>),
    #[doc = "Model name"]
    #[code = "model-name"]
    ModelName(Option<Element>),
    #[doc = "other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Patient Reported name"]
    #[code = "patient-reported-name"]
    PatientReportedName(Option<Element>),
    #[doc = "UDI Label name"]
    #[code = "udi-label-name"]
    UdiLabelName(Option<Element>),
    #[doc = "User Friendly name"]
    #[code = "user-friendly-name"]
    UserFriendlyName(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceNametype {
    fn default() -> Self {
        DeviceNametype::Null(None)
    }
}
impl TryFrom<String> for DeviceNametype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "manufacturer-name" => Ok(DeviceNametype::ManufacturerName(None)),
            "model-name" => Ok(DeviceNametype::ModelName(None)),
            "other" => Ok(DeviceNametype::Other(None)),
            "patient-reported-name" => Ok(DeviceNametype::PatientReportedName(None)),
            "udi-label-name" => Ok(DeviceNametype::UdiLabelName(None)),
            "user-friendly-name" => Ok(DeviceNametype::UserFriendlyName(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceNametype {
    fn into(self) -> Option<String> {
        match self {
            DeviceNametype::ManufacturerName(_) => Some("manufacturer-name".to_string()),
            DeviceNametype::ModelName(_) => Some("model-name".to_string()),
            DeviceNametype::Other(_) => Some("other".to_string()),
            DeviceNametype::PatientReportedName(_) => Some("patient-reported-name".to_string()),
            DeviceNametype::UdiLabelName(_) => Some("udi-label-name".to_string()),
            DeviceNametype::UserFriendlyName(_) => Some("user-friendly-name".to_string()),
            DeviceNametype::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceNametype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceNametype::ManufacturerName(Some(e)) => e.get_field(field),
                DeviceNametype::ModelName(Some(e)) => e.get_field(field),
                DeviceNametype::Other(Some(e)) => e.get_field(field),
                DeviceNametype::PatientReportedName(Some(e)) => e.get_field(field),
                DeviceNametype::UdiLabelName(Some(e)) => e.get_field(field),
                DeviceNametype::UserFriendlyName(Some(e)) => e.get_field(field),
                DeviceNametype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceNametype::ManufacturerName(Some(e)) => e.get_field_mut(field),
                DeviceNametype::ModelName(Some(e)) => e.get_field_mut(field),
                DeviceNametype::Other(Some(e)) => e.get_field_mut(field),
                DeviceNametype::PatientReportedName(Some(e)) => e.get_field_mut(field),
                DeviceNametype::UdiLabelName(Some(e)) => e.get_field_mut(field),
                DeviceNametype::UserFriendlyName(Some(e)) => e.get_field_mut(field),
                DeviceNametype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceSafety {
    #[doc = "Labeled as Containing Natural Rubber Latex"]
    #[code = "C101673"]
    C101673(Option<Element>),
    #[doc = "Not Made with Natural Rubber Latex"]
    #[code = "C106038"]
    C106038(Option<Element>),
    #[doc = "Magnetic Resonance Safe"]
    #[code = "C106045"]
    C106045(Option<Element>),
    #[doc = "Magnetic Resonance Conditional"]
    #[code = "C106046"]
    C106046(Option<Element>),
    #[doc = "Magnetic Resonance Unsafe"]
    #[code = "C106047"]
    C106047(Option<Element>),
    #[doc = "Labeling does not Contain MRI Safety Information"]
    #[code = "C113844"]
    C113844(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceSafety {
    fn default() -> Self {
        DeviceSafety::Null(None)
    }
}
impl TryFrom<String> for DeviceSafety {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C101673" => Ok(DeviceSafety::C101673(None)),
            "C106038" => Ok(DeviceSafety::C106038(None)),
            "C106045" => Ok(DeviceSafety::C106045(None)),
            "C106046" => Ok(DeviceSafety::C106046(None)),
            "C106047" => Ok(DeviceSafety::C106047(None)),
            "C113844" => Ok(DeviceSafety::C113844(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceSafety {
    fn into(self) -> Option<String> {
        match self {
            DeviceSafety::C101673(_) => Some("C101673".to_string()),
            DeviceSafety::C106038(_) => Some("C106038".to_string()),
            DeviceSafety::C106045(_) => Some("C106045".to_string()),
            DeviceSafety::C106046(_) => Some("C106046".to_string()),
            DeviceSafety::C106047(_) => Some("C106047".to_string()),
            DeviceSafety::C113844(_) => Some("C113844".to_string()),
            DeviceSafety::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceSafety {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceSafety::C101673(Some(e)) => e.get_field(field),
                DeviceSafety::C106038(Some(e)) => e.get_field(field),
                DeviceSafety::C106045(Some(e)) => e.get_field(field),
                DeviceSafety::C106046(Some(e)) => e.get_field(field),
                DeviceSafety::C106047(Some(e)) => e.get_field(field),
                DeviceSafety::C113844(Some(e)) => e.get_field(field),
                DeviceSafety::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceSafety::C101673(Some(e)) => e.get_field_mut(field),
                DeviceSafety::C106038(Some(e)) => e.get_field_mut(field),
                DeviceSafety::C106045(Some(e)) => e.get_field_mut(field),
                DeviceSafety::C106046(Some(e)) => e.get_field_mut(field),
                DeviceSafety::C106047(Some(e)) => e.get_field_mut(field),
                DeviceSafety::C113844(Some(e)) => e.get_field_mut(field),
                DeviceSafety::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceStatementStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Intended"]
    #[code = "intended"]
    Intended(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceStatementStatus {
    fn default() -> Self {
        DeviceStatementStatus::Null(None)
    }
}
impl TryFrom<String> for DeviceStatementStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(DeviceStatementStatus::Active(None)),
            "completed" => Ok(DeviceStatementStatus::Completed(None)),
            "entered-in-error" => Ok(DeviceStatementStatus::EnteredInError(None)),
            "intended" => Ok(DeviceStatementStatus::Intended(None)),
            "on-hold" => Ok(DeviceStatementStatus::OnHold(None)),
            "stopped" => Ok(DeviceStatementStatus::Stopped(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceStatementStatus {
    fn into(self) -> Option<String> {
        match self {
            DeviceStatementStatus::Active(_) => Some("active".to_string()),
            DeviceStatementStatus::Completed(_) => Some("completed".to_string()),
            DeviceStatementStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            DeviceStatementStatus::Intended(_) => Some("intended".to_string()),
            DeviceStatementStatus::OnHold(_) => Some("on-hold".to_string()),
            DeviceStatementStatus::Stopped(_) => Some("stopped".to_string()),
            DeviceStatementStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceStatementStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceStatementStatus::Active(Some(e)) => e.get_field(field),
                DeviceStatementStatus::Completed(Some(e)) => e.get_field(field),
                DeviceStatementStatus::EnteredInError(Some(e)) => e.get_field(field),
                DeviceStatementStatus::Intended(Some(e)) => e.get_field(field),
                DeviceStatementStatus::OnHold(Some(e)) => e.get_field(field),
                DeviceStatementStatus::Stopped(Some(e)) => e.get_field(field),
                DeviceStatementStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceStatementStatus::Active(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::Completed(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::Intended(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::OnHold(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::Stopped(Some(e)) => e.get_field_mut(field),
                DeviceStatementStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceStatus {
    fn default() -> Self {
        DeviceStatus::Null(None)
    }
}
impl TryFrom<String> for DeviceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(DeviceStatus::Active(None)),
            "entered-in-error" => Ok(DeviceStatus::EnteredInError(None)),
            "inactive" => Ok(DeviceStatus::Inactive(None)),
            "unknown" => Ok(DeviceStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceStatus {
    fn into(self) -> Option<String> {
        match self {
            DeviceStatus::Active(_) => Some("active".to_string()),
            DeviceStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            DeviceStatus::Inactive(_) => Some("inactive".to_string()),
            DeviceStatus::Unknown(_) => Some("unknown".to_string()),
            DeviceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceStatus::Active(Some(e)) => e.get_field(field),
                DeviceStatus::EnteredInError(Some(e)) => e.get_field(field),
                DeviceStatus::Inactive(Some(e)) => e.get_field(field),
                DeviceStatus::Unknown(Some(e)) => e.get_field(field),
                DeviceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceStatus::Active(Some(e)) => e.get_field_mut(field),
                DeviceStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                DeviceStatus::Inactive(Some(e)) => e.get_field_mut(field),
                DeviceStatus::Unknown(Some(e)) => e.get_field_mut(field),
                DeviceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DeviceStatusReason {
    #[doc = "Hardware Disconnected"]
    #[code = "hw-discon"]
    HwDiscon(Option<Element>),
    #[doc = "Not Ready"]
    #[code = "not-ready"]
    NotReady(Option<Element>),
    #[doc = "Off"]
    #[code = "off"]
    Off(Option<Element>),
    #[doc = "Offline"]
    #[code = "offline"]
    Offline(Option<Element>),
    #[doc = "Online"]
    #[code = "online"]
    Online(Option<Element>),
    #[doc = "Paused"]
    #[code = "paused"]
    Paused(Option<Element>),
    #[doc = "Standby"]
    #[code = "standby"]
    Standby(Option<Element>),
    #[doc = "Transducer Disconnected"]
    #[code = "transduc-discon"]
    TransducDiscon(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DeviceStatusReason {
    fn default() -> Self {
        DeviceStatusReason::Null(None)
    }
}
impl TryFrom<String> for DeviceStatusReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "hw-discon" => Ok(DeviceStatusReason::HwDiscon(None)),
            "not-ready" => Ok(DeviceStatusReason::NotReady(None)),
            "off" => Ok(DeviceStatusReason::Off(None)),
            "offline" => Ok(DeviceStatusReason::Offline(None)),
            "online" => Ok(DeviceStatusReason::Online(None)),
            "paused" => Ok(DeviceStatusReason::Paused(None)),
            "standby" => Ok(DeviceStatusReason::Standby(None)),
            "transduc-discon" => Ok(DeviceStatusReason::TransducDiscon(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DeviceStatusReason {
    fn into(self) -> Option<String> {
        match self {
            DeviceStatusReason::HwDiscon(_) => Some("hw-discon".to_string()),
            DeviceStatusReason::NotReady(_) => Some("not-ready".to_string()),
            DeviceStatusReason::Off(_) => Some("off".to_string()),
            DeviceStatusReason::Offline(_) => Some("offline".to_string()),
            DeviceStatusReason::Online(_) => Some("online".to_string()),
            DeviceStatusReason::Paused(_) => Some("paused".to_string()),
            DeviceStatusReason::Standby(_) => Some("standby".to_string()),
            DeviceStatusReason::TransducDiscon(_) => Some("transduc-discon".to_string()),
            DeviceStatusReason::Null(_) => None,
        }
    }
}
impl MetaValue for DeviceStatusReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DeviceStatusReason::HwDiscon(Some(e)) => e.get_field(field),
                DeviceStatusReason::NotReady(Some(e)) => e.get_field(field),
                DeviceStatusReason::Off(Some(e)) => e.get_field(field),
                DeviceStatusReason::Offline(Some(e)) => e.get_field(field),
                DeviceStatusReason::Online(Some(e)) => e.get_field(field),
                DeviceStatusReason::Paused(Some(e)) => e.get_field(field),
                DeviceStatusReason::Standby(Some(e)) => e.get_field(field),
                DeviceStatusReason::TransducDiscon(Some(e)) => e.get_field(field),
                DeviceStatusReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DeviceStatusReason::HwDiscon(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::NotReady(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Off(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Offline(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Online(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Paused(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Standby(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::TransducDiscon(Some(e)) => e.get_field_mut(field),
                DeviceStatusReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DiagnosisRole {
    #[doc = "Admission diagnosis"]
    #[code = "AD"]
    AD(Option<Element>),
    #[doc = "Chief complaint"]
    #[code = "CC"]
    CC(Option<Element>),
    #[doc = "Comorbidity diagnosis"]
    #[code = "CM"]
    CM(Option<Element>),
    #[doc = "Discharge diagnosis"]
    #[code = "DD"]
    DD(Option<Element>),
    #[doc = "Billing"]
    #[code = "billing"]
    Billing(Option<Element>),
    #[doc = "post-op diagnosis"]
    #[code = "post-op"]
    PostOp(Option<Element>),
    #[doc = "pre-op diagnosis"]
    #[code = "pre-op"]
    PreOp(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DiagnosisRole {
    fn default() -> Self {
        DiagnosisRole::Null(None)
    }
}
impl TryFrom<String> for DiagnosisRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AD" => Ok(DiagnosisRole::AD(None)),
            "CC" => Ok(DiagnosisRole::CC(None)),
            "CM" => Ok(DiagnosisRole::CM(None)),
            "DD" => Ok(DiagnosisRole::DD(None)),
            "billing" => Ok(DiagnosisRole::Billing(None)),
            "post-op" => Ok(DiagnosisRole::PostOp(None)),
            "pre-op" => Ok(DiagnosisRole::PreOp(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DiagnosisRole {
    fn into(self) -> Option<String> {
        match self {
            DiagnosisRole::AD(_) => Some("AD".to_string()),
            DiagnosisRole::CC(_) => Some("CC".to_string()),
            DiagnosisRole::CM(_) => Some("CM".to_string()),
            DiagnosisRole::DD(_) => Some("DD".to_string()),
            DiagnosisRole::Billing(_) => Some("billing".to_string()),
            DiagnosisRole::PostOp(_) => Some("post-op".to_string()),
            DiagnosisRole::PreOp(_) => Some("pre-op".to_string()),
            DiagnosisRole::Null(_) => None,
        }
    }
}
impl MetaValue for DiagnosisRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DiagnosisRole::AD(Some(e)) => e.get_field(field),
                DiagnosisRole::CC(Some(e)) => e.get_field(field),
                DiagnosisRole::CM(Some(e)) => e.get_field(field),
                DiagnosisRole::DD(Some(e)) => e.get_field(field),
                DiagnosisRole::Billing(Some(e)) => e.get_field(field),
                DiagnosisRole::PostOp(Some(e)) => e.get_field(field),
                DiagnosisRole::PreOp(Some(e)) => e.get_field(field),
                DiagnosisRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DiagnosisRole::AD(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::CC(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::CM(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::DD(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::Billing(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::PostOp(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::PreOp(Some(e)) => e.get_field_mut(field),
                DiagnosisRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DiagnosticReportStatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Appended"]
    #[code = "appended"]
    Appended(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Corrected"]
    #[code = "corrected"]
    Corrected(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Final"]
    #[code = "final"]
    Final(Option<Element>),
    #[doc = "Partial"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "Preliminary"]
    #[code = "preliminary"]
    Preliminary(Option<Element>),
    #[doc = "Registered"]
    #[code = "registered"]
    Registered(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DiagnosticReportStatus {
    fn default() -> Self {
        DiagnosticReportStatus::Null(None)
    }
}
impl TryFrom<String> for DiagnosticReportStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(DiagnosticReportStatus::Amended(None)),
            "appended" => Ok(DiagnosticReportStatus::Appended(None)),
            "cancelled" => Ok(DiagnosticReportStatus::Cancelled(None)),
            "corrected" => Ok(DiagnosticReportStatus::Corrected(None)),
            "entered-in-error" => Ok(DiagnosticReportStatus::EnteredInError(None)),
            "final" => Ok(DiagnosticReportStatus::Final(None)),
            "partial" => Ok(DiagnosticReportStatus::Partial(None)),
            "preliminary" => Ok(DiagnosticReportStatus::Preliminary(None)),
            "registered" => Ok(DiagnosticReportStatus::Registered(None)),
            "unknown" => Ok(DiagnosticReportStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DiagnosticReportStatus {
    fn into(self) -> Option<String> {
        match self {
            DiagnosticReportStatus::Amended(_) => Some("amended".to_string()),
            DiagnosticReportStatus::Appended(_) => Some("appended".to_string()),
            DiagnosticReportStatus::Cancelled(_) => Some("cancelled".to_string()),
            DiagnosticReportStatus::Corrected(_) => Some("corrected".to_string()),
            DiagnosticReportStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            DiagnosticReportStatus::Final(_) => Some("final".to_string()),
            DiagnosticReportStatus::Partial(_) => Some("partial".to_string()),
            DiagnosticReportStatus::Preliminary(_) => Some("preliminary".to_string()),
            DiagnosticReportStatus::Registered(_) => Some("registered".to_string()),
            DiagnosticReportStatus::Unknown(_) => Some("unknown".to_string()),
            DiagnosticReportStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DiagnosticReportStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DiagnosticReportStatus::Amended(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Appended(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Cancelled(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Corrected(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::EnteredInError(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Final(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Partial(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Preliminary(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Registered(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Unknown(Some(e)) => e.get_field(field),
                DiagnosticReportStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DiagnosticReportStatus::Amended(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Appended(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Corrected(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Final(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Partial(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Preliminary(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Registered(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Unknown(Some(e)) => e.get_field_mut(field),
                DiagnosticReportStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Dicm405Mediatype {
    #[code = "110010"]
    V110010(Option<Element>),
    #[code = "110030"]
    V110030(Option<Element>),
    #[code = "110031"]
    V110031(Option<Element>),
    #[code = "110032"]
    V110032(Option<Element>),
    #[code = "110033"]
    V110033(Option<Element>),
    #[code = "110034"]
    V110034(Option<Element>),
    #[code = "110035"]
    V110035(Option<Element>),
    #[code = "110036"]
    V110036(Option<Element>),
    #[code = "110037"]
    V110037(Option<Element>),
    #[code = "110038"]
    V110038(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Dicm405Mediatype {
    fn default() -> Self {
        Dicm405Mediatype::Null(None)
    }
}
impl TryFrom<String> for Dicm405Mediatype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "110010" => Ok(Dicm405Mediatype::V110010(None)),
            "110030" => Ok(Dicm405Mediatype::V110030(None)),
            "110031" => Ok(Dicm405Mediatype::V110031(None)),
            "110032" => Ok(Dicm405Mediatype::V110032(None)),
            "110033" => Ok(Dicm405Mediatype::V110033(None)),
            "110034" => Ok(Dicm405Mediatype::V110034(None)),
            "110035" => Ok(Dicm405Mediatype::V110035(None)),
            "110036" => Ok(Dicm405Mediatype::V110036(None)),
            "110037" => Ok(Dicm405Mediatype::V110037(None)),
            "110038" => Ok(Dicm405Mediatype::V110038(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Dicm405Mediatype {
    fn into(self) -> Option<String> {
        match self {
            Dicm405Mediatype::V110010(_) => Some("110010".to_string()),
            Dicm405Mediatype::V110030(_) => Some("110030".to_string()),
            Dicm405Mediatype::V110031(_) => Some("110031".to_string()),
            Dicm405Mediatype::V110032(_) => Some("110032".to_string()),
            Dicm405Mediatype::V110033(_) => Some("110033".to_string()),
            Dicm405Mediatype::V110034(_) => Some("110034".to_string()),
            Dicm405Mediatype::V110035(_) => Some("110035".to_string()),
            Dicm405Mediatype::V110036(_) => Some("110036".to_string()),
            Dicm405Mediatype::V110037(_) => Some("110037".to_string()),
            Dicm405Mediatype::V110038(_) => Some("110038".to_string()),
            Dicm405Mediatype::Null(_) => None,
        }
    }
}
impl MetaValue for Dicm405Mediatype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Dicm405Mediatype::V110010(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110030(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110031(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110032(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110033(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110034(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110035(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110036(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110037(Some(e)) => e.get_field(field),
                Dicm405Mediatype::V110038(Some(e)) => e.get_field(field),
                Dicm405Mediatype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Dicm405Mediatype::V110010(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110030(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110031(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110032(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110033(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110034(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110035(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110036(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110037(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::V110038(Some(e)) => e.get_field_mut(field),
                Dicm405Mediatype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DiscriminatorType {
    #[doc = "Exists"]
    #[code = "exists"]
    Exists(Option<Element>),
    #[doc = "Pattern"]
    #[code = "pattern"]
    Pattern(Option<Element>),
    #[doc = "Profile"]
    #[code = "profile"]
    Profile(Option<Element>),
    #[doc = "Type"]
    #[code = "type"]
    Type(Option<Element>),
    #[doc = "Value"]
    #[code = "value"]
    Value(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DiscriminatorType {
    fn default() -> Self {
        DiscriminatorType::Null(None)
    }
}
impl TryFrom<String> for DiscriminatorType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exists" => Ok(DiscriminatorType::Exists(None)),
            "pattern" => Ok(DiscriminatorType::Pattern(None)),
            "profile" => Ok(DiscriminatorType::Profile(None)),
            "type" => Ok(DiscriminatorType::Type(None)),
            "value" => Ok(DiscriminatorType::Value(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DiscriminatorType {
    fn into(self) -> Option<String> {
        match self {
            DiscriminatorType::Exists(_) => Some("exists".to_string()),
            DiscriminatorType::Pattern(_) => Some("pattern".to_string()),
            DiscriminatorType::Profile(_) => Some("profile".to_string()),
            DiscriminatorType::Type(_) => Some("type".to_string()),
            DiscriminatorType::Value(_) => Some("value".to_string()),
            DiscriminatorType::Null(_) => None,
        }
    }
}
impl MetaValue for DiscriminatorType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DiscriminatorType::Exists(Some(e)) => e.get_field(field),
                DiscriminatorType::Pattern(Some(e)) => e.get_field(field),
                DiscriminatorType::Profile(Some(e)) => e.get_field(field),
                DiscriminatorType::Type(Some(e)) => e.get_field(field),
                DiscriminatorType::Value(Some(e)) => e.get_field(field),
                DiscriminatorType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DiscriminatorType::Exists(Some(e)) => e.get_field_mut(field),
                DiscriminatorType::Pattern(Some(e)) => e.get_field_mut(field),
                DiscriminatorType::Profile(Some(e)) => e.get_field_mut(field),
                DiscriminatorType::Type(Some(e)) => e.get_field_mut(field),
                DiscriminatorType::Value(Some(e)) => e.get_field_mut(field),
                DiscriminatorType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DistanceUnits {
    #[doc = "kilometers"]
    #[code = "km"]
    Km(Option<Element>),
    #[doc = "meters"]
    #[code = "m"]
    M(Option<Element>),
    #[doc = "millimeters"]
    #[code = "mm"]
    Mm(Option<Element>),
    #[doc = "nanometers"]
    #[code = "nm"]
    Nm(Option<Element>),
    #[doc = "micrometers"]
    #[code = "um"]
    Um(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DistanceUnits {
    fn default() -> Self {
        DistanceUnits::Null(None)
    }
}
impl TryFrom<String> for DistanceUnits {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "km" => Ok(DistanceUnits::Km(None)),
            "m" => Ok(DistanceUnits::M(None)),
            "mm" => Ok(DistanceUnits::Mm(None)),
            "nm" => Ok(DistanceUnits::Nm(None)),
            "um" => Ok(DistanceUnits::Um(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DistanceUnits {
    fn into(self) -> Option<String> {
        match self {
            DistanceUnits::Km(_) => Some("km".to_string()),
            DistanceUnits::M(_) => Some("m".to_string()),
            DistanceUnits::Mm(_) => Some("mm".to_string()),
            DistanceUnits::Nm(_) => Some("nm".to_string()),
            DistanceUnits::Um(_) => Some("um".to_string()),
            DistanceUnits::Null(_) => None,
        }
    }
}
impl MetaValue for DistanceUnits {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DistanceUnits::Km(Some(e)) => e.get_field(field),
                DistanceUnits::M(Some(e)) => e.get_field(field),
                DistanceUnits::Mm(Some(e)) => e.get_field(field),
                DistanceUnits::Nm(Some(e)) => e.get_field(field),
                DistanceUnits::Um(Some(e)) => e.get_field(field),
                DistanceUnits::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DistanceUnits::Km(Some(e)) => e.get_field_mut(field),
                DistanceUnits::M(Some(e)) => e.get_field_mut(field),
                DistanceUnits::Mm(Some(e)) => e.get_field_mut(field),
                DistanceUnits::Nm(Some(e)) => e.get_field_mut(field),
                DistanceUnits::Um(Some(e)) => e.get_field_mut(field),
                DistanceUnits::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DocSectionCodes {
    #[code = "10154-3"]
    V101543(Option<Element>),
    #[code = "10157-6"]
    V101576(Option<Element>),
    #[code = "10160-0"]
    V101600(Option<Element>),
    #[code = "10164-2"]
    V101642(Option<Element>),
    #[code = "10183-2"]
    V101832(Option<Element>),
    #[code = "10184-0"]
    V101840(Option<Element>),
    #[code = "10187-3"]
    V101873(Option<Element>),
    #[code = "10210-3"]
    V102103(Option<Element>),
    #[code = "10216-0"]
    V102160(Option<Element>),
    #[code = "10218-6"]
    V102186(Option<Element>),
    #[code = "10222-8"]
    V102228(Option<Element>),
    #[code = "10223-6"]
    V102236(Option<Element>),
    #[code = "11329-0"]
    V113290(Option<Element>),
    #[code = "11348-0"]
    V113480(Option<Element>),
    #[code = "11369-6"]
    V113696(Option<Element>),
    #[code = "11493-4"]
    V114934(Option<Element>),
    #[code = "11535-2"]
    V115352(Option<Element>),
    #[code = "11537-8"]
    V115378(Option<Element>),
    #[code = "18776-5"]
    V187765(Option<Element>),
    #[code = "18841-7"]
    V188417(Option<Element>),
    #[code = "29299-5"]
    V292995(Option<Element>),
    #[code = "29545-1"]
    V295451(Option<Element>),
    #[code = "29549-3"]
    V295493(Option<Element>),
    #[code = "29554-3"]
    V295543(Option<Element>),
    #[code = "29762-2"]
    V297622(Option<Element>),
    #[code = "30954-2"]
    V309542(Option<Element>),
    #[code = "42344-2"]
    V423442(Option<Element>),
    #[code = "42346-7"]
    V423467(Option<Element>),
    #[code = "42348-3"]
    V423483(Option<Element>),
    #[code = "42349-1"]
    V423491(Option<Element>),
    #[code = "46240-8"]
    V462408(Option<Element>),
    #[code = "46241-6"]
    V462416(Option<Element>),
    #[code = "46264-8"]
    V462648(Option<Element>),
    #[code = "47420-5"]
    V474205(Option<Element>),
    #[code = "47519-4"]
    V475194(Option<Element>),
    #[code = "48765-2"]
    V487652(Option<Element>),
    #[code = "48768-6"]
    V487686(Option<Element>),
    #[code = "51848-0"]
    V518480(Option<Element>),
    #[code = "55109-3"]
    V551093(Option<Element>),
    #[code = "55122-6"]
    V551226(Option<Element>),
    #[code = "57852-6"]
    V578526(Option<Element>),
    #[code = "59768-2"]
    V597682(Option<Element>),
    #[code = "59769-0"]
    V597690(Option<Element>),
    #[code = "59770-8"]
    V597708(Option<Element>),
    #[code = "59771-6"]
    V597716(Option<Element>),
    #[code = "59772-4"]
    V597724(Option<Element>),
    #[code = "59773-2"]
    V597732(Option<Element>),
    #[code = "59775-7"]
    V597757(Option<Element>),
    #[code = "59776-5"]
    V597765(Option<Element>),
    #[code = "61149-1"]
    V611491(Option<Element>),
    #[code = "61150-9"]
    V611509(Option<Element>),
    #[code = "69730-0"]
    V697300(Option<Element>),
    #[code = "8648-8"]
    V86488(Option<Element>),
    #[code = "8653-8"]
    V86538(Option<Element>),
    #[code = "8716-3"]
    V87163(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DocSectionCodes {
    fn default() -> Self {
        DocSectionCodes::Null(None)
    }
}
impl TryFrom<String> for DocSectionCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "10154-3" => Ok(DocSectionCodes::V101543(None)),
            "10157-6" => Ok(DocSectionCodes::V101576(None)),
            "10160-0" => Ok(DocSectionCodes::V101600(None)),
            "10164-2" => Ok(DocSectionCodes::V101642(None)),
            "10183-2" => Ok(DocSectionCodes::V101832(None)),
            "10184-0" => Ok(DocSectionCodes::V101840(None)),
            "10187-3" => Ok(DocSectionCodes::V101873(None)),
            "10210-3" => Ok(DocSectionCodes::V102103(None)),
            "10216-0" => Ok(DocSectionCodes::V102160(None)),
            "10218-6" => Ok(DocSectionCodes::V102186(None)),
            "10222-8" => Ok(DocSectionCodes::V102228(None)),
            "10223-6" => Ok(DocSectionCodes::V102236(None)),
            "11329-0" => Ok(DocSectionCodes::V113290(None)),
            "11348-0" => Ok(DocSectionCodes::V113480(None)),
            "11369-6" => Ok(DocSectionCodes::V113696(None)),
            "11493-4" => Ok(DocSectionCodes::V114934(None)),
            "11535-2" => Ok(DocSectionCodes::V115352(None)),
            "11537-8" => Ok(DocSectionCodes::V115378(None)),
            "18776-5" => Ok(DocSectionCodes::V187765(None)),
            "18841-7" => Ok(DocSectionCodes::V188417(None)),
            "29299-5" => Ok(DocSectionCodes::V292995(None)),
            "29545-1" => Ok(DocSectionCodes::V295451(None)),
            "29549-3" => Ok(DocSectionCodes::V295493(None)),
            "29554-3" => Ok(DocSectionCodes::V295543(None)),
            "29762-2" => Ok(DocSectionCodes::V297622(None)),
            "30954-2" => Ok(DocSectionCodes::V309542(None)),
            "42344-2" => Ok(DocSectionCodes::V423442(None)),
            "42346-7" => Ok(DocSectionCodes::V423467(None)),
            "42348-3" => Ok(DocSectionCodes::V423483(None)),
            "42349-1" => Ok(DocSectionCodes::V423491(None)),
            "46240-8" => Ok(DocSectionCodes::V462408(None)),
            "46241-6" => Ok(DocSectionCodes::V462416(None)),
            "46264-8" => Ok(DocSectionCodes::V462648(None)),
            "47420-5" => Ok(DocSectionCodes::V474205(None)),
            "47519-4" => Ok(DocSectionCodes::V475194(None)),
            "48765-2" => Ok(DocSectionCodes::V487652(None)),
            "48768-6" => Ok(DocSectionCodes::V487686(None)),
            "51848-0" => Ok(DocSectionCodes::V518480(None)),
            "55109-3" => Ok(DocSectionCodes::V551093(None)),
            "55122-6" => Ok(DocSectionCodes::V551226(None)),
            "57852-6" => Ok(DocSectionCodes::V578526(None)),
            "59768-2" => Ok(DocSectionCodes::V597682(None)),
            "59769-0" => Ok(DocSectionCodes::V597690(None)),
            "59770-8" => Ok(DocSectionCodes::V597708(None)),
            "59771-6" => Ok(DocSectionCodes::V597716(None)),
            "59772-4" => Ok(DocSectionCodes::V597724(None)),
            "59773-2" => Ok(DocSectionCodes::V597732(None)),
            "59775-7" => Ok(DocSectionCodes::V597757(None)),
            "59776-5" => Ok(DocSectionCodes::V597765(None)),
            "61149-1" => Ok(DocSectionCodes::V611491(None)),
            "61150-9" => Ok(DocSectionCodes::V611509(None)),
            "69730-0" => Ok(DocSectionCodes::V697300(None)),
            "8648-8" => Ok(DocSectionCodes::V86488(None)),
            "8653-8" => Ok(DocSectionCodes::V86538(None)),
            "8716-3" => Ok(DocSectionCodes::V87163(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DocSectionCodes {
    fn into(self) -> Option<String> {
        match self {
            DocSectionCodes::V101543(_) => Some("10154-3".to_string()),
            DocSectionCodes::V101576(_) => Some("10157-6".to_string()),
            DocSectionCodes::V101600(_) => Some("10160-0".to_string()),
            DocSectionCodes::V101642(_) => Some("10164-2".to_string()),
            DocSectionCodes::V101832(_) => Some("10183-2".to_string()),
            DocSectionCodes::V101840(_) => Some("10184-0".to_string()),
            DocSectionCodes::V101873(_) => Some("10187-3".to_string()),
            DocSectionCodes::V102103(_) => Some("10210-3".to_string()),
            DocSectionCodes::V102160(_) => Some("10216-0".to_string()),
            DocSectionCodes::V102186(_) => Some("10218-6".to_string()),
            DocSectionCodes::V102228(_) => Some("10222-8".to_string()),
            DocSectionCodes::V102236(_) => Some("10223-6".to_string()),
            DocSectionCodes::V113290(_) => Some("11329-0".to_string()),
            DocSectionCodes::V113480(_) => Some("11348-0".to_string()),
            DocSectionCodes::V113696(_) => Some("11369-6".to_string()),
            DocSectionCodes::V114934(_) => Some("11493-4".to_string()),
            DocSectionCodes::V115352(_) => Some("11535-2".to_string()),
            DocSectionCodes::V115378(_) => Some("11537-8".to_string()),
            DocSectionCodes::V187765(_) => Some("18776-5".to_string()),
            DocSectionCodes::V188417(_) => Some("18841-7".to_string()),
            DocSectionCodes::V292995(_) => Some("29299-5".to_string()),
            DocSectionCodes::V295451(_) => Some("29545-1".to_string()),
            DocSectionCodes::V295493(_) => Some("29549-3".to_string()),
            DocSectionCodes::V295543(_) => Some("29554-3".to_string()),
            DocSectionCodes::V297622(_) => Some("29762-2".to_string()),
            DocSectionCodes::V309542(_) => Some("30954-2".to_string()),
            DocSectionCodes::V423442(_) => Some("42344-2".to_string()),
            DocSectionCodes::V423467(_) => Some("42346-7".to_string()),
            DocSectionCodes::V423483(_) => Some("42348-3".to_string()),
            DocSectionCodes::V423491(_) => Some("42349-1".to_string()),
            DocSectionCodes::V462408(_) => Some("46240-8".to_string()),
            DocSectionCodes::V462416(_) => Some("46241-6".to_string()),
            DocSectionCodes::V462648(_) => Some("46264-8".to_string()),
            DocSectionCodes::V474205(_) => Some("47420-5".to_string()),
            DocSectionCodes::V475194(_) => Some("47519-4".to_string()),
            DocSectionCodes::V487652(_) => Some("48765-2".to_string()),
            DocSectionCodes::V487686(_) => Some("48768-6".to_string()),
            DocSectionCodes::V518480(_) => Some("51848-0".to_string()),
            DocSectionCodes::V551093(_) => Some("55109-3".to_string()),
            DocSectionCodes::V551226(_) => Some("55122-6".to_string()),
            DocSectionCodes::V578526(_) => Some("57852-6".to_string()),
            DocSectionCodes::V597682(_) => Some("59768-2".to_string()),
            DocSectionCodes::V597690(_) => Some("59769-0".to_string()),
            DocSectionCodes::V597708(_) => Some("59770-8".to_string()),
            DocSectionCodes::V597716(_) => Some("59771-6".to_string()),
            DocSectionCodes::V597724(_) => Some("59772-4".to_string()),
            DocSectionCodes::V597732(_) => Some("59773-2".to_string()),
            DocSectionCodes::V597757(_) => Some("59775-7".to_string()),
            DocSectionCodes::V597765(_) => Some("59776-5".to_string()),
            DocSectionCodes::V611491(_) => Some("61149-1".to_string()),
            DocSectionCodes::V611509(_) => Some("61150-9".to_string()),
            DocSectionCodes::V697300(_) => Some("69730-0".to_string()),
            DocSectionCodes::V86488(_) => Some("8648-8".to_string()),
            DocSectionCodes::V86538(_) => Some("8653-8".to_string()),
            DocSectionCodes::V87163(_) => Some("8716-3".to_string()),
            DocSectionCodes::Null(_) => None,
        }
    }
}
impl MetaValue for DocSectionCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DocSectionCodes::V101543(Some(e)) => e.get_field(field),
                DocSectionCodes::V101576(Some(e)) => e.get_field(field),
                DocSectionCodes::V101600(Some(e)) => e.get_field(field),
                DocSectionCodes::V101642(Some(e)) => e.get_field(field),
                DocSectionCodes::V101832(Some(e)) => e.get_field(field),
                DocSectionCodes::V101840(Some(e)) => e.get_field(field),
                DocSectionCodes::V101873(Some(e)) => e.get_field(field),
                DocSectionCodes::V102103(Some(e)) => e.get_field(field),
                DocSectionCodes::V102160(Some(e)) => e.get_field(field),
                DocSectionCodes::V102186(Some(e)) => e.get_field(field),
                DocSectionCodes::V102228(Some(e)) => e.get_field(field),
                DocSectionCodes::V102236(Some(e)) => e.get_field(field),
                DocSectionCodes::V113290(Some(e)) => e.get_field(field),
                DocSectionCodes::V113480(Some(e)) => e.get_field(field),
                DocSectionCodes::V113696(Some(e)) => e.get_field(field),
                DocSectionCodes::V114934(Some(e)) => e.get_field(field),
                DocSectionCodes::V115352(Some(e)) => e.get_field(field),
                DocSectionCodes::V115378(Some(e)) => e.get_field(field),
                DocSectionCodes::V187765(Some(e)) => e.get_field(field),
                DocSectionCodes::V188417(Some(e)) => e.get_field(field),
                DocSectionCodes::V292995(Some(e)) => e.get_field(field),
                DocSectionCodes::V295451(Some(e)) => e.get_field(field),
                DocSectionCodes::V295493(Some(e)) => e.get_field(field),
                DocSectionCodes::V295543(Some(e)) => e.get_field(field),
                DocSectionCodes::V297622(Some(e)) => e.get_field(field),
                DocSectionCodes::V309542(Some(e)) => e.get_field(field),
                DocSectionCodes::V423442(Some(e)) => e.get_field(field),
                DocSectionCodes::V423467(Some(e)) => e.get_field(field),
                DocSectionCodes::V423483(Some(e)) => e.get_field(field),
                DocSectionCodes::V423491(Some(e)) => e.get_field(field),
                DocSectionCodes::V462408(Some(e)) => e.get_field(field),
                DocSectionCodes::V462416(Some(e)) => e.get_field(field),
                DocSectionCodes::V462648(Some(e)) => e.get_field(field),
                DocSectionCodes::V474205(Some(e)) => e.get_field(field),
                DocSectionCodes::V475194(Some(e)) => e.get_field(field),
                DocSectionCodes::V487652(Some(e)) => e.get_field(field),
                DocSectionCodes::V487686(Some(e)) => e.get_field(field),
                DocSectionCodes::V518480(Some(e)) => e.get_field(field),
                DocSectionCodes::V551093(Some(e)) => e.get_field(field),
                DocSectionCodes::V551226(Some(e)) => e.get_field(field),
                DocSectionCodes::V578526(Some(e)) => e.get_field(field),
                DocSectionCodes::V597682(Some(e)) => e.get_field(field),
                DocSectionCodes::V597690(Some(e)) => e.get_field(field),
                DocSectionCodes::V597708(Some(e)) => e.get_field(field),
                DocSectionCodes::V597716(Some(e)) => e.get_field(field),
                DocSectionCodes::V597724(Some(e)) => e.get_field(field),
                DocSectionCodes::V597732(Some(e)) => e.get_field(field),
                DocSectionCodes::V597757(Some(e)) => e.get_field(field),
                DocSectionCodes::V597765(Some(e)) => e.get_field(field),
                DocSectionCodes::V611491(Some(e)) => e.get_field(field),
                DocSectionCodes::V611509(Some(e)) => e.get_field(field),
                DocSectionCodes::V697300(Some(e)) => e.get_field(field),
                DocSectionCodes::V86488(Some(e)) => e.get_field(field),
                DocSectionCodes::V86538(Some(e)) => e.get_field(field),
                DocSectionCodes::V87163(Some(e)) => e.get_field(field),
                DocSectionCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DocSectionCodes::V101543(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101576(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101600(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101642(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101832(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101840(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V101873(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V102103(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V102160(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V102186(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V102228(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V102236(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V113290(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V113480(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V113696(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V114934(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V115352(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V115378(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V187765(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V188417(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V292995(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V295451(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V295493(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V295543(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V297622(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V309542(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V423442(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V423467(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V423483(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V423491(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V462408(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V462416(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V462648(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V474205(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V475194(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V487652(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V487686(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V518480(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V551093(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V551226(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V578526(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597682(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597690(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597708(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597716(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597724(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597732(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597757(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V597765(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V611491(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V611509(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V697300(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V86488(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V86538(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::V87163(Some(e)) => e.get_field_mut(field),
                DocSectionCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DocumentClasscodes {
    #[doc = "History of Immunization"]
    #[code = "11369-6"]
    V113696(Option<Element>),
    #[doc = "Anesthesia records"]
    #[code = "11485-0"]
    V114850(Option<Element>),
    #[doc = "Chemotherapy records"]
    #[code = "11486-8"]
    V114868(Option<Element>),
    #[doc = "Consult Note"]
    #[code = "11488-4"]
    V114884(Option<Element>),
    #[doc = "Surgical operation note "]
    #[code = "11504-8"]
    V115048(Option<Element>),
    #[doc = "Provider-unspecified progress note"]
    #[code = "11506-3"]
    V115063(Option<Element>),
    #[doc = "Nursery records"]
    #[code = "11543-6"]
    V115436(Option<Element>),
    #[doc = "Labor and delivery records"]
    #[code = "15508-5"]
    V155085(Option<Element>),
    #[doc = "Radiology studies (set)"]
    #[code = "18726-0"]
    V187260(Option<Element>),
    #[doc = "Diagnostic imaging study"]
    #[code = "18748-4"]
    V187484(Option<Element>),
    #[doc = "Provider-unspecified transfer summary"]
    #[code = "18761-7"]
    V187617(Option<Element>),
    #[doc = "Discharge summary"]
    #[code = "18842-5"]
    V188425(Option<Element>),
    #[doc = "Laboratory Studies (set)"]
    #[code = "26436-6"]
    V264366(Option<Element>),
    #[doc = "Cardiology studies (set)"]
    #[code = "26441-6"]
    V264416(Option<Element>),
    #[doc = "Obstetrical studies (set)"]
    #[code = "26442-4"]
    V264424(Option<Element>),
    #[doc = "Gastroenterology endoscopy studies (set)"]
    #[code = "27895-2"]
    V278952(Option<Element>),
    #[doc = "Pulmonary studies (set)"]
    #[code = "27896-0"]
    V278960(Option<Element>),
    #[doc = "Neuromuscular electrophysiology studies (set)"]
    #[code = "27897-8"]
    V278978(Option<Element>),
    #[doc = "Pathology studies (set)"]
    #[code = "27898-6"]
    V278986(Option<Element>),
    #[doc = "Provider-unspecified procedure note"]
    #[code = "28570-0"]
    V285700(Option<Element>),
    #[doc = "Ophthalmology/optometry studies (set)"]
    #[code = "28619-5"]
    V286195(Option<Element>),
    #[doc = "Miscellaneous studies (set)"]
    #[code = "28634-4"]
    V286344(Option<Element>),
    #[doc = "Dialysis records"]
    #[code = "29749-9"]
    V297499(Option<Element>),
    #[doc = "Neonatal intensive care records"]
    #[code = "29750-7"]
    V297507(Option<Element>),
    #[doc = "Critical care records"]
    #[code = "29751-5"]
    V297515(Option<Element>),
    #[doc = "Perioperative records"]
    #[code = "29752-3"]
    V297523(Option<Element>),
    #[doc = "Evaluation and management note"]
    #[code = "34109-9"]
    V341099(Option<Element>),
    #[doc = "Provider-unspecified, History and physical note"]
    #[code = "34117-2"]
    V341172(Option<Element>),
    #[doc = "Interventional procedure note"]
    #[code = "34121-4"]
    V341214(Option<Element>),
    #[doc = "Pathology procedure note"]
    #[code = "34122-2"]
    V341222(Option<Element>),
    #[doc = "Summarization of episode note"]
    #[code = "34133-9"]
    V341339(Option<Element>),
    #[doc = "Transfer of care referral note"]
    #[code = "34140-4"]
    V341404(Option<Element>),
    #[doc = "Telephone encounter note"]
    #[code = "34748-4"]
    V347484(Option<Element>),
    #[doc = "General surgery Pre-operative evaluation and management note"]
    #[code = "34775-7"]
    V347757(Option<Element>),
    #[doc = "Inpatient Admission history and physical note"]
    #[code = "47039-3"]
    V470393(Option<Element>),
    #[doc = "Counseling note"]
    #[code = "47042-7"]
    V470427(Option<Element>),
    #[doc = "Study report Document"]
    #[code = "47045-0"]
    V470450(Option<Element>),
    #[doc = "Summary of death"]
    #[code = "47046-8"]
    V470468(Option<Element>),
    #[doc = "Non-patient Communication"]
    #[code = "47049-2"]
    V470492(Option<Element>),
    #[doc = "Personal health monitoring report Document"]
    #[code = "53576-5"]
    V535765(Option<Element>),
    #[doc = "Medication Summary Document"]
    #[code = "56445-0"]
    V564450(Option<Element>),
    #[doc = "Plan of care note"]
    #[code = "56447-6"]
    V564476(Option<Element>),
    #[doc = "Privacy Policy Acknowledgment Document"]
    #[code = "57016-8"]
    V570168(Option<Element>),
    #[doc = "Privacy Policy Organization Document"]
    #[code = "57017-6"]
    V570176(Option<Element>),
    #[doc = "Referral note"]
    #[code = "57133-1"]
    V571331(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DocumentClasscodes {
    fn default() -> Self {
        DocumentClasscodes::Null(None)
    }
}
impl TryFrom<String> for DocumentClasscodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "11369-6" => Ok(DocumentClasscodes::V113696(None)),
            "11485-0" => Ok(DocumentClasscodes::V114850(None)),
            "11486-8" => Ok(DocumentClasscodes::V114868(None)),
            "11488-4" => Ok(DocumentClasscodes::V114884(None)),
            "11504-8" => Ok(DocumentClasscodes::V115048(None)),
            "11506-3" => Ok(DocumentClasscodes::V115063(None)),
            "11543-6" => Ok(DocumentClasscodes::V115436(None)),
            "15508-5" => Ok(DocumentClasscodes::V155085(None)),
            "18726-0" => Ok(DocumentClasscodes::V187260(None)),
            "18748-4" => Ok(DocumentClasscodes::V187484(None)),
            "18761-7" => Ok(DocumentClasscodes::V187617(None)),
            "18842-5" => Ok(DocumentClasscodes::V188425(None)),
            "26436-6" => Ok(DocumentClasscodes::V264366(None)),
            "26441-6" => Ok(DocumentClasscodes::V264416(None)),
            "26442-4" => Ok(DocumentClasscodes::V264424(None)),
            "27895-2" => Ok(DocumentClasscodes::V278952(None)),
            "27896-0" => Ok(DocumentClasscodes::V278960(None)),
            "27897-8" => Ok(DocumentClasscodes::V278978(None)),
            "27898-6" => Ok(DocumentClasscodes::V278986(None)),
            "28570-0" => Ok(DocumentClasscodes::V285700(None)),
            "28619-5" => Ok(DocumentClasscodes::V286195(None)),
            "28634-4" => Ok(DocumentClasscodes::V286344(None)),
            "29749-9" => Ok(DocumentClasscodes::V297499(None)),
            "29750-7" => Ok(DocumentClasscodes::V297507(None)),
            "29751-5" => Ok(DocumentClasscodes::V297515(None)),
            "29752-3" => Ok(DocumentClasscodes::V297523(None)),
            "34109-9" => Ok(DocumentClasscodes::V341099(None)),
            "34117-2" => Ok(DocumentClasscodes::V341172(None)),
            "34121-4" => Ok(DocumentClasscodes::V341214(None)),
            "34122-2" => Ok(DocumentClasscodes::V341222(None)),
            "34133-9" => Ok(DocumentClasscodes::V341339(None)),
            "34140-4" => Ok(DocumentClasscodes::V341404(None)),
            "34748-4" => Ok(DocumentClasscodes::V347484(None)),
            "34775-7" => Ok(DocumentClasscodes::V347757(None)),
            "47039-3" => Ok(DocumentClasscodes::V470393(None)),
            "47042-7" => Ok(DocumentClasscodes::V470427(None)),
            "47045-0" => Ok(DocumentClasscodes::V470450(None)),
            "47046-8" => Ok(DocumentClasscodes::V470468(None)),
            "47049-2" => Ok(DocumentClasscodes::V470492(None)),
            "53576-5" => Ok(DocumentClasscodes::V535765(None)),
            "56445-0" => Ok(DocumentClasscodes::V564450(None)),
            "56447-6" => Ok(DocumentClasscodes::V564476(None)),
            "57016-8" => Ok(DocumentClasscodes::V570168(None)),
            "57017-6" => Ok(DocumentClasscodes::V570176(None)),
            "57133-1" => Ok(DocumentClasscodes::V571331(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DocumentClasscodes {
    fn into(self) -> Option<String> {
        match self {
            DocumentClasscodes::V113696(_) => Some("11369-6".to_string()),
            DocumentClasscodes::V114850(_) => Some("11485-0".to_string()),
            DocumentClasscodes::V114868(_) => Some("11486-8".to_string()),
            DocumentClasscodes::V114884(_) => Some("11488-4".to_string()),
            DocumentClasscodes::V115048(_) => Some("11504-8".to_string()),
            DocumentClasscodes::V115063(_) => Some("11506-3".to_string()),
            DocumentClasscodes::V115436(_) => Some("11543-6".to_string()),
            DocumentClasscodes::V155085(_) => Some("15508-5".to_string()),
            DocumentClasscodes::V187260(_) => Some("18726-0".to_string()),
            DocumentClasscodes::V187484(_) => Some("18748-4".to_string()),
            DocumentClasscodes::V187617(_) => Some("18761-7".to_string()),
            DocumentClasscodes::V188425(_) => Some("18842-5".to_string()),
            DocumentClasscodes::V264366(_) => Some("26436-6".to_string()),
            DocumentClasscodes::V264416(_) => Some("26441-6".to_string()),
            DocumentClasscodes::V264424(_) => Some("26442-4".to_string()),
            DocumentClasscodes::V278952(_) => Some("27895-2".to_string()),
            DocumentClasscodes::V278960(_) => Some("27896-0".to_string()),
            DocumentClasscodes::V278978(_) => Some("27897-8".to_string()),
            DocumentClasscodes::V278986(_) => Some("27898-6".to_string()),
            DocumentClasscodes::V285700(_) => Some("28570-0".to_string()),
            DocumentClasscodes::V286195(_) => Some("28619-5".to_string()),
            DocumentClasscodes::V286344(_) => Some("28634-4".to_string()),
            DocumentClasscodes::V297499(_) => Some("29749-9".to_string()),
            DocumentClasscodes::V297507(_) => Some("29750-7".to_string()),
            DocumentClasscodes::V297515(_) => Some("29751-5".to_string()),
            DocumentClasscodes::V297523(_) => Some("29752-3".to_string()),
            DocumentClasscodes::V341099(_) => Some("34109-9".to_string()),
            DocumentClasscodes::V341172(_) => Some("34117-2".to_string()),
            DocumentClasscodes::V341214(_) => Some("34121-4".to_string()),
            DocumentClasscodes::V341222(_) => Some("34122-2".to_string()),
            DocumentClasscodes::V341339(_) => Some("34133-9".to_string()),
            DocumentClasscodes::V341404(_) => Some("34140-4".to_string()),
            DocumentClasscodes::V347484(_) => Some("34748-4".to_string()),
            DocumentClasscodes::V347757(_) => Some("34775-7".to_string()),
            DocumentClasscodes::V470393(_) => Some("47039-3".to_string()),
            DocumentClasscodes::V470427(_) => Some("47042-7".to_string()),
            DocumentClasscodes::V470450(_) => Some("47045-0".to_string()),
            DocumentClasscodes::V470468(_) => Some("47046-8".to_string()),
            DocumentClasscodes::V470492(_) => Some("47049-2".to_string()),
            DocumentClasscodes::V535765(_) => Some("53576-5".to_string()),
            DocumentClasscodes::V564450(_) => Some("56445-0".to_string()),
            DocumentClasscodes::V564476(_) => Some("56447-6".to_string()),
            DocumentClasscodes::V570168(_) => Some("57016-8".to_string()),
            DocumentClasscodes::V570176(_) => Some("57017-6".to_string()),
            DocumentClasscodes::V571331(_) => Some("57133-1".to_string()),
            DocumentClasscodes::Null(_) => None,
        }
    }
}
impl MetaValue for DocumentClasscodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DocumentClasscodes::V113696(Some(e)) => e.get_field(field),
                DocumentClasscodes::V114850(Some(e)) => e.get_field(field),
                DocumentClasscodes::V114868(Some(e)) => e.get_field(field),
                DocumentClasscodes::V114884(Some(e)) => e.get_field(field),
                DocumentClasscodes::V115048(Some(e)) => e.get_field(field),
                DocumentClasscodes::V115063(Some(e)) => e.get_field(field),
                DocumentClasscodes::V115436(Some(e)) => e.get_field(field),
                DocumentClasscodes::V155085(Some(e)) => e.get_field(field),
                DocumentClasscodes::V187260(Some(e)) => e.get_field(field),
                DocumentClasscodes::V187484(Some(e)) => e.get_field(field),
                DocumentClasscodes::V187617(Some(e)) => e.get_field(field),
                DocumentClasscodes::V188425(Some(e)) => e.get_field(field),
                DocumentClasscodes::V264366(Some(e)) => e.get_field(field),
                DocumentClasscodes::V264416(Some(e)) => e.get_field(field),
                DocumentClasscodes::V264424(Some(e)) => e.get_field(field),
                DocumentClasscodes::V278952(Some(e)) => e.get_field(field),
                DocumentClasscodes::V278960(Some(e)) => e.get_field(field),
                DocumentClasscodes::V278978(Some(e)) => e.get_field(field),
                DocumentClasscodes::V278986(Some(e)) => e.get_field(field),
                DocumentClasscodes::V285700(Some(e)) => e.get_field(field),
                DocumentClasscodes::V286195(Some(e)) => e.get_field(field),
                DocumentClasscodes::V286344(Some(e)) => e.get_field(field),
                DocumentClasscodes::V297499(Some(e)) => e.get_field(field),
                DocumentClasscodes::V297507(Some(e)) => e.get_field(field),
                DocumentClasscodes::V297515(Some(e)) => e.get_field(field),
                DocumentClasscodes::V297523(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341099(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341172(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341214(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341222(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341339(Some(e)) => e.get_field(field),
                DocumentClasscodes::V341404(Some(e)) => e.get_field(field),
                DocumentClasscodes::V347484(Some(e)) => e.get_field(field),
                DocumentClasscodes::V347757(Some(e)) => e.get_field(field),
                DocumentClasscodes::V470393(Some(e)) => e.get_field(field),
                DocumentClasscodes::V470427(Some(e)) => e.get_field(field),
                DocumentClasscodes::V470450(Some(e)) => e.get_field(field),
                DocumentClasscodes::V470468(Some(e)) => e.get_field(field),
                DocumentClasscodes::V470492(Some(e)) => e.get_field(field),
                DocumentClasscodes::V535765(Some(e)) => e.get_field(field),
                DocumentClasscodes::V564450(Some(e)) => e.get_field(field),
                DocumentClasscodes::V564476(Some(e)) => e.get_field(field),
                DocumentClasscodes::V570168(Some(e)) => e.get_field(field),
                DocumentClasscodes::V570176(Some(e)) => e.get_field(field),
                DocumentClasscodes::V571331(Some(e)) => e.get_field(field),
                DocumentClasscodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DocumentClasscodes::V113696(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V114850(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V114868(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V114884(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V115048(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V115063(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V115436(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V155085(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V187260(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V187484(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V187617(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V188425(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V264366(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V264416(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V264424(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V278952(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V278960(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V278978(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V278986(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V285700(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V286195(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V286344(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V297499(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V297507(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V297515(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V297523(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341099(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341172(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341214(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341222(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341339(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V341404(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V347484(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V347757(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V470393(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V470427(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V470450(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V470468(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V470492(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V535765(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V564450(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V564476(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V570168(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V570176(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::V571331(Some(e)) => e.get_field_mut(field),
                DocumentClasscodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DocumentMode {
    #[doc = "Consumer"]
    #[code = "consumer"]
    Consumer(Option<Element>),
    #[doc = "Producer"]
    #[code = "producer"]
    Producer(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DocumentMode {
    fn default() -> Self {
        DocumentMode::Null(None)
    }
}
impl TryFrom<String> for DocumentMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "consumer" => Ok(DocumentMode::Consumer(None)),
            "producer" => Ok(DocumentMode::Producer(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DocumentMode {
    fn into(self) -> Option<String> {
        match self {
            DocumentMode::Consumer(_) => Some("consumer".to_string()),
            DocumentMode::Producer(_) => Some("producer".to_string()),
            DocumentMode::Null(_) => None,
        }
    }
}
impl MetaValue for DocumentMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DocumentMode::Consumer(Some(e)) => e.get_field(field),
                DocumentMode::Producer(Some(e)) => e.get_field(field),
                DocumentMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DocumentMode::Consumer(Some(e)) => e.get_field_mut(field),
                DocumentMode::Producer(Some(e)) => e.get_field_mut(field),
                DocumentMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DocumentReferenceStatus {
    #[doc = "Current"]
    #[code = "current"]
    Current(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Superseded"]
    #[code = "superseded"]
    Superseded(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DocumentReferenceStatus {
    fn default() -> Self {
        DocumentReferenceStatus::Null(None)
    }
}
impl TryFrom<String> for DocumentReferenceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "current" => Ok(DocumentReferenceStatus::Current(None)),
            "entered-in-error" => Ok(DocumentReferenceStatus::EnteredInError(None)),
            "superseded" => Ok(DocumentReferenceStatus::Superseded(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DocumentReferenceStatus {
    fn into(self) -> Option<String> {
        match self {
            DocumentReferenceStatus::Current(_) => Some("current".to_string()),
            DocumentReferenceStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            DocumentReferenceStatus::Superseded(_) => Some("superseded".to_string()),
            DocumentReferenceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for DocumentReferenceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DocumentReferenceStatus::Current(Some(e)) => e.get_field(field),
                DocumentReferenceStatus::EnteredInError(Some(e)) => e.get_field(field),
                DocumentReferenceStatus::Superseded(Some(e)) => e.get_field(field),
                DocumentReferenceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DocumentReferenceStatus::Current(Some(e)) => e.get_field_mut(field),
                DocumentReferenceStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                DocumentReferenceStatus::Superseded(Some(e)) => e.get_field_mut(field),
                DocumentReferenceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DocumentRelationshipType {
    #[doc = "Appends"]
    #[code = "appends"]
    Appends(Option<Element>),
    #[doc = "Replaces"]
    #[code = "replaces"]
    Replaces(Option<Element>),
    #[doc = "Signs"]
    #[code = "signs"]
    Signs(Option<Element>),
    #[doc = "Transforms"]
    #[code = "transforms"]
    Transforms(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DocumentRelationshipType {
    fn default() -> Self {
        DocumentRelationshipType::Null(None)
    }
}
impl TryFrom<String> for DocumentRelationshipType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "appends" => Ok(DocumentRelationshipType::Appends(None)),
            "replaces" => Ok(DocumentRelationshipType::Replaces(None)),
            "signs" => Ok(DocumentRelationshipType::Signs(None)),
            "transforms" => Ok(DocumentRelationshipType::Transforms(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DocumentRelationshipType {
    fn into(self) -> Option<String> {
        match self {
            DocumentRelationshipType::Appends(_) => Some("appends".to_string()),
            DocumentRelationshipType::Replaces(_) => Some("replaces".to_string()),
            DocumentRelationshipType::Signs(_) => Some("signs".to_string()),
            DocumentRelationshipType::Transforms(_) => Some("transforms".to_string()),
            DocumentRelationshipType::Null(_) => None,
        }
    }
}
impl MetaValue for DocumentRelationshipType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DocumentRelationshipType::Appends(Some(e)) => e.get_field(field),
                DocumentRelationshipType::Replaces(Some(e)) => e.get_field(field),
                DocumentRelationshipType::Signs(Some(e)) => e.get_field(field),
                DocumentRelationshipType::Transforms(Some(e)) => e.get_field(field),
                DocumentRelationshipType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DocumentRelationshipType::Appends(Some(e)) => e.get_field_mut(field),
                DocumentRelationshipType::Replaces(Some(e)) => e.get_field_mut(field),
                DocumentRelationshipType::Signs(Some(e)) => e.get_field_mut(field),
                DocumentRelationshipType::Transforms(Some(e)) => e.get_field_mut(field),
                DocumentRelationshipType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DoseRateType {
    #[doc = "Calculated"]
    #[code = "calculated"]
    Calculated(Option<Element>),
    #[doc = "Ordered"]
    #[code = "ordered"]
    Ordered(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DoseRateType {
    fn default() -> Self {
        DoseRateType::Null(None)
    }
}
impl TryFrom<String> for DoseRateType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "calculated" => Ok(DoseRateType::Calculated(None)),
            "ordered" => Ok(DoseRateType::Ordered(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DoseRateType {
    fn into(self) -> Option<String> {
        match self {
            DoseRateType::Calculated(_) => Some("calculated".to_string()),
            DoseRateType::Ordered(_) => Some("ordered".to_string()),
            DoseRateType::Null(_) => None,
        }
    }
}
impl MetaValue for DoseRateType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DoseRateType::Calculated(Some(e)) => e.get_field(field),
                DoseRateType::Ordered(Some(e)) => e.get_field(field),
                DoseRateType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DoseRateType::Calculated(Some(e)) => e.get_field_mut(field),
                DoseRateType::Ordered(Some(e)) => e.get_field_mut(field),
                DoseRateType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum DurationUnits {
    #[doc = "years"]
    #[code = "a"]
    A(Option<Element>),
    #[doc = "days"]
    #[code = "d"]
    D(Option<Element>),
    #[doc = "hours"]
    #[code = "h"]
    H(Option<Element>),
    #[doc = "minutes"]
    #[code = "min"]
    Min(Option<Element>),
    #[doc = "months"]
    #[code = "mo"]
    Mo(Option<Element>),
    #[doc = "milliseconds"]
    #[code = "ms"]
    Ms(Option<Element>),
    #[doc = "seconds"]
    #[code = "s"]
    S(Option<Element>),
    #[doc = "weeks"]
    #[code = "wk"]
    Wk(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for DurationUnits {
    fn default() -> Self {
        DurationUnits::Null(None)
    }
}
impl TryFrom<String> for DurationUnits {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a" => Ok(DurationUnits::A(None)),
            "d" => Ok(DurationUnits::D(None)),
            "h" => Ok(DurationUnits::H(None)),
            "min" => Ok(DurationUnits::Min(None)),
            "mo" => Ok(DurationUnits::Mo(None)),
            "ms" => Ok(DurationUnits::Ms(None)),
            "s" => Ok(DurationUnits::S(None)),
            "wk" => Ok(DurationUnits::Wk(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &DurationUnits {
    fn into(self) -> Option<String> {
        match self {
            DurationUnits::A(_) => Some("a".to_string()),
            DurationUnits::D(_) => Some("d".to_string()),
            DurationUnits::H(_) => Some("h".to_string()),
            DurationUnits::Min(_) => Some("min".to_string()),
            DurationUnits::Mo(_) => Some("mo".to_string()),
            DurationUnits::Ms(_) => Some("ms".to_string()),
            DurationUnits::S(_) => Some("s".to_string()),
            DurationUnits::Wk(_) => Some("wk".to_string()),
            DurationUnits::Null(_) => None,
        }
    }
}
impl MetaValue for DurationUnits {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                DurationUnits::A(Some(e)) => e.get_field(field),
                DurationUnits::D(Some(e)) => e.get_field(field),
                DurationUnits::H(Some(e)) => e.get_field(field),
                DurationUnits::Min(Some(e)) => e.get_field(field),
                DurationUnits::Mo(Some(e)) => e.get_field(field),
                DurationUnits::Ms(Some(e)) => e.get_field(field),
                DurationUnits::S(Some(e)) => e.get_field(field),
                DurationUnits::Wk(Some(e)) => e.get_field(field),
                DurationUnits::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                DurationUnits::A(Some(e)) => e.get_field_mut(field),
                DurationUnits::D(Some(e)) => e.get_field_mut(field),
                DurationUnits::H(Some(e)) => e.get_field_mut(field),
                DurationUnits::Min(Some(e)) => e.get_field_mut(field),
                DurationUnits::Mo(Some(e)) => e.get_field_mut(field),
                DurationUnits::Ms(Some(e)) => e.get_field_mut(field),
                DurationUnits::S(Some(e)) => e.get_field_mut(field),
                DurationUnits::Wk(Some(e)) => e.get_field_mut(field),
                DurationUnits::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EffectEstimateType {
    #[doc = "absolute risk difference"]
    #[code = "absolute-ARD"]
    AbsoluteARD(Option<Element>),
    #[doc = "mean difference"]
    #[code = "absolute-MeanDiff"]
    AbsoluteMeanDiff(Option<Element>),
    #[doc = "median difference"]
    #[code = "absolute-MedianDiff"]
    AbsoluteMedianDiff(Option<Element>),
    #[doc = "standardized mean difference"]
    #[code = "absolute-SMD"]
    AbsoluteSMD(Option<Element>),
    #[doc = "hazard ratio"]
    #[code = "relative-HR"]
    RelativeHR(Option<Element>),
    #[doc = "odds ratio"]
    #[code = "relative-OR"]
    RelativeOR(Option<Element>),
    #[doc = "relative risk"]
    #[code = "relative-RR"]
    RelativeRR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EffectEstimateType {
    fn default() -> Self {
        EffectEstimateType::Null(None)
    }
}
impl TryFrom<String> for EffectEstimateType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "absolute-ARD" => Ok(EffectEstimateType::AbsoluteARD(None)),
            "absolute-MeanDiff" => Ok(EffectEstimateType::AbsoluteMeanDiff(None)),
            "absolute-MedianDiff" => Ok(EffectEstimateType::AbsoluteMedianDiff(None)),
            "absolute-SMD" => Ok(EffectEstimateType::AbsoluteSMD(None)),
            "relative-HR" => Ok(EffectEstimateType::RelativeHR(None)),
            "relative-OR" => Ok(EffectEstimateType::RelativeOR(None)),
            "relative-RR" => Ok(EffectEstimateType::RelativeRR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EffectEstimateType {
    fn into(self) -> Option<String> {
        match self {
            EffectEstimateType::AbsoluteARD(_) => Some("absolute-ARD".to_string()),
            EffectEstimateType::AbsoluteMeanDiff(_) => Some("absolute-MeanDiff".to_string()),
            EffectEstimateType::AbsoluteMedianDiff(_) => Some("absolute-MedianDiff".to_string()),
            EffectEstimateType::AbsoluteSMD(_) => Some("absolute-SMD".to_string()),
            EffectEstimateType::RelativeHR(_) => Some("relative-HR".to_string()),
            EffectEstimateType::RelativeOR(_) => Some("relative-OR".to_string()),
            EffectEstimateType::RelativeRR(_) => Some("relative-RR".to_string()),
            EffectEstimateType::Null(_) => None,
        }
    }
}
impl MetaValue for EffectEstimateType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EffectEstimateType::AbsoluteARD(Some(e)) => e.get_field(field),
                EffectEstimateType::AbsoluteMeanDiff(Some(e)) => e.get_field(field),
                EffectEstimateType::AbsoluteMedianDiff(Some(e)) => e.get_field(field),
                EffectEstimateType::AbsoluteSMD(Some(e)) => e.get_field(field),
                EffectEstimateType::RelativeHR(Some(e)) => e.get_field(field),
                EffectEstimateType::RelativeOR(Some(e)) => e.get_field(field),
                EffectEstimateType::RelativeRR(Some(e)) => e.get_field(field),
                EffectEstimateType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EffectEstimateType::AbsoluteARD(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::AbsoluteMeanDiff(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::AbsoluteMedianDiff(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::AbsoluteSMD(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::RelativeHR(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::RelativeOR(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::RelativeRR(Some(e)) => e.get_field_mut(field),
                EffectEstimateType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EligibilityrequestPurpose {
    #[doc = "Coverage auth-requirements"]
    #[code = "auth-requirements"]
    AuthRequirements(Option<Element>),
    #[doc = "Coverage benefits"]
    #[code = "benefits"]
    Benefits(Option<Element>),
    #[doc = "Coverage Discovery"]
    #[code = "discovery"]
    Discovery(Option<Element>),
    #[doc = "Coverage Validation"]
    #[code = "validation"]
    Validation(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EligibilityrequestPurpose {
    fn default() -> Self {
        EligibilityrequestPurpose::Null(None)
    }
}
impl TryFrom<String> for EligibilityrequestPurpose {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "auth-requirements" => Ok(EligibilityrequestPurpose::AuthRequirements(None)),
            "benefits" => Ok(EligibilityrequestPurpose::Benefits(None)),
            "discovery" => Ok(EligibilityrequestPurpose::Discovery(None)),
            "validation" => Ok(EligibilityrequestPurpose::Validation(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EligibilityrequestPurpose {
    fn into(self) -> Option<String> {
        match self {
            EligibilityrequestPurpose::AuthRequirements(_) => Some("auth-requirements".to_string()),
            EligibilityrequestPurpose::Benefits(_) => Some("benefits".to_string()),
            EligibilityrequestPurpose::Discovery(_) => Some("discovery".to_string()),
            EligibilityrequestPurpose::Validation(_) => Some("validation".to_string()),
            EligibilityrequestPurpose::Null(_) => None,
        }
    }
}
impl MetaValue for EligibilityrequestPurpose {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EligibilityrequestPurpose::AuthRequirements(Some(e)) => e.get_field(field),
                EligibilityrequestPurpose::Benefits(Some(e)) => e.get_field(field),
                EligibilityrequestPurpose::Discovery(Some(e)) => e.get_field(field),
                EligibilityrequestPurpose::Validation(Some(e)) => e.get_field(field),
                EligibilityrequestPurpose::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EligibilityrequestPurpose::AuthRequirements(Some(e)) => e.get_field_mut(field),
                EligibilityrequestPurpose::Benefits(Some(e)) => e.get_field_mut(field),
                EligibilityrequestPurpose::Discovery(Some(e)) => e.get_field_mut(field),
                EligibilityrequestPurpose::Validation(Some(e)) => e.get_field_mut(field),
                EligibilityrequestPurpose::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EligibilityresponsePurpose {
    #[doc = "Coverage auth-requirements"]
    #[code = "auth-requirements"]
    AuthRequirements(Option<Element>),
    #[doc = "Coverage benefits"]
    #[code = "benefits"]
    Benefits(Option<Element>),
    #[doc = "Coverage Discovery"]
    #[code = "discovery"]
    Discovery(Option<Element>),
    #[doc = "Coverage Validation"]
    #[code = "validation"]
    Validation(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EligibilityresponsePurpose {
    fn default() -> Self {
        EligibilityresponsePurpose::Null(None)
    }
}
impl TryFrom<String> for EligibilityresponsePurpose {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "auth-requirements" => Ok(EligibilityresponsePurpose::AuthRequirements(None)),
            "benefits" => Ok(EligibilityresponsePurpose::Benefits(None)),
            "discovery" => Ok(EligibilityresponsePurpose::Discovery(None)),
            "validation" => Ok(EligibilityresponsePurpose::Validation(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EligibilityresponsePurpose {
    fn into(self) -> Option<String> {
        match self {
            EligibilityresponsePurpose::AuthRequirements(_) => {
                Some("auth-requirements".to_string())
            }
            EligibilityresponsePurpose::Benefits(_) => Some("benefits".to_string()),
            EligibilityresponsePurpose::Discovery(_) => Some("discovery".to_string()),
            EligibilityresponsePurpose::Validation(_) => Some("validation".to_string()),
            EligibilityresponsePurpose::Null(_) => None,
        }
    }
}
impl MetaValue for EligibilityresponsePurpose {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EligibilityresponsePurpose::AuthRequirements(Some(e)) => e.get_field(field),
                EligibilityresponsePurpose::Benefits(Some(e)) => e.get_field(field),
                EligibilityresponsePurpose::Discovery(Some(e)) => e.get_field(field),
                EligibilityresponsePurpose::Validation(Some(e)) => e.get_field(field),
                EligibilityresponsePurpose::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EligibilityresponsePurpose::AuthRequirements(Some(e)) => e.get_field_mut(field),
                EligibilityresponsePurpose::Benefits(Some(e)) => e.get_field_mut(field),
                EligibilityresponsePurpose::Discovery(Some(e)) => e.get_field_mut(field),
                EligibilityresponsePurpose::Validation(Some(e)) => e.get_field_mut(field),
                EligibilityresponsePurpose::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterAdmitSource {
    #[doc = "Born in hospital"]
    #[code = "born"]
    Born(Option<Element>),
    #[doc = "From accident/emergency department"]
    #[code = "emd"]
    Emd(Option<Element>),
    #[doc = "General Practitioner referral"]
    #[code = "gp"]
    Gp(Option<Element>),
    #[doc = "Transferred from other hospital"]
    #[code = "hosp-trans"]
    HospTrans(Option<Element>),
    #[doc = "Medical Practitioner/physician referral"]
    #[code = "mp"]
    Mp(Option<Element>),
    #[doc = "From nursing home"]
    #[code = "nursing"]
    Nursing(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "From outpatient department"]
    #[code = "outp"]
    Outp(Option<Element>),
    #[doc = "From psychiatric hospital"]
    #[code = "psych"]
    Psych(Option<Element>),
    #[doc = "From rehabilitation facility"]
    #[code = "rehab"]
    Rehab(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterAdmitSource {
    fn default() -> Self {
        EncounterAdmitSource::Null(None)
    }
}
impl TryFrom<String> for EncounterAdmitSource {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "born" => Ok(EncounterAdmitSource::Born(None)),
            "emd" => Ok(EncounterAdmitSource::Emd(None)),
            "gp" => Ok(EncounterAdmitSource::Gp(None)),
            "hosp-trans" => Ok(EncounterAdmitSource::HospTrans(None)),
            "mp" => Ok(EncounterAdmitSource::Mp(None)),
            "nursing" => Ok(EncounterAdmitSource::Nursing(None)),
            "other" => Ok(EncounterAdmitSource::Other(None)),
            "outp" => Ok(EncounterAdmitSource::Outp(None)),
            "psych" => Ok(EncounterAdmitSource::Psych(None)),
            "rehab" => Ok(EncounterAdmitSource::Rehab(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterAdmitSource {
    fn into(self) -> Option<String> {
        match self {
            EncounterAdmitSource::Born(_) => Some("born".to_string()),
            EncounterAdmitSource::Emd(_) => Some("emd".to_string()),
            EncounterAdmitSource::Gp(_) => Some("gp".to_string()),
            EncounterAdmitSource::HospTrans(_) => Some("hosp-trans".to_string()),
            EncounterAdmitSource::Mp(_) => Some("mp".to_string()),
            EncounterAdmitSource::Nursing(_) => Some("nursing".to_string()),
            EncounterAdmitSource::Other(_) => Some("other".to_string()),
            EncounterAdmitSource::Outp(_) => Some("outp".to_string()),
            EncounterAdmitSource::Psych(_) => Some("psych".to_string()),
            EncounterAdmitSource::Rehab(_) => Some("rehab".to_string()),
            EncounterAdmitSource::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterAdmitSource {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterAdmitSource::Born(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Emd(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Gp(Some(e)) => e.get_field(field),
                EncounterAdmitSource::HospTrans(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Mp(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Nursing(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Other(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Outp(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Psych(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Rehab(Some(e)) => e.get_field(field),
                EncounterAdmitSource::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterAdmitSource::Born(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Emd(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Gp(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::HospTrans(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Mp(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Nursing(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Other(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Outp(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Psych(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Rehab(Some(e)) => e.get_field_mut(field),
                EncounterAdmitSource::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterDiet {
    #[doc = "Dairy Free"]
    #[code = "dairy-free"]
    DairyFree(Option<Element>),
    #[doc = "Gluten Free"]
    #[code = "gluten-free"]
    GlutenFree(Option<Element>),
    #[doc = "Halal"]
    #[code = "halal"]
    Halal(Option<Element>),
    #[doc = "Kosher"]
    #[code = "kosher"]
    Kosher(Option<Element>),
    #[doc = "Nut Free"]
    #[code = "nut-free"]
    NutFree(Option<Element>),
    #[doc = "Vegan"]
    #[code = "vegan"]
    Vegan(Option<Element>),
    #[doc = "Vegetarian"]
    #[code = "vegetarian"]
    Vegetarian(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterDiet {
    fn default() -> Self {
        EncounterDiet::Null(None)
    }
}
impl TryFrom<String> for EncounterDiet {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "dairy-free" => Ok(EncounterDiet::DairyFree(None)),
            "gluten-free" => Ok(EncounterDiet::GlutenFree(None)),
            "halal" => Ok(EncounterDiet::Halal(None)),
            "kosher" => Ok(EncounterDiet::Kosher(None)),
            "nut-free" => Ok(EncounterDiet::NutFree(None)),
            "vegan" => Ok(EncounterDiet::Vegan(None)),
            "vegetarian" => Ok(EncounterDiet::Vegetarian(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterDiet {
    fn into(self) -> Option<String> {
        match self {
            EncounterDiet::DairyFree(_) => Some("dairy-free".to_string()),
            EncounterDiet::GlutenFree(_) => Some("gluten-free".to_string()),
            EncounterDiet::Halal(_) => Some("halal".to_string()),
            EncounterDiet::Kosher(_) => Some("kosher".to_string()),
            EncounterDiet::NutFree(_) => Some("nut-free".to_string()),
            EncounterDiet::Vegan(_) => Some("vegan".to_string()),
            EncounterDiet::Vegetarian(_) => Some("vegetarian".to_string()),
            EncounterDiet::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterDiet {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterDiet::DairyFree(Some(e)) => e.get_field(field),
                EncounterDiet::GlutenFree(Some(e)) => e.get_field(field),
                EncounterDiet::Halal(Some(e)) => e.get_field(field),
                EncounterDiet::Kosher(Some(e)) => e.get_field(field),
                EncounterDiet::NutFree(Some(e)) => e.get_field(field),
                EncounterDiet::Vegan(Some(e)) => e.get_field(field),
                EncounterDiet::Vegetarian(Some(e)) => e.get_field(field),
                EncounterDiet::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterDiet::DairyFree(Some(e)) => e.get_field_mut(field),
                EncounterDiet::GlutenFree(Some(e)) => e.get_field_mut(field),
                EncounterDiet::Halal(Some(e)) => e.get_field_mut(field),
                EncounterDiet::Kosher(Some(e)) => e.get_field_mut(field),
                EncounterDiet::NutFree(Some(e)) => e.get_field_mut(field),
                EncounterDiet::Vegan(Some(e)) => e.get_field_mut(field),
                EncounterDiet::Vegetarian(Some(e)) => e.get_field_mut(field),
                EncounterDiet::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterDischargeDisposition {
    #[doc = "Left against advice"]
    #[code = "aadvice"]
    Aadvice(Option<Element>),
    #[doc = "Alternative home"]
    #[code = "alt-home"]
    AltHome(Option<Element>),
    #[doc = "Expired"]
    #[code = "exp"]
    Exp(Option<Element>),
    #[doc = "Home"]
    #[code = "home"]
    Home(Option<Element>),
    #[doc = "Hospice"]
    #[code = "hosp"]
    Hosp(Option<Element>),
    #[doc = "Long-term care"]
    #[code = "long"]
    Long(Option<Element>),
    #[doc = "Other"]
    #[code = "oth"]
    Oth(Option<Element>),
    #[doc = "Other healthcare facility"]
    #[code = "other-hcf"]
    OtherHcf(Option<Element>),
    #[doc = "Psychiatric hospital"]
    #[code = "psy"]
    Psy(Option<Element>),
    #[doc = "Rehabilitation"]
    #[code = "rehab"]
    Rehab(Option<Element>),
    #[doc = "Skilled nursing facility"]
    #[code = "snf"]
    Snf(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterDischargeDisposition {
    fn default() -> Self {
        EncounterDischargeDisposition::Null(None)
    }
}
impl TryFrom<String> for EncounterDischargeDisposition {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aadvice" => Ok(EncounterDischargeDisposition::Aadvice(None)),
            "alt-home" => Ok(EncounterDischargeDisposition::AltHome(None)),
            "exp" => Ok(EncounterDischargeDisposition::Exp(None)),
            "home" => Ok(EncounterDischargeDisposition::Home(None)),
            "hosp" => Ok(EncounterDischargeDisposition::Hosp(None)),
            "long" => Ok(EncounterDischargeDisposition::Long(None)),
            "oth" => Ok(EncounterDischargeDisposition::Oth(None)),
            "other-hcf" => Ok(EncounterDischargeDisposition::OtherHcf(None)),
            "psy" => Ok(EncounterDischargeDisposition::Psy(None)),
            "rehab" => Ok(EncounterDischargeDisposition::Rehab(None)),
            "snf" => Ok(EncounterDischargeDisposition::Snf(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterDischargeDisposition {
    fn into(self) -> Option<String> {
        match self {
            EncounterDischargeDisposition::Aadvice(_) => Some("aadvice".to_string()),
            EncounterDischargeDisposition::AltHome(_) => Some("alt-home".to_string()),
            EncounterDischargeDisposition::Exp(_) => Some("exp".to_string()),
            EncounterDischargeDisposition::Home(_) => Some("home".to_string()),
            EncounterDischargeDisposition::Hosp(_) => Some("hosp".to_string()),
            EncounterDischargeDisposition::Long(_) => Some("long".to_string()),
            EncounterDischargeDisposition::Oth(_) => Some("oth".to_string()),
            EncounterDischargeDisposition::OtherHcf(_) => Some("other-hcf".to_string()),
            EncounterDischargeDisposition::Psy(_) => Some("psy".to_string()),
            EncounterDischargeDisposition::Rehab(_) => Some("rehab".to_string()),
            EncounterDischargeDisposition::Snf(_) => Some("snf".to_string()),
            EncounterDischargeDisposition::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterDischargeDisposition {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterDischargeDisposition::Aadvice(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::AltHome(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Exp(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Home(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Hosp(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Long(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Oth(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::OtherHcf(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Psy(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Rehab(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Snf(Some(e)) => e.get_field(field),
                EncounterDischargeDisposition::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterDischargeDisposition::Aadvice(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::AltHome(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Exp(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Home(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Hosp(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Long(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Oth(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::OtherHcf(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Psy(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Rehab(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Snf(Some(e)) => e.get_field_mut(field),
                EncounterDischargeDisposition::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterLocationStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "Reserved"]
    #[code = "reserved"]
    Reserved(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterLocationStatus {
    fn default() -> Self {
        EncounterLocationStatus::Null(None)
    }
}
impl TryFrom<String> for EncounterLocationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(EncounterLocationStatus::Active(None)),
            "completed" => Ok(EncounterLocationStatus::Completed(None)),
            "planned" => Ok(EncounterLocationStatus::Planned(None)),
            "reserved" => Ok(EncounterLocationStatus::Reserved(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterLocationStatus {
    fn into(self) -> Option<String> {
        match self {
            EncounterLocationStatus::Active(_) => Some("active".to_string()),
            EncounterLocationStatus::Completed(_) => Some("completed".to_string()),
            EncounterLocationStatus::Planned(_) => Some("planned".to_string()),
            EncounterLocationStatus::Reserved(_) => Some("reserved".to_string()),
            EncounterLocationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterLocationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterLocationStatus::Active(Some(e)) => e.get_field(field),
                EncounterLocationStatus::Completed(Some(e)) => e.get_field(field),
                EncounterLocationStatus::Planned(Some(e)) => e.get_field(field),
                EncounterLocationStatus::Reserved(Some(e)) => e.get_field(field),
                EncounterLocationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterLocationStatus::Active(Some(e)) => e.get_field_mut(field),
                EncounterLocationStatus::Completed(Some(e)) => e.get_field_mut(field),
                EncounterLocationStatus::Planned(Some(e)) => e.get_field_mut(field),
                EncounterLocationStatus::Reserved(Some(e)) => e.get_field_mut(field),
                EncounterLocationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterParticipantType {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[code = "PART"]
    PART(Option<Element>),
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "Emergency"]
    #[code = "emergency"]
    Emergency(Option<Element>),
    #[doc = "Translator"]
    #[code = "translator"]
    Translator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterParticipantType {
    fn default() -> Self {
        EncounterParticipantType::Null(None)
    }
}
impl TryFrom<String> for EncounterParticipantType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(EncounterParticipantType::ADM(None)),
            "ALY" => Ok(EncounterParticipantType::ALY(None)),
            "ATND" => Ok(EncounterParticipantType::ATND(None)),
            "AUT" => Ok(EncounterParticipantType::AUT(None)),
            "AUTHEN" => Ok(EncounterParticipantType::AUTHEN(None)),
            "BBY" => Ok(EncounterParticipantType::BBY(None)),
            "BEN" => Ok(EncounterParticipantType::BEN(None)),
            "CAGNT" => Ok(EncounterParticipantType::CAGNT(None)),
            "CALLBCK" => Ok(EncounterParticipantType::CALLBCK(None)),
            "CAT" => Ok(EncounterParticipantType::CAT(None)),
            "CON" => Ok(EncounterParticipantType::CON(None)),
            "COV" => Ok(EncounterParticipantType::COV(None)),
            "CSM" => Ok(EncounterParticipantType::CSM(None)),
            "CST" => Ok(EncounterParticipantType::CST(None)),
            "DEV" => Ok(EncounterParticipantType::DEV(None)),
            "DIR" => Ok(EncounterParticipantType::DIR(None)),
            "DIS" => Ok(EncounterParticipantType::DIS(None)),
            "DIST" => Ok(EncounterParticipantType::DIST(None)),
            "DON" => Ok(EncounterParticipantType::DON(None)),
            "DST" => Ok(EncounterParticipantType::DST(None)),
            "ELOC" => Ok(EncounterParticipantType::ELOC(None)),
            "ENT" => Ok(EncounterParticipantType::ENT(None)),
            "ESC" => Ok(EncounterParticipantType::ESC(None)),
            "EXPAGNT" => Ok(EncounterParticipantType::EXPAGNT(None)),
            "EXPART" => Ok(EncounterParticipantType::EXPART(None)),
            "EXPTRGT" => Ok(EncounterParticipantType::EXPTRGT(None)),
            "EXSRC" => Ok(EncounterParticipantType::EXSRC(None)),
            "GUAR" => Ok(EncounterParticipantType::GUAR(None)),
            "HLD" => Ok(EncounterParticipantType::HLD(None)),
            "IND" => Ok(EncounterParticipantType::IND(None)),
            "INF" => Ok(EncounterParticipantType::INF(None)),
            "IRCP" => Ok(EncounterParticipantType::IRCP(None)),
            "LA" => Ok(EncounterParticipantType::LA(None)),
            "LOC" => Ok(EncounterParticipantType::LOC(None)),
            "NOT" => Ok(EncounterParticipantType::NOT(None)),
            "NRD" => Ok(EncounterParticipantType::NRD(None)),
            "ORG" => Ok(EncounterParticipantType::ORG(None)),
            "PART" => Ok(EncounterParticipantType::PART(None)),
            "PPRF" => Ok(EncounterParticipantType::PPRF(None)),
            "PRCP" => Ok(EncounterParticipantType::PRCP(None)),
            "PRD" => Ok(EncounterParticipantType::PRD(None)),
            "PRF" => Ok(EncounterParticipantType::PRF(None)),
            "RCT" => Ok(EncounterParticipantType::RCT(None)),
            "RCV" => Ok(EncounterParticipantType::RCV(None)),
            "RDV" => Ok(EncounterParticipantType::RDV(None)),
            "REF" => Ok(EncounterParticipantType::REF(None)),
            "REFB" => Ok(EncounterParticipantType::REFB(None)),
            "REFT" => Ok(EncounterParticipantType::REFT(None)),
            "RESP" => Ok(EncounterParticipantType::RESP(None)),
            "RML" => Ok(EncounterParticipantType::RML(None)),
            "SBJ" => Ok(EncounterParticipantType::SBJ(None)),
            "SPC" => Ok(EncounterParticipantType::SPC(None)),
            "SPRF" => Ok(EncounterParticipantType::SPRF(None)),
            "TPA" => Ok(EncounterParticipantType::TPA(None)),
            "TRANS" => Ok(EncounterParticipantType::TRANS(None)),
            "TRC" => Ok(EncounterParticipantType::TRC(None)),
            "VIA" => Ok(EncounterParticipantType::VIA(None)),
            "VRF" => Ok(EncounterParticipantType::VRF(None)),
            "WIT" => Ok(EncounterParticipantType::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(EncounterParticipantType::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(EncounterParticipantType::_ParticipationInformationGenerator(None))
            }
            "emergency" => Ok(EncounterParticipantType::Emergency(None)),
            "translator" => Ok(EncounterParticipantType::Translator(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterParticipantType {
    fn into(self) -> Option<String> {
        match self {
            EncounterParticipantType::ADM(_) => Some("ADM".to_string()),
            EncounterParticipantType::ALY(_) => Some("ALY".to_string()),
            EncounterParticipantType::ATND(_) => Some("ATND".to_string()),
            EncounterParticipantType::AUT(_) => Some("AUT".to_string()),
            EncounterParticipantType::AUTHEN(_) => Some("AUTHEN".to_string()),
            EncounterParticipantType::BBY(_) => Some("BBY".to_string()),
            EncounterParticipantType::BEN(_) => Some("BEN".to_string()),
            EncounterParticipantType::CAGNT(_) => Some("CAGNT".to_string()),
            EncounterParticipantType::CALLBCK(_) => Some("CALLBCK".to_string()),
            EncounterParticipantType::CAT(_) => Some("CAT".to_string()),
            EncounterParticipantType::CON(_) => Some("CON".to_string()),
            EncounterParticipantType::COV(_) => Some("COV".to_string()),
            EncounterParticipantType::CSM(_) => Some("CSM".to_string()),
            EncounterParticipantType::CST(_) => Some("CST".to_string()),
            EncounterParticipantType::DEV(_) => Some("DEV".to_string()),
            EncounterParticipantType::DIR(_) => Some("DIR".to_string()),
            EncounterParticipantType::DIS(_) => Some("DIS".to_string()),
            EncounterParticipantType::DIST(_) => Some("DIST".to_string()),
            EncounterParticipantType::DON(_) => Some("DON".to_string()),
            EncounterParticipantType::DST(_) => Some("DST".to_string()),
            EncounterParticipantType::ELOC(_) => Some("ELOC".to_string()),
            EncounterParticipantType::ENT(_) => Some("ENT".to_string()),
            EncounterParticipantType::ESC(_) => Some("ESC".to_string()),
            EncounterParticipantType::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            EncounterParticipantType::EXPART(_) => Some("EXPART".to_string()),
            EncounterParticipantType::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            EncounterParticipantType::EXSRC(_) => Some("EXSRC".to_string()),
            EncounterParticipantType::GUAR(_) => Some("GUAR".to_string()),
            EncounterParticipantType::HLD(_) => Some("HLD".to_string()),
            EncounterParticipantType::IND(_) => Some("IND".to_string()),
            EncounterParticipantType::INF(_) => Some("INF".to_string()),
            EncounterParticipantType::IRCP(_) => Some("IRCP".to_string()),
            EncounterParticipantType::LA(_) => Some("LA".to_string()),
            EncounterParticipantType::LOC(_) => Some("LOC".to_string()),
            EncounterParticipantType::NOT(_) => Some("NOT".to_string()),
            EncounterParticipantType::NRD(_) => Some("NRD".to_string()),
            EncounterParticipantType::ORG(_) => Some("ORG".to_string()),
            EncounterParticipantType::PART(_) => Some("PART".to_string()),
            EncounterParticipantType::PPRF(_) => Some("PPRF".to_string()),
            EncounterParticipantType::PRCP(_) => Some("PRCP".to_string()),
            EncounterParticipantType::PRD(_) => Some("PRD".to_string()),
            EncounterParticipantType::PRF(_) => Some("PRF".to_string()),
            EncounterParticipantType::RCT(_) => Some("RCT".to_string()),
            EncounterParticipantType::RCV(_) => Some("RCV".to_string()),
            EncounterParticipantType::RDV(_) => Some("RDV".to_string()),
            EncounterParticipantType::REF(_) => Some("REF".to_string()),
            EncounterParticipantType::REFB(_) => Some("REFB".to_string()),
            EncounterParticipantType::REFT(_) => Some("REFT".to_string()),
            EncounterParticipantType::RESP(_) => Some("RESP".to_string()),
            EncounterParticipantType::RML(_) => Some("RML".to_string()),
            EncounterParticipantType::SBJ(_) => Some("SBJ".to_string()),
            EncounterParticipantType::SPC(_) => Some("SPC".to_string()),
            EncounterParticipantType::SPRF(_) => Some("SPRF".to_string()),
            EncounterParticipantType::TPA(_) => Some("TPA".to_string()),
            EncounterParticipantType::TRANS(_) => Some("TRANS".to_string()),
            EncounterParticipantType::TRC(_) => Some("TRC".to_string()),
            EncounterParticipantType::VIA(_) => Some("VIA".to_string()),
            EncounterParticipantType::VRF(_) => Some("VRF".to_string()),
            EncounterParticipantType::WIT(_) => Some("WIT".to_string()),
            EncounterParticipantType::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            EncounterParticipantType::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            EncounterParticipantType::Emergency(_) => Some("emergency".to_string()),
            EncounterParticipantType::Translator(_) => Some("translator".to_string()),
            EncounterParticipantType::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterParticipantType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterParticipantType::ADM(Some(e)) => e.get_field(field),
                EncounterParticipantType::ALY(Some(e)) => e.get_field(field),
                EncounterParticipantType::ATND(Some(e)) => e.get_field(field),
                EncounterParticipantType::AUT(Some(e)) => e.get_field(field),
                EncounterParticipantType::AUTHEN(Some(e)) => e.get_field(field),
                EncounterParticipantType::BBY(Some(e)) => e.get_field(field),
                EncounterParticipantType::BEN(Some(e)) => e.get_field(field),
                EncounterParticipantType::CAGNT(Some(e)) => e.get_field(field),
                EncounterParticipantType::CALLBCK(Some(e)) => e.get_field(field),
                EncounterParticipantType::CAT(Some(e)) => e.get_field(field),
                EncounterParticipantType::CON(Some(e)) => e.get_field(field),
                EncounterParticipantType::COV(Some(e)) => e.get_field(field),
                EncounterParticipantType::CSM(Some(e)) => e.get_field(field),
                EncounterParticipantType::CST(Some(e)) => e.get_field(field),
                EncounterParticipantType::DEV(Some(e)) => e.get_field(field),
                EncounterParticipantType::DIR(Some(e)) => e.get_field(field),
                EncounterParticipantType::DIS(Some(e)) => e.get_field(field),
                EncounterParticipantType::DIST(Some(e)) => e.get_field(field),
                EncounterParticipantType::DON(Some(e)) => e.get_field(field),
                EncounterParticipantType::DST(Some(e)) => e.get_field(field),
                EncounterParticipantType::ELOC(Some(e)) => e.get_field(field),
                EncounterParticipantType::ENT(Some(e)) => e.get_field(field),
                EncounterParticipantType::ESC(Some(e)) => e.get_field(field),
                EncounterParticipantType::EXPAGNT(Some(e)) => e.get_field(field),
                EncounterParticipantType::EXPART(Some(e)) => e.get_field(field),
                EncounterParticipantType::EXPTRGT(Some(e)) => e.get_field(field),
                EncounterParticipantType::EXSRC(Some(e)) => e.get_field(field),
                EncounterParticipantType::GUAR(Some(e)) => e.get_field(field),
                EncounterParticipantType::HLD(Some(e)) => e.get_field(field),
                EncounterParticipantType::IND(Some(e)) => e.get_field(field),
                EncounterParticipantType::INF(Some(e)) => e.get_field(field),
                EncounterParticipantType::IRCP(Some(e)) => e.get_field(field),
                EncounterParticipantType::LA(Some(e)) => e.get_field(field),
                EncounterParticipantType::LOC(Some(e)) => e.get_field(field),
                EncounterParticipantType::NOT(Some(e)) => e.get_field(field),
                EncounterParticipantType::NRD(Some(e)) => e.get_field(field),
                EncounterParticipantType::ORG(Some(e)) => e.get_field(field),
                EncounterParticipantType::PART(Some(e)) => e.get_field(field),
                EncounterParticipantType::PPRF(Some(e)) => e.get_field(field),
                EncounterParticipantType::PRCP(Some(e)) => e.get_field(field),
                EncounterParticipantType::PRD(Some(e)) => e.get_field(field),
                EncounterParticipantType::PRF(Some(e)) => e.get_field(field),
                EncounterParticipantType::RCT(Some(e)) => e.get_field(field),
                EncounterParticipantType::RCV(Some(e)) => e.get_field(field),
                EncounterParticipantType::RDV(Some(e)) => e.get_field(field),
                EncounterParticipantType::REF(Some(e)) => e.get_field(field),
                EncounterParticipantType::REFB(Some(e)) => e.get_field(field),
                EncounterParticipantType::REFT(Some(e)) => e.get_field(field),
                EncounterParticipantType::RESP(Some(e)) => e.get_field(field),
                EncounterParticipantType::RML(Some(e)) => e.get_field(field),
                EncounterParticipantType::SBJ(Some(e)) => e.get_field(field),
                EncounterParticipantType::SPC(Some(e)) => e.get_field(field),
                EncounterParticipantType::SPRF(Some(e)) => e.get_field(field),
                EncounterParticipantType::TPA(Some(e)) => e.get_field(field),
                EncounterParticipantType::TRANS(Some(e)) => e.get_field(field),
                EncounterParticipantType::TRC(Some(e)) => e.get_field(field),
                EncounterParticipantType::VIA(Some(e)) => e.get_field(field),
                EncounterParticipantType::VRF(Some(e)) => e.get_field(field),
                EncounterParticipantType::WIT(Some(e)) => e.get_field(field),
                EncounterParticipantType::_ParticipationAncillary(Some(e)) => e.get_field(field),
                EncounterParticipantType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                EncounterParticipantType::Emergency(Some(e)) => e.get_field(field),
                EncounterParticipantType::Translator(Some(e)) => e.get_field(field),
                EncounterParticipantType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterParticipantType::ADM(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ALY(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ATND(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::AUT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::AUTHEN(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::BBY(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::BEN(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CAGNT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CALLBCK(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CAT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CON(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::COV(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CSM(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::CST(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DEV(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DIR(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DIS(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DIST(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DON(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::DST(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ELOC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ENT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ESC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::EXPAGNT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::EXPART(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::EXPTRGT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::EXSRC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::GUAR(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::HLD(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::IND(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::INF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::IRCP(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::LA(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::LOC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::NOT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::NRD(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::ORG(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::PART(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::PPRF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::PRCP(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::PRD(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::PRF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::RCT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::RCV(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::RDV(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::REF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::REFB(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::REFT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::RESP(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::RML(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::SBJ(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::SPC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::SPRF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::TPA(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::TRANS(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::TRC(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::VIA(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::VRF(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::WIT(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                EncounterParticipantType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                EncounterParticipantType::Emergency(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::Translator(Some(e)) => e.get_field_mut(field),
                EncounterParticipantType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterSpecialArrangements {
    #[doc = "Additional bedding"]
    #[code = "add-bed"]
    AddBed(Option<Element>),
    #[doc = "Attendant"]
    #[code = "att"]
    Att(Option<Element>),
    #[doc = "Guide dog"]
    #[code = "dog"]
    Dog(Option<Element>),
    #[doc = "Interpreter"]
    #[code = "int"]
    Int(Option<Element>),
    #[doc = "Wheelchair"]
    #[code = "wheel"]
    Wheel(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterSpecialArrangements {
    fn default() -> Self {
        EncounterSpecialArrangements::Null(None)
    }
}
impl TryFrom<String> for EncounterSpecialArrangements {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "add-bed" => Ok(EncounterSpecialArrangements::AddBed(None)),
            "att" => Ok(EncounterSpecialArrangements::Att(None)),
            "dog" => Ok(EncounterSpecialArrangements::Dog(None)),
            "int" => Ok(EncounterSpecialArrangements::Int(None)),
            "wheel" => Ok(EncounterSpecialArrangements::Wheel(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterSpecialArrangements {
    fn into(self) -> Option<String> {
        match self {
            EncounterSpecialArrangements::AddBed(_) => Some("add-bed".to_string()),
            EncounterSpecialArrangements::Att(_) => Some("att".to_string()),
            EncounterSpecialArrangements::Dog(_) => Some("dog".to_string()),
            EncounterSpecialArrangements::Int(_) => Some("int".to_string()),
            EncounterSpecialArrangements::Wheel(_) => Some("wheel".to_string()),
            EncounterSpecialArrangements::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterSpecialArrangements {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterSpecialArrangements::AddBed(Some(e)) => e.get_field(field),
                EncounterSpecialArrangements::Att(Some(e)) => e.get_field(field),
                EncounterSpecialArrangements::Dog(Some(e)) => e.get_field(field),
                EncounterSpecialArrangements::Int(Some(e)) => e.get_field(field),
                EncounterSpecialArrangements::Wheel(Some(e)) => e.get_field(field),
                EncounterSpecialArrangements::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterSpecialArrangements::AddBed(Some(e)) => e.get_field_mut(field),
                EncounterSpecialArrangements::Att(Some(e)) => e.get_field_mut(field),
                EncounterSpecialArrangements::Dog(Some(e)) => e.get_field_mut(field),
                EncounterSpecialArrangements::Int(Some(e)) => e.get_field_mut(field),
                EncounterSpecialArrangements::Wheel(Some(e)) => e.get_field_mut(field),
                EncounterSpecialArrangements::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterSpecialCourtesy {
    #[code = "EXT"]
    EXT(Option<Element>),
    #[code = "NRM"]
    NRM(Option<Element>),
    #[code = "PRF"]
    PRF(Option<Element>),
    #[code = "STF"]
    STF(Option<Element>),
    #[code = "UNK"]
    UNK(Option<Element>),
    #[code = "VIP"]
    VIP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterSpecialCourtesy {
    fn default() -> Self {
        EncounterSpecialCourtesy::Null(None)
    }
}
impl TryFrom<String> for EncounterSpecialCourtesy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "EXT" => Ok(EncounterSpecialCourtesy::EXT(None)),
            "NRM" => Ok(EncounterSpecialCourtesy::NRM(None)),
            "PRF" => Ok(EncounterSpecialCourtesy::PRF(None)),
            "STF" => Ok(EncounterSpecialCourtesy::STF(None)),
            "UNK" => Ok(EncounterSpecialCourtesy::UNK(None)),
            "VIP" => Ok(EncounterSpecialCourtesy::VIP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterSpecialCourtesy {
    fn into(self) -> Option<String> {
        match self {
            EncounterSpecialCourtesy::EXT(_) => Some("EXT".to_string()),
            EncounterSpecialCourtesy::NRM(_) => Some("NRM".to_string()),
            EncounterSpecialCourtesy::PRF(_) => Some("PRF".to_string()),
            EncounterSpecialCourtesy::STF(_) => Some("STF".to_string()),
            EncounterSpecialCourtesy::UNK(_) => Some("UNK".to_string()),
            EncounterSpecialCourtesy::VIP(_) => Some("VIP".to_string()),
            EncounterSpecialCourtesy::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterSpecialCourtesy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterSpecialCourtesy::EXT(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::NRM(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::PRF(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::STF(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::UNK(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::VIP(Some(e)) => e.get_field(field),
                EncounterSpecialCourtesy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterSpecialCourtesy::EXT(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::NRM(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::PRF(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::STF(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::UNK(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::VIP(Some(e)) => e.get_field_mut(field),
                EncounterSpecialCourtesy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterStatus {
    #[doc = "Arrived"]
    #[code = "arrived"]
    Arrived(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Finished"]
    #[code = "finished"]
    Finished(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "On Leave"]
    #[code = "onleave"]
    Onleave(Option<Element>),
    #[doc = "Planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "Triaged"]
    #[code = "triaged"]
    Triaged(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterStatus {
    fn default() -> Self {
        EncounterStatus::Null(None)
    }
}
impl TryFrom<String> for EncounterStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "arrived" => Ok(EncounterStatus::Arrived(None)),
            "cancelled" => Ok(EncounterStatus::Cancelled(None)),
            "entered-in-error" => Ok(EncounterStatus::EnteredInError(None)),
            "finished" => Ok(EncounterStatus::Finished(None)),
            "in-progress" => Ok(EncounterStatus::InProgress(None)),
            "onleave" => Ok(EncounterStatus::Onleave(None)),
            "planned" => Ok(EncounterStatus::Planned(None)),
            "triaged" => Ok(EncounterStatus::Triaged(None)),
            "unknown" => Ok(EncounterStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterStatus {
    fn into(self) -> Option<String> {
        match self {
            EncounterStatus::Arrived(_) => Some("arrived".to_string()),
            EncounterStatus::Cancelled(_) => Some("cancelled".to_string()),
            EncounterStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            EncounterStatus::Finished(_) => Some("finished".to_string()),
            EncounterStatus::InProgress(_) => Some("in-progress".to_string()),
            EncounterStatus::Onleave(_) => Some("onleave".to_string()),
            EncounterStatus::Planned(_) => Some("planned".to_string()),
            EncounterStatus::Triaged(_) => Some("triaged".to_string()),
            EncounterStatus::Unknown(_) => Some("unknown".to_string()),
            EncounterStatus::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterStatus::Arrived(Some(e)) => e.get_field(field),
                EncounterStatus::Cancelled(Some(e)) => e.get_field(field),
                EncounterStatus::EnteredInError(Some(e)) => e.get_field(field),
                EncounterStatus::Finished(Some(e)) => e.get_field(field),
                EncounterStatus::InProgress(Some(e)) => e.get_field(field),
                EncounterStatus::Onleave(Some(e)) => e.get_field(field),
                EncounterStatus::Planned(Some(e)) => e.get_field(field),
                EncounterStatus::Triaged(Some(e)) => e.get_field(field),
                EncounterStatus::Unknown(Some(e)) => e.get_field(field),
                EncounterStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterStatus::Arrived(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                EncounterStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Finished(Some(e)) => e.get_field_mut(field),
                EncounterStatus::InProgress(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Onleave(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Planned(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Triaged(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Unknown(Some(e)) => e.get_field_mut(field),
                EncounterStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EncounterType {
    #[doc = "Annual diabetes mellitus screening"]
    #[code = "ADMS"]
    ADMS(Option<Element>),
    #[doc = "Bone drilling/bone marrow punction in clinic"]
    #[code = "BD/BM-clin"]
    BD_BMClin(Option<Element>),
    #[doc = "Infant colon screening - 60 minutes"]
    #[code = "CCS60"]
    CCS60(Option<Element>),
    #[doc = "Outpatient Kenacort injection"]
    #[code = "OKI"]
    OKI(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EncounterType {
    fn default() -> Self {
        EncounterType::Null(None)
    }
}
impl TryFrom<String> for EncounterType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADMS" => Ok(EncounterType::ADMS(None)),
            "BD/BM-clin" => Ok(EncounterType::BD_BMClin(None)),
            "CCS60" => Ok(EncounterType::CCS60(None)),
            "OKI" => Ok(EncounterType::OKI(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EncounterType {
    fn into(self) -> Option<String> {
        match self {
            EncounterType::ADMS(_) => Some("ADMS".to_string()),
            EncounterType::BD_BMClin(_) => Some("BD/BM-clin".to_string()),
            EncounterType::CCS60(_) => Some("CCS60".to_string()),
            EncounterType::OKI(_) => Some("OKI".to_string()),
            EncounterType::Null(_) => None,
        }
    }
}
impl MetaValue for EncounterType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EncounterType::ADMS(Some(e)) => e.get_field(field),
                EncounterType::BD_BMClin(Some(e)) => e.get_field(field),
                EncounterType::CCS60(Some(e)) => e.get_field(field),
                EncounterType::OKI(Some(e)) => e.get_field(field),
                EncounterType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EncounterType::ADMS(Some(e)) => e.get_field_mut(field),
                EncounterType::BD_BMClin(Some(e)) => e.get_field_mut(field),
                EncounterType::CCS60(Some(e)) => e.get_field_mut(field),
                EncounterType::OKI(Some(e)) => e.get_field_mut(field),
                EncounterType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EndpointConnectionType {
    #[doc = "DICOM QIDO-RS"]
    #[code = "dicom-qido-rs"]
    DicomQidoRs(Option<Element>),
    #[doc = "DICOM STOW-RS"]
    #[code = "dicom-stow-rs"]
    DicomStowRs(Option<Element>),
    #[doc = "DICOM WADO-RS"]
    #[code = "dicom-wado-rs"]
    DicomWadoRs(Option<Element>),
    #[doc = "DICOM WADO-URI"]
    #[code = "dicom-wado-uri"]
    DicomWadoUri(Option<Element>),
    #[doc = "Direct Project"]
    #[code = "direct-project"]
    DirectProject(Option<Element>),
    #[doc = "HL7 FHIR Messaging"]
    #[code = "hl7-fhir-msg"]
    Hl7FhirMsg(Option<Element>),
    #[doc = "HL7 FHIR"]
    #[code = "hl7-fhir-rest"]
    Hl7FhirRest(Option<Element>),
    #[doc = "HL7 v2 MLLP"]
    #[code = "hl7v2-mllp"]
    Hl7v2Mllp(Option<Element>),
    #[doc = "IHE IID"]
    #[code = "ihe-iid"]
    IheIid(Option<Element>),
    #[doc = "IHE XCA"]
    #[code = "ihe-xca"]
    IheXca(Option<Element>),
    #[doc = "IHE XCPD"]
    #[code = "ihe-xcpd"]
    IheXcpd(Option<Element>),
    #[doc = "IHE XDR"]
    #[code = "ihe-xdr"]
    IheXdr(Option<Element>),
    #[doc = "IHE XDS"]
    #[code = "ihe-xds"]
    IheXds(Option<Element>),
    #[doc = "Secure email"]
    #[code = "secure-email"]
    SecureEmail(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EndpointConnectionType {
    fn default() -> Self {
        EndpointConnectionType::Null(None)
    }
}
impl TryFrom<String> for EndpointConnectionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "dicom-qido-rs" => Ok(EndpointConnectionType::DicomQidoRs(None)),
            "dicom-stow-rs" => Ok(EndpointConnectionType::DicomStowRs(None)),
            "dicom-wado-rs" => Ok(EndpointConnectionType::DicomWadoRs(None)),
            "dicom-wado-uri" => Ok(EndpointConnectionType::DicomWadoUri(None)),
            "direct-project" => Ok(EndpointConnectionType::DirectProject(None)),
            "hl7-fhir-msg" => Ok(EndpointConnectionType::Hl7FhirMsg(None)),
            "hl7-fhir-rest" => Ok(EndpointConnectionType::Hl7FhirRest(None)),
            "hl7v2-mllp" => Ok(EndpointConnectionType::Hl7v2Mllp(None)),
            "ihe-iid" => Ok(EndpointConnectionType::IheIid(None)),
            "ihe-xca" => Ok(EndpointConnectionType::IheXca(None)),
            "ihe-xcpd" => Ok(EndpointConnectionType::IheXcpd(None)),
            "ihe-xdr" => Ok(EndpointConnectionType::IheXdr(None)),
            "ihe-xds" => Ok(EndpointConnectionType::IheXds(None)),
            "secure-email" => Ok(EndpointConnectionType::SecureEmail(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EndpointConnectionType {
    fn into(self) -> Option<String> {
        match self {
            EndpointConnectionType::DicomQidoRs(_) => Some("dicom-qido-rs".to_string()),
            EndpointConnectionType::DicomStowRs(_) => Some("dicom-stow-rs".to_string()),
            EndpointConnectionType::DicomWadoRs(_) => Some("dicom-wado-rs".to_string()),
            EndpointConnectionType::DicomWadoUri(_) => Some("dicom-wado-uri".to_string()),
            EndpointConnectionType::DirectProject(_) => Some("direct-project".to_string()),
            EndpointConnectionType::Hl7FhirMsg(_) => Some("hl7-fhir-msg".to_string()),
            EndpointConnectionType::Hl7FhirRest(_) => Some("hl7-fhir-rest".to_string()),
            EndpointConnectionType::Hl7v2Mllp(_) => Some("hl7v2-mllp".to_string()),
            EndpointConnectionType::IheIid(_) => Some("ihe-iid".to_string()),
            EndpointConnectionType::IheXca(_) => Some("ihe-xca".to_string()),
            EndpointConnectionType::IheXcpd(_) => Some("ihe-xcpd".to_string()),
            EndpointConnectionType::IheXdr(_) => Some("ihe-xdr".to_string()),
            EndpointConnectionType::IheXds(_) => Some("ihe-xds".to_string()),
            EndpointConnectionType::SecureEmail(_) => Some("secure-email".to_string()),
            EndpointConnectionType::Null(_) => None,
        }
    }
}
impl MetaValue for EndpointConnectionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EndpointConnectionType::DicomQidoRs(Some(e)) => e.get_field(field),
                EndpointConnectionType::DicomStowRs(Some(e)) => e.get_field(field),
                EndpointConnectionType::DicomWadoRs(Some(e)) => e.get_field(field),
                EndpointConnectionType::DicomWadoUri(Some(e)) => e.get_field(field),
                EndpointConnectionType::DirectProject(Some(e)) => e.get_field(field),
                EndpointConnectionType::Hl7FhirMsg(Some(e)) => e.get_field(field),
                EndpointConnectionType::Hl7FhirRest(Some(e)) => e.get_field(field),
                EndpointConnectionType::Hl7v2Mllp(Some(e)) => e.get_field(field),
                EndpointConnectionType::IheIid(Some(e)) => e.get_field(field),
                EndpointConnectionType::IheXca(Some(e)) => e.get_field(field),
                EndpointConnectionType::IheXcpd(Some(e)) => e.get_field(field),
                EndpointConnectionType::IheXdr(Some(e)) => e.get_field(field),
                EndpointConnectionType::IheXds(Some(e)) => e.get_field(field),
                EndpointConnectionType::SecureEmail(Some(e)) => e.get_field(field),
                EndpointConnectionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EndpointConnectionType::DicomQidoRs(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::DicomStowRs(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::DicomWadoRs(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::DicomWadoUri(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::DirectProject(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::Hl7FhirMsg(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::Hl7FhirRest(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::Hl7v2Mllp(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::IheIid(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::IheXca(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::IheXcpd(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::IheXdr(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::IheXds(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::SecureEmail(Some(e)) => e.get_field_mut(field),
                EndpointConnectionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EndpointPayloadType {
    #[doc = "Any"]
    #[code = "any"]
    Any(Option<Element>),
    #[doc = "None"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "For documents following C-CDA constraints using a non structured body. "]
    #[code = "urn:hl7-org:sdwg:ccda-nonXMLBody:1.1"]
    Urn_Hl7Org_Sdwg_CcdaNonXMLBody_11(Option<Element>),
    #[doc = "For documents following C-CDA constraints using a structured body. "]
    #[code = "urn:hl7-org:sdwg:ccda-structuredBody:1.1"]
    Urn_Hl7Org_Sdwg_CcdaStructuredBody_11(Option<Element>),
    #[doc = "Cardiology CRC"]
    #[code = "urn:ihe:card:CRC:2012"]
    Urn_Ihe_Card_CRC_2012(Option<Element>),
    #[doc = "Cardiology EPRC-IE"]
    #[code = "urn:ihe:card:EPRC-IE:2014"]
    Urn_Ihe_Card_EPRCIE_2014(Option<Element>),
    #[doc = "Cardiac Imaging Report"]
    #[code = "urn:ihe:card:imaging:2011"]
    Urn_Ihe_Card_Imaging_2011(Option<Element>),
    #[doc = "Dental CDA"]
    #[code = "urn:ihe:dent:CDA:ImagingReportStructuredHeadings:2013"]
    Urn_Ihe_Dent_CDA_ImagingReportStructuredHeadings_2013(Option<Element>),
    #[doc = "Dental PDF"]
    #[code = "urn:ihe:dent:PDF"]
    Urn_Ihe_Dent_PDF(Option<Element>),
    #[doc = "Dental Text"]
    #[code = "urn:ihe:dent:TEXT"]
    Urn_Ihe_Dent_TEXT(Option<Element>),
    #[doc = "Basic Patient Privacy Consents with Scanned Document"]
    #[code = "urn:ihe:iti:bppc-sd:2007"]
    Urn_Ihe_Iti_BppcSd_2007(Option<Element>),
    #[doc = "Basic Patient Privacy Consents"]
    #[code = "urn:ihe:iti:bppc:2007"]
    Urn_Ihe_Iti_Bppc_2007(Option<Element>),
    #[doc = "DSG Detached Document"]
    #[code = "urn:ihe:iti:dsg:detached:2014"]
    Urn_Ihe_Iti_Dsg_Detached_2014(Option<Element>),
    #[doc = "DSG Enveloping Document"]
    #[code = "urn:ihe:iti:dsg:enveloping:2014"]
    Urn_Ihe_Iti_Dsg_Enveloping_2014(Option<Element>),
    #[doc = "PDF embedded in CDA per XDS-SD profile"]
    #[code = "urn:ihe:iti:xds-sd:pdf:2008"]
    Urn_Ihe_Iti_XdsSd_Pdf_2008(Option<Element>),
    #[doc = "Text embedded in CDA per XDS-SD profile"]
    #[code = "urn:ihe:iti:xds-sd:text:2008"]
    Urn_Ihe_Iti_XdsSd_Text_2008(Option<Element>),
    #[doc = "XDW Workflow Document"]
    #[code = "urn:ihe:iti:xdw:2011:workflowDoc"]
    Urn_Ihe_Iti_Xdw_2011_WorkflowDoc(Option<Element>),
    #[doc = "CDA Laboratory Report"]
    #[code = "urn:ihe:lab:xd-lab:2008"]
    Urn_Ihe_Lab_XdLab_2008(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report All"]
    #[code = "urn:ihe:pat:apsr:all:2010"]
    Urn_Ihe_Pat_Apsr_All_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer All"]
    #[code = "urn:ihe:pat:apsr:cancer:all:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_All_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Breast"]
    #[code = "urn:ihe:pat:apsr:cancer:breast:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Breast_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Cervix"]
    #[code = "urn:ihe:pat:apsr:cancer:cervix:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Cervix_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Colon"]
    #[code = "urn:ihe:pat:apsr:cancer:colon:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Colon_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Endometrium"]
    #[code = "urn:ihe:pat:apsr:cancer:endometrium:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Endometrium_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Esophagus"]
    #[code = "urn:ihe:pat:apsr:cancer:esophagus: 2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Esophagus_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Kidney"]
    #[code = "urn:ihe:pat:apsr:cancer:kidney:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Kidney_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Larynx"]
    #[code = "urn:ihe:pat:apsr:cancer:larynx:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Larynx_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Lip Oral Cavity"]
    #[code = "urn:ihe:pat:apsr:cancer:lip_oral_cavity:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Lip_oral_cavity_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Liver"]
    #[code = "urn:ihe:pat:apsr:cancer:liver:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Liver_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Lung"]
    #[code = "urn:ihe:pat:apsr:cancer:lung:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Lung_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Ovary"]
    #[code = "urn:ihe:pat:apsr:cancer:ovary:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Ovary_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Pancreas"]
    #[code = "urn:ihe:pat:apsr:cancer:pancreas: 2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Pancreas_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Pharynx"]
    #[code = "urn:ihe:pat:apsr:cancer:pharynx:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Pharynx_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Prostate"]
    #[code = "urn:ihe:pat:apsr:cancer:prostate:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Prostate_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Salivary Gland"]
    #[code = "urn:ihe:pat:apsr:cancer:salivary_gland:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Salivary_gland_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Skin"]
    #[code = "urn:ihe:pat:apsr:cancer:skin:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Skin_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Stomach"]
    #[code = "urn:ihe:pat:apsr:cancer:stomach: 2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Stomach_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Testis"]
    #[code = "urn:ihe:pat:apsr:cancer:testis:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Testis_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Thyroid"]
    #[code = "urn:ihe:pat:apsr:cancer:thyroid:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Thyroid_2010(Option<Element>),
    #[doc = "Anatomic Pathology Structured Report Cancer Urinary Bladder"]
    #[code = "urn:ihe:pat:apsr:cancer:urinary_bladder:2010"]
    Urn_Ihe_Pat_Apsr_Cancer_Urinary_bladder_2010(Option<Element>),
    #[doc = "Antepartum Record (APR) - Education"]
    #[code = "urn:ihe:pcc:apr:edu:2008"]
    Urn_Ihe_Pcc_Apr_Edu_2008(Option<Element>),
    #[doc = "Antepartum Record (APR) - History and Physical"]
    #[code = "urn:ihe:pcc:apr:handp:2008"]
    Urn_Ihe_Pcc_Apr_Handp_2008(Option<Element>),
    #[doc = "Antepartum Record (APR) - Laboratory"]
    #[code = "urn:ihe:pcc:apr:lab:2008"]
    Urn_Ihe_Pcc_Apr_Lab_2008(Option<Element>),
    #[doc = "IHE Antepartum Summary"]
    #[code = "urn:ihe:pcc:aps:2007"]
    Urn_Ihe_Pcc_Aps_2007(Option<Element>),
    #[doc = "Care Management (CM)"]
    #[code = "urn:ihe:pcc:cm:2008"]
    Urn_Ihe_Pcc_Cm_2008(Option<Element>),
    #[doc = "Cancer Registry Content (CRC)"]
    #[code = "urn:ihe:pcc:crc:2008"]
    Urn_Ihe_Pcc_Crc_2008(Option<Element>),
    #[doc = "PCC CTN"]
    #[code = "urn:ihe:pcc:ctn:2007"]
    Urn_Ihe_Pcc_Ctn_2007(Option<Element>),
    #[doc = "Emergency Department Encounter Summary (EDES)"]
    #[code = "urn:ihe:pcc:edes:2007"]
    Urn_Ihe_Pcc_Edes_2007(Option<Element>),
    #[doc = "PCC EDPN"]
    #[code = "urn:ihe:pcc:edpn:2007"]
    Urn_Ihe_Pcc_Edpn_2007(Option<Element>),
    #[doc = "Emergency Department Referral (EDR)"]
    #[code = "urn:ihe:pcc:edr:2007"]
    Urn_Ihe_Pcc_Edr_2007(Option<Element>),
    #[doc = "PCC ETS"]
    #[code = "urn:ihe:pcc:ets:2011"]
    Urn_Ihe_Pcc_Ets_2011(Option<Element>),
    #[doc = "History and Physical Specification"]
    #[code = "urn:ihe:pcc:handp:2008"]
    Urn_Ihe_Pcc_Handp_2008(Option<Element>),
    #[doc = "PCC HP"]
    #[code = "urn:ihe:pcc:hp:2008"]
    Urn_Ihe_Pcc_Hp_2008(Option<Element>),
    #[doc = "Immunization Content (IC)"]
    #[code = "urn:ihe:pcc:ic:2009"]
    Urn_Ihe_Pcc_Ic_2009(Option<Element>),
    #[doc = "Immunization Registry Content (IRC)"]
    #[code = "urn:ihe:pcc:irc:2008"]
    Urn_Ihe_Pcc_Irc_2008(Option<Element>),
    #[doc = "PCC ITS"]
    #[code = "urn:ihe:pcc:its:2011"]
    Urn_Ihe_Pcc_Its_2011(Option<Element>),
    #[doc = "PCC LDHP"]
    #[code = "urn:ihe:pcc:ldhp:2009"]
    Urn_Ihe_Pcc_Ldhp_2009(Option<Element>),
    #[doc = "PCC LDS"]
    #[code = "urn:ihe:pcc:lds:2009"]
    Urn_Ihe_Pcc_Lds_2009(Option<Element>),
    #[doc = "PCC MDS"]
    #[code = "urn:ihe:pcc:mds:2009"]
    Urn_Ihe_Pcc_Mds_2009(Option<Element>),
    #[doc = "PCC NDS"]
    #[code = "urn:ihe:pcc:nds:2010"]
    Urn_Ihe_Pcc_Nds_2010(Option<Element>),
    #[doc = "PCC NN"]
    #[code = "urn:ihe:pcc:nn:2007"]
    Urn_Ihe_Pcc_Nn_2007(Option<Element>),
    #[doc = "PCC PPVS"]
    #[code = "urn:ihe:pcc:ppvs:2010"]
    Urn_Ihe_Pcc_Ppvs_2010(Option<Element>),
    #[doc = "PCC TN"]
    #[code = "urn:ihe:pcc:tn:2007"]
    Urn_Ihe_Pcc_Tn_2007(Option<Element>),
    #[doc = "PCC TRS"]
    #[code = "urn:ihe:pcc:trs:2011"]
    Urn_Ihe_Pcc_Trs_2011(Option<Element>),
    #[doc = "XDS Medical Summaries"]
    #[code = "urn:ihe:pcc:xds-ms:2007"]
    Urn_Ihe_Pcc_XdsMs_2007(Option<Element>),
    #[doc = "Personal Health Records"]
    #[code = "urn:ihe:pcc:xphr:2007"]
    Urn_Ihe_Pcc_Xphr_2007(Option<Element>),
    #[doc = "Pharmacy DIS"]
    #[code = "urn:ihe:pharm:dis:2010"]
    Urn_Ihe_Pharm_Dis_2010(Option<Element>),
    #[doc = "Pharmacy PADV"]
    #[code = "urn:ihe:pharm:padv:2010"]
    Urn_Ihe_Pharm_Padv_2010(Option<Element>),
    #[doc = "Pharmacy PML"]
    #[code = "urn:ihe:pharm:pml:2013"]
    Urn_Ihe_Pharm_Pml_2013(Option<Element>),
    #[doc = "Pharmacy Pre"]
    #[code = "urn:ihe:pharm:pre:2010"]
    Urn_Ihe_Pharm_Pre_2010(Option<Element>),
    #[doc = "Radiology XDS-I Structured CDA"]
    #[code = "urn:ihe:rad:CDA:ImagingReportStructuredHeadings:2013"]
    Urn_Ihe_Rad_CDA_ImagingReportStructuredHeadings_2013(Option<Element>),
    #[doc = "Radiology XDS-I PDF"]
    #[code = "urn:ihe:rad:PDF"]
    Urn_Ihe_Rad_PDF(Option<Element>),
    #[doc = "Radiology XDS-I Text"]
    #[code = "urn:ihe:rad:TEXT"]
    Urn_Ihe_Rad_TEXT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EndpointPayloadType {
    fn default() -> Self {
        EndpointPayloadType::Null(None)
    }
}
impl TryFrom<String> for EndpointPayloadType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "any" => Ok(EndpointPayloadType::Any(None)),
            "none" => Ok(EndpointPayloadType::None(None)),
            "urn:hl7-org:sdwg:ccda-nonXMLBody:1.1" => {
                Ok(EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaNonXMLBody_11(None))
            }
            "urn:hl7-org:sdwg:ccda-structuredBody:1.1" => Ok(
                EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaStructuredBody_11(None),
            ),
            "urn:ihe:card:CRC:2012" => Ok(EndpointPayloadType::Urn_Ihe_Card_CRC_2012(None)),
            "urn:ihe:card:EPRC-IE:2014" => Ok(EndpointPayloadType::Urn_Ihe_Card_EPRCIE_2014(None)),
            "urn:ihe:card:imaging:2011" => Ok(EndpointPayloadType::Urn_Ihe_Card_Imaging_2011(None)),
            "urn:ihe:dent:CDA:ImagingReportStructuredHeadings:2013" => Ok(
                EndpointPayloadType::Urn_Ihe_Dent_CDA_ImagingReportStructuredHeadings_2013(None),
            ),
            "urn:ihe:dent:PDF" => Ok(EndpointPayloadType::Urn_Ihe_Dent_PDF(None)),
            "urn:ihe:dent:TEXT" => Ok(EndpointPayloadType::Urn_Ihe_Dent_TEXT(None)),
            "urn:ihe:iti:bppc-sd:2007" => Ok(EndpointPayloadType::Urn_Ihe_Iti_BppcSd_2007(None)),
            "urn:ihe:iti:bppc:2007" => Ok(EndpointPayloadType::Urn_Ihe_Iti_Bppc_2007(None)),
            "urn:ihe:iti:dsg:detached:2014" => {
                Ok(EndpointPayloadType::Urn_Ihe_Iti_Dsg_Detached_2014(None))
            }
            "urn:ihe:iti:dsg:enveloping:2014" => {
                Ok(EndpointPayloadType::Urn_Ihe_Iti_Dsg_Enveloping_2014(None))
            }
            "urn:ihe:iti:xds-sd:pdf:2008" => {
                Ok(EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Pdf_2008(None))
            }
            "urn:ihe:iti:xds-sd:text:2008" => {
                Ok(EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Text_2008(None))
            }
            "urn:ihe:iti:xdw:2011:workflowDoc" => {
                Ok(EndpointPayloadType::Urn_Ihe_Iti_Xdw_2011_WorkflowDoc(None))
            }
            "urn:ihe:lab:xd-lab:2008" => Ok(EndpointPayloadType::Urn_Ihe_Lab_XdLab_2008(None)),
            "urn:ihe:pat:apsr:all:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_All_2010(None)),
            "urn:ihe:pat:apsr:cancer:all:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_All_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:breast:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Breast_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:cervix:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Cervix_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:colon:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Colon_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:endometrium:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Endometrium_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:esophagus: 2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Esophagus_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:kidney:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Kidney_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:larynx:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Larynx_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:lip_oral_cavity:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lip_oral_cavity_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:liver:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Liver_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:lung:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lung_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:ovary:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Ovary_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:pancreas: 2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pancreas_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:pharynx:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pharynx_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:prostate:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Prostate_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:salivary_gland:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Salivary_gland_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:skin:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Skin_2010(None))
            }
            "urn:ihe:pat:apsr:cancer:stomach: 2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Stomach_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:testis:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Testis_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:thyroid:2010" => Ok(
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Thyroid_2010(None),
            ),
            "urn:ihe:pat:apsr:cancer:urinary_bladder:2010" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Urinary_bladder_2010(None))
            }
            "urn:ihe:pcc:apr:edu:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Apr_Edu_2008(None)),
            "urn:ihe:pcc:apr:handp:2008" => {
                Ok(EndpointPayloadType::Urn_Ihe_Pcc_Apr_Handp_2008(None))
            }
            "urn:ihe:pcc:apr:lab:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Apr_Lab_2008(None)),
            "urn:ihe:pcc:aps:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Aps_2007(None)),
            "urn:ihe:pcc:cm:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Cm_2008(None)),
            "urn:ihe:pcc:crc:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Crc_2008(None)),
            "urn:ihe:pcc:ctn:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Ctn_2007(None)),
            "urn:ihe:pcc:edes:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Edes_2007(None)),
            "urn:ihe:pcc:edpn:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Edpn_2007(None)),
            "urn:ihe:pcc:edr:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Edr_2007(None)),
            "urn:ihe:pcc:ets:2011" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Ets_2011(None)),
            "urn:ihe:pcc:handp:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Handp_2008(None)),
            "urn:ihe:pcc:hp:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Hp_2008(None)),
            "urn:ihe:pcc:ic:2009" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Ic_2009(None)),
            "urn:ihe:pcc:irc:2008" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Irc_2008(None)),
            "urn:ihe:pcc:its:2011" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Its_2011(None)),
            "urn:ihe:pcc:ldhp:2009" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Ldhp_2009(None)),
            "urn:ihe:pcc:lds:2009" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Lds_2009(None)),
            "urn:ihe:pcc:mds:2009" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Mds_2009(None)),
            "urn:ihe:pcc:nds:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Nds_2010(None)),
            "urn:ihe:pcc:nn:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Nn_2007(None)),
            "urn:ihe:pcc:ppvs:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Ppvs_2010(None)),
            "urn:ihe:pcc:tn:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Tn_2007(None)),
            "urn:ihe:pcc:trs:2011" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Trs_2011(None)),
            "urn:ihe:pcc:xds-ms:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_XdsMs_2007(None)),
            "urn:ihe:pcc:xphr:2007" => Ok(EndpointPayloadType::Urn_Ihe_Pcc_Xphr_2007(None)),
            "urn:ihe:pharm:dis:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pharm_Dis_2010(None)),
            "urn:ihe:pharm:padv:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pharm_Padv_2010(None)),
            "urn:ihe:pharm:pml:2013" => Ok(EndpointPayloadType::Urn_Ihe_Pharm_Pml_2013(None)),
            "urn:ihe:pharm:pre:2010" => Ok(EndpointPayloadType::Urn_Ihe_Pharm_Pre_2010(None)),
            "urn:ihe:rad:CDA:ImagingReportStructuredHeadings:2013" => {
                Ok(EndpointPayloadType::Urn_Ihe_Rad_CDA_ImagingReportStructuredHeadings_2013(None))
            }
            "urn:ihe:rad:PDF" => Ok(EndpointPayloadType::Urn_Ihe_Rad_PDF(None)),
            "urn:ihe:rad:TEXT" => Ok(EndpointPayloadType::Urn_Ihe_Rad_TEXT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EndpointPayloadType {
    fn into(self) -> Option<String> {
        match self {
            EndpointPayloadType::Any(_) => Some("any".to_string()),
            EndpointPayloadType::None(_) => Some("none".to_string()),
            EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaNonXMLBody_11(_) => {
                Some("urn:hl7-org:sdwg:ccda-nonXMLBody:1.1".to_string())
            }
            EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaStructuredBody_11(_) => {
                Some("urn:hl7-org:sdwg:ccda-structuredBody:1.1".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Card_CRC_2012(_) => {
                Some("urn:ihe:card:CRC:2012".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Card_EPRCIE_2014(_) => {
                Some("urn:ihe:card:EPRC-IE:2014".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Card_Imaging_2011(_) => {
                Some("urn:ihe:card:imaging:2011".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Dent_CDA_ImagingReportStructuredHeadings_2013(_) => {
                Some("urn:ihe:dent:CDA:ImagingReportStructuredHeadings:2013".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Dent_PDF(_) => Some("urn:ihe:dent:PDF".to_string()),
            EndpointPayloadType::Urn_Ihe_Dent_TEXT(_) => Some("urn:ihe:dent:TEXT".to_string()),
            EndpointPayloadType::Urn_Ihe_Iti_BppcSd_2007(_) => {
                Some("urn:ihe:iti:bppc-sd:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_Bppc_2007(_) => {
                Some("urn:ihe:iti:bppc:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_Dsg_Detached_2014(_) => {
                Some("urn:ihe:iti:dsg:detached:2014".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_Dsg_Enveloping_2014(_) => {
                Some("urn:ihe:iti:dsg:enveloping:2014".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Pdf_2008(_) => {
                Some("urn:ihe:iti:xds-sd:pdf:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Text_2008(_) => {
                Some("urn:ihe:iti:xds-sd:text:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Iti_Xdw_2011_WorkflowDoc(_) => {
                Some("urn:ihe:iti:xdw:2011:workflowDoc".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Lab_XdLab_2008(_) => {
                Some("urn:ihe:lab:xd-lab:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_All_2010(_) => {
                Some("urn:ihe:pat:apsr:all:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_All_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:all:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Breast_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:breast:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Cervix_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:cervix:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Colon_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:colon:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Endometrium_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:endometrium:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Esophagus_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:esophagus: 2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Kidney_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:kidney:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Larynx_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:larynx:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lip_oral_cavity_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:lip_oral_cavity:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Liver_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:liver:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lung_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:lung:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Ovary_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:ovary:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pancreas_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:pancreas: 2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pharynx_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:pharynx:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Prostate_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:prostate:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Salivary_gland_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:salivary_gland:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Skin_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:skin:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Stomach_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:stomach: 2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Testis_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:testis:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Thyroid_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:thyroid:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Urinary_bladder_2010(_) => {
                Some("urn:ihe:pat:apsr:cancer:urinary_bladder:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Apr_Edu_2008(_) => {
                Some("urn:ihe:pcc:apr:edu:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Apr_Handp_2008(_) => {
                Some("urn:ihe:pcc:apr:handp:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Apr_Lab_2008(_) => {
                Some("urn:ihe:pcc:apr:lab:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Aps_2007(_) => {
                Some("urn:ihe:pcc:aps:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Cm_2008(_) => Some("urn:ihe:pcc:cm:2008".to_string()),
            EndpointPayloadType::Urn_Ihe_Pcc_Crc_2008(_) => {
                Some("urn:ihe:pcc:crc:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Ctn_2007(_) => {
                Some("urn:ihe:pcc:ctn:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Edes_2007(_) => {
                Some("urn:ihe:pcc:edes:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Edpn_2007(_) => {
                Some("urn:ihe:pcc:edpn:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Edr_2007(_) => {
                Some("urn:ihe:pcc:edr:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Ets_2011(_) => {
                Some("urn:ihe:pcc:ets:2011".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Handp_2008(_) => {
                Some("urn:ihe:pcc:handp:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Hp_2008(_) => Some("urn:ihe:pcc:hp:2008".to_string()),
            EndpointPayloadType::Urn_Ihe_Pcc_Ic_2009(_) => Some("urn:ihe:pcc:ic:2009".to_string()),
            EndpointPayloadType::Urn_Ihe_Pcc_Irc_2008(_) => {
                Some("urn:ihe:pcc:irc:2008".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Its_2011(_) => {
                Some("urn:ihe:pcc:its:2011".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Ldhp_2009(_) => {
                Some("urn:ihe:pcc:ldhp:2009".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Lds_2009(_) => {
                Some("urn:ihe:pcc:lds:2009".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Mds_2009(_) => {
                Some("urn:ihe:pcc:mds:2009".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Nds_2010(_) => {
                Some("urn:ihe:pcc:nds:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Nn_2007(_) => Some("urn:ihe:pcc:nn:2007".to_string()),
            EndpointPayloadType::Urn_Ihe_Pcc_Ppvs_2010(_) => {
                Some("urn:ihe:pcc:ppvs:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Tn_2007(_) => Some("urn:ihe:pcc:tn:2007".to_string()),
            EndpointPayloadType::Urn_Ihe_Pcc_Trs_2011(_) => {
                Some("urn:ihe:pcc:trs:2011".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_XdsMs_2007(_) => {
                Some("urn:ihe:pcc:xds-ms:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pcc_Xphr_2007(_) => {
                Some("urn:ihe:pcc:xphr:2007".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pharm_Dis_2010(_) => {
                Some("urn:ihe:pharm:dis:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pharm_Padv_2010(_) => {
                Some("urn:ihe:pharm:padv:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pharm_Pml_2013(_) => {
                Some("urn:ihe:pharm:pml:2013".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Pharm_Pre_2010(_) => {
                Some("urn:ihe:pharm:pre:2010".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Rad_CDA_ImagingReportStructuredHeadings_2013(_) => {
                Some("urn:ihe:rad:CDA:ImagingReportStructuredHeadings:2013".to_string())
            }
            EndpointPayloadType::Urn_Ihe_Rad_PDF(_) => Some("urn:ihe:rad:PDF".to_string()),
            EndpointPayloadType::Urn_Ihe_Rad_TEXT(_) => Some("urn:ihe:rad:TEXT".to_string()),
            EndpointPayloadType::Null(_) => None,
        }
    }
}
impl MetaValue for EndpointPayloadType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EndpointPayloadType::Any(Some(e)) => e.get_field(field),
                EndpointPayloadType::None(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaNonXMLBody_11(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaStructuredBody_11(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Card_CRC_2012(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Card_EPRCIE_2014(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Card_Imaging_2011(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Dent_CDA_ImagingReportStructuredHeadings_2013(
                    Some(e),
                ) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Dent_PDF(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Dent_TEXT(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_BppcSd_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_Bppc_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_Dsg_Detached_2014(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_Dsg_Enveloping_2014(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Pdf_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Text_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Iti_Xdw_2011_WorkflowDoc(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Lab_XdLab_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_All_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_All_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Breast_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Cervix_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Colon_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Endometrium_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Esophagus_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Kidney_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Larynx_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lip_oral_cavity_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Liver_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lung_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Ovary_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pancreas_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pharynx_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Prostate_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Salivary_gland_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Skin_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Stomach_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Testis_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Thyroid_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Urinary_bladder_2010(Some(e)) => {
                    e.get_field(field)
                }
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Edu_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Handp_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Lab_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Aps_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Cm_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Crc_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ctn_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edes_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edpn_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edr_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ets_2011(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Handp_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Hp_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ic_2009(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Irc_2008(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Its_2011(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ldhp_2009(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Lds_2009(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Mds_2009(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Nds_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Nn_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ppvs_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Tn_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Trs_2011(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_XdsMs_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Xphr_2007(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Dis_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Padv_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Pml_2013(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Pre_2010(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Rad_CDA_ImagingReportStructuredHeadings_2013(
                    Some(e),
                ) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Rad_PDF(Some(e)) => e.get_field(field),
                EndpointPayloadType::Urn_Ihe_Rad_TEXT(Some(e)) => e.get_field(field),
                EndpointPayloadType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EndpointPayloadType::Any(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::None(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaNonXMLBody_11(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Hl7Org_Sdwg_CcdaStructuredBody_11(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Card_CRC_2012(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Card_EPRCIE_2014(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Card_Imaging_2011(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Dent_CDA_ImagingReportStructuredHeadings_2013(
                    Some(e),
                ) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Dent_PDF(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Dent_TEXT(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Iti_BppcSd_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Iti_Bppc_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Iti_Dsg_Detached_2014(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Iti_Dsg_Enveloping_2014(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Pdf_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Iti_XdsSd_Text_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Iti_Xdw_2011_WorkflowDoc(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Lab_XdLab_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_All_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_All_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Breast_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Cervix_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Colon_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Endometrium_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Esophagus_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Kidney_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Larynx_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lip_oral_cavity_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Liver_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Lung_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Ovary_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pancreas_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Pharynx_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Prostate_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Salivary_gland_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Skin_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Stomach_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Testis_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Thyroid_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pat_Apsr_Cancer_Urinary_bladder_2010(Some(e)) => {
                    e.get_field_mut(field)
                }
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Edu_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Handp_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Apr_Lab_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Aps_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Cm_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Crc_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ctn_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edes_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edpn_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Edr_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ets_2011(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Handp_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Hp_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ic_2009(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Irc_2008(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Its_2011(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ldhp_2009(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Lds_2009(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Mds_2009(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Nds_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Nn_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Ppvs_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Tn_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Trs_2011(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_XdsMs_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pcc_Xphr_2007(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Dis_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Padv_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Pml_2013(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Pharm_Pre_2010(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Rad_CDA_ImagingReportStructuredHeadings_2013(
                    Some(e),
                ) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Rad_PDF(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Urn_Ihe_Rad_TEXT(Some(e)) => e.get_field_mut(field),
                EndpointPayloadType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EndpointStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Off"]
    #[code = "off"]
    Off(Option<Element>),
    #[doc = "Suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "Test"]
    #[code = "test"]
    Test(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EndpointStatus {
    fn default() -> Self {
        EndpointStatus::Null(None)
    }
}
impl TryFrom<String> for EndpointStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(EndpointStatus::Active(None)),
            "entered-in-error" => Ok(EndpointStatus::EnteredInError(None)),
            "error" => Ok(EndpointStatus::Error(None)),
            "off" => Ok(EndpointStatus::Off(None)),
            "suspended" => Ok(EndpointStatus::Suspended(None)),
            "test" => Ok(EndpointStatus::Test(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EndpointStatus {
    fn into(self) -> Option<String> {
        match self {
            EndpointStatus::Active(_) => Some("active".to_string()),
            EndpointStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            EndpointStatus::Error(_) => Some("error".to_string()),
            EndpointStatus::Off(_) => Some("off".to_string()),
            EndpointStatus::Suspended(_) => Some("suspended".to_string()),
            EndpointStatus::Test(_) => Some("test".to_string()),
            EndpointStatus::Null(_) => None,
        }
    }
}
impl MetaValue for EndpointStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EndpointStatus::Active(Some(e)) => e.get_field(field),
                EndpointStatus::EnteredInError(Some(e)) => e.get_field(field),
                EndpointStatus::Error(Some(e)) => e.get_field(field),
                EndpointStatus::Off(Some(e)) => e.get_field(field),
                EndpointStatus::Suspended(Some(e)) => e.get_field(field),
                EndpointStatus::Test(Some(e)) => e.get_field(field),
                EndpointStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EndpointStatus::Active(Some(e)) => e.get_field_mut(field),
                EndpointStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                EndpointStatus::Error(Some(e)) => e.get_field_mut(field),
                EndpointStatus::Off(Some(e)) => e.get_field_mut(field),
                EndpointStatus::Suspended(Some(e)) => e.get_field_mut(field),
                EndpointStatus::Test(Some(e)) => e.get_field_mut(field),
                EndpointStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EnteralRoute {
    #[code = "EFT"]
    EFT(Option<Element>),
    #[code = "ENTINSTL"]
    ENTINSTL(Option<Element>),
    #[code = "GJT"]
    GJT(Option<Element>),
    #[code = "GT"]
    GT(Option<Element>),
    #[code = "JJTINSTL"]
    JJTINSTL(Option<Element>),
    #[code = "NGT"]
    NGT(Option<Element>),
    #[code = "OGT"]
    OGT(Option<Element>),
    #[code = "OJJ"]
    OJJ(Option<Element>),
    #[code = "PO"]
    PO(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EnteralRoute {
    fn default() -> Self {
        EnteralRoute::Null(None)
    }
}
impl TryFrom<String> for EnteralRoute {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "EFT" => Ok(EnteralRoute::EFT(None)),
            "ENTINSTL" => Ok(EnteralRoute::ENTINSTL(None)),
            "GJT" => Ok(EnteralRoute::GJT(None)),
            "GT" => Ok(EnteralRoute::GT(None)),
            "JJTINSTL" => Ok(EnteralRoute::JJTINSTL(None)),
            "NGT" => Ok(EnteralRoute::NGT(None)),
            "OGT" => Ok(EnteralRoute::OGT(None)),
            "OJJ" => Ok(EnteralRoute::OJJ(None)),
            "PO" => Ok(EnteralRoute::PO(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EnteralRoute {
    fn into(self) -> Option<String> {
        match self {
            EnteralRoute::EFT(_) => Some("EFT".to_string()),
            EnteralRoute::ENTINSTL(_) => Some("ENTINSTL".to_string()),
            EnteralRoute::GJT(_) => Some("GJT".to_string()),
            EnteralRoute::GT(_) => Some("GT".to_string()),
            EnteralRoute::JJTINSTL(_) => Some("JJTINSTL".to_string()),
            EnteralRoute::NGT(_) => Some("NGT".to_string()),
            EnteralRoute::OGT(_) => Some("OGT".to_string()),
            EnteralRoute::OJJ(_) => Some("OJJ".to_string()),
            EnteralRoute::PO(_) => Some("PO".to_string()),
            EnteralRoute::Null(_) => None,
        }
    }
}
impl MetaValue for EnteralRoute {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EnteralRoute::EFT(Some(e)) => e.get_field(field),
                EnteralRoute::ENTINSTL(Some(e)) => e.get_field(field),
                EnteralRoute::GJT(Some(e)) => e.get_field(field),
                EnteralRoute::GT(Some(e)) => e.get_field(field),
                EnteralRoute::JJTINSTL(Some(e)) => e.get_field(field),
                EnteralRoute::NGT(Some(e)) => e.get_field(field),
                EnteralRoute::OGT(Some(e)) => e.get_field(field),
                EnteralRoute::OJJ(Some(e)) => e.get_field(field),
                EnteralRoute::PO(Some(e)) => e.get_field(field),
                EnteralRoute::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EnteralRoute::EFT(Some(e)) => e.get_field_mut(field),
                EnteralRoute::ENTINSTL(Some(e)) => e.get_field_mut(field),
                EnteralRoute::GJT(Some(e)) => e.get_field_mut(field),
                EnteralRoute::GT(Some(e)) => e.get_field_mut(field),
                EnteralRoute::JJTINSTL(Some(e)) => e.get_field_mut(field),
                EnteralRoute::NGT(Some(e)) => e.get_field_mut(field),
                EnteralRoute::OGT(Some(e)) => e.get_field_mut(field),
                EnteralRoute::OJJ(Some(e)) => e.get_field_mut(field),
                EnteralRoute::PO(Some(e)) => e.get_field_mut(field),
                EnteralRoute::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EntformulaAdditive {
    #[doc = "Carbohydrate"]
    #[code = "carbohydrate"]
    Carbohydrate(Option<Element>),
    #[doc = "Fiber"]
    #[code = "fiber"]
    Fiber(Option<Element>),
    #[doc = "Lipid"]
    #[code = "lipid"]
    Lipid(Option<Element>),
    #[doc = "Protein"]
    #[code = "protein"]
    Protein(Option<Element>),
    #[doc = "Water"]
    #[code = "water"]
    Water(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EntformulaAdditive {
    fn default() -> Self {
        EntformulaAdditive::Null(None)
    }
}
impl TryFrom<String> for EntformulaAdditive {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "carbohydrate" => Ok(EntformulaAdditive::Carbohydrate(None)),
            "fiber" => Ok(EntformulaAdditive::Fiber(None)),
            "lipid" => Ok(EntformulaAdditive::Lipid(None)),
            "protein" => Ok(EntformulaAdditive::Protein(None)),
            "water" => Ok(EntformulaAdditive::Water(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EntformulaAdditive {
    fn into(self) -> Option<String> {
        match self {
            EntformulaAdditive::Carbohydrate(_) => Some("carbohydrate".to_string()),
            EntformulaAdditive::Fiber(_) => Some("fiber".to_string()),
            EntformulaAdditive::Lipid(_) => Some("lipid".to_string()),
            EntformulaAdditive::Protein(_) => Some("protein".to_string()),
            EntformulaAdditive::Water(_) => Some("water".to_string()),
            EntformulaAdditive::Null(_) => None,
        }
    }
}
impl MetaValue for EntformulaAdditive {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EntformulaAdditive::Carbohydrate(Some(e)) => e.get_field(field),
                EntformulaAdditive::Fiber(Some(e)) => e.get_field(field),
                EntformulaAdditive::Lipid(Some(e)) => e.get_field(field),
                EntformulaAdditive::Protein(Some(e)) => e.get_field(field),
                EntformulaAdditive::Water(Some(e)) => e.get_field(field),
                EntformulaAdditive::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EntformulaAdditive::Carbohydrate(Some(e)) => e.get_field_mut(field),
                EntformulaAdditive::Fiber(Some(e)) => e.get_field_mut(field),
                EntformulaAdditive::Lipid(Some(e)) => e.get_field_mut(field),
                EntformulaAdditive::Protein(Some(e)) => e.get_field_mut(field),
                EntformulaAdditive::Water(Some(e)) => e.get_field_mut(field),
                EntformulaAdditive::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EntformulaType {
    #[doc = "Standard Enteral Formula"]
    #[code = "441531000124102"]
    V441531000124102(Option<Element>),
    #[doc = "Standard enteral formula with fiber"]
    #[code = "441561000124106"]
    V441561000124106(Option<Element>),
    #[doc = "High energy enteral formula with fiber"]
    #[code = "441571000124104"]
    V441571000124104(Option<Element>),
    #[doc = "Diabetic enteral formula with fiber"]
    #[code = "441591000124103"]
    V441591000124103(Option<Element>),
    #[doc = "Diabetic high calorie high protein enteral formula with fiber"]
    #[code = "441601000124106"]
    V441601000124106(Option<Element>),
    #[doc = "Hydrolyzed peptide-based high protein enteral formula"]
    #[code = "441671000124100"]
    V441671000124100(Option<Element>),
    #[doc = "Adult formula"]
    #[code = "442651000124102"]
    V442651000124102(Option<Element>),
    #[doc = "Adult elemental formula"]
    #[code = "442911000124109"]
    V442911000124109(Option<Element>),
    #[doc = "Adult standard formula"]
    #[code = "442921000124101"]
    V442921000124101(Option<Element>),
    #[doc = "Adult soy protein isolate formula"]
    #[code = "442931000124103"]
    V442931000124103(Option<Element>),
    #[doc = "Adult renal specialty formula"]
    #[code = "442941000124108"]
    V442941000124108(Option<Element>),
    #[doc = "Adult pulmonary specialty formula"]
    #[code = "442951000124105"]
    V442951000124105(Option<Element>),
    #[doc = "Adult low carbohydrate formula"]
    #[code = "442961000124107"]
    V442961000124107(Option<Element>),
    #[doc = "Adult high energy formula"]
    #[code = "442971000124100"]
    V442971000124100(Option<Element>),
    #[doc = "Adult hydrolyzed protein formula"]
    #[code = "442981000124102"]
    V442981000124102(Option<Element>),
    #[doc = "Adult high protein formula"]
    #[code = "442991000124104"]
    V442991000124104(Option<Element>),
    #[doc = "Adult high protein high fiber formula"]
    #[code = "443011000124100"]
    V443011000124100(Option<Element>),
    #[doc = "Adult hepatic specialty formula"]
    #[code = "443021000124108"]
    V443021000124108(Option<Element>),
    #[doc = "Adult critical care formula"]
    #[code = "443031000124106"]
    V443031000124106(Option<Element>),
    #[doc = "Adult diabetes specialty formula"]
    #[code = "443051000124104"]
    V443051000124104(Option<Element>),
    #[doc = "High protein formula"]
    #[code = "443111000124101"]
    V443111000124101(Option<Element>),
    #[doc = "Increased fiber formula"]
    #[code = "443351000124102"]
    V443351000124102(Option<Element>),
    #[doc = "Pediatric Formula"]
    #[code = "443361000124100"]
    V443361000124100(Option<Element>),
    #[doc = "Pediatric elemental formula"]
    #[code = "443401000124105"]
    V443401000124105(Option<Element>),
    #[doc = "Elemental Formula"]
    #[code = "443411000124108"]
    V443411000124108(Option<Element>),
    #[doc = "Pediatric hydrolyzed protein formula"]
    #[code = "443421000124100"]
    V443421000124100(Option<Element>),
    #[doc = "High Energy Formula"]
    #[code = "443431000124102"]
    V443431000124102(Option<Element>),
    #[doc = "Pediatric standard formula"]
    #[code = "443451000124109"]
    V443451000124109(Option<Element>),
    #[doc = "Standard Formula"]
    #[code = "443461000124106"]
    V443461000124106(Option<Element>),
    #[doc = "Pediatric increased fiber formula"]
    #[code = "443471000124104"]
    V443471000124104(Option<Element>),
    #[doc = "Renal Formula"]
    #[code = "443481000124101"]
    V443481000124101(Option<Element>),
    #[doc = "Pediatric high energy formula"]
    #[code = "443491000124103"]
    V443491000124103(Option<Element>),
    #[doc = "Pediatric high energy formula with increased fiber"]
    #[code = "443501000124106"]
    V443501000124106(Option<Element>),
    #[doc = "Soy based formula"]
    #[code = "443561000124107"]
    V443561000124107(Option<Element>),
    #[doc = "Hydrolyzed protein formula"]
    #[code = "443771000124106"]
    V443771000124106(Option<Element>),
    #[doc = "Pediatric reduced energy formula"]
    #[code = "444431000124104"]
    V444431000124104(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EntformulaType {
    fn default() -> Self {
        EntformulaType::Null(None)
    }
}
impl TryFrom<String> for EntformulaType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "441531000124102" => Ok(EntformulaType::V441531000124102(None)),
            "441561000124106" => Ok(EntformulaType::V441561000124106(None)),
            "441571000124104" => Ok(EntformulaType::V441571000124104(None)),
            "441591000124103" => Ok(EntformulaType::V441591000124103(None)),
            "441601000124106" => Ok(EntformulaType::V441601000124106(None)),
            "441671000124100" => Ok(EntformulaType::V441671000124100(None)),
            "442651000124102" => Ok(EntformulaType::V442651000124102(None)),
            "442911000124109" => Ok(EntformulaType::V442911000124109(None)),
            "442921000124101" => Ok(EntformulaType::V442921000124101(None)),
            "442931000124103" => Ok(EntformulaType::V442931000124103(None)),
            "442941000124108" => Ok(EntformulaType::V442941000124108(None)),
            "442951000124105" => Ok(EntformulaType::V442951000124105(None)),
            "442961000124107" => Ok(EntformulaType::V442961000124107(None)),
            "442971000124100" => Ok(EntformulaType::V442971000124100(None)),
            "442981000124102" => Ok(EntformulaType::V442981000124102(None)),
            "442991000124104" => Ok(EntformulaType::V442991000124104(None)),
            "443011000124100" => Ok(EntformulaType::V443011000124100(None)),
            "443021000124108" => Ok(EntformulaType::V443021000124108(None)),
            "443031000124106" => Ok(EntformulaType::V443031000124106(None)),
            "443051000124104" => Ok(EntformulaType::V443051000124104(None)),
            "443111000124101" => Ok(EntformulaType::V443111000124101(None)),
            "443351000124102" => Ok(EntformulaType::V443351000124102(None)),
            "443361000124100" => Ok(EntformulaType::V443361000124100(None)),
            "443401000124105" => Ok(EntformulaType::V443401000124105(None)),
            "443411000124108" => Ok(EntformulaType::V443411000124108(None)),
            "443421000124100" => Ok(EntformulaType::V443421000124100(None)),
            "443431000124102" => Ok(EntformulaType::V443431000124102(None)),
            "443451000124109" => Ok(EntformulaType::V443451000124109(None)),
            "443461000124106" => Ok(EntformulaType::V443461000124106(None)),
            "443471000124104" => Ok(EntformulaType::V443471000124104(None)),
            "443481000124101" => Ok(EntformulaType::V443481000124101(None)),
            "443491000124103" => Ok(EntformulaType::V443491000124103(None)),
            "443501000124106" => Ok(EntformulaType::V443501000124106(None)),
            "443561000124107" => Ok(EntformulaType::V443561000124107(None)),
            "443771000124106" => Ok(EntformulaType::V443771000124106(None)),
            "444431000124104" => Ok(EntformulaType::V444431000124104(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EntformulaType {
    fn into(self) -> Option<String> {
        match self {
            EntformulaType::V441531000124102(_) => Some("441531000124102".to_string()),
            EntformulaType::V441561000124106(_) => Some("441561000124106".to_string()),
            EntformulaType::V441571000124104(_) => Some("441571000124104".to_string()),
            EntformulaType::V441591000124103(_) => Some("441591000124103".to_string()),
            EntformulaType::V441601000124106(_) => Some("441601000124106".to_string()),
            EntformulaType::V441671000124100(_) => Some("441671000124100".to_string()),
            EntformulaType::V442651000124102(_) => Some("442651000124102".to_string()),
            EntformulaType::V442911000124109(_) => Some("442911000124109".to_string()),
            EntformulaType::V442921000124101(_) => Some("442921000124101".to_string()),
            EntformulaType::V442931000124103(_) => Some("442931000124103".to_string()),
            EntformulaType::V442941000124108(_) => Some("442941000124108".to_string()),
            EntformulaType::V442951000124105(_) => Some("442951000124105".to_string()),
            EntformulaType::V442961000124107(_) => Some("442961000124107".to_string()),
            EntformulaType::V442971000124100(_) => Some("442971000124100".to_string()),
            EntformulaType::V442981000124102(_) => Some("442981000124102".to_string()),
            EntformulaType::V442991000124104(_) => Some("442991000124104".to_string()),
            EntformulaType::V443011000124100(_) => Some("443011000124100".to_string()),
            EntformulaType::V443021000124108(_) => Some("443021000124108".to_string()),
            EntformulaType::V443031000124106(_) => Some("443031000124106".to_string()),
            EntformulaType::V443051000124104(_) => Some("443051000124104".to_string()),
            EntformulaType::V443111000124101(_) => Some("443111000124101".to_string()),
            EntformulaType::V443351000124102(_) => Some("443351000124102".to_string()),
            EntformulaType::V443361000124100(_) => Some("443361000124100".to_string()),
            EntformulaType::V443401000124105(_) => Some("443401000124105".to_string()),
            EntformulaType::V443411000124108(_) => Some("443411000124108".to_string()),
            EntformulaType::V443421000124100(_) => Some("443421000124100".to_string()),
            EntformulaType::V443431000124102(_) => Some("443431000124102".to_string()),
            EntformulaType::V443451000124109(_) => Some("443451000124109".to_string()),
            EntformulaType::V443461000124106(_) => Some("443461000124106".to_string()),
            EntformulaType::V443471000124104(_) => Some("443471000124104".to_string()),
            EntformulaType::V443481000124101(_) => Some("443481000124101".to_string()),
            EntformulaType::V443491000124103(_) => Some("443491000124103".to_string()),
            EntformulaType::V443501000124106(_) => Some("443501000124106".to_string()),
            EntformulaType::V443561000124107(_) => Some("443561000124107".to_string()),
            EntformulaType::V443771000124106(_) => Some("443771000124106".to_string()),
            EntformulaType::V444431000124104(_) => Some("444431000124104".to_string()),
            EntformulaType::Null(_) => None,
        }
    }
}
impl MetaValue for EntformulaType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EntformulaType::V441531000124102(Some(e)) => e.get_field(field),
                EntformulaType::V441561000124106(Some(e)) => e.get_field(field),
                EntformulaType::V441571000124104(Some(e)) => e.get_field(field),
                EntformulaType::V441591000124103(Some(e)) => e.get_field(field),
                EntformulaType::V441601000124106(Some(e)) => e.get_field(field),
                EntformulaType::V441671000124100(Some(e)) => e.get_field(field),
                EntformulaType::V442651000124102(Some(e)) => e.get_field(field),
                EntformulaType::V442911000124109(Some(e)) => e.get_field(field),
                EntformulaType::V442921000124101(Some(e)) => e.get_field(field),
                EntformulaType::V442931000124103(Some(e)) => e.get_field(field),
                EntformulaType::V442941000124108(Some(e)) => e.get_field(field),
                EntformulaType::V442951000124105(Some(e)) => e.get_field(field),
                EntformulaType::V442961000124107(Some(e)) => e.get_field(field),
                EntformulaType::V442971000124100(Some(e)) => e.get_field(field),
                EntformulaType::V442981000124102(Some(e)) => e.get_field(field),
                EntformulaType::V442991000124104(Some(e)) => e.get_field(field),
                EntformulaType::V443011000124100(Some(e)) => e.get_field(field),
                EntformulaType::V443021000124108(Some(e)) => e.get_field(field),
                EntformulaType::V443031000124106(Some(e)) => e.get_field(field),
                EntformulaType::V443051000124104(Some(e)) => e.get_field(field),
                EntformulaType::V443111000124101(Some(e)) => e.get_field(field),
                EntformulaType::V443351000124102(Some(e)) => e.get_field(field),
                EntformulaType::V443361000124100(Some(e)) => e.get_field(field),
                EntformulaType::V443401000124105(Some(e)) => e.get_field(field),
                EntformulaType::V443411000124108(Some(e)) => e.get_field(field),
                EntformulaType::V443421000124100(Some(e)) => e.get_field(field),
                EntformulaType::V443431000124102(Some(e)) => e.get_field(field),
                EntformulaType::V443451000124109(Some(e)) => e.get_field(field),
                EntformulaType::V443461000124106(Some(e)) => e.get_field(field),
                EntformulaType::V443471000124104(Some(e)) => e.get_field(field),
                EntformulaType::V443481000124101(Some(e)) => e.get_field(field),
                EntformulaType::V443491000124103(Some(e)) => e.get_field(field),
                EntformulaType::V443501000124106(Some(e)) => e.get_field(field),
                EntformulaType::V443561000124107(Some(e)) => e.get_field(field),
                EntformulaType::V443771000124106(Some(e)) => e.get_field(field),
                EntformulaType::V444431000124104(Some(e)) => e.get_field(field),
                EntformulaType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EntformulaType::V441531000124102(Some(e)) => e.get_field_mut(field),
                EntformulaType::V441561000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V441571000124104(Some(e)) => e.get_field_mut(field),
                EntformulaType::V441591000124103(Some(e)) => e.get_field_mut(field),
                EntformulaType::V441601000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V441671000124100(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442651000124102(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442911000124109(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442921000124101(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442931000124103(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442941000124108(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442951000124105(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442961000124107(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442971000124100(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442981000124102(Some(e)) => e.get_field_mut(field),
                EntformulaType::V442991000124104(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443011000124100(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443021000124108(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443031000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443051000124104(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443111000124101(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443351000124102(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443361000124100(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443401000124105(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443411000124108(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443421000124100(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443431000124102(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443451000124109(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443461000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443471000124104(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443481000124101(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443491000124103(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443501000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443561000124107(Some(e)) => e.get_field_mut(field),
                EntformulaType::V443771000124106(Some(e)) => e.get_field_mut(field),
                EntformulaType::V444431000124104(Some(e)) => e.get_field_mut(field),
                EntformulaType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EpisodeOfCareStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Finished"]
    #[code = "finished"]
    Finished(Option<Element>),
    #[doc = "On Hold"]
    #[code = "onhold"]
    Onhold(Option<Element>),
    #[doc = "Planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "Waitlist"]
    #[code = "waitlist"]
    Waitlist(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EpisodeOfCareStatus {
    fn default() -> Self {
        EpisodeOfCareStatus::Null(None)
    }
}
impl TryFrom<String> for EpisodeOfCareStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(EpisodeOfCareStatus::Active(None)),
            "cancelled" => Ok(EpisodeOfCareStatus::Cancelled(None)),
            "entered-in-error" => Ok(EpisodeOfCareStatus::EnteredInError(None)),
            "finished" => Ok(EpisodeOfCareStatus::Finished(None)),
            "onhold" => Ok(EpisodeOfCareStatus::Onhold(None)),
            "planned" => Ok(EpisodeOfCareStatus::Planned(None)),
            "waitlist" => Ok(EpisodeOfCareStatus::Waitlist(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EpisodeOfCareStatus {
    fn into(self) -> Option<String> {
        match self {
            EpisodeOfCareStatus::Active(_) => Some("active".to_string()),
            EpisodeOfCareStatus::Cancelled(_) => Some("cancelled".to_string()),
            EpisodeOfCareStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            EpisodeOfCareStatus::Finished(_) => Some("finished".to_string()),
            EpisodeOfCareStatus::Onhold(_) => Some("onhold".to_string()),
            EpisodeOfCareStatus::Planned(_) => Some("planned".to_string()),
            EpisodeOfCareStatus::Waitlist(_) => Some("waitlist".to_string()),
            EpisodeOfCareStatus::Null(_) => None,
        }
    }
}
impl MetaValue for EpisodeOfCareStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EpisodeOfCareStatus::Active(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Cancelled(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::EnteredInError(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Finished(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Onhold(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Planned(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Waitlist(Some(e)) => e.get_field(field),
                EpisodeOfCareStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EpisodeOfCareStatus::Active(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Finished(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Onhold(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Planned(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Waitlist(Some(e)) => e.get_field_mut(field),
                EpisodeOfCareStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EpisodeofcareType {
    #[doc = "Community-based aged care"]
    #[code = "cacp"]
    Cacp(Option<Element>),
    #[doc = "Drug and alcohol rehabilitation"]
    #[code = "da"]
    Da(Option<Element>),
    #[doc = "Post coordinated diabetes program"]
    #[code = "diab"]
    Diab(Option<Element>),
    #[doc = "Home and Community Care"]
    #[code = "hacc"]
    Hacc(Option<Element>),
    #[doc = "Post Acute Care"]
    #[code = "pac"]
    Pac(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EpisodeofcareType {
    fn default() -> Self {
        EpisodeofcareType::Null(None)
    }
}
impl TryFrom<String> for EpisodeofcareType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cacp" => Ok(EpisodeofcareType::Cacp(None)),
            "da" => Ok(EpisodeofcareType::Da(None)),
            "diab" => Ok(EpisodeofcareType::Diab(None)),
            "hacc" => Ok(EpisodeofcareType::Hacc(None)),
            "pac" => Ok(EpisodeofcareType::Pac(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EpisodeofcareType {
    fn into(self) -> Option<String> {
        match self {
            EpisodeofcareType::Cacp(_) => Some("cacp".to_string()),
            EpisodeofcareType::Da(_) => Some("da".to_string()),
            EpisodeofcareType::Diab(_) => Some("diab".to_string()),
            EpisodeofcareType::Hacc(_) => Some("hacc".to_string()),
            EpisodeofcareType::Pac(_) => Some("pac".to_string()),
            EpisodeofcareType::Null(_) => None,
        }
    }
}
impl MetaValue for EpisodeofcareType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EpisodeofcareType::Cacp(Some(e)) => e.get_field(field),
                EpisodeofcareType::Da(Some(e)) => e.get_field(field),
                EpisodeofcareType::Diab(Some(e)) => e.get_field(field),
                EpisodeofcareType::Hacc(Some(e)) => e.get_field(field),
                EpisodeofcareType::Pac(Some(e)) => e.get_field(field),
                EpisodeofcareType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EpisodeofcareType::Cacp(Some(e)) => e.get_field_mut(field),
                EpisodeofcareType::Da(Some(e)) => e.get_field_mut(field),
                EpisodeofcareType::Diab(Some(e)) => e.get_field_mut(field),
                EpisodeofcareType::Hacc(Some(e)) => e.get_field_mut(field),
                EpisodeofcareType::Pac(Some(e)) => e.get_field_mut(field),
                EpisodeofcareType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EventCapabilityMode {
    #[doc = "Receiver"]
    #[code = "receiver"]
    Receiver(Option<Element>),
    #[doc = "Sender"]
    #[code = "sender"]
    Sender(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EventCapabilityMode {
    fn default() -> Self {
        EventCapabilityMode::Null(None)
    }
}
impl TryFrom<String> for EventCapabilityMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "receiver" => Ok(EventCapabilityMode::Receiver(None)),
            "sender" => Ok(EventCapabilityMode::Sender(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EventCapabilityMode {
    fn into(self) -> Option<String> {
        match self {
            EventCapabilityMode::Receiver(_) => Some("receiver".to_string()),
            EventCapabilityMode::Sender(_) => Some("sender".to_string()),
            EventCapabilityMode::Null(_) => None,
        }
    }
}
impl MetaValue for EventCapabilityMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EventCapabilityMode::Receiver(Some(e)) => e.get_field(field),
                EventCapabilityMode::Sender(Some(e)) => e.get_field(field),
                EventCapabilityMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EventCapabilityMode::Receiver(Some(e)) => e.get_field_mut(field),
                EventCapabilityMode::Sender(Some(e)) => e.get_field_mut(field),
                EventCapabilityMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EventOrRequestResourceTypes {
    #[doc = "Appointment"]
    #[code = "Appointment"]
    Appointment(Option<Element>),
    #[doc = "AppointmentResponse"]
    #[code = "AppointmentResponse"]
    AppointmentResponse(Option<Element>),
    #[doc = "CarePlan"]
    #[code = "CarePlan"]
    CarePlan(Option<Element>),
    #[doc = "ChargeItem"]
    #[code = "ChargeItem"]
    ChargeItem(Option<Element>),
    #[doc = "Claim"]
    #[code = "Claim"]
    Claim(Option<Element>),
    #[doc = "ClaimResponse"]
    #[code = "ClaimResponse"]
    ClaimResponse(Option<Element>),
    #[doc = "ClinicalImpression"]
    #[code = "ClinicalImpression"]
    ClinicalImpression(Option<Element>),
    #[doc = "Communication"]
    #[code = "Communication"]
    Communication(Option<Element>),
    #[doc = "CommunicationRequest"]
    #[code = "CommunicationRequest"]
    CommunicationRequest(Option<Element>),
    #[doc = "Composition"]
    #[code = "Composition"]
    Composition(Option<Element>),
    #[doc = "Condition"]
    #[code = "Condition"]
    Condition(Option<Element>),
    #[doc = "Consent"]
    #[code = "Consent"]
    Consent(Option<Element>),
    #[doc = "Contract"]
    #[code = "Contract"]
    Contract(Option<Element>),
    #[doc = "Coverage"]
    #[code = "Coverage"]
    Coverage(Option<Element>),
    #[doc = "DeviceRequest"]
    #[code = "DeviceRequest"]
    DeviceRequest(Option<Element>),
    #[doc = "DeviceUseStatement"]
    #[code = "DeviceUseStatement"]
    DeviceUseStatement(Option<Element>),
    #[doc = "DiagnosticReport"]
    #[code = "DiagnosticReport"]
    DiagnosticReport(Option<Element>),
    #[doc = "DocumentManifest"]
    #[code = "DocumentManifest"]
    DocumentManifest(Option<Element>),
    #[doc = "DocumentReference"]
    #[code = "DocumentReference"]
    DocumentReference(Option<Element>),
    #[doc = "Encounter"]
    #[code = "Encounter"]
    Encounter(Option<Element>),
    #[doc = "EnrollmentRequest"]
    #[code = "EnrollmentRequest"]
    EnrollmentRequest(Option<Element>),
    #[doc = "EnrollmentResponse"]
    #[code = "EnrollmentResponse"]
    EnrollmentResponse(Option<Element>),
    #[doc = "EpisodeOfCare"]
    #[code = "EpisodeOfCare"]
    EpisodeOfCare(Option<Element>),
    #[doc = "ExplanationOfBenefit"]
    #[code = "ExplanationOfBenefit"]
    ExplanationOfBenefit(Option<Element>),
    #[doc = "FamilyMemberHistory"]
    #[code = "FamilyMemberHistory"]
    FamilyMemberHistory(Option<Element>),
    #[doc = "GuidanceResponse"]
    #[code = "GuidanceResponse"]
    GuidanceResponse(Option<Element>),
    #[doc = "ImagingStudy"]
    #[code = "ImagingStudy"]
    ImagingStudy(Option<Element>),
    #[doc = "Immunization"]
    #[code = "Immunization"]
    Immunization(Option<Element>),
    #[doc = "ImmunizationRecommendation"]
    #[code = "ImmunizationRecommendation"]
    ImmunizationRecommendation(Option<Element>),
    #[doc = "MeasureReport"]
    #[code = "MeasureReport"]
    MeasureReport(Option<Element>),
    #[doc = "Media"]
    #[code = "Media"]
    Media(Option<Element>),
    #[doc = "MedicationAdministration"]
    #[code = "MedicationAdministration"]
    MedicationAdministration(Option<Element>),
    #[doc = "MedicationDispense"]
    #[code = "MedicationDispense"]
    MedicationDispense(Option<Element>),
    #[doc = "MedicationRequest"]
    #[code = "MedicationRequest"]
    MedicationRequest(Option<Element>),
    #[doc = "MedicationStatement"]
    #[code = "MedicationStatement"]
    MedicationStatement(Option<Element>),
    #[doc = "NutritionOrder"]
    #[code = "NutritionOrder"]
    NutritionOrder(Option<Element>),
    #[doc = "Observation"]
    #[code = "Observation"]
    Observation(Option<Element>),
    #[doc = "PaymentNotice"]
    #[code = "PaymentNotice"]
    PaymentNotice(Option<Element>),
    #[doc = "PaymentReconciliation"]
    #[code = "PaymentReconciliation"]
    PaymentReconciliation(Option<Element>),
    #[doc = "Procedure"]
    #[code = "Procedure"]
    Procedure(Option<Element>),
    #[doc = "ProcessResponse"]
    #[code = "ProcessResponse"]
    ProcessResponse(Option<Element>),
    #[doc = "QuestionnaireResponse"]
    #[code = "QuestionnaireResponse"]
    QuestionnaireResponse(Option<Element>),
    #[doc = "RiskAssessment"]
    #[code = "RiskAssessment"]
    RiskAssessment(Option<Element>),
    #[doc = "ServiceRequest"]
    #[code = "ServiceRequest"]
    ServiceRequest(Option<Element>),
    #[doc = "SupplyDelivery"]
    #[code = "SupplyDelivery"]
    SupplyDelivery(Option<Element>),
    #[doc = "SupplyRequest"]
    #[code = "SupplyRequest"]
    SupplyRequest(Option<Element>),
    #[doc = "Task"]
    #[code = "Task"]
    Task(Option<Element>),
    #[doc = "VisionPrescription"]
    #[code = "VisionPrescription"]
    VisionPrescription(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EventOrRequestResourceTypes {
    fn default() -> Self {
        EventOrRequestResourceTypes::Null(None)
    }
}
impl TryFrom<String> for EventOrRequestResourceTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Appointment" => Ok(EventOrRequestResourceTypes::Appointment(None)),
            "AppointmentResponse" => Ok(EventOrRequestResourceTypes::AppointmentResponse(None)),
            "CarePlan" => Ok(EventOrRequestResourceTypes::CarePlan(None)),
            "ChargeItem" => Ok(EventOrRequestResourceTypes::ChargeItem(None)),
            "Claim" => Ok(EventOrRequestResourceTypes::Claim(None)),
            "ClaimResponse" => Ok(EventOrRequestResourceTypes::ClaimResponse(None)),
            "ClinicalImpression" => Ok(EventOrRequestResourceTypes::ClinicalImpression(None)),
            "Communication" => Ok(EventOrRequestResourceTypes::Communication(None)),
            "CommunicationRequest" => Ok(EventOrRequestResourceTypes::CommunicationRequest(None)),
            "Composition" => Ok(EventOrRequestResourceTypes::Composition(None)),
            "Condition" => Ok(EventOrRequestResourceTypes::Condition(None)),
            "Consent" => Ok(EventOrRequestResourceTypes::Consent(None)),
            "Contract" => Ok(EventOrRequestResourceTypes::Contract(None)),
            "Coverage" => Ok(EventOrRequestResourceTypes::Coverage(None)),
            "DeviceRequest" => Ok(EventOrRequestResourceTypes::DeviceRequest(None)),
            "DeviceUseStatement" => Ok(EventOrRequestResourceTypes::DeviceUseStatement(None)),
            "DiagnosticReport" => Ok(EventOrRequestResourceTypes::DiagnosticReport(None)),
            "DocumentManifest" => Ok(EventOrRequestResourceTypes::DocumentManifest(None)),
            "DocumentReference" => Ok(EventOrRequestResourceTypes::DocumentReference(None)),
            "Encounter" => Ok(EventOrRequestResourceTypes::Encounter(None)),
            "EnrollmentRequest" => Ok(EventOrRequestResourceTypes::EnrollmentRequest(None)),
            "EnrollmentResponse" => Ok(EventOrRequestResourceTypes::EnrollmentResponse(None)),
            "EpisodeOfCare" => Ok(EventOrRequestResourceTypes::EpisodeOfCare(None)),
            "ExplanationOfBenefit" => Ok(EventOrRequestResourceTypes::ExplanationOfBenefit(None)),
            "FamilyMemberHistory" => Ok(EventOrRequestResourceTypes::FamilyMemberHistory(None)),
            "GuidanceResponse" => Ok(EventOrRequestResourceTypes::GuidanceResponse(None)),
            "ImagingStudy" => Ok(EventOrRequestResourceTypes::ImagingStudy(None)),
            "Immunization" => Ok(EventOrRequestResourceTypes::Immunization(None)),
            "ImmunizationRecommendation" => Ok(
                EventOrRequestResourceTypes::ImmunizationRecommendation(None),
            ),
            "MeasureReport" => Ok(EventOrRequestResourceTypes::MeasureReport(None)),
            "Media" => Ok(EventOrRequestResourceTypes::Media(None)),
            "MedicationAdministration" => {
                Ok(EventOrRequestResourceTypes::MedicationAdministration(None))
            }
            "MedicationDispense" => Ok(EventOrRequestResourceTypes::MedicationDispense(None)),
            "MedicationRequest" => Ok(EventOrRequestResourceTypes::MedicationRequest(None)),
            "MedicationStatement" => Ok(EventOrRequestResourceTypes::MedicationStatement(None)),
            "NutritionOrder" => Ok(EventOrRequestResourceTypes::NutritionOrder(None)),
            "Observation" => Ok(EventOrRequestResourceTypes::Observation(None)),
            "PaymentNotice" => Ok(EventOrRequestResourceTypes::PaymentNotice(None)),
            "PaymentReconciliation" => Ok(EventOrRequestResourceTypes::PaymentReconciliation(None)),
            "Procedure" => Ok(EventOrRequestResourceTypes::Procedure(None)),
            "ProcessResponse" => Ok(EventOrRequestResourceTypes::ProcessResponse(None)),
            "QuestionnaireResponse" => Ok(EventOrRequestResourceTypes::QuestionnaireResponse(None)),
            "RiskAssessment" => Ok(EventOrRequestResourceTypes::RiskAssessment(None)),
            "ServiceRequest" => Ok(EventOrRequestResourceTypes::ServiceRequest(None)),
            "SupplyDelivery" => Ok(EventOrRequestResourceTypes::SupplyDelivery(None)),
            "SupplyRequest" => Ok(EventOrRequestResourceTypes::SupplyRequest(None)),
            "Task" => Ok(EventOrRequestResourceTypes::Task(None)),
            "VisionPrescription" => Ok(EventOrRequestResourceTypes::VisionPrescription(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EventOrRequestResourceTypes {
    fn into(self) -> Option<String> {
        match self {
            EventOrRequestResourceTypes::Appointment(_) => Some("Appointment".to_string()),
            EventOrRequestResourceTypes::AppointmentResponse(_) => {
                Some("AppointmentResponse".to_string())
            }
            EventOrRequestResourceTypes::CarePlan(_) => Some("CarePlan".to_string()),
            EventOrRequestResourceTypes::ChargeItem(_) => Some("ChargeItem".to_string()),
            EventOrRequestResourceTypes::Claim(_) => Some("Claim".to_string()),
            EventOrRequestResourceTypes::ClaimResponse(_) => Some("ClaimResponse".to_string()),
            EventOrRequestResourceTypes::ClinicalImpression(_) => {
                Some("ClinicalImpression".to_string())
            }
            EventOrRequestResourceTypes::Communication(_) => Some("Communication".to_string()),
            EventOrRequestResourceTypes::CommunicationRequest(_) => {
                Some("CommunicationRequest".to_string())
            }
            EventOrRequestResourceTypes::Composition(_) => Some("Composition".to_string()),
            EventOrRequestResourceTypes::Condition(_) => Some("Condition".to_string()),
            EventOrRequestResourceTypes::Consent(_) => Some("Consent".to_string()),
            EventOrRequestResourceTypes::Contract(_) => Some("Contract".to_string()),
            EventOrRequestResourceTypes::Coverage(_) => Some("Coverage".to_string()),
            EventOrRequestResourceTypes::DeviceRequest(_) => Some("DeviceRequest".to_string()),
            EventOrRequestResourceTypes::DeviceUseStatement(_) => {
                Some("DeviceUseStatement".to_string())
            }
            EventOrRequestResourceTypes::DiagnosticReport(_) => {
                Some("DiagnosticReport".to_string())
            }
            EventOrRequestResourceTypes::DocumentManifest(_) => {
                Some("DocumentManifest".to_string())
            }
            EventOrRequestResourceTypes::DocumentReference(_) => {
                Some("DocumentReference".to_string())
            }
            EventOrRequestResourceTypes::Encounter(_) => Some("Encounter".to_string()),
            EventOrRequestResourceTypes::EnrollmentRequest(_) => {
                Some("EnrollmentRequest".to_string())
            }
            EventOrRequestResourceTypes::EnrollmentResponse(_) => {
                Some("EnrollmentResponse".to_string())
            }
            EventOrRequestResourceTypes::EpisodeOfCare(_) => Some("EpisodeOfCare".to_string()),
            EventOrRequestResourceTypes::ExplanationOfBenefit(_) => {
                Some("ExplanationOfBenefit".to_string())
            }
            EventOrRequestResourceTypes::FamilyMemberHistory(_) => {
                Some("FamilyMemberHistory".to_string())
            }
            EventOrRequestResourceTypes::GuidanceResponse(_) => {
                Some("GuidanceResponse".to_string())
            }
            EventOrRequestResourceTypes::ImagingStudy(_) => Some("ImagingStudy".to_string()),
            EventOrRequestResourceTypes::Immunization(_) => Some("Immunization".to_string()),
            EventOrRequestResourceTypes::ImmunizationRecommendation(_) => {
                Some("ImmunizationRecommendation".to_string())
            }
            EventOrRequestResourceTypes::MeasureReport(_) => Some("MeasureReport".to_string()),
            EventOrRequestResourceTypes::Media(_) => Some("Media".to_string()),
            EventOrRequestResourceTypes::MedicationAdministration(_) => {
                Some("MedicationAdministration".to_string())
            }
            EventOrRequestResourceTypes::MedicationDispense(_) => {
                Some("MedicationDispense".to_string())
            }
            EventOrRequestResourceTypes::MedicationRequest(_) => {
                Some("MedicationRequest".to_string())
            }
            EventOrRequestResourceTypes::MedicationStatement(_) => {
                Some("MedicationStatement".to_string())
            }
            EventOrRequestResourceTypes::NutritionOrder(_) => Some("NutritionOrder".to_string()),
            EventOrRequestResourceTypes::Observation(_) => Some("Observation".to_string()),
            EventOrRequestResourceTypes::PaymentNotice(_) => Some("PaymentNotice".to_string()),
            EventOrRequestResourceTypes::PaymentReconciliation(_) => {
                Some("PaymentReconciliation".to_string())
            }
            EventOrRequestResourceTypes::Procedure(_) => Some("Procedure".to_string()),
            EventOrRequestResourceTypes::ProcessResponse(_) => Some("ProcessResponse".to_string()),
            EventOrRequestResourceTypes::QuestionnaireResponse(_) => {
                Some("QuestionnaireResponse".to_string())
            }
            EventOrRequestResourceTypes::RiskAssessment(_) => Some("RiskAssessment".to_string()),
            EventOrRequestResourceTypes::ServiceRequest(_) => Some("ServiceRequest".to_string()),
            EventOrRequestResourceTypes::SupplyDelivery(_) => Some("SupplyDelivery".to_string()),
            EventOrRequestResourceTypes::SupplyRequest(_) => Some("SupplyRequest".to_string()),
            EventOrRequestResourceTypes::Task(_) => Some("Task".to_string()),
            EventOrRequestResourceTypes::VisionPrescription(_) => {
                Some("VisionPrescription".to_string())
            }
            EventOrRequestResourceTypes::Null(_) => None,
        }
    }
}
impl MetaValue for EventOrRequestResourceTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EventOrRequestResourceTypes::Appointment(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::AppointmentResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::CarePlan(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ChargeItem(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Claim(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ClaimResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ClinicalImpression(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Communication(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::CommunicationRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Composition(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Condition(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Consent(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Contract(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Coverage(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::DeviceRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::DeviceUseStatement(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::DiagnosticReport(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::DocumentManifest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::DocumentReference(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Encounter(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::EnrollmentRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::EnrollmentResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::EpisodeOfCare(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ExplanationOfBenefit(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::FamilyMemberHistory(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::GuidanceResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ImagingStudy(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Immunization(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ImmunizationRecommendation(Some(e)) => {
                    e.get_field(field)
                }
                EventOrRequestResourceTypes::MeasureReport(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Media(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::MedicationAdministration(Some(e)) => {
                    e.get_field(field)
                }
                EventOrRequestResourceTypes::MedicationDispense(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::MedicationRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::MedicationStatement(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::NutritionOrder(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Observation(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::PaymentNotice(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::PaymentReconciliation(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Procedure(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ProcessResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::QuestionnaireResponse(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::RiskAssessment(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::ServiceRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::SupplyDelivery(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::SupplyRequest(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Task(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::VisionPrescription(Some(e)) => e.get_field(field),
                EventOrRequestResourceTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EventOrRequestResourceTypes::Appointment(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::AppointmentResponse(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::CarePlan(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ChargeItem(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Claim(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ClaimResponse(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ClinicalImpression(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Communication(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::CommunicationRequest(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::Composition(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Condition(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Consent(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Contract(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Coverage(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::DeviceRequest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::DeviceUseStatement(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::DiagnosticReport(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::DocumentManifest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::DocumentReference(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Encounter(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::EnrollmentRequest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::EnrollmentResponse(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::EpisodeOfCare(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ExplanationOfBenefit(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::FamilyMemberHistory(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::GuidanceResponse(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ImagingStudy(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Immunization(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ImmunizationRecommendation(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::MeasureReport(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Media(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::MedicationAdministration(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::MedicationDispense(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::MedicationRequest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::MedicationStatement(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::NutritionOrder(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Observation(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::PaymentNotice(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::PaymentReconciliation(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::Procedure(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ProcessResponse(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::QuestionnaireResponse(Some(e)) => {
                    e.get_field_mut(field)
                }
                EventOrRequestResourceTypes::RiskAssessment(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::ServiceRequest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::SupplyDelivery(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::SupplyRequest(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Task(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::VisionPrescription(Some(e)) => e.get_field_mut(field),
                EventOrRequestResourceTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EventResourceTypes {
    #[doc = "ChargeItem"]
    #[code = "ChargeItem"]
    ChargeItem(Option<Element>),
    #[doc = "ClaimResponse"]
    #[code = "ClaimResponse"]
    ClaimResponse(Option<Element>),
    #[doc = "ClinicalImpression"]
    #[code = "ClinicalImpression"]
    ClinicalImpression(Option<Element>),
    #[doc = "Communication"]
    #[code = "Communication"]
    Communication(Option<Element>),
    #[doc = "Composition"]
    #[code = "Composition"]
    Composition(Option<Element>),
    #[doc = "Condition"]
    #[code = "Condition"]
    Condition(Option<Element>),
    #[doc = "Consent"]
    #[code = "Consent"]
    Consent(Option<Element>),
    #[doc = "Coverage"]
    #[code = "Coverage"]
    Coverage(Option<Element>),
    #[doc = "DeviceUseStatement"]
    #[code = "DeviceUseStatement"]
    DeviceUseStatement(Option<Element>),
    #[doc = "DiagnosticReport"]
    #[code = "DiagnosticReport"]
    DiagnosticReport(Option<Element>),
    #[doc = "DocumentManifest"]
    #[code = "DocumentManifest"]
    DocumentManifest(Option<Element>),
    #[doc = "DocumentReference"]
    #[code = "DocumentReference"]
    DocumentReference(Option<Element>),
    #[doc = "Encounter"]
    #[code = "Encounter"]
    Encounter(Option<Element>),
    #[doc = "EnrollmentResponse"]
    #[code = "EnrollmentResponse"]
    EnrollmentResponse(Option<Element>),
    #[doc = "EpisodeOfCare"]
    #[code = "EpisodeOfCare"]
    EpisodeOfCare(Option<Element>),
    #[doc = "ExplanationOfBenefit"]
    #[code = "ExplanationOfBenefit"]
    ExplanationOfBenefit(Option<Element>),
    #[doc = "FamilyMemberHistory"]
    #[code = "FamilyMemberHistory"]
    FamilyMemberHistory(Option<Element>),
    #[doc = "GuidanceResponse"]
    #[code = "GuidanceResponse"]
    GuidanceResponse(Option<Element>),
    #[doc = "ImagingStudy"]
    #[code = "ImagingStudy"]
    ImagingStudy(Option<Element>),
    #[doc = "Immunization"]
    #[code = "Immunization"]
    Immunization(Option<Element>),
    #[doc = "MeasureReport"]
    #[code = "MeasureReport"]
    MeasureReport(Option<Element>),
    #[doc = "Media"]
    #[code = "Media"]
    Media(Option<Element>),
    #[doc = "MedicationAdministration"]
    #[code = "MedicationAdministration"]
    MedicationAdministration(Option<Element>),
    #[doc = "MedicationDispense"]
    #[code = "MedicationDispense"]
    MedicationDispense(Option<Element>),
    #[doc = "MedicationStatement"]
    #[code = "MedicationStatement"]
    MedicationStatement(Option<Element>),
    #[doc = "Observation"]
    #[code = "Observation"]
    Observation(Option<Element>),
    #[doc = "PaymentNotice"]
    #[code = "PaymentNotice"]
    PaymentNotice(Option<Element>),
    #[doc = "PaymentReconciliation"]
    #[code = "PaymentReconciliation"]
    PaymentReconciliation(Option<Element>),
    #[doc = "Procedure"]
    #[code = "Procedure"]
    Procedure(Option<Element>),
    #[doc = "ProcessResponse"]
    #[code = "ProcessResponse"]
    ProcessResponse(Option<Element>),
    #[doc = "QuestionnaireResponse"]
    #[code = "QuestionnaireResponse"]
    QuestionnaireResponse(Option<Element>),
    #[doc = "RiskAssessment"]
    #[code = "RiskAssessment"]
    RiskAssessment(Option<Element>),
    #[doc = "SupplyDelivery"]
    #[code = "SupplyDelivery"]
    SupplyDelivery(Option<Element>),
    #[doc = "Task"]
    #[code = "Task"]
    Task(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EventResourceTypes {
    fn default() -> Self {
        EventResourceTypes::Null(None)
    }
}
impl TryFrom<String> for EventResourceTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ChargeItem" => Ok(EventResourceTypes::ChargeItem(None)),
            "ClaimResponse" => Ok(EventResourceTypes::ClaimResponse(None)),
            "ClinicalImpression" => Ok(EventResourceTypes::ClinicalImpression(None)),
            "Communication" => Ok(EventResourceTypes::Communication(None)),
            "Composition" => Ok(EventResourceTypes::Composition(None)),
            "Condition" => Ok(EventResourceTypes::Condition(None)),
            "Consent" => Ok(EventResourceTypes::Consent(None)),
            "Coverage" => Ok(EventResourceTypes::Coverage(None)),
            "DeviceUseStatement" => Ok(EventResourceTypes::DeviceUseStatement(None)),
            "DiagnosticReport" => Ok(EventResourceTypes::DiagnosticReport(None)),
            "DocumentManifest" => Ok(EventResourceTypes::DocumentManifest(None)),
            "DocumentReference" => Ok(EventResourceTypes::DocumentReference(None)),
            "Encounter" => Ok(EventResourceTypes::Encounter(None)),
            "EnrollmentResponse" => Ok(EventResourceTypes::EnrollmentResponse(None)),
            "EpisodeOfCare" => Ok(EventResourceTypes::EpisodeOfCare(None)),
            "ExplanationOfBenefit" => Ok(EventResourceTypes::ExplanationOfBenefit(None)),
            "FamilyMemberHistory" => Ok(EventResourceTypes::FamilyMemberHistory(None)),
            "GuidanceResponse" => Ok(EventResourceTypes::GuidanceResponse(None)),
            "ImagingStudy" => Ok(EventResourceTypes::ImagingStudy(None)),
            "Immunization" => Ok(EventResourceTypes::Immunization(None)),
            "MeasureReport" => Ok(EventResourceTypes::MeasureReport(None)),
            "Media" => Ok(EventResourceTypes::Media(None)),
            "MedicationAdministration" => Ok(EventResourceTypes::MedicationAdministration(None)),
            "MedicationDispense" => Ok(EventResourceTypes::MedicationDispense(None)),
            "MedicationStatement" => Ok(EventResourceTypes::MedicationStatement(None)),
            "Observation" => Ok(EventResourceTypes::Observation(None)),
            "PaymentNotice" => Ok(EventResourceTypes::PaymentNotice(None)),
            "PaymentReconciliation" => Ok(EventResourceTypes::PaymentReconciliation(None)),
            "Procedure" => Ok(EventResourceTypes::Procedure(None)),
            "ProcessResponse" => Ok(EventResourceTypes::ProcessResponse(None)),
            "QuestionnaireResponse" => Ok(EventResourceTypes::QuestionnaireResponse(None)),
            "RiskAssessment" => Ok(EventResourceTypes::RiskAssessment(None)),
            "SupplyDelivery" => Ok(EventResourceTypes::SupplyDelivery(None)),
            "Task" => Ok(EventResourceTypes::Task(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EventResourceTypes {
    fn into(self) -> Option<String> {
        match self {
            EventResourceTypes::ChargeItem(_) => Some("ChargeItem".to_string()),
            EventResourceTypes::ClaimResponse(_) => Some("ClaimResponse".to_string()),
            EventResourceTypes::ClinicalImpression(_) => Some("ClinicalImpression".to_string()),
            EventResourceTypes::Communication(_) => Some("Communication".to_string()),
            EventResourceTypes::Composition(_) => Some("Composition".to_string()),
            EventResourceTypes::Condition(_) => Some("Condition".to_string()),
            EventResourceTypes::Consent(_) => Some("Consent".to_string()),
            EventResourceTypes::Coverage(_) => Some("Coverage".to_string()),
            EventResourceTypes::DeviceUseStatement(_) => Some("DeviceUseStatement".to_string()),
            EventResourceTypes::DiagnosticReport(_) => Some("DiagnosticReport".to_string()),
            EventResourceTypes::DocumentManifest(_) => Some("DocumentManifest".to_string()),
            EventResourceTypes::DocumentReference(_) => Some("DocumentReference".to_string()),
            EventResourceTypes::Encounter(_) => Some("Encounter".to_string()),
            EventResourceTypes::EnrollmentResponse(_) => Some("EnrollmentResponse".to_string()),
            EventResourceTypes::EpisodeOfCare(_) => Some("EpisodeOfCare".to_string()),
            EventResourceTypes::ExplanationOfBenefit(_) => Some("ExplanationOfBenefit".to_string()),
            EventResourceTypes::FamilyMemberHistory(_) => Some("FamilyMemberHistory".to_string()),
            EventResourceTypes::GuidanceResponse(_) => Some("GuidanceResponse".to_string()),
            EventResourceTypes::ImagingStudy(_) => Some("ImagingStudy".to_string()),
            EventResourceTypes::Immunization(_) => Some("Immunization".to_string()),
            EventResourceTypes::MeasureReport(_) => Some("MeasureReport".to_string()),
            EventResourceTypes::Media(_) => Some("Media".to_string()),
            EventResourceTypes::MedicationAdministration(_) => {
                Some("MedicationAdministration".to_string())
            }
            EventResourceTypes::MedicationDispense(_) => Some("MedicationDispense".to_string()),
            EventResourceTypes::MedicationStatement(_) => Some("MedicationStatement".to_string()),
            EventResourceTypes::Observation(_) => Some("Observation".to_string()),
            EventResourceTypes::PaymentNotice(_) => Some("PaymentNotice".to_string()),
            EventResourceTypes::PaymentReconciliation(_) => {
                Some("PaymentReconciliation".to_string())
            }
            EventResourceTypes::Procedure(_) => Some("Procedure".to_string()),
            EventResourceTypes::ProcessResponse(_) => Some("ProcessResponse".to_string()),
            EventResourceTypes::QuestionnaireResponse(_) => {
                Some("QuestionnaireResponse".to_string())
            }
            EventResourceTypes::RiskAssessment(_) => Some("RiskAssessment".to_string()),
            EventResourceTypes::SupplyDelivery(_) => Some("SupplyDelivery".to_string()),
            EventResourceTypes::Task(_) => Some("Task".to_string()),
            EventResourceTypes::Null(_) => None,
        }
    }
}
impl MetaValue for EventResourceTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EventResourceTypes::ChargeItem(Some(e)) => e.get_field(field),
                EventResourceTypes::ClaimResponse(Some(e)) => e.get_field(field),
                EventResourceTypes::ClinicalImpression(Some(e)) => e.get_field(field),
                EventResourceTypes::Communication(Some(e)) => e.get_field(field),
                EventResourceTypes::Composition(Some(e)) => e.get_field(field),
                EventResourceTypes::Condition(Some(e)) => e.get_field(field),
                EventResourceTypes::Consent(Some(e)) => e.get_field(field),
                EventResourceTypes::Coverage(Some(e)) => e.get_field(field),
                EventResourceTypes::DeviceUseStatement(Some(e)) => e.get_field(field),
                EventResourceTypes::DiagnosticReport(Some(e)) => e.get_field(field),
                EventResourceTypes::DocumentManifest(Some(e)) => e.get_field(field),
                EventResourceTypes::DocumentReference(Some(e)) => e.get_field(field),
                EventResourceTypes::Encounter(Some(e)) => e.get_field(field),
                EventResourceTypes::EnrollmentResponse(Some(e)) => e.get_field(field),
                EventResourceTypes::EpisodeOfCare(Some(e)) => e.get_field(field),
                EventResourceTypes::ExplanationOfBenefit(Some(e)) => e.get_field(field),
                EventResourceTypes::FamilyMemberHistory(Some(e)) => e.get_field(field),
                EventResourceTypes::GuidanceResponse(Some(e)) => e.get_field(field),
                EventResourceTypes::ImagingStudy(Some(e)) => e.get_field(field),
                EventResourceTypes::Immunization(Some(e)) => e.get_field(field),
                EventResourceTypes::MeasureReport(Some(e)) => e.get_field(field),
                EventResourceTypes::Media(Some(e)) => e.get_field(field),
                EventResourceTypes::MedicationAdministration(Some(e)) => e.get_field(field),
                EventResourceTypes::MedicationDispense(Some(e)) => e.get_field(field),
                EventResourceTypes::MedicationStatement(Some(e)) => e.get_field(field),
                EventResourceTypes::Observation(Some(e)) => e.get_field(field),
                EventResourceTypes::PaymentNotice(Some(e)) => e.get_field(field),
                EventResourceTypes::PaymentReconciliation(Some(e)) => e.get_field(field),
                EventResourceTypes::Procedure(Some(e)) => e.get_field(field),
                EventResourceTypes::ProcessResponse(Some(e)) => e.get_field(field),
                EventResourceTypes::QuestionnaireResponse(Some(e)) => e.get_field(field),
                EventResourceTypes::RiskAssessment(Some(e)) => e.get_field(field),
                EventResourceTypes::SupplyDelivery(Some(e)) => e.get_field(field),
                EventResourceTypes::Task(Some(e)) => e.get_field(field),
                EventResourceTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EventResourceTypes::ChargeItem(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::ClaimResponse(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::ClinicalImpression(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Communication(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Composition(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Condition(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Consent(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Coverage(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::DeviceUseStatement(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::DiagnosticReport(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::DocumentManifest(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::DocumentReference(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Encounter(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::EnrollmentResponse(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::EpisodeOfCare(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::ExplanationOfBenefit(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::FamilyMemberHistory(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::GuidanceResponse(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::ImagingStudy(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Immunization(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::MeasureReport(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Media(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::MedicationAdministration(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::MedicationDispense(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::MedicationStatement(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Observation(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::PaymentNotice(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::PaymentReconciliation(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Procedure(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::ProcessResponse(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::QuestionnaireResponse(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::RiskAssessment(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::SupplyDelivery(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Task(Some(e)) => e.get_field_mut(field),
                EventResourceTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EventStatus {
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Not Done"]
    #[code = "not-done"]
    NotDone(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Preparation"]
    #[code = "preparation"]
    Preparation(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EventStatus {
    fn default() -> Self {
        EventStatus::Null(None)
    }
}
impl TryFrom<String> for EventStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(EventStatus::Completed(None)),
            "entered-in-error" => Ok(EventStatus::EnteredInError(None)),
            "in-progress" => Ok(EventStatus::InProgress(None)),
            "not-done" => Ok(EventStatus::NotDone(None)),
            "on-hold" => Ok(EventStatus::OnHold(None)),
            "preparation" => Ok(EventStatus::Preparation(None)),
            "stopped" => Ok(EventStatus::Stopped(None)),
            "unknown" => Ok(EventStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EventStatus {
    fn into(self) -> Option<String> {
        match self {
            EventStatus::Completed(_) => Some("completed".to_string()),
            EventStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            EventStatus::InProgress(_) => Some("in-progress".to_string()),
            EventStatus::NotDone(_) => Some("not-done".to_string()),
            EventStatus::OnHold(_) => Some("on-hold".to_string()),
            EventStatus::Preparation(_) => Some("preparation".to_string()),
            EventStatus::Stopped(_) => Some("stopped".to_string()),
            EventStatus::Unknown(_) => Some("unknown".to_string()),
            EventStatus::Null(_) => None,
        }
    }
}
impl MetaValue for EventStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EventStatus::Completed(Some(e)) => e.get_field(field),
                EventStatus::EnteredInError(Some(e)) => e.get_field(field),
                EventStatus::InProgress(Some(e)) => e.get_field(field),
                EventStatus::NotDone(Some(e)) => e.get_field(field),
                EventStatus::OnHold(Some(e)) => e.get_field(field),
                EventStatus::Preparation(Some(e)) => e.get_field(field),
                EventStatus::Stopped(Some(e)) => e.get_field(field),
                EventStatus::Unknown(Some(e)) => e.get_field(field),
                EventStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EventStatus::Completed(Some(e)) => e.get_field_mut(field),
                EventStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                EventStatus::InProgress(Some(e)) => e.get_field_mut(field),
                EventStatus::NotDone(Some(e)) => e.get_field_mut(field),
                EventStatus::OnHold(Some(e)) => e.get_field_mut(field),
                EventStatus::Preparation(Some(e)) => e.get_field_mut(field),
                EventStatus::Stopped(Some(e)) => e.get_field_mut(field),
                EventStatus::Unknown(Some(e)) => e.get_field_mut(field),
                EventStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EventTiming {
    #[code = "AC"]
    AC(Option<Element>),
    #[code = "ACD"]
    ACD(Option<Element>),
    #[code = "ACM"]
    ACM(Option<Element>),
    #[code = "ACV"]
    ACV(Option<Element>),
    #[doc = "Afternoon"]
    #[code = "AFT"]
    AFT(Option<Element>),
    #[doc = "Early Afternoon"]
    #[code = "AFT.early"]
    AFTEarly(Option<Element>),
    #[doc = "Late Afternoon"]
    #[code = "AFT.late"]
    AFTLate(Option<Element>),
    #[code = "C"]
    C(Option<Element>),
    #[code = "CD"]
    CD(Option<Element>),
    #[code = "CM"]
    CM(Option<Element>),
    #[code = "CV"]
    CV(Option<Element>),
    #[doc = "Evening"]
    #[code = "EVE"]
    EVE(Option<Element>),
    #[doc = "Early Evening"]
    #[code = "EVE.early"]
    EVEEarly(Option<Element>),
    #[doc = "Late Evening"]
    #[code = "EVE.late"]
    EVELate(Option<Element>),
    #[code = "HS"]
    HS(Option<Element>),
    #[doc = "Morning"]
    #[code = "MORN"]
    MORN(Option<Element>),
    #[doc = "Early Morning"]
    #[code = "MORN.early"]
    MORNEarly(Option<Element>),
    #[doc = "Late Morning"]
    #[code = "MORN.late"]
    MORNLate(Option<Element>),
    #[doc = "Night"]
    #[code = "NIGHT"]
    NIGHT(Option<Element>),
    #[doc = "Noon"]
    #[code = "NOON"]
    NOON(Option<Element>),
    #[code = "PC"]
    PC(Option<Element>),
    #[code = "PCD"]
    PCD(Option<Element>),
    #[code = "PCM"]
    PCM(Option<Element>),
    #[code = "PCV"]
    PCV(Option<Element>),
    #[doc = "After Sleep"]
    #[code = "PHS"]
    PHS(Option<Element>),
    #[code = "WAKE"]
    WAKE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EventTiming {
    fn default() -> Self {
        EventTiming::Null(None)
    }
}
impl TryFrom<String> for EventTiming {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AC" => Ok(EventTiming::AC(None)),
            "ACD" => Ok(EventTiming::ACD(None)),
            "ACM" => Ok(EventTiming::ACM(None)),
            "ACV" => Ok(EventTiming::ACV(None)),
            "AFT" => Ok(EventTiming::AFT(None)),
            "AFT.early" => Ok(EventTiming::AFTEarly(None)),
            "AFT.late" => Ok(EventTiming::AFTLate(None)),
            "C" => Ok(EventTiming::C(None)),
            "CD" => Ok(EventTiming::CD(None)),
            "CM" => Ok(EventTiming::CM(None)),
            "CV" => Ok(EventTiming::CV(None)),
            "EVE" => Ok(EventTiming::EVE(None)),
            "EVE.early" => Ok(EventTiming::EVEEarly(None)),
            "EVE.late" => Ok(EventTiming::EVELate(None)),
            "HS" => Ok(EventTiming::HS(None)),
            "MORN" => Ok(EventTiming::MORN(None)),
            "MORN.early" => Ok(EventTiming::MORNEarly(None)),
            "MORN.late" => Ok(EventTiming::MORNLate(None)),
            "NIGHT" => Ok(EventTiming::NIGHT(None)),
            "NOON" => Ok(EventTiming::NOON(None)),
            "PC" => Ok(EventTiming::PC(None)),
            "PCD" => Ok(EventTiming::PCD(None)),
            "PCM" => Ok(EventTiming::PCM(None)),
            "PCV" => Ok(EventTiming::PCV(None)),
            "PHS" => Ok(EventTiming::PHS(None)),
            "WAKE" => Ok(EventTiming::WAKE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EventTiming {
    fn into(self) -> Option<String> {
        match self {
            EventTiming::AC(_) => Some("AC".to_string()),
            EventTiming::ACD(_) => Some("ACD".to_string()),
            EventTiming::ACM(_) => Some("ACM".to_string()),
            EventTiming::ACV(_) => Some("ACV".to_string()),
            EventTiming::AFT(_) => Some("AFT".to_string()),
            EventTiming::AFTEarly(_) => Some("AFT.early".to_string()),
            EventTiming::AFTLate(_) => Some("AFT.late".to_string()),
            EventTiming::C(_) => Some("C".to_string()),
            EventTiming::CD(_) => Some("CD".to_string()),
            EventTiming::CM(_) => Some("CM".to_string()),
            EventTiming::CV(_) => Some("CV".to_string()),
            EventTiming::EVE(_) => Some("EVE".to_string()),
            EventTiming::EVEEarly(_) => Some("EVE.early".to_string()),
            EventTiming::EVELate(_) => Some("EVE.late".to_string()),
            EventTiming::HS(_) => Some("HS".to_string()),
            EventTiming::MORN(_) => Some("MORN".to_string()),
            EventTiming::MORNEarly(_) => Some("MORN.early".to_string()),
            EventTiming::MORNLate(_) => Some("MORN.late".to_string()),
            EventTiming::NIGHT(_) => Some("NIGHT".to_string()),
            EventTiming::NOON(_) => Some("NOON".to_string()),
            EventTiming::PC(_) => Some("PC".to_string()),
            EventTiming::PCD(_) => Some("PCD".to_string()),
            EventTiming::PCM(_) => Some("PCM".to_string()),
            EventTiming::PCV(_) => Some("PCV".to_string()),
            EventTiming::PHS(_) => Some("PHS".to_string()),
            EventTiming::WAKE(_) => Some("WAKE".to_string()),
            EventTiming::Null(_) => None,
        }
    }
}
impl MetaValue for EventTiming {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EventTiming::AC(Some(e)) => e.get_field(field),
                EventTiming::ACD(Some(e)) => e.get_field(field),
                EventTiming::ACM(Some(e)) => e.get_field(field),
                EventTiming::ACV(Some(e)) => e.get_field(field),
                EventTiming::AFT(Some(e)) => e.get_field(field),
                EventTiming::AFTEarly(Some(e)) => e.get_field(field),
                EventTiming::AFTLate(Some(e)) => e.get_field(field),
                EventTiming::C(Some(e)) => e.get_field(field),
                EventTiming::CD(Some(e)) => e.get_field(field),
                EventTiming::CM(Some(e)) => e.get_field(field),
                EventTiming::CV(Some(e)) => e.get_field(field),
                EventTiming::EVE(Some(e)) => e.get_field(field),
                EventTiming::EVEEarly(Some(e)) => e.get_field(field),
                EventTiming::EVELate(Some(e)) => e.get_field(field),
                EventTiming::HS(Some(e)) => e.get_field(field),
                EventTiming::MORN(Some(e)) => e.get_field(field),
                EventTiming::MORNEarly(Some(e)) => e.get_field(field),
                EventTiming::MORNLate(Some(e)) => e.get_field(field),
                EventTiming::NIGHT(Some(e)) => e.get_field(field),
                EventTiming::NOON(Some(e)) => e.get_field(field),
                EventTiming::PC(Some(e)) => e.get_field(field),
                EventTiming::PCD(Some(e)) => e.get_field(field),
                EventTiming::PCM(Some(e)) => e.get_field(field),
                EventTiming::PCV(Some(e)) => e.get_field(field),
                EventTiming::PHS(Some(e)) => e.get_field(field),
                EventTiming::WAKE(Some(e)) => e.get_field(field),
                EventTiming::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EventTiming::AC(Some(e)) => e.get_field_mut(field),
                EventTiming::ACD(Some(e)) => e.get_field_mut(field),
                EventTiming::ACM(Some(e)) => e.get_field_mut(field),
                EventTiming::ACV(Some(e)) => e.get_field_mut(field),
                EventTiming::AFT(Some(e)) => e.get_field_mut(field),
                EventTiming::AFTEarly(Some(e)) => e.get_field_mut(field),
                EventTiming::AFTLate(Some(e)) => e.get_field_mut(field),
                EventTiming::C(Some(e)) => e.get_field_mut(field),
                EventTiming::CD(Some(e)) => e.get_field_mut(field),
                EventTiming::CM(Some(e)) => e.get_field_mut(field),
                EventTiming::CV(Some(e)) => e.get_field_mut(field),
                EventTiming::EVE(Some(e)) => e.get_field_mut(field),
                EventTiming::EVEEarly(Some(e)) => e.get_field_mut(field),
                EventTiming::EVELate(Some(e)) => e.get_field_mut(field),
                EventTiming::HS(Some(e)) => e.get_field_mut(field),
                EventTiming::MORN(Some(e)) => e.get_field_mut(field),
                EventTiming::MORNEarly(Some(e)) => e.get_field_mut(field),
                EventTiming::MORNLate(Some(e)) => e.get_field_mut(field),
                EventTiming::NIGHT(Some(e)) => e.get_field_mut(field),
                EventTiming::NOON(Some(e)) => e.get_field_mut(field),
                EventTiming::PC(Some(e)) => e.get_field_mut(field),
                EventTiming::PCD(Some(e)) => e.get_field_mut(field),
                EventTiming::PCM(Some(e)) => e.get_field_mut(field),
                EventTiming::PCV(Some(e)) => e.get_field_mut(field),
                EventTiming::PHS(Some(e)) => e.get_field_mut(field),
                EventTiming::WAKE(Some(e)) => e.get_field_mut(field),
                EventTiming::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EvidenceQuality {
    #[doc = "High quality"]
    #[code = "high"]
    High(Option<Element>),
    #[doc = "Low quality"]
    #[code = "low"]
    Low(Option<Element>),
    #[doc = "Moderate quality"]
    #[code = "moderate"]
    Moderate(Option<Element>),
    #[doc = "Very low quality"]
    #[code = "very-low"]
    VeryLow(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EvidenceQuality {
    fn default() -> Self {
        EvidenceQuality::Null(None)
    }
}
impl TryFrom<String> for EvidenceQuality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "high" => Ok(EvidenceQuality::High(None)),
            "low" => Ok(EvidenceQuality::Low(None)),
            "moderate" => Ok(EvidenceQuality::Moderate(None)),
            "very-low" => Ok(EvidenceQuality::VeryLow(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EvidenceQuality {
    fn into(self) -> Option<String> {
        match self {
            EvidenceQuality::High(_) => Some("high".to_string()),
            EvidenceQuality::Low(_) => Some("low".to_string()),
            EvidenceQuality::Moderate(_) => Some("moderate".to_string()),
            EvidenceQuality::VeryLow(_) => Some("very-low".to_string()),
            EvidenceQuality::Null(_) => None,
        }
    }
}
impl MetaValue for EvidenceQuality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EvidenceQuality::High(Some(e)) => e.get_field(field),
                EvidenceQuality::Low(Some(e)) => e.get_field(field),
                EvidenceQuality::Moderate(Some(e)) => e.get_field(field),
                EvidenceQuality::VeryLow(Some(e)) => e.get_field(field),
                EvidenceQuality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EvidenceQuality::High(Some(e)) => e.get_field_mut(field),
                EvidenceQuality::Low(Some(e)) => e.get_field_mut(field),
                EvidenceQuality::Moderate(Some(e)) => e.get_field_mut(field),
                EvidenceQuality::VeryLow(Some(e)) => e.get_field_mut(field),
                EvidenceQuality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum EvidenceVariantState {
    #[doc = "high risk"]
    #[code = "high-risk"]
    HighRisk(Option<Element>),
    #[doc = "low risk"]
    #[code = "low-risk"]
    LowRisk(Option<Element>),
    #[doc = "medium risk"]
    #[code = "medium-risk"]
    MediumRisk(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for EvidenceVariantState {
    fn default() -> Self {
        EvidenceVariantState::Null(None)
    }
}
impl TryFrom<String> for EvidenceVariantState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "high-risk" => Ok(EvidenceVariantState::HighRisk(None)),
            "low-risk" => Ok(EvidenceVariantState::LowRisk(None)),
            "medium-risk" => Ok(EvidenceVariantState::MediumRisk(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &EvidenceVariantState {
    fn into(self) -> Option<String> {
        match self {
            EvidenceVariantState::HighRisk(_) => Some("high-risk".to_string()),
            EvidenceVariantState::LowRisk(_) => Some("low-risk".to_string()),
            EvidenceVariantState::MediumRisk(_) => Some("medium-risk".to_string()),
            EvidenceVariantState::Null(_) => None,
        }
    }
}
impl MetaValue for EvidenceVariantState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                EvidenceVariantState::HighRisk(Some(e)) => e.get_field(field),
                EvidenceVariantState::LowRisk(Some(e)) => e.get_field(field),
                EvidenceVariantState::MediumRisk(Some(e)) => e.get_field(field),
                EvidenceVariantState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                EvidenceVariantState::HighRisk(Some(e)) => e.get_field_mut(field),
                EvidenceVariantState::LowRisk(Some(e)) => e.get_field_mut(field),
                EvidenceVariantState::MediumRisk(Some(e)) => e.get_field_mut(field),
                EvidenceVariantState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExBenefitcategory {
    #[doc = "Medical Care"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Renal Supplies"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "Surgical"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Diagnostic Dental"]
    #[code = "23"]
    V23(Option<Element>),
    #[doc = "Periodontics"]
    #[code = "24"]
    V24(Option<Element>),
    #[doc = "Restorative"]
    #[code = "25"]
    V25(Option<Element>),
    #[doc = "Endodontics"]
    #[code = "26"]
    V26(Option<Element>),
    #[doc = "Maxillofacial Prosthetics"]
    #[code = "27"]
    V27(Option<Element>),
    #[doc = "Adjunctive Dental Services"]
    #[code = "28"]
    V28(Option<Element>),
    #[doc = "Consultation"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Health Benefit Plan Coverage"]
    #[code = "30"]
    V30(Option<Element>),
    #[doc = "Dental Care"]
    #[code = "35"]
    V35(Option<Element>),
    #[doc = "Dental Crowns"]
    #[code = "36"]
    V36(Option<Element>),
    #[doc = "Dental Accident"]
    #[code = "37"]
    V37(Option<Element>),
    #[doc = "Diagnostic XRay"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Hospital Room and Board"]
    #[code = "49"]
    V49(Option<Element>),
    #[doc = "Diagnostic Lab"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "Major Medical"]
    #[code = "55"]
    V55(Option<Element>),
    #[doc = "Medically Related Transportation"]
    #[code = "56"]
    V56(Option<Element>),
    #[doc = "In-vitro Fertilization"]
    #[code = "61"]
    V61(Option<Element>),
    #[doc = "MRI Scan"]
    #[code = "62"]
    V62(Option<Element>),
    #[doc = "Donor Procedures"]
    #[code = "63"]
    V63(Option<Element>),
    #[doc = "Maternity"]
    #[code = "69"]
    V69(Option<Element>),
    #[doc = "Renal Dialysis"]
    #[code = "76"]
    V76(Option<Element>),
    #[doc = "Medical Coverage"]
    #[code = "F1"]
    F1(Option<Element>),
    #[doc = "Dental Coverage"]
    #[code = "F3"]
    F3(Option<Element>),
    #[doc = "Hearing Coverage"]
    #[code = "F4"]
    F4(Option<Element>),
    #[doc = "Vision Coverage"]
    #[code = "F6"]
    F6(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExBenefitcategory {
    fn default() -> Self {
        ExBenefitcategory::Null(None)
    }
}
impl TryFrom<String> for ExBenefitcategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(ExBenefitcategory::V1(None)),
            "14" => Ok(ExBenefitcategory::V14(None)),
            "2" => Ok(ExBenefitcategory::V2(None)),
            "23" => Ok(ExBenefitcategory::V23(None)),
            "24" => Ok(ExBenefitcategory::V24(None)),
            "25" => Ok(ExBenefitcategory::V25(None)),
            "26" => Ok(ExBenefitcategory::V26(None)),
            "27" => Ok(ExBenefitcategory::V27(None)),
            "28" => Ok(ExBenefitcategory::V28(None)),
            "3" => Ok(ExBenefitcategory::V3(None)),
            "30" => Ok(ExBenefitcategory::V30(None)),
            "35" => Ok(ExBenefitcategory::V35(None)),
            "36" => Ok(ExBenefitcategory::V36(None)),
            "37" => Ok(ExBenefitcategory::V37(None)),
            "4" => Ok(ExBenefitcategory::V4(None)),
            "49" => Ok(ExBenefitcategory::V49(None)),
            "5" => Ok(ExBenefitcategory::V5(None)),
            "55" => Ok(ExBenefitcategory::V55(None)),
            "56" => Ok(ExBenefitcategory::V56(None)),
            "61" => Ok(ExBenefitcategory::V61(None)),
            "62" => Ok(ExBenefitcategory::V62(None)),
            "63" => Ok(ExBenefitcategory::V63(None)),
            "69" => Ok(ExBenefitcategory::V69(None)),
            "76" => Ok(ExBenefitcategory::V76(None)),
            "F1" => Ok(ExBenefitcategory::F1(None)),
            "F3" => Ok(ExBenefitcategory::F3(None)),
            "F4" => Ok(ExBenefitcategory::F4(None)),
            "F6" => Ok(ExBenefitcategory::F6(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExBenefitcategory {
    fn into(self) -> Option<String> {
        match self {
            ExBenefitcategory::V1(_) => Some("1".to_string()),
            ExBenefitcategory::V14(_) => Some("14".to_string()),
            ExBenefitcategory::V2(_) => Some("2".to_string()),
            ExBenefitcategory::V23(_) => Some("23".to_string()),
            ExBenefitcategory::V24(_) => Some("24".to_string()),
            ExBenefitcategory::V25(_) => Some("25".to_string()),
            ExBenefitcategory::V26(_) => Some("26".to_string()),
            ExBenefitcategory::V27(_) => Some("27".to_string()),
            ExBenefitcategory::V28(_) => Some("28".to_string()),
            ExBenefitcategory::V3(_) => Some("3".to_string()),
            ExBenefitcategory::V30(_) => Some("30".to_string()),
            ExBenefitcategory::V35(_) => Some("35".to_string()),
            ExBenefitcategory::V36(_) => Some("36".to_string()),
            ExBenefitcategory::V37(_) => Some("37".to_string()),
            ExBenefitcategory::V4(_) => Some("4".to_string()),
            ExBenefitcategory::V49(_) => Some("49".to_string()),
            ExBenefitcategory::V5(_) => Some("5".to_string()),
            ExBenefitcategory::V55(_) => Some("55".to_string()),
            ExBenefitcategory::V56(_) => Some("56".to_string()),
            ExBenefitcategory::V61(_) => Some("61".to_string()),
            ExBenefitcategory::V62(_) => Some("62".to_string()),
            ExBenefitcategory::V63(_) => Some("63".to_string()),
            ExBenefitcategory::V69(_) => Some("69".to_string()),
            ExBenefitcategory::V76(_) => Some("76".to_string()),
            ExBenefitcategory::F1(_) => Some("F1".to_string()),
            ExBenefitcategory::F3(_) => Some("F3".to_string()),
            ExBenefitcategory::F4(_) => Some("F4".to_string()),
            ExBenefitcategory::F6(_) => Some("F6".to_string()),
            ExBenefitcategory::Null(_) => None,
        }
    }
}
impl MetaValue for ExBenefitcategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExBenefitcategory::V1(Some(e)) => e.get_field(field),
                ExBenefitcategory::V14(Some(e)) => e.get_field(field),
                ExBenefitcategory::V2(Some(e)) => e.get_field(field),
                ExBenefitcategory::V23(Some(e)) => e.get_field(field),
                ExBenefitcategory::V24(Some(e)) => e.get_field(field),
                ExBenefitcategory::V25(Some(e)) => e.get_field(field),
                ExBenefitcategory::V26(Some(e)) => e.get_field(field),
                ExBenefitcategory::V27(Some(e)) => e.get_field(field),
                ExBenefitcategory::V28(Some(e)) => e.get_field(field),
                ExBenefitcategory::V3(Some(e)) => e.get_field(field),
                ExBenefitcategory::V30(Some(e)) => e.get_field(field),
                ExBenefitcategory::V35(Some(e)) => e.get_field(field),
                ExBenefitcategory::V36(Some(e)) => e.get_field(field),
                ExBenefitcategory::V37(Some(e)) => e.get_field(field),
                ExBenefitcategory::V4(Some(e)) => e.get_field(field),
                ExBenefitcategory::V49(Some(e)) => e.get_field(field),
                ExBenefitcategory::V5(Some(e)) => e.get_field(field),
                ExBenefitcategory::V55(Some(e)) => e.get_field(field),
                ExBenefitcategory::V56(Some(e)) => e.get_field(field),
                ExBenefitcategory::V61(Some(e)) => e.get_field(field),
                ExBenefitcategory::V62(Some(e)) => e.get_field(field),
                ExBenefitcategory::V63(Some(e)) => e.get_field(field),
                ExBenefitcategory::V69(Some(e)) => e.get_field(field),
                ExBenefitcategory::V76(Some(e)) => e.get_field(field),
                ExBenefitcategory::F1(Some(e)) => e.get_field(field),
                ExBenefitcategory::F3(Some(e)) => e.get_field(field),
                ExBenefitcategory::F4(Some(e)) => e.get_field(field),
                ExBenefitcategory::F6(Some(e)) => e.get_field(field),
                ExBenefitcategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExBenefitcategory::V1(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V14(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V2(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V23(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V24(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V25(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V26(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V27(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V28(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V3(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V30(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V35(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V36(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V37(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V4(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V49(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V5(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V55(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V56(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V61(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V62(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V63(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V69(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::V76(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::F1(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::F3(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::F4(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::F6(Some(e)) => e.get_field_mut(field),
                ExBenefitcategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExDiagnosisOnAdmission {
    #[doc = "No"]
    #[code = "n"]
    N(Option<Element>),
    #[doc = "Unknown"]
    #[code = "u"]
    U(Option<Element>),
    #[doc = "Undetermined"]
    #[code = "w"]
    W(Option<Element>),
    #[doc = "Yes"]
    #[code = "y"]
    Y(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExDiagnosisOnAdmission {
    fn default() -> Self {
        ExDiagnosisOnAdmission::Null(None)
    }
}
impl TryFrom<String> for ExDiagnosisOnAdmission {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "n" => Ok(ExDiagnosisOnAdmission::N(None)),
            "u" => Ok(ExDiagnosisOnAdmission::U(None)),
            "w" => Ok(ExDiagnosisOnAdmission::W(None)),
            "y" => Ok(ExDiagnosisOnAdmission::Y(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExDiagnosisOnAdmission {
    fn into(self) -> Option<String> {
        match self {
            ExDiagnosisOnAdmission::N(_) => Some("n".to_string()),
            ExDiagnosisOnAdmission::U(_) => Some("u".to_string()),
            ExDiagnosisOnAdmission::W(_) => Some("w".to_string()),
            ExDiagnosisOnAdmission::Y(_) => Some("y".to_string()),
            ExDiagnosisOnAdmission::Null(_) => None,
        }
    }
}
impl MetaValue for ExDiagnosisOnAdmission {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExDiagnosisOnAdmission::N(Some(e)) => e.get_field(field),
                ExDiagnosisOnAdmission::U(Some(e)) => e.get_field(field),
                ExDiagnosisOnAdmission::W(Some(e)) => e.get_field(field),
                ExDiagnosisOnAdmission::Y(Some(e)) => e.get_field(field),
                ExDiagnosisOnAdmission::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExDiagnosisOnAdmission::N(Some(e)) => e.get_field_mut(field),
                ExDiagnosisOnAdmission::U(Some(e)) => e.get_field_mut(field),
                ExDiagnosisOnAdmission::W(Some(e)) => e.get_field_mut(field),
                ExDiagnosisOnAdmission::Y(Some(e)) => e.get_field_mut(field),
                ExDiagnosisOnAdmission::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExDiagnosisrelatedgroup {
    #[doc = "Normal Vaginal Delivery"]
    #[code = "100"]
    V100(Option<Element>),
    #[doc = "Appendectomy - uncomplicated"]
    #[code = "101"]
    V101(Option<Element>),
    #[doc = "Tooth abscess"]
    #[code = "300"]
    V300(Option<Element>),
    #[doc = "Head trauma - concussion"]
    #[code = "400"]
    V400(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExDiagnosisrelatedgroup {
    fn default() -> Self {
        ExDiagnosisrelatedgroup::Null(None)
    }
}
impl TryFrom<String> for ExDiagnosisrelatedgroup {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "100" => Ok(ExDiagnosisrelatedgroup::V100(None)),
            "101" => Ok(ExDiagnosisrelatedgroup::V101(None)),
            "300" => Ok(ExDiagnosisrelatedgroup::V300(None)),
            "400" => Ok(ExDiagnosisrelatedgroup::V400(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExDiagnosisrelatedgroup {
    fn into(self) -> Option<String> {
        match self {
            ExDiagnosisrelatedgroup::V100(_) => Some("100".to_string()),
            ExDiagnosisrelatedgroup::V101(_) => Some("101".to_string()),
            ExDiagnosisrelatedgroup::V300(_) => Some("300".to_string()),
            ExDiagnosisrelatedgroup::V400(_) => Some("400".to_string()),
            ExDiagnosisrelatedgroup::Null(_) => None,
        }
    }
}
impl MetaValue for ExDiagnosisrelatedgroup {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExDiagnosisrelatedgroup::V100(Some(e)) => e.get_field(field),
                ExDiagnosisrelatedgroup::V101(Some(e)) => e.get_field(field),
                ExDiagnosisrelatedgroup::V300(Some(e)) => e.get_field(field),
                ExDiagnosisrelatedgroup::V400(Some(e)) => e.get_field(field),
                ExDiagnosisrelatedgroup::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExDiagnosisrelatedgroup::V100(Some(e)) => e.get_field_mut(field),
                ExDiagnosisrelatedgroup::V101(Some(e)) => e.get_field_mut(field),
                ExDiagnosisrelatedgroup::V300(Some(e)) => e.get_field_mut(field),
                ExDiagnosisrelatedgroup::V400(Some(e)) => e.get_field_mut(field),
                ExDiagnosisrelatedgroup::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExDiagnosistype {
    #[doc = "Admitting Diagnosis"]
    #[code = "admitting"]
    Admitting(Option<Element>),
    #[doc = "Clinical Diagnosis"]
    #[code = "clinical"]
    Clinical(Option<Element>),
    #[doc = "Differential Diagnosis"]
    #[code = "differential"]
    Differential(Option<Element>),
    #[doc = "Discharge Diagnosis"]
    #[code = "discharge"]
    Discharge(Option<Element>),
    #[doc = "Laboratory Diagnosis"]
    #[code = "laboratory"]
    Laboratory(Option<Element>),
    #[doc = "Nursing Diagnosis"]
    #[code = "nursing"]
    Nursing(Option<Element>),
    #[doc = "Prenatal Diagnosis"]
    #[code = "prenatal"]
    Prenatal(Option<Element>),
    #[doc = "Principal Diagnosis"]
    #[code = "principal"]
    Principal(Option<Element>),
    #[doc = "Radiology Diagnosis"]
    #[code = "radiology"]
    Radiology(Option<Element>),
    #[doc = "Remote Diagnosis"]
    #[code = "remote"]
    Remote(Option<Element>),
    #[doc = "Retrospective Diagnosis"]
    #[code = "retrospective"]
    Retrospective(Option<Element>),
    #[doc = "Self Diagnosis"]
    #[code = "self"]
    _Self(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExDiagnosistype {
    fn default() -> Self {
        ExDiagnosistype::Null(None)
    }
}
impl TryFrom<String> for ExDiagnosistype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "admitting" => Ok(ExDiagnosistype::Admitting(None)),
            "clinical" => Ok(ExDiagnosistype::Clinical(None)),
            "differential" => Ok(ExDiagnosistype::Differential(None)),
            "discharge" => Ok(ExDiagnosistype::Discharge(None)),
            "laboratory" => Ok(ExDiagnosistype::Laboratory(None)),
            "nursing" => Ok(ExDiagnosistype::Nursing(None)),
            "prenatal" => Ok(ExDiagnosistype::Prenatal(None)),
            "principal" => Ok(ExDiagnosistype::Principal(None)),
            "radiology" => Ok(ExDiagnosistype::Radiology(None)),
            "remote" => Ok(ExDiagnosistype::Remote(None)),
            "retrospective" => Ok(ExDiagnosistype::Retrospective(None)),
            "self" => Ok(ExDiagnosistype::_Self(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExDiagnosistype {
    fn into(self) -> Option<String> {
        match self {
            ExDiagnosistype::Admitting(_) => Some("admitting".to_string()),
            ExDiagnosistype::Clinical(_) => Some("clinical".to_string()),
            ExDiagnosistype::Differential(_) => Some("differential".to_string()),
            ExDiagnosistype::Discharge(_) => Some("discharge".to_string()),
            ExDiagnosistype::Laboratory(_) => Some("laboratory".to_string()),
            ExDiagnosistype::Nursing(_) => Some("nursing".to_string()),
            ExDiagnosistype::Prenatal(_) => Some("prenatal".to_string()),
            ExDiagnosistype::Principal(_) => Some("principal".to_string()),
            ExDiagnosistype::Radiology(_) => Some("radiology".to_string()),
            ExDiagnosistype::Remote(_) => Some("remote".to_string()),
            ExDiagnosistype::Retrospective(_) => Some("retrospective".to_string()),
            ExDiagnosistype::_Self(_) => Some("self".to_string()),
            ExDiagnosistype::Null(_) => None,
        }
    }
}
impl MetaValue for ExDiagnosistype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExDiagnosistype::Admitting(Some(e)) => e.get_field(field),
                ExDiagnosistype::Clinical(Some(e)) => e.get_field(field),
                ExDiagnosistype::Differential(Some(e)) => e.get_field(field),
                ExDiagnosistype::Discharge(Some(e)) => e.get_field(field),
                ExDiagnosistype::Laboratory(Some(e)) => e.get_field(field),
                ExDiagnosistype::Nursing(Some(e)) => e.get_field(field),
                ExDiagnosistype::Prenatal(Some(e)) => e.get_field(field),
                ExDiagnosistype::Principal(Some(e)) => e.get_field(field),
                ExDiagnosistype::Radiology(Some(e)) => e.get_field(field),
                ExDiagnosistype::Remote(Some(e)) => e.get_field(field),
                ExDiagnosistype::Retrospective(Some(e)) => e.get_field(field),
                ExDiagnosistype::_Self(Some(e)) => e.get_field(field),
                ExDiagnosistype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExDiagnosistype::Admitting(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Clinical(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Differential(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Discharge(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Laboratory(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Nursing(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Prenatal(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Principal(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Radiology(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Remote(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Retrospective(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::_Self(Some(e)) => e.get_field_mut(field),
                ExDiagnosistype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExOnsettype {
    #[doc = "Last Menstruation"]
    #[code = "lmn"]
    Lmn(Option<Element>),
    #[doc = "Last Exam"]
    #[code = "lxm"]
    Lxm(Option<Element>),
    #[doc = "Start of Symptoms"]
    #[code = "sym"]
    Sym(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExOnsettype {
    fn default() -> Self {
        ExOnsettype::Null(None)
    }
}
impl TryFrom<String> for ExOnsettype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "lmn" => Ok(ExOnsettype::Lmn(None)),
            "lxm" => Ok(ExOnsettype::Lxm(None)),
            "sym" => Ok(ExOnsettype::Sym(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExOnsettype {
    fn into(self) -> Option<String> {
        match self {
            ExOnsettype::Lmn(_) => Some("lmn".to_string()),
            ExOnsettype::Lxm(_) => Some("lxm".to_string()),
            ExOnsettype::Sym(_) => Some("sym".to_string()),
            ExOnsettype::Null(_) => None,
        }
    }
}
impl MetaValue for ExOnsettype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExOnsettype::Lmn(Some(e)) => e.get_field(field),
                ExOnsettype::Lxm(Some(e)) => e.get_field(field),
                ExOnsettype::Sym(Some(e)) => e.get_field(field),
                ExOnsettype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExOnsettype::Lmn(Some(e)) => e.get_field_mut(field),
                ExOnsettype::Lxm(Some(e)) => e.get_field_mut(field),
                ExOnsettype::Sym(Some(e)) => e.get_field_mut(field),
                ExOnsettype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExPayeeResourceType {
    #[doc = "Organization"]
    #[code = "organization"]
    Organization(Option<Element>),
    #[doc = "Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "practitioner"]
    Practitioner(Option<Element>),
    #[doc = "RelatedPerson"]
    #[code = "relatedperson"]
    Relatedperson(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExPayeeResourceType {
    fn default() -> Self {
        ExPayeeResourceType::Null(None)
    }
}
impl TryFrom<String> for ExPayeeResourceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "organization" => Ok(ExPayeeResourceType::Organization(None)),
            "patient" => Ok(ExPayeeResourceType::Patient(None)),
            "practitioner" => Ok(ExPayeeResourceType::Practitioner(None)),
            "relatedperson" => Ok(ExPayeeResourceType::Relatedperson(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExPayeeResourceType {
    fn into(self) -> Option<String> {
        match self {
            ExPayeeResourceType::Organization(_) => Some("organization".to_string()),
            ExPayeeResourceType::Patient(_) => Some("patient".to_string()),
            ExPayeeResourceType::Practitioner(_) => Some("practitioner".to_string()),
            ExPayeeResourceType::Relatedperson(_) => Some("relatedperson".to_string()),
            ExPayeeResourceType::Null(_) => None,
        }
    }
}
impl MetaValue for ExPayeeResourceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExPayeeResourceType::Organization(Some(e)) => e.get_field(field),
                ExPayeeResourceType::Patient(Some(e)) => e.get_field(field),
                ExPayeeResourceType::Practitioner(Some(e)) => e.get_field(field),
                ExPayeeResourceType::Relatedperson(Some(e)) => e.get_field(field),
                ExPayeeResourceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExPayeeResourceType::Organization(Some(e)) => e.get_field_mut(field),
                ExPayeeResourceType::Patient(Some(e)) => e.get_field_mut(field),
                ExPayeeResourceType::Practitioner(Some(e)) => e.get_field_mut(field),
                ExPayeeResourceType::Relatedperson(Some(e)) => e.get_field_mut(field),
                ExPayeeResourceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExPaymenttype {
    #[doc = "Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "Partial"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExPaymenttype {
    fn default() -> Self {
        ExPaymenttype::Null(None)
    }
}
impl TryFrom<String> for ExPaymenttype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(ExPaymenttype::Complete(None)),
            "partial" => Ok(ExPaymenttype::Partial(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExPaymenttype {
    fn into(self) -> Option<String> {
        match self {
            ExPaymenttype::Complete(_) => Some("complete".to_string()),
            ExPaymenttype::Partial(_) => Some("partial".to_string()),
            ExPaymenttype::Null(_) => None,
        }
    }
}
impl MetaValue for ExPaymenttype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExPaymenttype::Complete(Some(e)) => e.get_field(field),
                ExPaymenttype::Partial(Some(e)) => e.get_field(field),
                ExPaymenttype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExPaymenttype::Complete(Some(e)) => e.get_field_mut(field),
                ExPaymenttype::Partial(Some(e)) => e.get_field_mut(field),
                ExPaymenttype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExProcedureType {
    #[doc = "Primary procedure"]
    #[code = "primary"]
    Primary(Option<Element>),
    #[doc = "Secondary procedure"]
    #[code = "secondary"]
    Secondary(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExProcedureType {
    fn default() -> Self {
        ExProcedureType::Null(None)
    }
}
impl TryFrom<String> for ExProcedureType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "primary" => Ok(ExProcedureType::Primary(None)),
            "secondary" => Ok(ExProcedureType::Secondary(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExProcedureType {
    fn into(self) -> Option<String> {
        match self {
            ExProcedureType::Primary(_) => Some("primary".to_string()),
            ExProcedureType::Secondary(_) => Some("secondary".to_string()),
            ExProcedureType::Null(_) => None,
        }
    }
}
impl MetaValue for ExProcedureType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExProcedureType::Primary(Some(e)) => e.get_field(field),
                ExProcedureType::Secondary(Some(e)) => e.get_field(field),
                ExProcedureType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExProcedureType::Primary(Some(e)) => e.get_field_mut(field),
                ExProcedureType::Secondary(Some(e)) => e.get_field_mut(field),
                ExProcedureType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExProgramCode {
    #[doc = "Child Asthma"]
    #[code = "as"]
    As(Option<Element>),
    #[doc = "Autism Screening"]
    #[code = "auscr"]
    Auscr(Option<Element>),
    #[doc = "Hemodialysis"]
    #[code = "hd"]
    Hd(Option<Element>),
    #[doc = "None"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExProgramCode {
    fn default() -> Self {
        ExProgramCode::Null(None)
    }
}
impl TryFrom<String> for ExProgramCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "as" => Ok(ExProgramCode::As(None)),
            "auscr" => Ok(ExProgramCode::Auscr(None)),
            "hd" => Ok(ExProgramCode::Hd(None)),
            "none" => Ok(ExProgramCode::None(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExProgramCode {
    fn into(self) -> Option<String> {
        match self {
            ExProgramCode::As(_) => Some("as".to_string()),
            ExProgramCode::Auscr(_) => Some("auscr".to_string()),
            ExProgramCode::Hd(_) => Some("hd".to_string()),
            ExProgramCode::None(_) => Some("none".to_string()),
            ExProgramCode::Null(_) => None,
        }
    }
}
impl MetaValue for ExProgramCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExProgramCode::As(Some(e)) => e.get_field(field),
                ExProgramCode::Auscr(Some(e)) => e.get_field(field),
                ExProgramCode::Hd(Some(e)) => e.get_field(field),
                ExProgramCode::None(Some(e)) => e.get_field(field),
                ExProgramCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExProgramCode::As(Some(e)) => e.get_field_mut(field),
                ExProgramCode::Auscr(Some(e)) => e.get_field_mut(field),
                ExProgramCode::Hd(Some(e)) => e.get_field_mut(field),
                ExProgramCode::None(Some(e)) => e.get_field_mut(field),
                ExProgramCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExRevenueCenter {
    #[doc = "Vision Clinic"]
    #[code = "0010"]
    V0010(Option<Element>),
    #[doc = "Anaesthesia"]
    #[code = "0370"]
    V0370(Option<Element>),
    #[doc = "Physical Therapy"]
    #[code = "0420"]
    V0420(Option<Element>),
    #[doc = "Physical Therapy - "]
    #[code = "0421"]
    V0421(Option<Element>),
    #[doc = "Speech-Language Pathology"]
    #[code = "0440"]
    V0440(Option<Element>),
    #[doc = "Speech-Language Pathology - Visit"]
    #[code = "0441"]
    V0441(Option<Element>),
    #[doc = "Emergency Room"]
    #[code = "0450"]
    V0450(Option<Element>),
    #[doc = "Emergency Room - EM/EMTALA"]
    #[code = "0451"]
    V0451(Option<Element>),
    #[doc = "Emergency Room - beyond EMTALA"]
    #[code = "0452"]
    V0452(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExRevenueCenter {
    fn default() -> Self {
        ExRevenueCenter::Null(None)
    }
}
impl TryFrom<String> for ExRevenueCenter {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "0010" => Ok(ExRevenueCenter::V0010(None)),
            "0370" => Ok(ExRevenueCenter::V0370(None)),
            "0420" => Ok(ExRevenueCenter::V0420(None)),
            "0421" => Ok(ExRevenueCenter::V0421(None)),
            "0440" => Ok(ExRevenueCenter::V0440(None)),
            "0441" => Ok(ExRevenueCenter::V0441(None)),
            "0450" => Ok(ExRevenueCenter::V0450(None)),
            "0451" => Ok(ExRevenueCenter::V0451(None)),
            "0452" => Ok(ExRevenueCenter::V0452(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExRevenueCenter {
    fn into(self) -> Option<String> {
        match self {
            ExRevenueCenter::V0010(_) => Some("0010".to_string()),
            ExRevenueCenter::V0370(_) => Some("0370".to_string()),
            ExRevenueCenter::V0420(_) => Some("0420".to_string()),
            ExRevenueCenter::V0421(_) => Some("0421".to_string()),
            ExRevenueCenter::V0440(_) => Some("0440".to_string()),
            ExRevenueCenter::V0441(_) => Some("0441".to_string()),
            ExRevenueCenter::V0450(_) => Some("0450".to_string()),
            ExRevenueCenter::V0451(_) => Some("0451".to_string()),
            ExRevenueCenter::V0452(_) => Some("0452".to_string()),
            ExRevenueCenter::Null(_) => None,
        }
    }
}
impl MetaValue for ExRevenueCenter {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExRevenueCenter::V0010(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0370(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0420(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0421(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0440(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0441(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0450(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0451(Some(e)) => e.get_field(field),
                ExRevenueCenter::V0452(Some(e)) => e.get_field(field),
                ExRevenueCenter::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExRevenueCenter::V0010(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0370(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0420(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0421(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0440(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0441(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0450(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0451(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::V0452(Some(e)) => e.get_field_mut(field),
                ExRevenueCenter::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExampleExtensional {
    #[doc = "Cholesterol [Moles/Volume]"]
    #[code = "14647-2"]
    V146472(Option<Element>),
    #[doc = "Cholesterol [Mass/Volume]"]
    #[code = "2093-3"]
    V20933(Option<Element>),
    #[doc = "Cholesterol [Mass Or Moles/Volume]"]
    #[code = "35200-5"]
    V352005(Option<Element>),
    #[doc = "Cholesterol [Percentile]"]
    #[code = "9342-7"]
    V93427(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExampleExtensional {
    fn default() -> Self {
        ExampleExtensional::Null(None)
    }
}
impl TryFrom<String> for ExampleExtensional {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "14647-2" => Ok(ExampleExtensional::V146472(None)),
            "2093-3" => Ok(ExampleExtensional::V20933(None)),
            "35200-5" => Ok(ExampleExtensional::V352005(None)),
            "9342-7" => Ok(ExampleExtensional::V93427(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExampleExtensional {
    fn into(self) -> Option<String> {
        match self {
            ExampleExtensional::V146472(_) => Some("14647-2".to_string()),
            ExampleExtensional::V20933(_) => Some("2093-3".to_string()),
            ExampleExtensional::V352005(_) => Some("35200-5".to_string()),
            ExampleExtensional::V93427(_) => Some("9342-7".to_string()),
            ExampleExtensional::Null(_) => None,
        }
    }
}
impl MetaValue for ExampleExtensional {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExampleExtensional::V146472(Some(e)) => e.get_field(field),
                ExampleExtensional::V20933(Some(e)) => e.get_field(field),
                ExampleExtensional::V352005(Some(e)) => e.get_field(field),
                ExampleExtensional::V93427(Some(e)) => e.get_field(field),
                ExampleExtensional::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExampleExtensional::V146472(Some(e)) => e.get_field_mut(field),
                ExampleExtensional::V20933(Some(e)) => e.get_field_mut(field),
                ExampleExtensional::V352005(Some(e)) => e.get_field_mut(field),
                ExampleExtensional::V93427(Some(e)) => e.get_field_mut(field),
                ExampleExtensional::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExampleFilter {
    #[doc = "SChol"]
    #[code = "chol"]
    Chol(Option<Element>),
    #[doc = "SChol (mg/L)"]
    #[code = "chol-mass"]
    CholMass(Option<Element>),
    #[doc = "SChol (mmol/L)"]
    #[code = "chol-mmol"]
    CholMmol(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExampleFilter {
    fn default() -> Self {
        ExampleFilter::Null(None)
    }
}
impl TryFrom<String> for ExampleFilter {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "chol" => Ok(ExampleFilter::Chol(None)),
            "chol-mass" => Ok(ExampleFilter::CholMass(None)),
            "chol-mmol" => Ok(ExampleFilter::CholMmol(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExampleFilter {
    fn into(self) -> Option<String> {
        match self {
            ExampleFilter::Chol(_) => Some("chol".to_string()),
            ExampleFilter::CholMass(_) => Some("chol-mass".to_string()),
            ExampleFilter::CholMmol(_) => Some("chol-mmol".to_string()),
            ExampleFilter::Null(_) => None,
        }
    }
}
impl MetaValue for ExampleFilter {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExampleFilter::Chol(Some(e)) => e.get_field(field),
                ExampleFilter::CholMass(Some(e)) => e.get_field(field),
                ExampleFilter::CholMmol(Some(e)) => e.get_field(field),
                ExampleFilter::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExampleFilter::Chol(Some(e)) => e.get_field_mut(field),
                ExampleFilter::CholMass(Some(e)) => e.get_field_mut(field),
                ExampleFilter::CholMmol(Some(e)) => e.get_field_mut(field),
                ExampleFilter::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExampleHierarchical {
    #[code = "conflict"]
    Conflict(Option<Element>),
    #[code = "duplicate"]
    Duplicate(Option<Element>),
    #[code = "exception"]
    Exception(Option<Element>),
    #[code = "invalid"]
    Invalid(Option<Element>),
    #[code = "lock"]
    Lock(Option<Element>),
    #[code = "login"]
    Login(Option<Element>),
    #[code = "not-found"]
    NotFound(Option<Element>),
    #[code = "processing"]
    Processing(Option<Element>),
    #[code = "required"]
    Required(Option<Element>),
    #[code = "structure"]
    Structure(Option<Element>),
    #[code = "tbrottled"]
    Tbrottled(Option<Element>),
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[code = "value"]
    Value(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExampleHierarchical {
    fn default() -> Self {
        ExampleHierarchical::Null(None)
    }
}
impl TryFrom<String> for ExampleHierarchical {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "conflict" => Ok(ExampleHierarchical::Conflict(None)),
            "duplicate" => Ok(ExampleHierarchical::Duplicate(None)),
            "exception" => Ok(ExampleHierarchical::Exception(None)),
            "invalid" => Ok(ExampleHierarchical::Invalid(None)),
            "lock" => Ok(ExampleHierarchical::Lock(None)),
            "login" => Ok(ExampleHierarchical::Login(None)),
            "not-found" => Ok(ExampleHierarchical::NotFound(None)),
            "processing" => Ok(ExampleHierarchical::Processing(None)),
            "required" => Ok(ExampleHierarchical::Required(None)),
            "structure" => Ok(ExampleHierarchical::Structure(None)),
            "tbrottled" => Ok(ExampleHierarchical::Tbrottled(None)),
            "unknown" => Ok(ExampleHierarchical::Unknown(None)),
            "value" => Ok(ExampleHierarchical::Value(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExampleHierarchical {
    fn into(self) -> Option<String> {
        match self {
            ExampleHierarchical::Conflict(_) => Some("conflict".to_string()),
            ExampleHierarchical::Duplicate(_) => Some("duplicate".to_string()),
            ExampleHierarchical::Exception(_) => Some("exception".to_string()),
            ExampleHierarchical::Invalid(_) => Some("invalid".to_string()),
            ExampleHierarchical::Lock(_) => Some("lock".to_string()),
            ExampleHierarchical::Login(_) => Some("login".to_string()),
            ExampleHierarchical::NotFound(_) => Some("not-found".to_string()),
            ExampleHierarchical::Processing(_) => Some("processing".to_string()),
            ExampleHierarchical::Required(_) => Some("required".to_string()),
            ExampleHierarchical::Structure(_) => Some("structure".to_string()),
            ExampleHierarchical::Tbrottled(_) => Some("tbrottled".to_string()),
            ExampleHierarchical::Unknown(_) => Some("unknown".to_string()),
            ExampleHierarchical::Value(_) => Some("value".to_string()),
            ExampleHierarchical::Null(_) => None,
        }
    }
}
impl MetaValue for ExampleHierarchical {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExampleHierarchical::Conflict(Some(e)) => e.get_field(field),
                ExampleHierarchical::Duplicate(Some(e)) => e.get_field(field),
                ExampleHierarchical::Exception(Some(e)) => e.get_field(field),
                ExampleHierarchical::Invalid(Some(e)) => e.get_field(field),
                ExampleHierarchical::Lock(Some(e)) => e.get_field(field),
                ExampleHierarchical::Login(Some(e)) => e.get_field(field),
                ExampleHierarchical::NotFound(Some(e)) => e.get_field(field),
                ExampleHierarchical::Processing(Some(e)) => e.get_field(field),
                ExampleHierarchical::Required(Some(e)) => e.get_field(field),
                ExampleHierarchical::Structure(Some(e)) => e.get_field(field),
                ExampleHierarchical::Tbrottled(Some(e)) => e.get_field(field),
                ExampleHierarchical::Unknown(Some(e)) => e.get_field(field),
                ExampleHierarchical::Value(Some(e)) => e.get_field(field),
                ExampleHierarchical::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExampleHierarchical::Conflict(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Duplicate(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Exception(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Invalid(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Lock(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Login(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::NotFound(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Processing(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Required(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Structure(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Tbrottled(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Unknown(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Value(Some(e)) => e.get_field_mut(field),
                ExampleHierarchical::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExamplescenarioActorType {
    #[doc = "System"]
    #[code = "entity"]
    Entity(Option<Element>),
    #[doc = "Person"]
    #[code = "person"]
    Person(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExamplescenarioActorType {
    fn default() -> Self {
        ExamplescenarioActorType::Null(None)
    }
}
impl TryFrom<String> for ExamplescenarioActorType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "entity" => Ok(ExamplescenarioActorType::Entity(None)),
            "person" => Ok(ExamplescenarioActorType::Person(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExamplescenarioActorType {
    fn into(self) -> Option<String> {
        match self {
            ExamplescenarioActorType::Entity(_) => Some("entity".to_string()),
            ExamplescenarioActorType::Person(_) => Some("person".to_string()),
            ExamplescenarioActorType::Null(_) => None,
        }
    }
}
impl MetaValue for ExamplescenarioActorType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExamplescenarioActorType::Entity(Some(e)) => e.get_field(field),
                ExamplescenarioActorType::Person(Some(e)) => e.get_field(field),
                ExamplescenarioActorType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExamplescenarioActorType::Entity(Some(e)) => e.get_field_mut(field),
                ExamplescenarioActorType::Person(Some(e)) => e.get_field_mut(field),
                ExamplescenarioActorType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExpansionParameterSource {
    #[doc = "Code System"]
    #[code = "codesystem"]
    Codesystem(Option<Element>),
    #[doc = "Client Input"]
    #[code = "input"]
    Input(Option<Element>),
    #[doc = "Server Engine"]
    #[code = "server"]
    Server(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExpansionParameterSource {
    fn default() -> Self {
        ExpansionParameterSource::Null(None)
    }
}
impl TryFrom<String> for ExpansionParameterSource {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "codesystem" => Ok(ExpansionParameterSource::Codesystem(None)),
            "input" => Ok(ExpansionParameterSource::Input(None)),
            "server" => Ok(ExpansionParameterSource::Server(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExpansionParameterSource {
    fn into(self) -> Option<String> {
        match self {
            ExpansionParameterSource::Codesystem(_) => Some("codesystem".to_string()),
            ExpansionParameterSource::Input(_) => Some("input".to_string()),
            ExpansionParameterSource::Server(_) => Some("server".to_string()),
            ExpansionParameterSource::Null(_) => None,
        }
    }
}
impl MetaValue for ExpansionParameterSource {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExpansionParameterSource::Codesystem(Some(e)) => e.get_field(field),
                ExpansionParameterSource::Input(Some(e)) => e.get_field(field),
                ExpansionParameterSource::Server(Some(e)) => e.get_field(field),
                ExpansionParameterSource::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExpansionParameterSource::Codesystem(Some(e)) => e.get_field_mut(field),
                ExpansionParameterSource::Input(Some(e)) => e.get_field_mut(field),
                ExpansionParameterSource::Server(Some(e)) => e.get_field_mut(field),
                ExpansionParameterSource::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExpansionProcessingRule {
    #[doc = "All Codes"]
    #[code = "all-codes"]
    AllCodes(Option<Element>),
    #[doc = "Groups Only"]
    #[code = "groups-only"]
    GroupsOnly(Option<Element>),
    #[doc = "Groups + Ungrouped codes"]
    #[code = "ungrouped"]
    Ungrouped(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExpansionProcessingRule {
    fn default() -> Self {
        ExpansionProcessingRule::Null(None)
    }
}
impl TryFrom<String> for ExpansionProcessingRule {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all-codes" => Ok(ExpansionProcessingRule::AllCodes(None)),
            "groups-only" => Ok(ExpansionProcessingRule::GroupsOnly(None)),
            "ungrouped" => Ok(ExpansionProcessingRule::Ungrouped(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExpansionProcessingRule {
    fn into(self) -> Option<String> {
        match self {
            ExpansionProcessingRule::AllCodes(_) => Some("all-codes".to_string()),
            ExpansionProcessingRule::GroupsOnly(_) => Some("groups-only".to_string()),
            ExpansionProcessingRule::Ungrouped(_) => Some("ungrouped".to_string()),
            ExpansionProcessingRule::Null(_) => None,
        }
    }
}
impl MetaValue for ExpansionProcessingRule {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExpansionProcessingRule::AllCodes(Some(e)) => e.get_field(field),
                ExpansionProcessingRule::GroupsOnly(Some(e)) => e.get_field(field),
                ExpansionProcessingRule::Ungrouped(Some(e)) => e.get_field(field),
                ExpansionProcessingRule::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExpansionProcessingRule::AllCodes(Some(e)) => e.get_field_mut(field),
                ExpansionProcessingRule::GroupsOnly(Some(e)) => e.get_field_mut(field),
                ExpansionProcessingRule::Ungrouped(Some(e)) => e.get_field_mut(field),
                ExpansionProcessingRule::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExplanationofbenefitStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExplanationofbenefitStatus {
    fn default() -> Self {
        ExplanationofbenefitStatus::Null(None)
    }
}
impl TryFrom<String> for ExplanationofbenefitStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(ExplanationofbenefitStatus::Active(None)),
            "cancelled" => Ok(ExplanationofbenefitStatus::Cancelled(None)),
            "draft" => Ok(ExplanationofbenefitStatus::Draft(None)),
            "entered-in-error" => Ok(ExplanationofbenefitStatus::EnteredInError(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExplanationofbenefitStatus {
    fn into(self) -> Option<String> {
        match self {
            ExplanationofbenefitStatus::Active(_) => Some("active".to_string()),
            ExplanationofbenefitStatus::Cancelled(_) => Some("cancelled".to_string()),
            ExplanationofbenefitStatus::Draft(_) => Some("draft".to_string()),
            ExplanationofbenefitStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ExplanationofbenefitStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ExplanationofbenefitStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExplanationofbenefitStatus::Active(Some(e)) => e.get_field(field),
                ExplanationofbenefitStatus::Cancelled(Some(e)) => e.get_field(field),
                ExplanationofbenefitStatus::Draft(Some(e)) => e.get_field(field),
                ExplanationofbenefitStatus::EnteredInError(Some(e)) => e.get_field(field),
                ExplanationofbenefitStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExplanationofbenefitStatus::Active(Some(e)) => e.get_field_mut(field),
                ExplanationofbenefitStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                ExplanationofbenefitStatus::Draft(Some(e)) => e.get_field_mut(field),
                ExplanationofbenefitStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ExplanationofbenefitStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExposureState {
    #[doc = "Exposure"]
    #[code = "exposure"]
    Exposure(Option<Element>),
    #[doc = "Exposure Alternative"]
    #[code = "exposure-alternative"]
    ExposureAlternative(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExposureState {
    fn default() -> Self {
        ExposureState::Null(None)
    }
}
impl TryFrom<String> for ExposureState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exposure" => Ok(ExposureState::Exposure(None)),
            "exposure-alternative" => Ok(ExposureState::ExposureAlternative(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExposureState {
    fn into(self) -> Option<String> {
        match self {
            ExposureState::Exposure(_) => Some("exposure".to_string()),
            ExposureState::ExposureAlternative(_) => Some("exposure-alternative".to_string()),
            ExposureState::Null(_) => None,
        }
    }
}
impl MetaValue for ExposureState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExposureState::Exposure(Some(e)) => e.get_field(field),
                ExposureState::ExposureAlternative(Some(e)) => e.get_field(field),
                ExposureState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExposureState::Exposure(Some(e)) => e.get_field_mut(field),
                ExposureState::ExposureAlternative(Some(e)) => e.get_field_mut(field),
                ExposureState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExpressionLanguage {
    #[doc = "FHIR Query"]
    #[code = "application/x-fhir-query"]
    Application_XFhirQuery(Option<Element>),
    #[doc = "CQL"]
    #[code = "text/cql"]
    Text_Cql(Option<Element>),
    #[doc = "FHIRPath"]
    #[code = "text/fhirpath"]
    Text_Fhirpath(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExpressionLanguage {
    fn default() -> Self {
        ExpressionLanguage::Null(None)
    }
}
impl TryFrom<String> for ExpressionLanguage {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "application/x-fhir-query" => Ok(ExpressionLanguage::Application_XFhirQuery(None)),
            "text/cql" => Ok(ExpressionLanguage::Text_Cql(None)),
            "text/fhirpath" => Ok(ExpressionLanguage::Text_Fhirpath(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExpressionLanguage {
    fn into(self) -> Option<String> {
        match self {
            ExpressionLanguage::Application_XFhirQuery(_) => {
                Some("application/x-fhir-query".to_string())
            }
            ExpressionLanguage::Text_Cql(_) => Some("text/cql".to_string()),
            ExpressionLanguage::Text_Fhirpath(_) => Some("text/fhirpath".to_string()),
            ExpressionLanguage::Null(_) => None,
        }
    }
}
impl MetaValue for ExpressionLanguage {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExpressionLanguage::Application_XFhirQuery(Some(e)) => e.get_field(field),
                ExpressionLanguage::Text_Cql(Some(e)) => e.get_field(field),
                ExpressionLanguage::Text_Fhirpath(Some(e)) => e.get_field(field),
                ExpressionLanguage::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExpressionLanguage::Application_XFhirQuery(Some(e)) => e.get_field_mut(field),
                ExpressionLanguage::Text_Cql(Some(e)) => e.get_field_mut(field),
                ExpressionLanguage::Text_Fhirpath(Some(e)) => e.get_field_mut(field),
                ExpressionLanguage::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ExtensionContextType {
    #[doc = "Element ID"]
    #[code = "element"]
    Element(Option<Element>),
    #[doc = "Extension URL"]
    #[code = "extension"]
    Extension(Option<Element>),
    #[doc = "FHIRPath"]
    #[code = "fhirpath"]
    Fhirpath(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ExtensionContextType {
    fn default() -> Self {
        ExtensionContextType::Null(None)
    }
}
impl TryFrom<String> for ExtensionContextType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "element" => Ok(ExtensionContextType::Element(None)),
            "extension" => Ok(ExtensionContextType::Extension(None)),
            "fhirpath" => Ok(ExtensionContextType::Fhirpath(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ExtensionContextType {
    fn into(self) -> Option<String> {
        match self {
            ExtensionContextType::Element(_) => Some("element".to_string()),
            ExtensionContextType::Extension(_) => Some("extension".to_string()),
            ExtensionContextType::Fhirpath(_) => Some("fhirpath".to_string()),
            ExtensionContextType::Null(_) => None,
        }
    }
}
impl MetaValue for ExtensionContextType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ExtensionContextType::Element(Some(e)) => e.get_field(field),
                ExtensionContextType::Extension(Some(e)) => e.get_field(field),
                ExtensionContextType::Fhirpath(Some(e)) => e.get_field(field),
                ExtensionContextType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ExtensionContextType::Element(Some(e)) => e.get_field_mut(field),
                ExtensionContextType::Extension(Some(e)) => e.get_field_mut(field),
                ExtensionContextType::Fhirpath(Some(e)) => e.get_field_mut(field),
                ExtensionContextType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FilterOperator {
    #[doc = "Equals"]
    #[code = "="]
    Equal(Option<Element>),
    #[doc = "Descendent Of (by subsumption)"]
    #[code = "descendent-of"]
    DescendentOf(Option<Element>),
    #[doc = "Exists"]
    #[code = "exists"]
    Exists(Option<Element>),
    #[doc = "Generalizes (by Subsumption)"]
    #[code = "generalizes"]
    Generalizes(Option<Element>),
    #[doc = "In Set"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "Is A (by subsumption)"]
    #[code = "is-a"]
    IsA(Option<Element>),
    #[doc = "Not (Is A) (by subsumption)"]
    #[code = "is-not-a"]
    IsNotA(Option<Element>),
    #[doc = "Not in Set"]
    #[code = "not-in"]
    NotIn(Option<Element>),
    #[doc = "Regular Expression"]
    #[code = "regex"]
    Regex(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FilterOperator {
    fn default() -> Self {
        FilterOperator::Null(None)
    }
}
impl TryFrom<String> for FilterOperator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "=" => Ok(FilterOperator::Equal(None)),
            "descendent-of" => Ok(FilterOperator::DescendentOf(None)),
            "exists" => Ok(FilterOperator::Exists(None)),
            "generalizes" => Ok(FilterOperator::Generalizes(None)),
            "in" => Ok(FilterOperator::In(None)),
            "is-a" => Ok(FilterOperator::IsA(None)),
            "is-not-a" => Ok(FilterOperator::IsNotA(None)),
            "not-in" => Ok(FilterOperator::NotIn(None)),
            "regex" => Ok(FilterOperator::Regex(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FilterOperator {
    fn into(self) -> Option<String> {
        match self {
            FilterOperator::Equal(_) => Some("=".to_string()),
            FilterOperator::DescendentOf(_) => Some("descendent-of".to_string()),
            FilterOperator::Exists(_) => Some("exists".to_string()),
            FilterOperator::Generalizes(_) => Some("generalizes".to_string()),
            FilterOperator::In(_) => Some("in".to_string()),
            FilterOperator::IsA(_) => Some("is-a".to_string()),
            FilterOperator::IsNotA(_) => Some("is-not-a".to_string()),
            FilterOperator::NotIn(_) => Some("not-in".to_string()),
            FilterOperator::Regex(_) => Some("regex".to_string()),
            FilterOperator::Null(_) => None,
        }
    }
}
impl MetaValue for FilterOperator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FilterOperator::Equal(Some(e)) => e.get_field(field),
                FilterOperator::DescendentOf(Some(e)) => e.get_field(field),
                FilterOperator::Exists(Some(e)) => e.get_field(field),
                FilterOperator::Generalizes(Some(e)) => e.get_field(field),
                FilterOperator::In(Some(e)) => e.get_field(field),
                FilterOperator::IsA(Some(e)) => e.get_field(field),
                FilterOperator::IsNotA(Some(e)) => e.get_field(field),
                FilterOperator::NotIn(Some(e)) => e.get_field(field),
                FilterOperator::Regex(Some(e)) => e.get_field(field),
                FilterOperator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FilterOperator::Equal(Some(e)) => e.get_field_mut(field),
                FilterOperator::DescendentOf(Some(e)) => e.get_field_mut(field),
                FilterOperator::Exists(Some(e)) => e.get_field_mut(field),
                FilterOperator::Generalizes(Some(e)) => e.get_field_mut(field),
                FilterOperator::In(Some(e)) => e.get_field_mut(field),
                FilterOperator::IsA(Some(e)) => e.get_field_mut(field),
                FilterOperator::IsNotA(Some(e)) => e.get_field_mut(field),
                FilterOperator::NotIn(Some(e)) => e.get_field_mut(field),
                FilterOperator::Regex(Some(e)) => e.get_field_mut(field),
                FilterOperator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FinancialTaskcode {
    #[doc = "Cancel"]
    #[code = "cancel"]
    Cancel(Option<Element>),
    #[doc = "Poll"]
    #[code = "poll"]
    Poll(Option<Element>),
    #[doc = "Release"]
    #[code = "release"]
    Release(Option<Element>),
    #[doc = "Reprocess"]
    #[code = "reprocess"]
    Reprocess(Option<Element>),
    #[doc = "Status check"]
    #[code = "status"]
    Status(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FinancialTaskcode {
    fn default() -> Self {
        FinancialTaskcode::Null(None)
    }
}
impl TryFrom<String> for FinancialTaskcode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cancel" => Ok(FinancialTaskcode::Cancel(None)),
            "poll" => Ok(FinancialTaskcode::Poll(None)),
            "release" => Ok(FinancialTaskcode::Release(None)),
            "reprocess" => Ok(FinancialTaskcode::Reprocess(None)),
            "status" => Ok(FinancialTaskcode::Status(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FinancialTaskcode {
    fn into(self) -> Option<String> {
        match self {
            FinancialTaskcode::Cancel(_) => Some("cancel".to_string()),
            FinancialTaskcode::Poll(_) => Some("poll".to_string()),
            FinancialTaskcode::Release(_) => Some("release".to_string()),
            FinancialTaskcode::Reprocess(_) => Some("reprocess".to_string()),
            FinancialTaskcode::Status(_) => Some("status".to_string()),
            FinancialTaskcode::Null(_) => None,
        }
    }
}
impl MetaValue for FinancialTaskcode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FinancialTaskcode::Cancel(Some(e)) => e.get_field(field),
                FinancialTaskcode::Poll(Some(e)) => e.get_field(field),
                FinancialTaskcode::Release(Some(e)) => e.get_field(field),
                FinancialTaskcode::Reprocess(Some(e)) => e.get_field(field),
                FinancialTaskcode::Status(Some(e)) => e.get_field(field),
                FinancialTaskcode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FinancialTaskcode::Cancel(Some(e)) => e.get_field_mut(field),
                FinancialTaskcode::Poll(Some(e)) => e.get_field_mut(field),
                FinancialTaskcode::Release(Some(e)) => e.get_field_mut(field),
                FinancialTaskcode::Reprocess(Some(e)) => e.get_field_mut(field),
                FinancialTaskcode::Status(Some(e)) => e.get_field_mut(field),
                FinancialTaskcode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FinancialTaskinputtype {
    #[doc = "Exclude"]
    #[code = "exclude"]
    Exclude(Option<Element>),
    #[doc = "Include"]
    #[code = "include"]
    Include(Option<Element>),
    #[doc = "Item Number"]
    #[code = "item"]
    Item(Option<Element>),
    #[doc = "Original Response"]
    #[code = "origresponse"]
    Origresponse(Option<Element>),
    #[doc = "Period"]
    #[code = "period"]
    Period(Option<Element>),
    #[doc = "Reference Number"]
    #[code = "reference"]
    Reference(Option<Element>),
    #[doc = "Status code"]
    #[code = "status"]
    Status(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FinancialTaskinputtype {
    fn default() -> Self {
        FinancialTaskinputtype::Null(None)
    }
}
impl TryFrom<String> for FinancialTaskinputtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exclude" => Ok(FinancialTaskinputtype::Exclude(None)),
            "include" => Ok(FinancialTaskinputtype::Include(None)),
            "item" => Ok(FinancialTaskinputtype::Item(None)),
            "origresponse" => Ok(FinancialTaskinputtype::Origresponse(None)),
            "period" => Ok(FinancialTaskinputtype::Period(None)),
            "reference" => Ok(FinancialTaskinputtype::Reference(None)),
            "status" => Ok(FinancialTaskinputtype::Status(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FinancialTaskinputtype {
    fn into(self) -> Option<String> {
        match self {
            FinancialTaskinputtype::Exclude(_) => Some("exclude".to_string()),
            FinancialTaskinputtype::Include(_) => Some("include".to_string()),
            FinancialTaskinputtype::Item(_) => Some("item".to_string()),
            FinancialTaskinputtype::Origresponse(_) => Some("origresponse".to_string()),
            FinancialTaskinputtype::Period(_) => Some("period".to_string()),
            FinancialTaskinputtype::Reference(_) => Some("reference".to_string()),
            FinancialTaskinputtype::Status(_) => Some("status".to_string()),
            FinancialTaskinputtype::Null(_) => None,
        }
    }
}
impl MetaValue for FinancialTaskinputtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FinancialTaskinputtype::Exclude(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Include(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Item(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Origresponse(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Period(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Reference(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Status(Some(e)) => e.get_field(field),
                FinancialTaskinputtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FinancialTaskinputtype::Exclude(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Include(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Item(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Origresponse(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Period(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Reference(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Status(Some(e)) => e.get_field_mut(field),
                FinancialTaskinputtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FlagCategory {
    #[doc = "Administrative"]
    #[code = "admin"]
    Admin(Option<Element>),
    #[doc = "Advance Directive"]
    #[code = "advance-directive"]
    AdvanceDirective(Option<Element>),
    #[doc = "Behavioral"]
    #[code = "behavioral"]
    Behavioral(Option<Element>),
    #[doc = "Clinical"]
    #[code = "clinical"]
    Clinical(Option<Element>),
    #[doc = "Subject Contact"]
    #[code = "contact"]
    Contact(Option<Element>),
    #[doc = "Diet"]
    #[code = "diet"]
    Diet(Option<Element>),
    #[doc = "Drug"]
    #[code = "drug"]
    Drug(Option<Element>),
    #[doc = "Lab"]
    #[code = "lab"]
    Lab(Option<Element>),
    #[doc = "Research"]
    #[code = "research"]
    Research(Option<Element>),
    #[doc = "Safety"]
    #[code = "safety"]
    Safety(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FlagCategory {
    fn default() -> Self {
        FlagCategory::Null(None)
    }
}
impl TryFrom<String> for FlagCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "admin" => Ok(FlagCategory::Admin(None)),
            "advance-directive" => Ok(FlagCategory::AdvanceDirective(None)),
            "behavioral" => Ok(FlagCategory::Behavioral(None)),
            "clinical" => Ok(FlagCategory::Clinical(None)),
            "contact" => Ok(FlagCategory::Contact(None)),
            "diet" => Ok(FlagCategory::Diet(None)),
            "drug" => Ok(FlagCategory::Drug(None)),
            "lab" => Ok(FlagCategory::Lab(None)),
            "research" => Ok(FlagCategory::Research(None)),
            "safety" => Ok(FlagCategory::Safety(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FlagCategory {
    fn into(self) -> Option<String> {
        match self {
            FlagCategory::Admin(_) => Some("admin".to_string()),
            FlagCategory::AdvanceDirective(_) => Some("advance-directive".to_string()),
            FlagCategory::Behavioral(_) => Some("behavioral".to_string()),
            FlagCategory::Clinical(_) => Some("clinical".to_string()),
            FlagCategory::Contact(_) => Some("contact".to_string()),
            FlagCategory::Diet(_) => Some("diet".to_string()),
            FlagCategory::Drug(_) => Some("drug".to_string()),
            FlagCategory::Lab(_) => Some("lab".to_string()),
            FlagCategory::Research(_) => Some("research".to_string()),
            FlagCategory::Safety(_) => Some("safety".to_string()),
            FlagCategory::Null(_) => None,
        }
    }
}
impl MetaValue for FlagCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FlagCategory::Admin(Some(e)) => e.get_field(field),
                FlagCategory::AdvanceDirective(Some(e)) => e.get_field(field),
                FlagCategory::Behavioral(Some(e)) => e.get_field(field),
                FlagCategory::Clinical(Some(e)) => e.get_field(field),
                FlagCategory::Contact(Some(e)) => e.get_field(field),
                FlagCategory::Diet(Some(e)) => e.get_field(field),
                FlagCategory::Drug(Some(e)) => e.get_field(field),
                FlagCategory::Lab(Some(e)) => e.get_field(field),
                FlagCategory::Research(Some(e)) => e.get_field(field),
                FlagCategory::Safety(Some(e)) => e.get_field(field),
                FlagCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FlagCategory::Admin(Some(e)) => e.get_field_mut(field),
                FlagCategory::AdvanceDirective(Some(e)) => e.get_field_mut(field),
                FlagCategory::Behavioral(Some(e)) => e.get_field_mut(field),
                FlagCategory::Clinical(Some(e)) => e.get_field_mut(field),
                FlagCategory::Contact(Some(e)) => e.get_field_mut(field),
                FlagCategory::Diet(Some(e)) => e.get_field_mut(field),
                FlagCategory::Drug(Some(e)) => e.get_field_mut(field),
                FlagCategory::Lab(Some(e)) => e.get_field_mut(field),
                FlagCategory::Research(Some(e)) => e.get_field_mut(field),
                FlagCategory::Safety(Some(e)) => e.get_field_mut(field),
                FlagCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FlagPriority {
    #[doc = "High priority"]
    #[code = "PH"]
    PH(Option<Element>),
    #[doc = "Low priority"]
    #[code = "PL"]
    PL(Option<Element>),
    #[doc = "Medium priority"]
    #[code = "PM"]
    PM(Option<Element>),
    #[doc = "No alarm"]
    #[code = "PN"]
    PN(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FlagPriority {
    fn default() -> Self {
        FlagPriority::Null(None)
    }
}
impl TryFrom<String> for FlagPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "PH" => Ok(FlagPriority::PH(None)),
            "PL" => Ok(FlagPriority::PL(None)),
            "PM" => Ok(FlagPriority::PM(None)),
            "PN" => Ok(FlagPriority::PN(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FlagPriority {
    fn into(self) -> Option<String> {
        match self {
            FlagPriority::PH(_) => Some("PH".to_string()),
            FlagPriority::PL(_) => Some("PL".to_string()),
            FlagPriority::PM(_) => Some("PM".to_string()),
            FlagPriority::PN(_) => Some("PN".to_string()),
            FlagPriority::Null(_) => None,
        }
    }
}
impl MetaValue for FlagPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FlagPriority::PH(Some(e)) => e.get_field(field),
                FlagPriority::PL(Some(e)) => e.get_field(field),
                FlagPriority::PM(Some(e)) => e.get_field(field),
                FlagPriority::PN(Some(e)) => e.get_field(field),
                FlagPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FlagPriority::PH(Some(e)) => e.get_field_mut(field),
                FlagPriority::PL(Some(e)) => e.get_field_mut(field),
                FlagPriority::PM(Some(e)) => e.get_field_mut(field),
                FlagPriority::PN(Some(e)) => e.get_field_mut(field),
                FlagPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FlagStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FlagStatus {
    fn default() -> Self {
        FlagStatus::Null(None)
    }
}
impl TryFrom<String> for FlagStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(FlagStatus::Active(None)),
            "entered-in-error" => Ok(FlagStatus::EnteredInError(None)),
            "inactive" => Ok(FlagStatus::Inactive(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FlagStatus {
    fn into(self) -> Option<String> {
        match self {
            FlagStatus::Active(_) => Some("active".to_string()),
            FlagStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            FlagStatus::Inactive(_) => Some("inactive".to_string()),
            FlagStatus::Null(_) => None,
        }
    }
}
impl MetaValue for FlagStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FlagStatus::Active(Some(e)) => e.get_field(field),
                FlagStatus::EnteredInError(Some(e)) => e.get_field(field),
                FlagStatus::Inactive(Some(e)) => e.get_field(field),
                FlagStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FlagStatus::Active(Some(e)) => e.get_field_mut(field),
                FlagStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                FlagStatus::Inactive(Some(e)) => e.get_field_mut(field),
                FlagStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FmConditions {
    #[doc = "Headache"]
    #[code = "123987"]
    V123987(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FmConditions {
    fn default() -> Self {
        FmConditions::Null(None)
    }
}
impl TryFrom<String> for FmConditions {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "123987" => Ok(FmConditions::V123987(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FmConditions {
    fn into(self) -> Option<String> {
        match self {
            FmConditions::V123987(_) => Some("123987".to_string()),
            FmConditions::Null(_) => None,
        }
    }
}
impl MetaValue for FmConditions {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FmConditions::V123987(Some(e)) => e.get_field(field),
                FmConditions::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FmConditions::V123987(Some(e)) => e.get_field_mut(field),
                FmConditions::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FmItemtype {
    #[doc = "Group"]
    #[code = "group"]
    Group(Option<Element>),
    #[doc = "Product"]
    #[code = "product"]
    Product(Option<Element>),
    #[doc = "Service"]
    #[code = "service"]
    Service(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FmItemtype {
    fn default() -> Self {
        FmItemtype::Null(None)
    }
}
impl TryFrom<String> for FmItemtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "group" => Ok(FmItemtype::Group(None)),
            "product" => Ok(FmItemtype::Product(None)),
            "service" => Ok(FmItemtype::Service(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FmItemtype {
    fn into(self) -> Option<String> {
        match self {
            FmItemtype::Group(_) => Some("group".to_string()),
            FmItemtype::Product(_) => Some("product".to_string()),
            FmItemtype::Service(_) => Some("service".to_string()),
            FmItemtype::Null(_) => None,
        }
    }
}
impl MetaValue for FmItemtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FmItemtype::Group(Some(e)) => e.get_field(field),
                FmItemtype::Product(Some(e)) => e.get_field(field),
                FmItemtype::Service(Some(e)) => e.get_field(field),
                FmItemtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FmItemtype::Group(Some(e)) => e.get_field_mut(field),
                FmItemtype::Product(Some(e)) => e.get_field_mut(field),
                FmItemtype::Service(Some(e)) => e.get_field_mut(field),
                FmItemtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FmStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FmStatus {
    fn default() -> Self {
        FmStatus::Null(None)
    }
}
impl TryFrom<String> for FmStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(FmStatus::Active(None)),
            "cancelled" => Ok(FmStatus::Cancelled(None)),
            "draft" => Ok(FmStatus::Draft(None)),
            "entered-in-error" => Ok(FmStatus::EnteredInError(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FmStatus {
    fn into(self) -> Option<String> {
        match self {
            FmStatus::Active(_) => Some("active".to_string()),
            FmStatus::Cancelled(_) => Some("cancelled".to_string()),
            FmStatus::Draft(_) => Some("draft".to_string()),
            FmStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            FmStatus::Null(_) => None,
        }
    }
}
impl MetaValue for FmStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FmStatus::Active(Some(e)) => e.get_field(field),
                FmStatus::Cancelled(Some(e)) => e.get_field(field),
                FmStatus::Draft(Some(e)) => e.get_field(field),
                FmStatus::EnteredInError(Some(e)) => e.get_field(field),
                FmStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FmStatus::Active(Some(e)) => e.get_field_mut(field),
                FmStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                FmStatus::Draft(Some(e)) => e.get_field_mut(field),
                FmStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                FmStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum FocalSubject {
    #[doc = "Fetus"]
    #[code = "83418008"]
    V83418008(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "spouse"]
    #[code = "SPS"]
    SPS(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for FocalSubject {
    fn default() -> Self {
        FocalSubject::Null(None)
    }
}
impl TryFrom<String> for FocalSubject {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "83418008" => Ok(FocalSubject::V83418008(None)),
            "DON" => Ok(FocalSubject::DON(None)),
            "SPS" => Ok(FocalSubject::SPS(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &FocalSubject {
    fn into(self) -> Option<String> {
        match self {
            FocalSubject::V83418008(_) => Some("83418008".to_string()),
            FocalSubject::DON(_) => Some("DON".to_string()),
            FocalSubject::SPS(_) => Some("SPS".to_string()),
            FocalSubject::Null(_) => None,
        }
    }
}
impl MetaValue for FocalSubject {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                FocalSubject::V83418008(Some(e)) => e.get_field(field),
                FocalSubject::DON(Some(e)) => e.get_field(field),
                FocalSubject::SPS(Some(e)) => e.get_field(field),
                FocalSubject::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                FocalSubject::V83418008(Some(e)) => e.get_field_mut(field),
                FocalSubject::DON(Some(e)) => e.get_field_mut(field),
                FocalSubject::SPS(Some(e)) => e.get_field_mut(field),
                FocalSubject::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Forms {
    #[doc = "Form #1"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Form #1"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Forms {
    fn default() -> Self {
        Forms::Null(None)
    }
}
impl TryFrom<String> for Forms {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(Forms::V1(None)),
            "2" => Ok(Forms::V2(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Forms {
    fn into(self) -> Option<String> {
        match self {
            Forms::V1(_) => Some("1".to_string()),
            Forms::V2(_) => Some("2".to_string()),
            Forms::Null(_) => None,
        }
    }
}
impl MetaValue for Forms {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Forms::V1(Some(e)) => e.get_field(field),
                Forms::V2(Some(e)) => e.get_field(field),
                Forms::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Forms::V1(Some(e)) => e.get_field_mut(field),
                Forms::V2(Some(e)) => e.get_field_mut(field),
                Forms::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Fundsreserve {
    #[doc = "None"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Provider"]
    #[code = "provider"]
    Provider(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Fundsreserve {
    fn default() -> Self {
        Fundsreserve::Null(None)
    }
}
impl TryFrom<String> for Fundsreserve {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "none" => Ok(Fundsreserve::None(None)),
            "patient" => Ok(Fundsreserve::Patient(None)),
            "provider" => Ok(Fundsreserve::Provider(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Fundsreserve {
    fn into(self) -> Option<String> {
        match self {
            Fundsreserve::None(_) => Some("none".to_string()),
            Fundsreserve::Patient(_) => Some("patient".to_string()),
            Fundsreserve::Provider(_) => Some("provider".to_string()),
            Fundsreserve::Null(_) => None,
        }
    }
}
impl MetaValue for Fundsreserve {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Fundsreserve::None(Some(e)) => e.get_field(field),
                Fundsreserve::Patient(Some(e)) => e.get_field(field),
                Fundsreserve::Provider(Some(e)) => e.get_field(field),
                Fundsreserve::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Fundsreserve::None(Some(e)) => e.get_field_mut(field),
                Fundsreserve::Patient(Some(e)) => e.get_field_mut(field),
                Fundsreserve::Provider(Some(e)) => e.get_field_mut(field),
                Fundsreserve::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GenderIdentity {
    #[doc = "female"]
    #[code = "female"]
    Female(Option<Element>),
    #[doc = "male"]
    #[code = "male"]
    Male(Option<Element>),
    #[doc = "non-binary"]
    #[code = "non-binary"]
    NonBinary(Option<Element>),
    #[doc = "does not wish to disclose"]
    #[code = "non-disclose"]
    NonDisclose(Option<Element>),
    #[doc = "other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "transgender female"]
    #[code = "transgender-female"]
    TransgenderFemale(Option<Element>),
    #[doc = "transgender male"]
    #[code = "transgender-male"]
    TransgenderMale(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GenderIdentity {
    fn default() -> Self {
        GenderIdentity::Null(None)
    }
}
impl TryFrom<String> for GenderIdentity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "female" => Ok(GenderIdentity::Female(None)),
            "male" => Ok(GenderIdentity::Male(None)),
            "non-binary" => Ok(GenderIdentity::NonBinary(None)),
            "non-disclose" => Ok(GenderIdentity::NonDisclose(None)),
            "other" => Ok(GenderIdentity::Other(None)),
            "transgender-female" => Ok(GenderIdentity::TransgenderFemale(None)),
            "transgender-male" => Ok(GenderIdentity::TransgenderMale(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GenderIdentity {
    fn into(self) -> Option<String> {
        match self {
            GenderIdentity::Female(_) => Some("female".to_string()),
            GenderIdentity::Male(_) => Some("male".to_string()),
            GenderIdentity::NonBinary(_) => Some("non-binary".to_string()),
            GenderIdentity::NonDisclose(_) => Some("non-disclose".to_string()),
            GenderIdentity::Other(_) => Some("other".to_string()),
            GenderIdentity::TransgenderFemale(_) => Some("transgender-female".to_string()),
            GenderIdentity::TransgenderMale(_) => Some("transgender-male".to_string()),
            GenderIdentity::Null(_) => None,
        }
    }
}
impl MetaValue for GenderIdentity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GenderIdentity::Female(Some(e)) => e.get_field(field),
                GenderIdentity::Male(Some(e)) => e.get_field(field),
                GenderIdentity::NonBinary(Some(e)) => e.get_field(field),
                GenderIdentity::NonDisclose(Some(e)) => e.get_field(field),
                GenderIdentity::Other(Some(e)) => e.get_field(field),
                GenderIdentity::TransgenderFemale(Some(e)) => e.get_field(field),
                GenderIdentity::TransgenderMale(Some(e)) => e.get_field(field),
                GenderIdentity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GenderIdentity::Female(Some(e)) => e.get_field_mut(field),
                GenderIdentity::Male(Some(e)) => e.get_field_mut(field),
                GenderIdentity::NonBinary(Some(e)) => e.get_field_mut(field),
                GenderIdentity::NonDisclose(Some(e)) => e.get_field_mut(field),
                GenderIdentity::Other(Some(e)) => e.get_field_mut(field),
                GenderIdentity::TransgenderFemale(Some(e)) => e.get_field_mut(field),
                GenderIdentity::TransgenderMale(Some(e)) => e.get_field_mut(field),
                GenderIdentity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalAcceptanceStatus {
    #[doc = "Agree"]
    #[code = "agree"]
    Agree(Option<Element>),
    #[doc = "Disagree"]
    #[code = "disagree"]
    Disagree(Option<Element>),
    #[doc = "Pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalAcceptanceStatus {
    fn default() -> Self {
        GoalAcceptanceStatus::Null(None)
    }
}
impl TryFrom<String> for GoalAcceptanceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "agree" => Ok(GoalAcceptanceStatus::Agree(None)),
            "disagree" => Ok(GoalAcceptanceStatus::Disagree(None)),
            "pending" => Ok(GoalAcceptanceStatus::Pending(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalAcceptanceStatus {
    fn into(self) -> Option<String> {
        match self {
            GoalAcceptanceStatus::Agree(_) => Some("agree".to_string()),
            GoalAcceptanceStatus::Disagree(_) => Some("disagree".to_string()),
            GoalAcceptanceStatus::Pending(_) => Some("pending".to_string()),
            GoalAcceptanceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for GoalAcceptanceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalAcceptanceStatus::Agree(Some(e)) => e.get_field(field),
                GoalAcceptanceStatus::Disagree(Some(e)) => e.get_field(field),
                GoalAcceptanceStatus::Pending(Some(e)) => e.get_field(field),
                GoalAcceptanceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalAcceptanceStatus::Agree(Some(e)) => e.get_field_mut(field),
                GoalAcceptanceStatus::Disagree(Some(e)) => e.get_field_mut(field),
                GoalAcceptanceStatus::Pending(Some(e)) => e.get_field_mut(field),
                GoalAcceptanceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalAchievement {
    #[doc = "Achieved"]
    #[code = "achieved"]
    Achieved(Option<Element>),
    #[doc = "Improving"]
    #[code = "improving"]
    Improving(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "No Change"]
    #[code = "no-change"]
    NoChange(Option<Element>),
    #[doc = "No Progress"]
    #[code = "no-progress"]
    NoProgress(Option<Element>),
    #[doc = "Not Achieved"]
    #[code = "not-achieved"]
    NotAchieved(Option<Element>),
    #[doc = "Not Attainable"]
    #[code = "not-attainable"]
    NotAttainable(Option<Element>),
    #[doc = "Sustaining"]
    #[code = "sustaining"]
    Sustaining(Option<Element>),
    #[doc = "Worsening"]
    #[code = "worsening"]
    Worsening(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalAchievement {
    fn default() -> Self {
        GoalAchievement::Null(None)
    }
}
impl TryFrom<String> for GoalAchievement {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "achieved" => Ok(GoalAchievement::Achieved(None)),
            "improving" => Ok(GoalAchievement::Improving(None)),
            "in-progress" => Ok(GoalAchievement::InProgress(None)),
            "no-change" => Ok(GoalAchievement::NoChange(None)),
            "no-progress" => Ok(GoalAchievement::NoProgress(None)),
            "not-achieved" => Ok(GoalAchievement::NotAchieved(None)),
            "not-attainable" => Ok(GoalAchievement::NotAttainable(None)),
            "sustaining" => Ok(GoalAchievement::Sustaining(None)),
            "worsening" => Ok(GoalAchievement::Worsening(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalAchievement {
    fn into(self) -> Option<String> {
        match self {
            GoalAchievement::Achieved(_) => Some("achieved".to_string()),
            GoalAchievement::Improving(_) => Some("improving".to_string()),
            GoalAchievement::InProgress(_) => Some("in-progress".to_string()),
            GoalAchievement::NoChange(_) => Some("no-change".to_string()),
            GoalAchievement::NoProgress(_) => Some("no-progress".to_string()),
            GoalAchievement::NotAchieved(_) => Some("not-achieved".to_string()),
            GoalAchievement::NotAttainable(_) => Some("not-attainable".to_string()),
            GoalAchievement::Sustaining(_) => Some("sustaining".to_string()),
            GoalAchievement::Worsening(_) => Some("worsening".to_string()),
            GoalAchievement::Null(_) => None,
        }
    }
}
impl MetaValue for GoalAchievement {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalAchievement::Achieved(Some(e)) => e.get_field(field),
                GoalAchievement::Improving(Some(e)) => e.get_field(field),
                GoalAchievement::InProgress(Some(e)) => e.get_field(field),
                GoalAchievement::NoChange(Some(e)) => e.get_field(field),
                GoalAchievement::NoProgress(Some(e)) => e.get_field(field),
                GoalAchievement::NotAchieved(Some(e)) => e.get_field(field),
                GoalAchievement::NotAttainable(Some(e)) => e.get_field(field),
                GoalAchievement::Sustaining(Some(e)) => e.get_field(field),
                GoalAchievement::Worsening(Some(e)) => e.get_field(field),
                GoalAchievement::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalAchievement::Achieved(Some(e)) => e.get_field_mut(field),
                GoalAchievement::Improving(Some(e)) => e.get_field_mut(field),
                GoalAchievement::InProgress(Some(e)) => e.get_field_mut(field),
                GoalAchievement::NoChange(Some(e)) => e.get_field_mut(field),
                GoalAchievement::NoProgress(Some(e)) => e.get_field_mut(field),
                GoalAchievement::NotAchieved(Some(e)) => e.get_field_mut(field),
                GoalAchievement::NotAttainable(Some(e)) => e.get_field_mut(field),
                GoalAchievement::Sustaining(Some(e)) => e.get_field_mut(field),
                GoalAchievement::Worsening(Some(e)) => e.get_field_mut(field),
                GoalAchievement::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalCategory {
    #[doc = "Behavioral"]
    #[code = "behavioral"]
    Behavioral(Option<Element>),
    #[doc = "Dietary"]
    #[code = "dietary"]
    Dietary(Option<Element>),
    #[doc = "Nursing"]
    #[code = "nursing"]
    Nursing(Option<Element>),
    #[doc = "Physiotherapy"]
    #[code = "physiotherapy"]
    Physiotherapy(Option<Element>),
    #[doc = "Safety"]
    #[code = "safety"]
    Safety(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalCategory {
    fn default() -> Self {
        GoalCategory::Null(None)
    }
}
impl TryFrom<String> for GoalCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "behavioral" => Ok(GoalCategory::Behavioral(None)),
            "dietary" => Ok(GoalCategory::Dietary(None)),
            "nursing" => Ok(GoalCategory::Nursing(None)),
            "physiotherapy" => Ok(GoalCategory::Physiotherapy(None)),
            "safety" => Ok(GoalCategory::Safety(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalCategory {
    fn into(self) -> Option<String> {
        match self {
            GoalCategory::Behavioral(_) => Some("behavioral".to_string()),
            GoalCategory::Dietary(_) => Some("dietary".to_string()),
            GoalCategory::Nursing(_) => Some("nursing".to_string()),
            GoalCategory::Physiotherapy(_) => Some("physiotherapy".to_string()),
            GoalCategory::Safety(_) => Some("safety".to_string()),
            GoalCategory::Null(_) => None,
        }
    }
}
impl MetaValue for GoalCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalCategory::Behavioral(Some(e)) => e.get_field(field),
                GoalCategory::Dietary(Some(e)) => e.get_field(field),
                GoalCategory::Nursing(Some(e)) => e.get_field(field),
                GoalCategory::Physiotherapy(Some(e)) => e.get_field(field),
                GoalCategory::Safety(Some(e)) => e.get_field(field),
                GoalCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalCategory::Behavioral(Some(e)) => e.get_field_mut(field),
                GoalCategory::Dietary(Some(e)) => e.get_field_mut(field),
                GoalCategory::Nursing(Some(e)) => e.get_field_mut(field),
                GoalCategory::Physiotherapy(Some(e)) => e.get_field_mut(field),
                GoalCategory::Safety(Some(e)) => e.get_field_mut(field),
                GoalCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalPriority {
    #[doc = "High Priority"]
    #[code = "high-priority"]
    HighPriority(Option<Element>),
    #[doc = "Low Priority"]
    #[code = "low-priority"]
    LowPriority(Option<Element>),
    #[doc = "Medium Priority"]
    #[code = "medium-priority"]
    MediumPriority(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalPriority {
    fn default() -> Self {
        GoalPriority::Null(None)
    }
}
impl TryFrom<String> for GoalPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "high-priority" => Ok(GoalPriority::HighPriority(None)),
            "low-priority" => Ok(GoalPriority::LowPriority(None)),
            "medium-priority" => Ok(GoalPriority::MediumPriority(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalPriority {
    fn into(self) -> Option<String> {
        match self {
            GoalPriority::HighPriority(_) => Some("high-priority".to_string()),
            GoalPriority::LowPriority(_) => Some("low-priority".to_string()),
            GoalPriority::MediumPriority(_) => Some("medium-priority".to_string()),
            GoalPriority::Null(_) => None,
        }
    }
}
impl MetaValue for GoalPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalPriority::HighPriority(Some(e)) => e.get_field(field),
                GoalPriority::LowPriority(Some(e)) => e.get_field(field),
                GoalPriority::MediumPriority(Some(e)) => e.get_field(field),
                GoalPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalPriority::HighPriority(Some(e)) => e.get_field_mut(field),
                GoalPriority::LowPriority(Some(e)) => e.get_field_mut(field),
                GoalPriority::MediumPriority(Some(e)) => e.get_field_mut(field),
                GoalPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalRelationshipType {
    #[doc = "Milestone"]
    #[code = "milestone"]
    Milestone(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Predecessor"]
    #[code = "predecessor"]
    Predecessor(Option<Element>),
    #[doc = "Replacement"]
    #[code = "replacement"]
    Replacement(Option<Element>),
    #[doc = "Successor"]
    #[code = "successor"]
    Successor(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalRelationshipType {
    fn default() -> Self {
        GoalRelationshipType::Null(None)
    }
}
impl TryFrom<String> for GoalRelationshipType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "milestone" => Ok(GoalRelationshipType::Milestone(None)),
            "other" => Ok(GoalRelationshipType::Other(None)),
            "predecessor" => Ok(GoalRelationshipType::Predecessor(None)),
            "replacement" => Ok(GoalRelationshipType::Replacement(None)),
            "successor" => Ok(GoalRelationshipType::Successor(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalRelationshipType {
    fn into(self) -> Option<String> {
        match self {
            GoalRelationshipType::Milestone(_) => Some("milestone".to_string()),
            GoalRelationshipType::Other(_) => Some("other".to_string()),
            GoalRelationshipType::Predecessor(_) => Some("predecessor".to_string()),
            GoalRelationshipType::Replacement(_) => Some("replacement".to_string()),
            GoalRelationshipType::Successor(_) => Some("successor".to_string()),
            GoalRelationshipType::Null(_) => None,
        }
    }
}
impl MetaValue for GoalRelationshipType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalRelationshipType::Milestone(Some(e)) => e.get_field(field),
                GoalRelationshipType::Other(Some(e)) => e.get_field(field),
                GoalRelationshipType::Predecessor(Some(e)) => e.get_field(field),
                GoalRelationshipType::Replacement(Some(e)) => e.get_field(field),
                GoalRelationshipType::Successor(Some(e)) => e.get_field(field),
                GoalRelationshipType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalRelationshipType::Milestone(Some(e)) => e.get_field_mut(field),
                GoalRelationshipType::Other(Some(e)) => e.get_field_mut(field),
                GoalRelationshipType::Predecessor(Some(e)) => e.get_field_mut(field),
                GoalRelationshipType::Replacement(Some(e)) => e.get_field_mut(field),
                GoalRelationshipType::Successor(Some(e)) => e.get_field_mut(field),
                GoalRelationshipType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalStartEvent {
    #[doc = "Discharge from hospital"]
    #[code = "308283009"]
    V308283009(Option<Element>),
    #[doc = "Admission to hospital"]
    #[code = "32485007"]
    V32485007(Option<Element>),
    #[doc = "Childbirth"]
    #[code = "386216000"]
    V386216000(Option<Element>),
    #[doc = "Completion time of procedure"]
    #[code = "442137000"]
    V442137000(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalStartEvent {
    fn default() -> Self {
        GoalStartEvent::Null(None)
    }
}
impl TryFrom<String> for GoalStartEvent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "308283009" => Ok(GoalStartEvent::V308283009(None)),
            "32485007" => Ok(GoalStartEvent::V32485007(None)),
            "386216000" => Ok(GoalStartEvent::V386216000(None)),
            "442137000" => Ok(GoalStartEvent::V442137000(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalStartEvent {
    fn into(self) -> Option<String> {
        match self {
            GoalStartEvent::V308283009(_) => Some("308283009".to_string()),
            GoalStartEvent::V32485007(_) => Some("32485007".to_string()),
            GoalStartEvent::V386216000(_) => Some("386216000".to_string()),
            GoalStartEvent::V442137000(_) => Some("442137000".to_string()),
            GoalStartEvent::Null(_) => None,
        }
    }
}
impl MetaValue for GoalStartEvent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalStartEvent::V308283009(Some(e)) => e.get_field(field),
                GoalStartEvent::V32485007(Some(e)) => e.get_field(field),
                GoalStartEvent::V386216000(Some(e)) => e.get_field(field),
                GoalStartEvent::V442137000(Some(e)) => e.get_field(field),
                GoalStartEvent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalStartEvent::V308283009(Some(e)) => e.get_field_mut(field),
                GoalStartEvent::V32485007(Some(e)) => e.get_field_mut(field),
                GoalStartEvent::V386216000(Some(e)) => e.get_field_mut(field),
                GoalStartEvent::V442137000(Some(e)) => e.get_field_mut(field),
                GoalStartEvent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalStatus {
    #[doc = "Accepted"]
    #[code = "accepted"]
    Accepted(Option<Element>),
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "Proposed"]
    #[code = "proposed"]
    Proposed(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalStatus {
    fn default() -> Self {
        GoalStatus::Null(None)
    }
}
impl TryFrom<String> for GoalStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "accepted" => Ok(GoalStatus::Accepted(None)),
            "active" => Ok(GoalStatus::Active(None)),
            "cancelled" => Ok(GoalStatus::Cancelled(None)),
            "completed" => Ok(GoalStatus::Completed(None)),
            "entered-in-error" => Ok(GoalStatus::EnteredInError(None)),
            "on-hold" => Ok(GoalStatus::OnHold(None)),
            "planned" => Ok(GoalStatus::Planned(None)),
            "proposed" => Ok(GoalStatus::Proposed(None)),
            "rejected" => Ok(GoalStatus::Rejected(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalStatus {
    fn into(self) -> Option<String> {
        match self {
            GoalStatus::Accepted(_) => Some("accepted".to_string()),
            GoalStatus::Active(_) => Some("active".to_string()),
            GoalStatus::Cancelled(_) => Some("cancelled".to_string()),
            GoalStatus::Completed(_) => Some("completed".to_string()),
            GoalStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            GoalStatus::OnHold(_) => Some("on-hold".to_string()),
            GoalStatus::Planned(_) => Some("planned".to_string()),
            GoalStatus::Proposed(_) => Some("proposed".to_string()),
            GoalStatus::Rejected(_) => Some("rejected".to_string()),
            GoalStatus::Null(_) => None,
        }
    }
}
impl MetaValue for GoalStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalStatus::Accepted(Some(e)) => e.get_field(field),
                GoalStatus::Active(Some(e)) => e.get_field(field),
                GoalStatus::Cancelled(Some(e)) => e.get_field(field),
                GoalStatus::Completed(Some(e)) => e.get_field(field),
                GoalStatus::EnteredInError(Some(e)) => e.get_field(field),
                GoalStatus::OnHold(Some(e)) => e.get_field(field),
                GoalStatus::Planned(Some(e)) => e.get_field(field),
                GoalStatus::Proposed(Some(e)) => e.get_field(field),
                GoalStatus::Rejected(Some(e)) => e.get_field(field),
                GoalStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalStatus::Accepted(Some(e)) => e.get_field_mut(field),
                GoalStatus::Active(Some(e)) => e.get_field_mut(field),
                GoalStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                GoalStatus::Completed(Some(e)) => e.get_field_mut(field),
                GoalStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                GoalStatus::OnHold(Some(e)) => e.get_field_mut(field),
                GoalStatus::Planned(Some(e)) => e.get_field_mut(field),
                GoalStatus::Proposed(Some(e)) => e.get_field_mut(field),
                GoalStatus::Rejected(Some(e)) => e.get_field_mut(field),
                GoalStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GoalStatusReason {
    #[doc = "Financial Reason"]
    #[code = "financial-barrier"]
    FinancialBarrier(Option<Element>),
    #[doc = "Lack Of Social Support"]
    #[code = "lack-of-social-support"]
    LackOfSocialSupport(Option<Element>),
    #[doc = "Lack Of Transportation"]
    #[code = "lack-of-transportation"]
    LackOfTransportation(Option<Element>),
    #[doc = "Life Event"]
    #[code = "life-event"]
    LifeEvent(Option<Element>),
    #[doc = "Patient Request"]
    #[code = "patient-request"]
    PatientRequest(Option<Element>),
    #[doc = "Goal Not Attainable Permanently"]
    #[code = "permanent-not-attainable"]
    PermanentNotAttainable(Option<Element>),
    #[doc = "Replaced"]
    #[code = "replaced"]
    Replaced(Option<Element>),
    #[doc = "Surgery"]
    #[code = "surgery"]
    Surgery(Option<Element>),
    #[doc = "Goal Not Attainable Temporarily"]
    #[code = "temp-not-attainable"]
    TempNotAttainable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GoalStatusReason {
    fn default() -> Self {
        GoalStatusReason::Null(None)
    }
}
impl TryFrom<String> for GoalStatusReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "financial-barrier" => Ok(GoalStatusReason::FinancialBarrier(None)),
            "lack-of-social-support" => Ok(GoalStatusReason::LackOfSocialSupport(None)),
            "lack-of-transportation" => Ok(GoalStatusReason::LackOfTransportation(None)),
            "life-event" => Ok(GoalStatusReason::LifeEvent(None)),
            "patient-request" => Ok(GoalStatusReason::PatientRequest(None)),
            "permanent-not-attainable" => Ok(GoalStatusReason::PermanentNotAttainable(None)),
            "replaced" => Ok(GoalStatusReason::Replaced(None)),
            "surgery" => Ok(GoalStatusReason::Surgery(None)),
            "temp-not-attainable" => Ok(GoalStatusReason::TempNotAttainable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GoalStatusReason {
    fn into(self) -> Option<String> {
        match self {
            GoalStatusReason::FinancialBarrier(_) => Some("financial-barrier".to_string()),
            GoalStatusReason::LackOfSocialSupport(_) => Some("lack-of-social-support".to_string()),
            GoalStatusReason::LackOfTransportation(_) => Some("lack-of-transportation".to_string()),
            GoalStatusReason::LifeEvent(_) => Some("life-event".to_string()),
            GoalStatusReason::PatientRequest(_) => Some("patient-request".to_string()),
            GoalStatusReason::PermanentNotAttainable(_) => {
                Some("permanent-not-attainable".to_string())
            }
            GoalStatusReason::Replaced(_) => Some("replaced".to_string()),
            GoalStatusReason::Surgery(_) => Some("surgery".to_string()),
            GoalStatusReason::TempNotAttainable(_) => Some("temp-not-attainable".to_string()),
            GoalStatusReason::Null(_) => None,
        }
    }
}
impl MetaValue for GoalStatusReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GoalStatusReason::FinancialBarrier(Some(e)) => e.get_field(field),
                GoalStatusReason::LackOfSocialSupport(Some(e)) => e.get_field(field),
                GoalStatusReason::LackOfTransportation(Some(e)) => e.get_field(field),
                GoalStatusReason::LifeEvent(Some(e)) => e.get_field(field),
                GoalStatusReason::PatientRequest(Some(e)) => e.get_field(field),
                GoalStatusReason::PermanentNotAttainable(Some(e)) => e.get_field(field),
                GoalStatusReason::Replaced(Some(e)) => e.get_field(field),
                GoalStatusReason::Surgery(Some(e)) => e.get_field(field),
                GoalStatusReason::TempNotAttainable(Some(e)) => e.get_field(field),
                GoalStatusReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GoalStatusReason::FinancialBarrier(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::LackOfSocialSupport(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::LackOfTransportation(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::LifeEvent(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::PatientRequest(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::PermanentNotAttainable(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::Replaced(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::Surgery(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::TempNotAttainable(Some(e)) => e.get_field_mut(field),
                GoalStatusReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GraphCompartmentRule {
    #[doc = "Custom"]
    #[code = "custom"]
    Custom(Option<Element>),
    #[doc = "Different"]
    #[code = "different"]
    Different(Option<Element>),
    #[doc = "Identical"]
    #[code = "identical"]
    Identical(Option<Element>),
    #[doc = "Matching"]
    #[code = "matching"]
    Matching(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GraphCompartmentRule {
    fn default() -> Self {
        GraphCompartmentRule::Null(None)
    }
}
impl TryFrom<String> for GraphCompartmentRule {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "custom" => Ok(GraphCompartmentRule::Custom(None)),
            "different" => Ok(GraphCompartmentRule::Different(None)),
            "identical" => Ok(GraphCompartmentRule::Identical(None)),
            "matching" => Ok(GraphCompartmentRule::Matching(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GraphCompartmentRule {
    fn into(self) -> Option<String> {
        match self {
            GraphCompartmentRule::Custom(_) => Some("custom".to_string()),
            GraphCompartmentRule::Different(_) => Some("different".to_string()),
            GraphCompartmentRule::Identical(_) => Some("identical".to_string()),
            GraphCompartmentRule::Matching(_) => Some("matching".to_string()),
            GraphCompartmentRule::Null(_) => None,
        }
    }
}
impl MetaValue for GraphCompartmentRule {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GraphCompartmentRule::Custom(Some(e)) => e.get_field(field),
                GraphCompartmentRule::Different(Some(e)) => e.get_field(field),
                GraphCompartmentRule::Identical(Some(e)) => e.get_field(field),
                GraphCompartmentRule::Matching(Some(e)) => e.get_field(field),
                GraphCompartmentRule::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GraphCompartmentRule::Custom(Some(e)) => e.get_field_mut(field),
                GraphCompartmentRule::Different(Some(e)) => e.get_field_mut(field),
                GraphCompartmentRule::Identical(Some(e)) => e.get_field_mut(field),
                GraphCompartmentRule::Matching(Some(e)) => e.get_field_mut(field),
                GraphCompartmentRule::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GraphCompartmentUse {
    #[doc = "Condition"]
    #[code = "condition"]
    Condition(Option<Element>),
    #[doc = "Requirement"]
    #[code = "requirement"]
    Requirement(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GraphCompartmentUse {
    fn default() -> Self {
        GraphCompartmentUse::Null(None)
    }
}
impl TryFrom<String> for GraphCompartmentUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "condition" => Ok(GraphCompartmentUse::Condition(None)),
            "requirement" => Ok(GraphCompartmentUse::Requirement(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GraphCompartmentUse {
    fn into(self) -> Option<String> {
        match self {
            GraphCompartmentUse::Condition(_) => Some("condition".to_string()),
            GraphCompartmentUse::Requirement(_) => Some("requirement".to_string()),
            GraphCompartmentUse::Null(_) => None,
        }
    }
}
impl MetaValue for GraphCompartmentUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GraphCompartmentUse::Condition(Some(e)) => e.get_field(field),
                GraphCompartmentUse::Requirement(Some(e)) => e.get_field(field),
                GraphCompartmentUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GraphCompartmentUse::Condition(Some(e)) => e.get_field_mut(field),
                GraphCompartmentUse::Requirement(Some(e)) => e.get_field_mut(field),
                GraphCompartmentUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GroupMeasure {
    #[doc = "Mean"]
    #[code = "mean"]
    Mean(Option<Element>),
    #[doc = "Mean of Study Means"]
    #[code = "mean-of-mean"]
    MeanOfMean(Option<Element>),
    #[doc = "Mean of Study Medins"]
    #[code = "mean-of-median"]
    MeanOfMedian(Option<Element>),
    #[doc = "Median"]
    #[code = "median"]
    Median(Option<Element>),
    #[doc = "Median of Study Means"]
    #[code = "median-of-mean"]
    MedianOfMean(Option<Element>),
    #[doc = "Median of Study Medians"]
    #[code = "median-of-median"]
    MedianOfMedian(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GroupMeasure {
    fn default() -> Self {
        GroupMeasure::Null(None)
    }
}
impl TryFrom<String> for GroupMeasure {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "mean" => Ok(GroupMeasure::Mean(None)),
            "mean-of-mean" => Ok(GroupMeasure::MeanOfMean(None)),
            "mean-of-median" => Ok(GroupMeasure::MeanOfMedian(None)),
            "median" => Ok(GroupMeasure::Median(None)),
            "median-of-mean" => Ok(GroupMeasure::MedianOfMean(None)),
            "median-of-median" => Ok(GroupMeasure::MedianOfMedian(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GroupMeasure {
    fn into(self) -> Option<String> {
        match self {
            GroupMeasure::Mean(_) => Some("mean".to_string()),
            GroupMeasure::MeanOfMean(_) => Some("mean-of-mean".to_string()),
            GroupMeasure::MeanOfMedian(_) => Some("mean-of-median".to_string()),
            GroupMeasure::Median(_) => Some("median".to_string()),
            GroupMeasure::MedianOfMean(_) => Some("median-of-mean".to_string()),
            GroupMeasure::MedianOfMedian(_) => Some("median-of-median".to_string()),
            GroupMeasure::Null(_) => None,
        }
    }
}
impl MetaValue for GroupMeasure {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GroupMeasure::Mean(Some(e)) => e.get_field(field),
                GroupMeasure::MeanOfMean(Some(e)) => e.get_field(field),
                GroupMeasure::MeanOfMedian(Some(e)) => e.get_field(field),
                GroupMeasure::Median(Some(e)) => e.get_field(field),
                GroupMeasure::MedianOfMean(Some(e)) => e.get_field(field),
                GroupMeasure::MedianOfMedian(Some(e)) => e.get_field(field),
                GroupMeasure::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GroupMeasure::Mean(Some(e)) => e.get_field_mut(field),
                GroupMeasure::MeanOfMean(Some(e)) => e.get_field_mut(field),
                GroupMeasure::MeanOfMedian(Some(e)) => e.get_field_mut(field),
                GroupMeasure::Median(Some(e)) => e.get_field_mut(field),
                GroupMeasure::MedianOfMean(Some(e)) => e.get_field_mut(field),
                GroupMeasure::MedianOfMedian(Some(e)) => e.get_field_mut(field),
                GroupMeasure::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GroupType {
    #[doc = "Animal"]
    #[code = "animal"]
    Animal(Option<Element>),
    #[doc = "Device"]
    #[code = "device"]
    Device(Option<Element>),
    #[doc = "Medication"]
    #[code = "medication"]
    Medication(Option<Element>),
    #[doc = "Person"]
    #[code = "person"]
    Person(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "practitioner"]
    Practitioner(Option<Element>),
    #[doc = "Substance"]
    #[code = "substance"]
    Substance(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GroupType {
    fn default() -> Self {
        GroupType::Null(None)
    }
}
impl TryFrom<String> for GroupType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "animal" => Ok(GroupType::Animal(None)),
            "device" => Ok(GroupType::Device(None)),
            "medication" => Ok(GroupType::Medication(None)),
            "person" => Ok(GroupType::Person(None)),
            "practitioner" => Ok(GroupType::Practitioner(None)),
            "substance" => Ok(GroupType::Substance(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GroupType {
    fn into(self) -> Option<String> {
        match self {
            GroupType::Animal(_) => Some("animal".to_string()),
            GroupType::Device(_) => Some("device".to_string()),
            GroupType::Medication(_) => Some("medication".to_string()),
            GroupType::Person(_) => Some("person".to_string()),
            GroupType::Practitioner(_) => Some("practitioner".to_string()),
            GroupType::Substance(_) => Some("substance".to_string()),
            GroupType::Null(_) => None,
        }
    }
}
impl MetaValue for GroupType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GroupType::Animal(Some(e)) => e.get_field(field),
                GroupType::Device(Some(e)) => e.get_field(field),
                GroupType::Medication(Some(e)) => e.get_field(field),
                GroupType::Person(Some(e)) => e.get_field(field),
                GroupType::Practitioner(Some(e)) => e.get_field(field),
                GroupType::Substance(Some(e)) => e.get_field(field),
                GroupType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GroupType::Animal(Some(e)) => e.get_field_mut(field),
                GroupType::Device(Some(e)) => e.get_field_mut(field),
                GroupType::Medication(Some(e)) => e.get_field_mut(field),
                GroupType::Person(Some(e)) => e.get_field_mut(field),
                GroupType::Practitioner(Some(e)) => e.get_field_mut(field),
                GroupType::Substance(Some(e)) => e.get_field_mut(field),
                GroupType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GuidanceResponseStatus {
    #[doc = "Data Requested"]
    #[code = "data-requested"]
    DataRequested(Option<Element>),
    #[doc = "Data Required"]
    #[code = "data-required"]
    DataRequired(Option<Element>),
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Failure"]
    #[code = "failure"]
    Failure(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Success"]
    #[code = "success"]
    Success(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GuidanceResponseStatus {
    fn default() -> Self {
        GuidanceResponseStatus::Null(None)
    }
}
impl TryFrom<String> for GuidanceResponseStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "data-requested" => Ok(GuidanceResponseStatus::DataRequested(None)),
            "data-required" => Ok(GuidanceResponseStatus::DataRequired(None)),
            "entered-in-error" => Ok(GuidanceResponseStatus::EnteredInError(None)),
            "failure" => Ok(GuidanceResponseStatus::Failure(None)),
            "in-progress" => Ok(GuidanceResponseStatus::InProgress(None)),
            "success" => Ok(GuidanceResponseStatus::Success(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GuidanceResponseStatus {
    fn into(self) -> Option<String> {
        match self {
            GuidanceResponseStatus::DataRequested(_) => Some("data-requested".to_string()),
            GuidanceResponseStatus::DataRequired(_) => Some("data-required".to_string()),
            GuidanceResponseStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            GuidanceResponseStatus::Failure(_) => Some("failure".to_string()),
            GuidanceResponseStatus::InProgress(_) => Some("in-progress".to_string()),
            GuidanceResponseStatus::Success(_) => Some("success".to_string()),
            GuidanceResponseStatus::Null(_) => None,
        }
    }
}
impl MetaValue for GuidanceResponseStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GuidanceResponseStatus::DataRequested(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::DataRequired(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::EnteredInError(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::Failure(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::InProgress(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::Success(Some(e)) => e.get_field(field),
                GuidanceResponseStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GuidanceResponseStatus::DataRequested(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::DataRequired(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::Failure(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::InProgress(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::Success(Some(e)) => e.get_field_mut(field),
                GuidanceResponseStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GuidePageGeneration {
    #[doc = "Generated"]
    #[code = "generated"]
    Generated(Option<Element>),
    #[doc = "HTML"]
    #[code = "html"]
    Html(Option<Element>),
    #[doc = "Markdown"]
    #[code = "markdown"]
    Markdown(Option<Element>),
    #[doc = "XML"]
    #[code = "xml"]
    Xml(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GuidePageGeneration {
    fn default() -> Self {
        GuidePageGeneration::Null(None)
    }
}
impl TryFrom<String> for GuidePageGeneration {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "generated" => Ok(GuidePageGeneration::Generated(None)),
            "html" => Ok(GuidePageGeneration::Html(None)),
            "markdown" => Ok(GuidePageGeneration::Markdown(None)),
            "xml" => Ok(GuidePageGeneration::Xml(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GuidePageGeneration {
    fn into(self) -> Option<String> {
        match self {
            GuidePageGeneration::Generated(_) => Some("generated".to_string()),
            GuidePageGeneration::Html(_) => Some("html".to_string()),
            GuidePageGeneration::Markdown(_) => Some("markdown".to_string()),
            GuidePageGeneration::Xml(_) => Some("xml".to_string()),
            GuidePageGeneration::Null(_) => None,
        }
    }
}
impl MetaValue for GuidePageGeneration {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GuidePageGeneration::Generated(Some(e)) => e.get_field(field),
                GuidePageGeneration::Html(Some(e)) => e.get_field(field),
                GuidePageGeneration::Markdown(Some(e)) => e.get_field(field),
                GuidePageGeneration::Xml(Some(e)) => e.get_field(field),
                GuidePageGeneration::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GuidePageGeneration::Generated(Some(e)) => e.get_field_mut(field),
                GuidePageGeneration::Html(Some(e)) => e.get_field_mut(field),
                GuidePageGeneration::Markdown(Some(e)) => e.get_field_mut(field),
                GuidePageGeneration::Xml(Some(e)) => e.get_field_mut(field),
                GuidePageGeneration::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum GuideParameterCode {
    #[doc = "Apply Metadata Value"]
    #[code = "apply"]
    Apply(Option<Element>),
    #[doc = "Expansion Profile"]
    #[code = "expansion-parameter"]
    ExpansionParameter(Option<Element>),
    #[doc = "Generate JSON"]
    #[code = "generate-json"]
    GenerateJson(Option<Element>),
    #[doc = "Generate Turtle"]
    #[code = "generate-turtle"]
    GenerateTurtle(Option<Element>),
    #[doc = "Generate XML"]
    #[code = "generate-xml"]
    GenerateXml(Option<Element>),
    #[doc = "HTML Template"]
    #[code = "html-template"]
    HtmlTemplate(Option<Element>),
    #[doc = "Pages Path"]
    #[code = "path-pages"]
    PathPages(Option<Element>),
    #[doc = "Resource Path"]
    #[code = "path-resource"]
    PathResource(Option<Element>),
    #[doc = "Terminology Cache Path"]
    #[code = "path-tx-cache"]
    PathTxCache(Option<Element>),
    #[doc = "Broken Links Rule"]
    #[code = "rule-broken-links"]
    RuleBrokenLinks(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for GuideParameterCode {
    fn default() -> Self {
        GuideParameterCode::Null(None)
    }
}
impl TryFrom<String> for GuideParameterCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "apply" => Ok(GuideParameterCode::Apply(None)),
            "expansion-parameter" => Ok(GuideParameterCode::ExpansionParameter(None)),
            "generate-json" => Ok(GuideParameterCode::GenerateJson(None)),
            "generate-turtle" => Ok(GuideParameterCode::GenerateTurtle(None)),
            "generate-xml" => Ok(GuideParameterCode::GenerateXml(None)),
            "html-template" => Ok(GuideParameterCode::HtmlTemplate(None)),
            "path-pages" => Ok(GuideParameterCode::PathPages(None)),
            "path-resource" => Ok(GuideParameterCode::PathResource(None)),
            "path-tx-cache" => Ok(GuideParameterCode::PathTxCache(None)),
            "rule-broken-links" => Ok(GuideParameterCode::RuleBrokenLinks(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &GuideParameterCode {
    fn into(self) -> Option<String> {
        match self {
            GuideParameterCode::Apply(_) => Some("apply".to_string()),
            GuideParameterCode::ExpansionParameter(_) => Some("expansion-parameter".to_string()),
            GuideParameterCode::GenerateJson(_) => Some("generate-json".to_string()),
            GuideParameterCode::GenerateTurtle(_) => Some("generate-turtle".to_string()),
            GuideParameterCode::GenerateXml(_) => Some("generate-xml".to_string()),
            GuideParameterCode::HtmlTemplate(_) => Some("html-template".to_string()),
            GuideParameterCode::PathPages(_) => Some("path-pages".to_string()),
            GuideParameterCode::PathResource(_) => Some("path-resource".to_string()),
            GuideParameterCode::PathTxCache(_) => Some("path-tx-cache".to_string()),
            GuideParameterCode::RuleBrokenLinks(_) => Some("rule-broken-links".to_string()),
            GuideParameterCode::Null(_) => None,
        }
    }
}
impl MetaValue for GuideParameterCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                GuideParameterCode::Apply(Some(e)) => e.get_field(field),
                GuideParameterCode::ExpansionParameter(Some(e)) => e.get_field(field),
                GuideParameterCode::GenerateJson(Some(e)) => e.get_field(field),
                GuideParameterCode::GenerateTurtle(Some(e)) => e.get_field(field),
                GuideParameterCode::GenerateXml(Some(e)) => e.get_field(field),
                GuideParameterCode::HtmlTemplate(Some(e)) => e.get_field(field),
                GuideParameterCode::PathPages(Some(e)) => e.get_field(field),
                GuideParameterCode::PathResource(Some(e)) => e.get_field(field),
                GuideParameterCode::PathTxCache(Some(e)) => e.get_field(field),
                GuideParameterCode::RuleBrokenLinks(Some(e)) => e.get_field(field),
                GuideParameterCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                GuideParameterCode::Apply(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::ExpansionParameter(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::GenerateJson(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::GenerateTurtle(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::GenerateXml(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::HtmlTemplate(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::PathPages(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::PathResource(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::PathTxCache(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::RuleBrokenLinks(Some(e)) => e.get_field_mut(field),
                GuideParameterCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum HandlingCondition {
    #[doc = "frozen"]
    #[code = "frozen"]
    Frozen(Option<Element>),
    #[doc = "refrigerated"]
    #[code = "refrigerated"]
    Refrigerated(Option<Element>),
    #[doc = "room temperature"]
    #[code = "room"]
    Room(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for HandlingCondition {
    fn default() -> Self {
        HandlingCondition::Null(None)
    }
}
impl TryFrom<String> for HandlingCondition {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "frozen" => Ok(HandlingCondition::Frozen(None)),
            "refrigerated" => Ok(HandlingCondition::Refrigerated(None)),
            "room" => Ok(HandlingCondition::Room(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &HandlingCondition {
    fn into(self) -> Option<String> {
        match self {
            HandlingCondition::Frozen(_) => Some("frozen".to_string()),
            HandlingCondition::Refrigerated(_) => Some("refrigerated".to_string()),
            HandlingCondition::Room(_) => Some("room".to_string()),
            HandlingCondition::Null(_) => None,
        }
    }
}
impl MetaValue for HandlingCondition {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                HandlingCondition::Frozen(Some(e)) => e.get_field(field),
                HandlingCondition::Refrigerated(Some(e)) => e.get_field(field),
                HandlingCondition::Room(Some(e)) => e.get_field(field),
                HandlingCondition::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                HandlingCondition::Frozen(Some(e)) => e.get_field_mut(field),
                HandlingCondition::Refrigerated(Some(e)) => e.get_field_mut(field),
                HandlingCondition::Room(Some(e)) => e.get_field_mut(field),
                HandlingCondition::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum HistoryAbsentReason {
    #[doc = "Deferred"]
    #[code = "deferred"]
    Deferred(Option<Element>),
    #[doc = "Subject Unknown"]
    #[code = "subject-unknown"]
    SubjectUnknown(Option<Element>),
    #[doc = "Unable To Obtain"]
    #[code = "unable-to-obtain"]
    UnableToObtain(Option<Element>),
    #[doc = "Information Withheld"]
    #[code = "withheld"]
    Withheld(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for HistoryAbsentReason {
    fn default() -> Self {
        HistoryAbsentReason::Null(None)
    }
}
impl TryFrom<String> for HistoryAbsentReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "deferred" => Ok(HistoryAbsentReason::Deferred(None)),
            "subject-unknown" => Ok(HistoryAbsentReason::SubjectUnknown(None)),
            "unable-to-obtain" => Ok(HistoryAbsentReason::UnableToObtain(None)),
            "withheld" => Ok(HistoryAbsentReason::Withheld(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &HistoryAbsentReason {
    fn into(self) -> Option<String> {
        match self {
            HistoryAbsentReason::Deferred(_) => Some("deferred".to_string()),
            HistoryAbsentReason::SubjectUnknown(_) => Some("subject-unknown".to_string()),
            HistoryAbsentReason::UnableToObtain(_) => Some("unable-to-obtain".to_string()),
            HistoryAbsentReason::Withheld(_) => Some("withheld".to_string()),
            HistoryAbsentReason::Null(_) => None,
        }
    }
}
impl MetaValue for HistoryAbsentReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                HistoryAbsentReason::Deferred(Some(e)) => e.get_field(field),
                HistoryAbsentReason::SubjectUnknown(Some(e)) => e.get_field(field),
                HistoryAbsentReason::UnableToObtain(Some(e)) => e.get_field(field),
                HistoryAbsentReason::Withheld(Some(e)) => e.get_field(field),
                HistoryAbsentReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                HistoryAbsentReason::Deferred(Some(e)) => e.get_field_mut(field),
                HistoryAbsentReason::SubjectUnknown(Some(e)) => e.get_field_mut(field),
                HistoryAbsentReason::UnableToObtain(Some(e)) => e.get_field_mut(field),
                HistoryAbsentReason::Withheld(Some(e)) => e.get_field_mut(field),
                HistoryAbsentReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum HistoryStatus {
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Health Unknown"]
    #[code = "health-unknown"]
    HealthUnknown(Option<Element>),
    #[doc = "Partial"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for HistoryStatus {
    fn default() -> Self {
        HistoryStatus::Null(None)
    }
}
impl TryFrom<String> for HistoryStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(HistoryStatus::Completed(None)),
            "entered-in-error" => Ok(HistoryStatus::EnteredInError(None)),
            "health-unknown" => Ok(HistoryStatus::HealthUnknown(None)),
            "partial" => Ok(HistoryStatus::Partial(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &HistoryStatus {
    fn into(self) -> Option<String> {
        match self {
            HistoryStatus::Completed(_) => Some("completed".to_string()),
            HistoryStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            HistoryStatus::HealthUnknown(_) => Some("health-unknown".to_string()),
            HistoryStatus::Partial(_) => Some("partial".to_string()),
            HistoryStatus::Null(_) => None,
        }
    }
}
impl MetaValue for HistoryStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                HistoryStatus::Completed(Some(e)) => e.get_field(field),
                HistoryStatus::EnteredInError(Some(e)) => e.get_field(field),
                HistoryStatus::HealthUnknown(Some(e)) => e.get_field(field),
                HistoryStatus::Partial(Some(e)) => e.get_field(field),
                HistoryStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                HistoryStatus::Completed(Some(e)) => e.get_field_mut(field),
                HistoryStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                HistoryStatus::HealthUnknown(Some(e)) => e.get_field_mut(field),
                HistoryStatus::Partial(Some(e)) => e.get_field_mut(field),
                HistoryStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Hl7WorkGroup {
    #[doc = "Application Implementation and Design"]
    #[code = "aid"]
    Aid(Option<Element>),
    #[doc = "Biomedical Research and Regulation"]
    #[code = "brr"]
    Brr(Option<Element>),
    #[doc = "Community Based Collaborative Care"]
    #[code = "cbcc"]
    Cbcc(Option<Element>),
    #[doc = "Clinical Decision Support"]
    #[code = "cds"]
    Cds(Option<Element>),
    #[doc = "Clinical Genomics"]
    #[code = "cg"]
    Cg(Option<Element>),
    #[doc = "Clinical Quality Information"]
    #[code = "cqi"]
    Cqi(Option<Element>),
    #[doc = "Health Care Devices"]
    #[code = "dev"]
    Dev(Option<Element>),
    #[doc = "Electronic Health Records"]
    #[code = "ehr"]
    Ehr(Option<Element>),
    #[doc = "FHIR Infrastructure"]
    #[code = "fhir"]
    Fhir(Option<Element>),
    #[doc = "Financial Management"]
    #[code = "fm"]
    Fm(Option<Element>),
    #[doc = "Health Standards Integration"]
    #[code = "hsi"]
    Hsi(Option<Element>),
    #[doc = "Imaging Integration"]
    #[code = "ii"]
    Ii(Option<Element>),
    #[doc = "Infrastructure And Messaging"]
    #[code = "inm"]
    Inm(Option<Element>),
    #[doc = "Implementable Technology Specifications"]
    #[code = "its"]
    Its(Option<Element>),
    #[doc = "Modeling and Methodology"]
    #[code = "mnm"]
    Mnm(Option<Element>),
    #[doc = "Orders and Observations"]
    #[code = "oo"]
    Oo(Option<Element>),
    #[doc = "Patient Administration"]
    #[code = "pa"]
    Pa(Option<Element>),
    #[doc = "Patient Care"]
    #[code = "pc"]
    Pc(Option<Element>),
    #[doc = "Public Health and Emergency Response"]
    #[code = "pher"]
    Pher(Option<Element>),
    #[doc = "Pharmacy"]
    #[code = "phx"]
    Phx(Option<Element>),
    #[doc = "Structured Documents"]
    #[code = "sd"]
    Sd(Option<Element>),
    #[doc = "Security"]
    #[code = "sec"]
    Sec(Option<Element>),
    #[doc = "US Realm Taskforce"]
    #[code = "us"]
    Us(Option<Element>),
    #[doc = "Vocabulary"]
    #[code = "vocab"]
    Vocab(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Hl7WorkGroup {
    fn default() -> Self {
        Hl7WorkGroup::Null(None)
    }
}
impl TryFrom<String> for Hl7WorkGroup {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aid" => Ok(Hl7WorkGroup::Aid(None)),
            "brr" => Ok(Hl7WorkGroup::Brr(None)),
            "cbcc" => Ok(Hl7WorkGroup::Cbcc(None)),
            "cds" => Ok(Hl7WorkGroup::Cds(None)),
            "cg" => Ok(Hl7WorkGroup::Cg(None)),
            "cqi" => Ok(Hl7WorkGroup::Cqi(None)),
            "dev" => Ok(Hl7WorkGroup::Dev(None)),
            "ehr" => Ok(Hl7WorkGroup::Ehr(None)),
            "fhir" => Ok(Hl7WorkGroup::Fhir(None)),
            "fm" => Ok(Hl7WorkGroup::Fm(None)),
            "hsi" => Ok(Hl7WorkGroup::Hsi(None)),
            "ii" => Ok(Hl7WorkGroup::Ii(None)),
            "inm" => Ok(Hl7WorkGroup::Inm(None)),
            "its" => Ok(Hl7WorkGroup::Its(None)),
            "mnm" => Ok(Hl7WorkGroup::Mnm(None)),
            "oo" => Ok(Hl7WorkGroup::Oo(None)),
            "pa" => Ok(Hl7WorkGroup::Pa(None)),
            "pc" => Ok(Hl7WorkGroup::Pc(None)),
            "pher" => Ok(Hl7WorkGroup::Pher(None)),
            "phx" => Ok(Hl7WorkGroup::Phx(None)),
            "sd" => Ok(Hl7WorkGroup::Sd(None)),
            "sec" => Ok(Hl7WorkGroup::Sec(None)),
            "us" => Ok(Hl7WorkGroup::Us(None)),
            "vocab" => Ok(Hl7WorkGroup::Vocab(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Hl7WorkGroup {
    fn into(self) -> Option<String> {
        match self {
            Hl7WorkGroup::Aid(_) => Some("aid".to_string()),
            Hl7WorkGroup::Brr(_) => Some("brr".to_string()),
            Hl7WorkGroup::Cbcc(_) => Some("cbcc".to_string()),
            Hl7WorkGroup::Cds(_) => Some("cds".to_string()),
            Hl7WorkGroup::Cg(_) => Some("cg".to_string()),
            Hl7WorkGroup::Cqi(_) => Some("cqi".to_string()),
            Hl7WorkGroup::Dev(_) => Some("dev".to_string()),
            Hl7WorkGroup::Ehr(_) => Some("ehr".to_string()),
            Hl7WorkGroup::Fhir(_) => Some("fhir".to_string()),
            Hl7WorkGroup::Fm(_) => Some("fm".to_string()),
            Hl7WorkGroup::Hsi(_) => Some("hsi".to_string()),
            Hl7WorkGroup::Ii(_) => Some("ii".to_string()),
            Hl7WorkGroup::Inm(_) => Some("inm".to_string()),
            Hl7WorkGroup::Its(_) => Some("its".to_string()),
            Hl7WorkGroup::Mnm(_) => Some("mnm".to_string()),
            Hl7WorkGroup::Oo(_) => Some("oo".to_string()),
            Hl7WorkGroup::Pa(_) => Some("pa".to_string()),
            Hl7WorkGroup::Pc(_) => Some("pc".to_string()),
            Hl7WorkGroup::Pher(_) => Some("pher".to_string()),
            Hl7WorkGroup::Phx(_) => Some("phx".to_string()),
            Hl7WorkGroup::Sd(_) => Some("sd".to_string()),
            Hl7WorkGroup::Sec(_) => Some("sec".to_string()),
            Hl7WorkGroup::Us(_) => Some("us".to_string()),
            Hl7WorkGroup::Vocab(_) => Some("vocab".to_string()),
            Hl7WorkGroup::Null(_) => None,
        }
    }
}
impl MetaValue for Hl7WorkGroup {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Hl7WorkGroup::Aid(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Brr(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Cbcc(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Cds(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Cg(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Cqi(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Dev(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Ehr(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Fhir(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Fm(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Hsi(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Ii(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Inm(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Its(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Mnm(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Oo(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Pa(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Pc(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Pher(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Phx(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Sd(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Sec(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Us(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Vocab(Some(e)) => e.get_field(field),
                Hl7WorkGroup::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Hl7WorkGroup::Aid(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Brr(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Cbcc(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Cds(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Cg(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Cqi(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Dev(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Ehr(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Fhir(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Fm(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Hsi(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Ii(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Inm(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Its(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Mnm(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Oo(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Pa(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Pc(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Pher(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Phx(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Sd(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Sec(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Us(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Vocab(Some(e)) => e.get_field_mut(field),
                Hl7WorkGroup::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum HttpOperations {
    #[doc = "DELETE"]
    #[code = "delete"]
    Delete(Option<Element>),
    #[doc = "GET"]
    #[code = "get"]
    Get(Option<Element>),
    #[doc = "HEAD"]
    #[code = "head"]
    Head(Option<Element>),
    #[doc = "OPTIONS"]
    #[code = "options"]
    Options(Option<Element>),
    #[doc = "PATCH"]
    #[code = "patch"]
    Patch(Option<Element>),
    #[doc = "POST"]
    #[code = "post"]
    Post(Option<Element>),
    #[doc = "PUT"]
    #[code = "put"]
    Put(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for HttpOperations {
    fn default() -> Self {
        HttpOperations::Null(None)
    }
}
impl TryFrom<String> for HttpOperations {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "delete" => Ok(HttpOperations::Delete(None)),
            "get" => Ok(HttpOperations::Get(None)),
            "head" => Ok(HttpOperations::Head(None)),
            "options" => Ok(HttpOperations::Options(None)),
            "patch" => Ok(HttpOperations::Patch(None)),
            "post" => Ok(HttpOperations::Post(None)),
            "put" => Ok(HttpOperations::Put(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &HttpOperations {
    fn into(self) -> Option<String> {
        match self {
            HttpOperations::Delete(_) => Some("delete".to_string()),
            HttpOperations::Get(_) => Some("get".to_string()),
            HttpOperations::Head(_) => Some("head".to_string()),
            HttpOperations::Options(_) => Some("options".to_string()),
            HttpOperations::Patch(_) => Some("patch".to_string()),
            HttpOperations::Post(_) => Some("post".to_string()),
            HttpOperations::Put(_) => Some("put".to_string()),
            HttpOperations::Null(_) => None,
        }
    }
}
impl MetaValue for HttpOperations {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                HttpOperations::Delete(Some(e)) => e.get_field(field),
                HttpOperations::Get(Some(e)) => e.get_field(field),
                HttpOperations::Head(Some(e)) => e.get_field(field),
                HttpOperations::Options(Some(e)) => e.get_field(field),
                HttpOperations::Patch(Some(e)) => e.get_field(field),
                HttpOperations::Post(Some(e)) => e.get_field(field),
                HttpOperations::Put(Some(e)) => e.get_field(field),
                HttpOperations::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                HttpOperations::Delete(Some(e)) => e.get_field_mut(field),
                HttpOperations::Get(Some(e)) => e.get_field_mut(field),
                HttpOperations::Head(Some(e)) => e.get_field_mut(field),
                HttpOperations::Options(Some(e)) => e.get_field_mut(field),
                HttpOperations::Patch(Some(e)) => e.get_field_mut(field),
                HttpOperations::Post(Some(e)) => e.get_field_mut(field),
                HttpOperations::Put(Some(e)) => e.get_field_mut(field),
                HttpOperations::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum HttpVerb {
    #[doc = "DELETE"]
    #[code = "DELETE"]
    DELETE(Option<Element>),
    #[doc = "GET"]
    #[code = "GET"]
    GET(Option<Element>),
    #[doc = "HEAD"]
    #[code = "HEAD"]
    HEAD(Option<Element>),
    #[doc = "PATCH"]
    #[code = "PATCH"]
    PATCH(Option<Element>),
    #[doc = "POST"]
    #[code = "POST"]
    POST(Option<Element>),
    #[doc = "PUT"]
    #[code = "PUT"]
    PUT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for HttpVerb {
    fn default() -> Self {
        HttpVerb::Null(None)
    }
}
impl TryFrom<String> for HttpVerb {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DELETE" => Ok(HttpVerb::DELETE(None)),
            "GET" => Ok(HttpVerb::GET(None)),
            "HEAD" => Ok(HttpVerb::HEAD(None)),
            "PATCH" => Ok(HttpVerb::PATCH(None)),
            "POST" => Ok(HttpVerb::POST(None)),
            "PUT" => Ok(HttpVerb::PUT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &HttpVerb {
    fn into(self) -> Option<String> {
        match self {
            HttpVerb::DELETE(_) => Some("DELETE".to_string()),
            HttpVerb::GET(_) => Some("GET".to_string()),
            HttpVerb::HEAD(_) => Some("HEAD".to_string()),
            HttpVerb::PATCH(_) => Some("PATCH".to_string()),
            HttpVerb::POST(_) => Some("POST".to_string()),
            HttpVerb::PUT(_) => Some("PUT".to_string()),
            HttpVerb::Null(_) => None,
        }
    }
}
impl MetaValue for HttpVerb {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                HttpVerb::DELETE(Some(e)) => e.get_field(field),
                HttpVerb::GET(Some(e)) => e.get_field(field),
                HttpVerb::HEAD(Some(e)) => e.get_field(field),
                HttpVerb::PATCH(Some(e)) => e.get_field(field),
                HttpVerb::POST(Some(e)) => e.get_field(field),
                HttpVerb::PUT(Some(e)) => e.get_field(field),
                HttpVerb::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                HttpVerb::DELETE(Some(e)) => e.get_field_mut(field),
                HttpVerb::GET(Some(e)) => e.get_field_mut(field),
                HttpVerb::HEAD(Some(e)) => e.get_field_mut(field),
                HttpVerb::PATCH(Some(e)) => e.get_field_mut(field),
                HttpVerb::POST(Some(e)) => e.get_field_mut(field),
                HttpVerb::PUT(Some(e)) => e.get_field_mut(field),
                HttpVerb::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Icd10 {
    #[doc = "DIAG-4"]
    #[code = "112233"]
    V112233(Option<Element>),
    #[doc = "DIAG-1"]
    #[code = "123456"]
    V123456(Option<Element>),
    #[doc = "DIAG-1a"]
    #[code = "123457"]
    V123457(Option<Element>),
    #[doc = "DIAG-3"]
    #[code = "123987"]
    V123987(Option<Element>),
    #[doc = "DIAG-6"]
    #[code = "321789"]
    V321789(Option<Element>),
    #[doc = "DIAG-2"]
    #[code = "987654"]
    V987654(Option<Element>),
    #[doc = "DIAG-5"]
    #[code = "997755"]
    V997755(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Icd10 {
    fn default() -> Self {
        Icd10::Null(None)
    }
}
impl TryFrom<String> for Icd10 {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "112233" => Ok(Icd10::V112233(None)),
            "123456" => Ok(Icd10::V123456(None)),
            "123457" => Ok(Icd10::V123457(None)),
            "123987" => Ok(Icd10::V123987(None)),
            "321789" => Ok(Icd10::V321789(None)),
            "987654" => Ok(Icd10::V987654(None)),
            "997755" => Ok(Icd10::V997755(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Icd10 {
    fn into(self) -> Option<String> {
        match self {
            Icd10::V112233(_) => Some("112233".to_string()),
            Icd10::V123456(_) => Some("123456".to_string()),
            Icd10::V123457(_) => Some("123457".to_string()),
            Icd10::V123987(_) => Some("123987".to_string()),
            Icd10::V321789(_) => Some("321789".to_string()),
            Icd10::V987654(_) => Some("987654".to_string()),
            Icd10::V997755(_) => Some("997755".to_string()),
            Icd10::Null(_) => None,
        }
    }
}
impl MetaValue for Icd10 {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Icd10::V112233(Some(e)) => e.get_field(field),
                Icd10::V123456(Some(e)) => e.get_field(field),
                Icd10::V123457(Some(e)) => e.get_field(field),
                Icd10::V123987(Some(e)) => e.get_field(field),
                Icd10::V321789(Some(e)) => e.get_field(field),
                Icd10::V987654(Some(e)) => e.get_field(field),
                Icd10::V997755(Some(e)) => e.get_field(field),
                Icd10::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Icd10::V112233(Some(e)) => e.get_field_mut(field),
                Icd10::V123456(Some(e)) => e.get_field_mut(field),
                Icd10::V123457(Some(e)) => e.get_field_mut(field),
                Icd10::V123987(Some(e)) => e.get_field_mut(field),
                Icd10::V321789(Some(e)) => e.get_field_mut(field),
                Icd10::V987654(Some(e)) => e.get_field_mut(field),
                Icd10::V997755(Some(e)) => e.get_field_mut(field),
                Icd10::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Icd10Procedures {
    #[doc = "PROC-1"]
    #[code = "123001"]
    V123001(Option<Element>),
    #[doc = "PROC-2"]
    #[code = "123002"]
    V123002(Option<Element>),
    #[doc = "PROC-3"]
    #[code = "123003"]
    V123003(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Icd10Procedures {
    fn default() -> Self {
        Icd10Procedures::Null(None)
    }
}
impl TryFrom<String> for Icd10Procedures {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "123001" => Ok(Icd10Procedures::V123001(None)),
            "123002" => Ok(Icd10Procedures::V123002(None)),
            "123003" => Ok(Icd10Procedures::V123003(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Icd10Procedures {
    fn into(self) -> Option<String> {
        match self {
            Icd10Procedures::V123001(_) => Some("123001".to_string()),
            Icd10Procedures::V123002(_) => Some("123002".to_string()),
            Icd10Procedures::V123003(_) => Some("123003".to_string()),
            Icd10Procedures::Null(_) => None,
        }
    }
}
impl MetaValue for Icd10Procedures {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Icd10Procedures::V123001(Some(e)) => e.get_field(field),
                Icd10Procedures::V123002(Some(e)) => e.get_field(field),
                Icd10Procedures::V123003(Some(e)) => e.get_field(field),
                Icd10Procedures::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Icd10Procedures::V123001(Some(e)) => e.get_field_mut(field),
                Icd10Procedures::V123002(Some(e)) => e.get_field_mut(field),
                Icd10Procedures::V123003(Some(e)) => e.get_field_mut(field),
                Icd10Procedures::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentifierType {
    #[code = "ACSN"]
    ACSN(Option<Element>),
    #[code = "BRN"]
    BRN(Option<Element>),
    #[code = "DL"]
    DL(Option<Element>),
    #[code = "DR"]
    DR(Option<Element>),
    #[code = "EN"]
    EN(Option<Element>),
    #[code = "FILL"]
    FILL(Option<Element>),
    #[code = "JHN"]
    JHN(Option<Element>),
    #[code = "MCN"]
    MCN(Option<Element>),
    #[code = "MD"]
    MD(Option<Element>),
    #[code = "MR"]
    MR(Option<Element>),
    #[code = "NIIP"]
    NIIP(Option<Element>),
    #[code = "PLAC"]
    PLAC(Option<Element>),
    #[code = "PPN"]
    PPN(Option<Element>),
    #[code = "PRN"]
    PRN(Option<Element>),
    #[code = "SB"]
    SB(Option<Element>),
    #[code = "SNO"]
    SNO(Option<Element>),
    #[code = "TAX"]
    TAX(Option<Element>),
    #[code = "UDI"]
    UDI(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentifierType {
    fn default() -> Self {
        IdentifierType::Null(None)
    }
}
impl TryFrom<String> for IdentifierType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ACSN" => Ok(IdentifierType::ACSN(None)),
            "BRN" => Ok(IdentifierType::BRN(None)),
            "DL" => Ok(IdentifierType::DL(None)),
            "DR" => Ok(IdentifierType::DR(None)),
            "EN" => Ok(IdentifierType::EN(None)),
            "FILL" => Ok(IdentifierType::FILL(None)),
            "JHN" => Ok(IdentifierType::JHN(None)),
            "MCN" => Ok(IdentifierType::MCN(None)),
            "MD" => Ok(IdentifierType::MD(None)),
            "MR" => Ok(IdentifierType::MR(None)),
            "NIIP" => Ok(IdentifierType::NIIP(None)),
            "PLAC" => Ok(IdentifierType::PLAC(None)),
            "PPN" => Ok(IdentifierType::PPN(None)),
            "PRN" => Ok(IdentifierType::PRN(None)),
            "SB" => Ok(IdentifierType::SB(None)),
            "SNO" => Ok(IdentifierType::SNO(None)),
            "TAX" => Ok(IdentifierType::TAX(None)),
            "UDI" => Ok(IdentifierType::UDI(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentifierType {
    fn into(self) -> Option<String> {
        match self {
            IdentifierType::ACSN(_) => Some("ACSN".to_string()),
            IdentifierType::BRN(_) => Some("BRN".to_string()),
            IdentifierType::DL(_) => Some("DL".to_string()),
            IdentifierType::DR(_) => Some("DR".to_string()),
            IdentifierType::EN(_) => Some("EN".to_string()),
            IdentifierType::FILL(_) => Some("FILL".to_string()),
            IdentifierType::JHN(_) => Some("JHN".to_string()),
            IdentifierType::MCN(_) => Some("MCN".to_string()),
            IdentifierType::MD(_) => Some("MD".to_string()),
            IdentifierType::MR(_) => Some("MR".to_string()),
            IdentifierType::NIIP(_) => Some("NIIP".to_string()),
            IdentifierType::PLAC(_) => Some("PLAC".to_string()),
            IdentifierType::PPN(_) => Some("PPN".to_string()),
            IdentifierType::PRN(_) => Some("PRN".to_string()),
            IdentifierType::SB(_) => Some("SB".to_string()),
            IdentifierType::SNO(_) => Some("SNO".to_string()),
            IdentifierType::TAX(_) => Some("TAX".to_string()),
            IdentifierType::UDI(_) => Some("UDI".to_string()),
            IdentifierType::Null(_) => None,
        }
    }
}
impl MetaValue for IdentifierType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentifierType::ACSN(Some(e)) => e.get_field(field),
                IdentifierType::BRN(Some(e)) => e.get_field(field),
                IdentifierType::DL(Some(e)) => e.get_field(field),
                IdentifierType::DR(Some(e)) => e.get_field(field),
                IdentifierType::EN(Some(e)) => e.get_field(field),
                IdentifierType::FILL(Some(e)) => e.get_field(field),
                IdentifierType::JHN(Some(e)) => e.get_field(field),
                IdentifierType::MCN(Some(e)) => e.get_field(field),
                IdentifierType::MD(Some(e)) => e.get_field(field),
                IdentifierType::MR(Some(e)) => e.get_field(field),
                IdentifierType::NIIP(Some(e)) => e.get_field(field),
                IdentifierType::PLAC(Some(e)) => e.get_field(field),
                IdentifierType::PPN(Some(e)) => e.get_field(field),
                IdentifierType::PRN(Some(e)) => e.get_field(field),
                IdentifierType::SB(Some(e)) => e.get_field(field),
                IdentifierType::SNO(Some(e)) => e.get_field(field),
                IdentifierType::TAX(Some(e)) => e.get_field(field),
                IdentifierType::UDI(Some(e)) => e.get_field(field),
                IdentifierType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentifierType::ACSN(Some(e)) => e.get_field_mut(field),
                IdentifierType::BRN(Some(e)) => e.get_field_mut(field),
                IdentifierType::DL(Some(e)) => e.get_field_mut(field),
                IdentifierType::DR(Some(e)) => e.get_field_mut(field),
                IdentifierType::EN(Some(e)) => e.get_field_mut(field),
                IdentifierType::FILL(Some(e)) => e.get_field_mut(field),
                IdentifierType::JHN(Some(e)) => e.get_field_mut(field),
                IdentifierType::MCN(Some(e)) => e.get_field_mut(field),
                IdentifierType::MD(Some(e)) => e.get_field_mut(field),
                IdentifierType::MR(Some(e)) => e.get_field_mut(field),
                IdentifierType::NIIP(Some(e)) => e.get_field_mut(field),
                IdentifierType::PLAC(Some(e)) => e.get_field_mut(field),
                IdentifierType::PPN(Some(e)) => e.get_field_mut(field),
                IdentifierType::PRN(Some(e)) => e.get_field_mut(field),
                IdentifierType::SB(Some(e)) => e.get_field_mut(field),
                IdentifierType::SNO(Some(e)) => e.get_field_mut(field),
                IdentifierType::TAX(Some(e)) => e.get_field_mut(field),
                IdentifierType::UDI(Some(e)) => e.get_field_mut(field),
                IdentifierType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentifierUse {
    #[doc = "Official"]
    #[code = "official"]
    Official(Option<Element>),
    #[doc = "Old"]
    #[code = "old"]
    Old(Option<Element>),
    #[doc = "Secondary"]
    #[code = "secondary"]
    Secondary(Option<Element>),
    #[doc = "Temp"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "Usual"]
    #[code = "usual"]
    Usual(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentifierUse {
    fn default() -> Self {
        IdentifierUse::Null(None)
    }
}
impl TryFrom<String> for IdentifierUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "official" => Ok(IdentifierUse::Official(None)),
            "old" => Ok(IdentifierUse::Old(None)),
            "secondary" => Ok(IdentifierUse::Secondary(None)),
            "temp" => Ok(IdentifierUse::Temp(None)),
            "usual" => Ok(IdentifierUse::Usual(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentifierUse {
    fn into(self) -> Option<String> {
        match self {
            IdentifierUse::Official(_) => Some("official".to_string()),
            IdentifierUse::Old(_) => Some("old".to_string()),
            IdentifierUse::Secondary(_) => Some("secondary".to_string()),
            IdentifierUse::Temp(_) => Some("temp".to_string()),
            IdentifierUse::Usual(_) => Some("usual".to_string()),
            IdentifierUse::Null(_) => None,
        }
    }
}
impl MetaValue for IdentifierUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentifierUse::Official(Some(e)) => e.get_field(field),
                IdentifierUse::Old(Some(e)) => e.get_field(field),
                IdentifierUse::Secondary(Some(e)) => e.get_field(field),
                IdentifierUse::Temp(Some(e)) => e.get_field(field),
                IdentifierUse::Usual(Some(e)) => e.get_field(field),
                IdentifierUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentifierUse::Official(Some(e)) => e.get_field_mut(field),
                IdentifierUse::Old(Some(e)) => e.get_field_mut(field),
                IdentifierUse::Secondary(Some(e)) => e.get_field_mut(field),
                IdentifierUse::Temp(Some(e)) => e.get_field_mut(field),
                IdentifierUse::Usual(Some(e)) => e.get_field_mut(field),
                IdentifierUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentityAssuranceLevel {
    #[doc = "Level 1"]
    #[code = "level1"]
    Level1(Option<Element>),
    #[doc = "Level 2"]
    #[code = "level2"]
    Level2(Option<Element>),
    #[doc = "Level 3"]
    #[code = "level3"]
    Level3(Option<Element>),
    #[doc = "Level 4"]
    #[code = "level4"]
    Level4(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentityAssuranceLevel {
    fn default() -> Self {
        IdentityAssuranceLevel::Null(None)
    }
}
impl TryFrom<String> for IdentityAssuranceLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "level1" => Ok(IdentityAssuranceLevel::Level1(None)),
            "level2" => Ok(IdentityAssuranceLevel::Level2(None)),
            "level3" => Ok(IdentityAssuranceLevel::Level3(None)),
            "level4" => Ok(IdentityAssuranceLevel::Level4(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentityAssuranceLevel {
    fn into(self) -> Option<String> {
        match self {
            IdentityAssuranceLevel::Level1(_) => Some("level1".to_string()),
            IdentityAssuranceLevel::Level2(_) => Some("level2".to_string()),
            IdentityAssuranceLevel::Level3(_) => Some("level3".to_string()),
            IdentityAssuranceLevel::Level4(_) => Some("level4".to_string()),
            IdentityAssuranceLevel::Null(_) => None,
        }
    }
}
impl MetaValue for IdentityAssuranceLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentityAssuranceLevel::Level1(Some(e)) => e.get_field(field),
                IdentityAssuranceLevel::Level2(Some(e)) => e.get_field(field),
                IdentityAssuranceLevel::Level3(Some(e)) => e.get_field(field),
                IdentityAssuranceLevel::Level4(Some(e)) => e.get_field(field),
                IdentityAssuranceLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentityAssuranceLevel::Level1(Some(e)) => e.get_field_mut(field),
                IdentityAssuranceLevel::Level2(Some(e)) => e.get_field_mut(field),
                IdentityAssuranceLevel::Level3(Some(e)) => e.get_field_mut(field),
                IdentityAssuranceLevel::Level4(Some(e)) => e.get_field_mut(field),
                IdentityAssuranceLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImagingstudyStatus {
    #[doc = "Available"]
    #[code = "available"]
    Available(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Registered"]
    #[code = "registered"]
    Registered(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImagingstudyStatus {
    fn default() -> Self {
        ImagingstudyStatus::Null(None)
    }
}
impl TryFrom<String> for ImagingstudyStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "available" => Ok(ImagingstudyStatus::Available(None)),
            "cancelled" => Ok(ImagingstudyStatus::Cancelled(None)),
            "entered-in-error" => Ok(ImagingstudyStatus::EnteredInError(None)),
            "registered" => Ok(ImagingstudyStatus::Registered(None)),
            "unknown" => Ok(ImagingstudyStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImagingstudyStatus {
    fn into(self) -> Option<String> {
        match self {
            ImagingstudyStatus::Available(_) => Some("available".to_string()),
            ImagingstudyStatus::Cancelled(_) => Some("cancelled".to_string()),
            ImagingstudyStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ImagingstudyStatus::Registered(_) => Some("registered".to_string()),
            ImagingstudyStatus::Unknown(_) => Some("unknown".to_string()),
            ImagingstudyStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImagingstudyStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImagingstudyStatus::Available(Some(e)) => e.get_field(field),
                ImagingstudyStatus::Cancelled(Some(e)) => e.get_field(field),
                ImagingstudyStatus::EnteredInError(Some(e)) => e.get_field(field),
                ImagingstudyStatus::Registered(Some(e)) => e.get_field(field),
                ImagingstudyStatus::Unknown(Some(e)) => e.get_field(field),
                ImagingstudyStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImagingstudyStatus::Available(Some(e)) => e.get_field_mut(field),
                ImagingstudyStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                ImagingstudyStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ImagingstudyStatus::Registered(Some(e)) => e.get_field_mut(field),
                ImagingstudyStatus::Unknown(Some(e)) => e.get_field_mut(field),
                ImagingstudyStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationEvaluationDoseStatus {
    #[doc = "Not valid"]
    #[code = "notvalid"]
    Notvalid(Option<Element>),
    #[doc = "Valid"]
    #[code = "valid"]
    Valid(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationEvaluationDoseStatus {
    fn default() -> Self {
        ImmunizationEvaluationDoseStatus::Null(None)
    }
}
impl TryFrom<String> for ImmunizationEvaluationDoseStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "notvalid" => Ok(ImmunizationEvaluationDoseStatus::Notvalid(None)),
            "valid" => Ok(ImmunizationEvaluationDoseStatus::Valid(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationEvaluationDoseStatus {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationEvaluationDoseStatus::Notvalid(_) => Some("notvalid".to_string()),
            ImmunizationEvaluationDoseStatus::Valid(_) => Some("valid".to_string()),
            ImmunizationEvaluationDoseStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationEvaluationDoseStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationEvaluationDoseStatus::Notvalid(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatus::Valid(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationEvaluationDoseStatus::Notvalid(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationDoseStatus::Valid(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationDoseStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationEvaluationDoseStatusReason {
    #[doc = "Adverse storage condition"]
    #[code = "advstorage"]
    Advstorage(Option<Element>),
    #[doc = "Cold chain break"]
    #[code = "coldchbrk"]
    Coldchbrk(Option<Element>),
    #[doc = "Expired lot"]
    #[code = "explot"]
    Explot(Option<Element>),
    #[doc = "Administered outside recommended schedule"]
    #[code = "outsidesched"]
    Outsidesched(Option<Element>),
    #[doc = "Product recall"]
    #[code = "prodrecall"]
    Prodrecall(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationEvaluationDoseStatusReason {
    fn default() -> Self {
        ImmunizationEvaluationDoseStatusReason::Null(None)
    }
}
impl TryFrom<String> for ImmunizationEvaluationDoseStatusReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "advstorage" => Ok(ImmunizationEvaluationDoseStatusReason::Advstorage(None)),
            "coldchbrk" => Ok(ImmunizationEvaluationDoseStatusReason::Coldchbrk(None)),
            "explot" => Ok(ImmunizationEvaluationDoseStatusReason::Explot(None)),
            "outsidesched" => Ok(ImmunizationEvaluationDoseStatusReason::Outsidesched(None)),
            "prodrecall" => Ok(ImmunizationEvaluationDoseStatusReason::Prodrecall(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationEvaluationDoseStatusReason {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationEvaluationDoseStatusReason::Advstorage(_) => Some("advstorage".to_string()),
            ImmunizationEvaluationDoseStatusReason::Coldchbrk(_) => Some("coldchbrk".to_string()),
            ImmunizationEvaluationDoseStatusReason::Explot(_) => Some("explot".to_string()),
            ImmunizationEvaluationDoseStatusReason::Outsidesched(_) => {
                Some("outsidesched".to_string())
            }
            ImmunizationEvaluationDoseStatusReason::Prodrecall(_) => Some("prodrecall".to_string()),
            ImmunizationEvaluationDoseStatusReason::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationEvaluationDoseStatusReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationEvaluationDoseStatusReason::Advstorage(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatusReason::Coldchbrk(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatusReason::Explot(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatusReason::Outsidesched(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatusReason::Prodrecall(Some(e)) => e.get_field(field),
                ImmunizationEvaluationDoseStatusReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationEvaluationDoseStatusReason::Advstorage(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationEvaluationDoseStatusReason::Coldchbrk(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationEvaluationDoseStatusReason::Explot(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationDoseStatusReason::Outsidesched(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationEvaluationDoseStatusReason::Prodrecall(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationEvaluationDoseStatusReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationEvaluationStatus {
    #[code = "completed"]
    Completed(Option<Element>),
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationEvaluationStatus {
    fn default() -> Self {
        ImmunizationEvaluationStatus::Null(None)
    }
}
impl TryFrom<String> for ImmunizationEvaluationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(ImmunizationEvaluationStatus::Completed(None)),
            "entered-in-error" => Ok(ImmunizationEvaluationStatus::EnteredInError(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationEvaluationStatus {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationEvaluationStatus::Completed(_) => Some("completed".to_string()),
            ImmunizationEvaluationStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ImmunizationEvaluationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationEvaluationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationEvaluationStatus::Completed(Some(e)) => e.get_field(field),
                ImmunizationEvaluationStatus::EnteredInError(Some(e)) => e.get_field(field),
                ImmunizationEvaluationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationEvaluationStatus::Completed(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationEvaluationTargetDisease {
    #[code = "14189004"]
    V14189004(Option<Element>),
    #[code = "1857005"]
    V1857005(Option<Element>),
    #[code = "27836007"]
    V27836007(Option<Element>),
    #[code = "36653000"]
    V36653000(Option<Element>),
    #[code = "36989005"]
    V36989005(Option<Element>),
    #[code = "397430003"]
    V397430003(Option<Element>),
    #[code = "398102009"]
    V398102009(Option<Element>),
    #[code = "709410003"]
    V709410003(Option<Element>),
    #[code = "76902006"]
    V76902006(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationEvaluationTargetDisease {
    fn default() -> Self {
        ImmunizationEvaluationTargetDisease::Null(None)
    }
}
impl TryFrom<String> for ImmunizationEvaluationTargetDisease {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "14189004" => Ok(ImmunizationEvaluationTargetDisease::V14189004(None)),
            "1857005" => Ok(ImmunizationEvaluationTargetDisease::V1857005(None)),
            "27836007" => Ok(ImmunizationEvaluationTargetDisease::V27836007(None)),
            "36653000" => Ok(ImmunizationEvaluationTargetDisease::V36653000(None)),
            "36989005" => Ok(ImmunizationEvaluationTargetDisease::V36989005(None)),
            "397430003" => Ok(ImmunizationEvaluationTargetDisease::V397430003(None)),
            "398102009" => Ok(ImmunizationEvaluationTargetDisease::V398102009(None)),
            "709410003" => Ok(ImmunizationEvaluationTargetDisease::V709410003(None)),
            "76902006" => Ok(ImmunizationEvaluationTargetDisease::V76902006(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationEvaluationTargetDisease {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationEvaluationTargetDisease::V14189004(_) => Some("14189004".to_string()),
            ImmunizationEvaluationTargetDisease::V1857005(_) => Some("1857005".to_string()),
            ImmunizationEvaluationTargetDisease::V27836007(_) => Some("27836007".to_string()),
            ImmunizationEvaluationTargetDisease::V36653000(_) => Some("36653000".to_string()),
            ImmunizationEvaluationTargetDisease::V36989005(_) => Some("36989005".to_string()),
            ImmunizationEvaluationTargetDisease::V397430003(_) => Some("397430003".to_string()),
            ImmunizationEvaluationTargetDisease::V398102009(_) => Some("398102009".to_string()),
            ImmunizationEvaluationTargetDisease::V709410003(_) => Some("709410003".to_string()),
            ImmunizationEvaluationTargetDisease::V76902006(_) => Some("76902006".to_string()),
            ImmunizationEvaluationTargetDisease::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationEvaluationTargetDisease {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationEvaluationTargetDisease::V14189004(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V1857005(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V27836007(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V36653000(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V36989005(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V397430003(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V398102009(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V709410003(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::V76902006(Some(e)) => e.get_field(field),
                ImmunizationEvaluationTargetDisease::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationEvaluationTargetDisease::V14189004(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V1857005(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V27836007(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V36653000(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V36989005(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V397430003(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V398102009(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V709410003(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::V76902006(Some(e)) => e.get_field_mut(field),
                ImmunizationEvaluationTargetDisease::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationFunction {
    #[code = "AP"]
    AP(Option<Element>),
    #[code = "OP"]
    OP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationFunction {
    fn default() -> Self {
        ImmunizationFunction::Null(None)
    }
}
impl TryFrom<String> for ImmunizationFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AP" => Ok(ImmunizationFunction::AP(None)),
            "OP" => Ok(ImmunizationFunction::OP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationFunction {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationFunction::AP(_) => Some("AP".to_string()),
            ImmunizationFunction::OP(_) => Some("OP".to_string()),
            ImmunizationFunction::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationFunction::AP(Some(e)) => e.get_field(field),
                ImmunizationFunction::OP(Some(e)) => e.get_field(field),
                ImmunizationFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationFunction::AP(Some(e)) => e.get_field_mut(field),
                ImmunizationFunction::OP(Some(e)) => e.get_field_mut(field),
                ImmunizationFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationFundingSource {
    #[doc = "Private"]
    #[code = "private"]
    Private(Option<Element>),
    #[doc = "Public"]
    #[code = "public"]
    Public(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationFundingSource {
    fn default() -> Self {
        ImmunizationFundingSource::Null(None)
    }
}
impl TryFrom<String> for ImmunizationFundingSource {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "private" => Ok(ImmunizationFundingSource::Private(None)),
            "public" => Ok(ImmunizationFundingSource::Public(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationFundingSource {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationFundingSource::Private(_) => Some("private".to_string()),
            ImmunizationFundingSource::Public(_) => Some("public".to_string()),
            ImmunizationFundingSource::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationFundingSource {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationFundingSource::Private(Some(e)) => e.get_field(field),
                ImmunizationFundingSource::Public(Some(e)) => e.get_field(field),
                ImmunizationFundingSource::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationFundingSource::Private(Some(e)) => e.get_field_mut(field),
                ImmunizationFundingSource::Public(Some(e)) => e.get_field_mut(field),
                ImmunizationFundingSource::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationOrigin {
    #[doc = "Other Provider"]
    #[code = "provider"]
    Provider(Option<Element>),
    #[doc = "Parent/Guardian/Patient Recall"]
    #[code = "recall"]
    Recall(Option<Element>),
    #[doc = "Written Record"]
    #[code = "record"]
    Record(Option<Element>),
    #[doc = "School Record"]
    #[code = "school"]
    School(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationOrigin {
    fn default() -> Self {
        ImmunizationOrigin::Null(None)
    }
}
impl TryFrom<String> for ImmunizationOrigin {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "provider" => Ok(ImmunizationOrigin::Provider(None)),
            "recall" => Ok(ImmunizationOrigin::Recall(None)),
            "record" => Ok(ImmunizationOrigin::Record(None)),
            "school" => Ok(ImmunizationOrigin::School(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationOrigin {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationOrigin::Provider(_) => Some("provider".to_string()),
            ImmunizationOrigin::Recall(_) => Some("recall".to_string()),
            ImmunizationOrigin::Record(_) => Some("record".to_string()),
            ImmunizationOrigin::School(_) => Some("school".to_string()),
            ImmunizationOrigin::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationOrigin {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationOrigin::Provider(Some(e)) => e.get_field(field),
                ImmunizationOrigin::Recall(Some(e)) => e.get_field(field),
                ImmunizationOrigin::Record(Some(e)) => e.get_field(field),
                ImmunizationOrigin::School(Some(e)) => e.get_field(field),
                ImmunizationOrigin::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationOrigin::Provider(Some(e)) => e.get_field_mut(field),
                ImmunizationOrigin::Recall(Some(e)) => e.get_field_mut(field),
                ImmunizationOrigin::Record(Some(e)) => e.get_field_mut(field),
                ImmunizationOrigin::School(Some(e)) => e.get_field_mut(field),
                ImmunizationOrigin::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationProgramEligibility {
    #[doc = "Not Eligible"]
    #[code = "ineligible"]
    Ineligible(Option<Element>),
    #[doc = "Uninsured"]
    #[code = "uninsured"]
    Uninsured(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationProgramEligibility {
    fn default() -> Self {
        ImmunizationProgramEligibility::Null(None)
    }
}
impl TryFrom<String> for ImmunizationProgramEligibility {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ineligible" => Ok(ImmunizationProgramEligibility::Ineligible(None)),
            "uninsured" => Ok(ImmunizationProgramEligibility::Uninsured(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationProgramEligibility {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationProgramEligibility::Ineligible(_) => Some("ineligible".to_string()),
            ImmunizationProgramEligibility::Uninsured(_) => Some("uninsured".to_string()),
            ImmunizationProgramEligibility::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationProgramEligibility {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationProgramEligibility::Ineligible(Some(e)) => e.get_field(field),
                ImmunizationProgramEligibility::Uninsured(Some(e)) => e.get_field(field),
                ImmunizationProgramEligibility::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationProgramEligibility::Ineligible(Some(e)) => e.get_field_mut(field),
                ImmunizationProgramEligibility::Uninsured(Some(e)) => e.get_field_mut(field),
                ImmunizationProgramEligibility::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationReason {
    #[code = "281657000"]
    V281657000(Option<Element>),
    #[code = "429060002"]
    V429060002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationReason {
    fn default() -> Self {
        ImmunizationReason::Null(None)
    }
}
impl TryFrom<String> for ImmunizationReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "281657000" => Ok(ImmunizationReason::V281657000(None)),
            "429060002" => Ok(ImmunizationReason::V429060002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationReason {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationReason::V281657000(_) => Some("281657000".to_string()),
            ImmunizationReason::V429060002(_) => Some("429060002".to_string()),
            ImmunizationReason::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationReason::V281657000(Some(e)) => e.get_field(field),
                ImmunizationReason::V429060002(Some(e)) => e.get_field(field),
                ImmunizationReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationReason::V281657000(Some(e)) => e.get_field_mut(field),
                ImmunizationReason::V429060002(Some(e)) => e.get_field_mut(field),
                ImmunizationReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationRecommendationDateCriterion {
    #[code = "30980-7"]
    V309807(Option<Element>),
    #[code = "30981-5"]
    V309815(Option<Element>),
    #[code = "59777-3"]
    V597773(Option<Element>),
    #[code = "59778-1"]
    V597781(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationRecommendationDateCriterion {
    fn default() -> Self {
        ImmunizationRecommendationDateCriterion::Null(None)
    }
}
impl TryFrom<String> for ImmunizationRecommendationDateCriterion {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "30980-7" => Ok(ImmunizationRecommendationDateCriterion::V309807(None)),
            "30981-5" => Ok(ImmunizationRecommendationDateCriterion::V309815(None)),
            "59777-3" => Ok(ImmunizationRecommendationDateCriterion::V597773(None)),
            "59778-1" => Ok(ImmunizationRecommendationDateCriterion::V597781(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationRecommendationDateCriterion {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationRecommendationDateCriterion::V309807(_) => Some("30980-7".to_string()),
            ImmunizationRecommendationDateCriterion::V309815(_) => Some("30981-5".to_string()),
            ImmunizationRecommendationDateCriterion::V597773(_) => Some("59777-3".to_string()),
            ImmunizationRecommendationDateCriterion::V597781(_) => Some("59778-1".to_string()),
            ImmunizationRecommendationDateCriterion::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationRecommendationDateCriterion {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationRecommendationDateCriterion::V309807(Some(e)) => e.get_field(field),
                ImmunizationRecommendationDateCriterion::V309815(Some(e)) => e.get_field(field),
                ImmunizationRecommendationDateCriterion::V597773(Some(e)) => e.get_field(field),
                ImmunizationRecommendationDateCriterion::V597781(Some(e)) => e.get_field(field),
                ImmunizationRecommendationDateCriterion::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationRecommendationDateCriterion::V309807(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationDateCriterion::V309815(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationDateCriterion::V597773(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationDateCriterion::V597781(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationDateCriterion::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationRecommendationReason {
    #[code = "77176002"]
    V77176002(Option<Element>),
    #[code = "77386006"]
    V77386006(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationRecommendationReason {
    fn default() -> Self {
        ImmunizationRecommendationReason::Null(None)
    }
}
impl TryFrom<String> for ImmunizationRecommendationReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "77176002" => Ok(ImmunizationRecommendationReason::V77176002(None)),
            "77386006" => Ok(ImmunizationRecommendationReason::V77386006(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationRecommendationReason {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationRecommendationReason::V77176002(_) => Some("77176002".to_string()),
            ImmunizationRecommendationReason::V77386006(_) => Some("77386006".to_string()),
            ImmunizationRecommendationReason::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationRecommendationReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationRecommendationReason::V77176002(Some(e)) => e.get_field(field),
                ImmunizationRecommendationReason::V77386006(Some(e)) => e.get_field(field),
                ImmunizationRecommendationReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationRecommendationReason::V77176002(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationReason::V77386006(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationRecommendationStatus {
    #[doc = "Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "Contraindicated"]
    #[code = "contraindicated"]
    Contraindicated(Option<Element>),
    #[doc = "Due"]
    #[code = "due"]
    Due(Option<Element>),
    #[doc = "Immune"]
    #[code = "immune"]
    Immune(Option<Element>),
    #[doc = "Overdue"]
    #[code = "overdue"]
    Overdue(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationRecommendationStatus {
    fn default() -> Self {
        ImmunizationRecommendationStatus::Null(None)
    }
}
impl TryFrom<String> for ImmunizationRecommendationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(ImmunizationRecommendationStatus::Complete(None)),
            "contraindicated" => Ok(ImmunizationRecommendationStatus::Contraindicated(None)),
            "due" => Ok(ImmunizationRecommendationStatus::Due(None)),
            "immune" => Ok(ImmunizationRecommendationStatus::Immune(None)),
            "overdue" => Ok(ImmunizationRecommendationStatus::Overdue(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationRecommendationStatus {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationRecommendationStatus::Complete(_) => Some("complete".to_string()),
            ImmunizationRecommendationStatus::Contraindicated(_) => {
                Some("contraindicated".to_string())
            }
            ImmunizationRecommendationStatus::Due(_) => Some("due".to_string()),
            ImmunizationRecommendationStatus::Immune(_) => Some("immune".to_string()),
            ImmunizationRecommendationStatus::Overdue(_) => Some("overdue".to_string()),
            ImmunizationRecommendationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationRecommendationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationRecommendationStatus::Complete(Some(e)) => e.get_field(field),
                ImmunizationRecommendationStatus::Contraindicated(Some(e)) => e.get_field(field),
                ImmunizationRecommendationStatus::Due(Some(e)) => e.get_field(field),
                ImmunizationRecommendationStatus::Immune(Some(e)) => e.get_field(field),
                ImmunizationRecommendationStatus::Overdue(Some(e)) => e.get_field(field),
                ImmunizationRecommendationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationRecommendationStatus::Complete(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationStatus::Contraindicated(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationStatus::Due(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationStatus::Immune(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationStatus::Overdue(Some(e)) => e.get_field_mut(field),
                ImmunizationRecommendationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationRecommendationTargetDisease {
    #[code = "14189004"]
    V14189004(Option<Element>),
    #[code = "1857005"]
    V1857005(Option<Element>),
    #[code = "27836007"]
    V27836007(Option<Element>),
    #[code = "36653000"]
    V36653000(Option<Element>),
    #[code = "36989005"]
    V36989005(Option<Element>),
    #[code = "397430003"]
    V397430003(Option<Element>),
    #[code = "398102009"]
    V398102009(Option<Element>),
    #[code = "709410003"]
    V709410003(Option<Element>),
    #[code = "76902006"]
    V76902006(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationRecommendationTargetDisease {
    fn default() -> Self {
        ImmunizationRecommendationTargetDisease::Null(None)
    }
}
impl TryFrom<String> for ImmunizationRecommendationTargetDisease {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "14189004" => Ok(ImmunizationRecommendationTargetDisease::V14189004(None)),
            "1857005" => Ok(ImmunizationRecommendationTargetDisease::V1857005(None)),
            "27836007" => Ok(ImmunizationRecommendationTargetDisease::V27836007(None)),
            "36653000" => Ok(ImmunizationRecommendationTargetDisease::V36653000(None)),
            "36989005" => Ok(ImmunizationRecommendationTargetDisease::V36989005(None)),
            "397430003" => Ok(ImmunizationRecommendationTargetDisease::V397430003(None)),
            "398102009" => Ok(ImmunizationRecommendationTargetDisease::V398102009(None)),
            "709410003" => Ok(ImmunizationRecommendationTargetDisease::V709410003(None)),
            "76902006" => Ok(ImmunizationRecommendationTargetDisease::V76902006(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationRecommendationTargetDisease {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationRecommendationTargetDisease::V14189004(_) => Some("14189004".to_string()),
            ImmunizationRecommendationTargetDisease::V1857005(_) => Some("1857005".to_string()),
            ImmunizationRecommendationTargetDisease::V27836007(_) => Some("27836007".to_string()),
            ImmunizationRecommendationTargetDisease::V36653000(_) => Some("36653000".to_string()),
            ImmunizationRecommendationTargetDisease::V36989005(_) => Some("36989005".to_string()),
            ImmunizationRecommendationTargetDisease::V397430003(_) => Some("397430003".to_string()),
            ImmunizationRecommendationTargetDisease::V398102009(_) => Some("398102009".to_string()),
            ImmunizationRecommendationTargetDisease::V709410003(_) => Some("709410003".to_string()),
            ImmunizationRecommendationTargetDisease::V76902006(_) => Some("76902006".to_string()),
            ImmunizationRecommendationTargetDisease::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationRecommendationTargetDisease {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationRecommendationTargetDisease::V14189004(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V1857005(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V27836007(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V36653000(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V36989005(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V397430003(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V398102009(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V709410003(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::V76902006(Some(e)) => e.get_field(field),
                ImmunizationRecommendationTargetDisease::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationRecommendationTargetDisease::V14189004(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V1857005(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V27836007(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V36653000(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V36989005(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V397430003(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V398102009(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V709410003(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::V76902006(Some(e)) => {
                    e.get_field_mut(field)
                }
                ImmunizationRecommendationTargetDisease::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationRoute {
    #[doc = "Injection, intradermal"]
    #[code = "IDINJ"]
    IDINJ(Option<Element>),
    #[doc = "Injection, intramuscular"]
    #[code = "IM"]
    IM(Option<Element>),
    #[doc = "Injection, intravenous"]
    #[code = "IVINJ"]
    IVINJ(Option<Element>),
    #[doc = "Inhalation, nasal"]
    #[code = "NASINHLC"]
    NASINHLC(Option<Element>),
    #[doc = "Swallow, oral"]
    #[code = "PO"]
    PO(Option<Element>),
    #[doc = "Injection, subcutaneous"]
    #[code = "SQ"]
    SQ(Option<Element>),
    #[doc = "Transdermal"]
    #[code = "TRNSDERM"]
    TRNSDERM(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationRoute {
    fn default() -> Self {
        ImmunizationRoute::Null(None)
    }
}
impl TryFrom<String> for ImmunizationRoute {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "IDINJ" => Ok(ImmunizationRoute::IDINJ(None)),
            "IM" => Ok(ImmunizationRoute::IM(None)),
            "IVINJ" => Ok(ImmunizationRoute::IVINJ(None)),
            "NASINHLC" => Ok(ImmunizationRoute::NASINHLC(None)),
            "PO" => Ok(ImmunizationRoute::PO(None)),
            "SQ" => Ok(ImmunizationRoute::SQ(None)),
            "TRNSDERM" => Ok(ImmunizationRoute::TRNSDERM(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationRoute {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationRoute::IDINJ(_) => Some("IDINJ".to_string()),
            ImmunizationRoute::IM(_) => Some("IM".to_string()),
            ImmunizationRoute::IVINJ(_) => Some("IVINJ".to_string()),
            ImmunizationRoute::NASINHLC(_) => Some("NASINHLC".to_string()),
            ImmunizationRoute::PO(_) => Some("PO".to_string()),
            ImmunizationRoute::SQ(_) => Some("SQ".to_string()),
            ImmunizationRoute::TRNSDERM(_) => Some("TRNSDERM".to_string()),
            ImmunizationRoute::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationRoute {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationRoute::IDINJ(Some(e)) => e.get_field(field),
                ImmunizationRoute::IM(Some(e)) => e.get_field(field),
                ImmunizationRoute::IVINJ(Some(e)) => e.get_field(field),
                ImmunizationRoute::NASINHLC(Some(e)) => e.get_field(field),
                ImmunizationRoute::PO(Some(e)) => e.get_field(field),
                ImmunizationRoute::SQ(Some(e)) => e.get_field(field),
                ImmunizationRoute::TRNSDERM(Some(e)) => e.get_field(field),
                ImmunizationRoute::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationRoute::IDINJ(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::IM(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::IVINJ(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::NASINHLC(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::PO(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::SQ(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::TRNSDERM(Some(e)) => e.get_field_mut(field),
                ImmunizationRoute::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationSite {
    #[doc = "Left arm"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "Right arm"]
    #[code = "RA"]
    RA(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationSite {
    fn default() -> Self {
        ImmunizationSite::Null(None)
    }
}
impl TryFrom<String> for ImmunizationSite {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "LA" => Ok(ImmunizationSite::LA(None)),
            "RA" => Ok(ImmunizationSite::RA(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationSite {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationSite::LA(_) => Some("LA".to_string()),
            ImmunizationSite::RA(_) => Some("RA".to_string()),
            ImmunizationSite::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationSite {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationSite::LA(Some(e)) => e.get_field(field),
                ImmunizationSite::RA(Some(e)) => e.get_field(field),
                ImmunizationSite::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationSite::LA(Some(e)) => e.get_field_mut(field),
                ImmunizationSite::RA(Some(e)) => e.get_field_mut(field),
                ImmunizationSite::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationStatus {
    #[code = "completed"]
    Completed(Option<Element>),
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[code = "not-done"]
    NotDone(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationStatus {
    fn default() -> Self {
        ImmunizationStatus::Null(None)
    }
}
impl TryFrom<String> for ImmunizationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(ImmunizationStatus::Completed(None)),
            "entered-in-error" => Ok(ImmunizationStatus::EnteredInError(None)),
            "not-done" => Ok(ImmunizationStatus::NotDone(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationStatus {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationStatus::Completed(_) => Some("completed".to_string()),
            ImmunizationStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ImmunizationStatus::NotDone(_) => Some("not-done".to_string()),
            ImmunizationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationStatus::Completed(Some(e)) => e.get_field(field),
                ImmunizationStatus::EnteredInError(Some(e)) => e.get_field(field),
                ImmunizationStatus::NotDone(Some(e)) => e.get_field(field),
                ImmunizationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationStatus::Completed(Some(e)) => e.get_field_mut(field),
                ImmunizationStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ImmunizationStatus::NotDone(Some(e)) => e.get_field_mut(field),
                ImmunizationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationSubpotentReason {
    #[doc = "Cold Chain Break"]
    #[code = "coldchainbreak"]
    Coldchainbreak(Option<Element>),
    #[doc = "Partial Dose"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "Manufacturer Recall"]
    #[code = "recall"]
    Recall(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationSubpotentReason {
    fn default() -> Self {
        ImmunizationSubpotentReason::Null(None)
    }
}
impl TryFrom<String> for ImmunizationSubpotentReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "coldchainbreak" => Ok(ImmunizationSubpotentReason::Coldchainbreak(None)),
            "partial" => Ok(ImmunizationSubpotentReason::Partial(None)),
            "recall" => Ok(ImmunizationSubpotentReason::Recall(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationSubpotentReason {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationSubpotentReason::Coldchainbreak(_) => Some("coldchainbreak".to_string()),
            ImmunizationSubpotentReason::Partial(_) => Some("partial".to_string()),
            ImmunizationSubpotentReason::Recall(_) => Some("recall".to_string()),
            ImmunizationSubpotentReason::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationSubpotentReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationSubpotentReason::Coldchainbreak(Some(e)) => e.get_field(field),
                ImmunizationSubpotentReason::Partial(Some(e)) => e.get_field(field),
                ImmunizationSubpotentReason::Recall(Some(e)) => e.get_field(field),
                ImmunizationSubpotentReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationSubpotentReason::Coldchainbreak(Some(e)) => e.get_field_mut(field),
                ImmunizationSubpotentReason::Partial(Some(e)) => e.get_field_mut(field),
                ImmunizationSubpotentReason::Recall(Some(e)) => e.get_field_mut(field),
                ImmunizationSubpotentReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImmunizationTargetDisease {
    #[code = "14189004"]
    V14189004(Option<Element>),
    #[code = "1857005"]
    V1857005(Option<Element>),
    #[code = "27836007"]
    V27836007(Option<Element>),
    #[code = "36653000"]
    V36653000(Option<Element>),
    #[code = "36989005"]
    V36989005(Option<Element>),
    #[code = "397430003"]
    V397430003(Option<Element>),
    #[code = "398102009"]
    V398102009(Option<Element>),
    #[code = "709410003"]
    V709410003(Option<Element>),
    #[code = "76902006"]
    V76902006(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImmunizationTargetDisease {
    fn default() -> Self {
        ImmunizationTargetDisease::Null(None)
    }
}
impl TryFrom<String> for ImmunizationTargetDisease {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "14189004" => Ok(ImmunizationTargetDisease::V14189004(None)),
            "1857005" => Ok(ImmunizationTargetDisease::V1857005(None)),
            "27836007" => Ok(ImmunizationTargetDisease::V27836007(None)),
            "36653000" => Ok(ImmunizationTargetDisease::V36653000(None)),
            "36989005" => Ok(ImmunizationTargetDisease::V36989005(None)),
            "397430003" => Ok(ImmunizationTargetDisease::V397430003(None)),
            "398102009" => Ok(ImmunizationTargetDisease::V398102009(None)),
            "709410003" => Ok(ImmunizationTargetDisease::V709410003(None)),
            "76902006" => Ok(ImmunizationTargetDisease::V76902006(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImmunizationTargetDisease {
    fn into(self) -> Option<String> {
        match self {
            ImmunizationTargetDisease::V14189004(_) => Some("14189004".to_string()),
            ImmunizationTargetDisease::V1857005(_) => Some("1857005".to_string()),
            ImmunizationTargetDisease::V27836007(_) => Some("27836007".to_string()),
            ImmunizationTargetDisease::V36653000(_) => Some("36653000".to_string()),
            ImmunizationTargetDisease::V36989005(_) => Some("36989005".to_string()),
            ImmunizationTargetDisease::V397430003(_) => Some("397430003".to_string()),
            ImmunizationTargetDisease::V398102009(_) => Some("398102009".to_string()),
            ImmunizationTargetDisease::V709410003(_) => Some("709410003".to_string()),
            ImmunizationTargetDisease::V76902006(_) => Some("76902006".to_string()),
            ImmunizationTargetDisease::Null(_) => None,
        }
    }
}
impl MetaValue for ImmunizationTargetDisease {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImmunizationTargetDisease::V14189004(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V1857005(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V27836007(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V36653000(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V36989005(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V397430003(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V398102009(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V709410003(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::V76902006(Some(e)) => e.get_field(field),
                ImmunizationTargetDisease::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImmunizationTargetDisease::V14189004(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V1857005(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V27836007(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V36653000(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V36989005(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V397430003(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V398102009(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V709410003(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::V76902006(Some(e)) => e.get_field_mut(field),
                ImmunizationTargetDisease::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ImplantStatus {
    #[doc = "Disabled"]
    #[code = "disabled"]
    Disabled(Option<Element>),
    #[doc = "Functional"]
    #[code = "functional"]
    Functional(Option<Element>),
    #[doc = "Non-Functional"]
    #[code = "non-functional"]
    NonFunctional(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ImplantStatus {
    fn default() -> Self {
        ImplantStatus::Null(None)
    }
}
impl TryFrom<String> for ImplantStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "disabled" => Ok(ImplantStatus::Disabled(None)),
            "functional" => Ok(ImplantStatus::Functional(None)),
            "non-functional" => Ok(ImplantStatus::NonFunctional(None)),
            "unknown" => Ok(ImplantStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ImplantStatus {
    fn into(self) -> Option<String> {
        match self {
            ImplantStatus::Disabled(_) => Some("disabled".to_string()),
            ImplantStatus::Functional(_) => Some("functional".to_string()),
            ImplantStatus::NonFunctional(_) => Some("non-functional".to_string()),
            ImplantStatus::Unknown(_) => Some("unknown".to_string()),
            ImplantStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ImplantStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ImplantStatus::Disabled(Some(e)) => e.get_field(field),
                ImplantStatus::Functional(Some(e)) => e.get_field(field),
                ImplantStatus::NonFunctional(Some(e)) => e.get_field(field),
                ImplantStatus::Unknown(Some(e)) => e.get_field(field),
                ImplantStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ImplantStatus::Disabled(Some(e)) => e.get_field_mut(field),
                ImplantStatus::Functional(Some(e)) => e.get_field_mut(field),
                ImplantStatus::NonFunctional(Some(e)) => e.get_field_mut(field),
                ImplantStatus::Unknown(Some(e)) => e.get_field_mut(field),
                ImplantStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Inactive {
    #[doc = "appointment"]
    #[code = "APT"]
    APT(Option<Element>),
    #[doc = "appointment request"]
    #[code = "ARQ"]
    ARQ(Option<Element>),
    #[doc = "criterion"]
    #[code = "CRT"]
    CRT(Option<Element>),
    #[doc = "definition"]
    #[code = "DEF"]
    DEF(Option<Element>),
    #[doc = "event (occurrence)"]
    #[code = "EVN"]
    EVN(Option<Element>),
    #[doc = "event criterion"]
    #[code = "EVN.CRT"]
    EVNCRT(Option<Element>),
    #[doc = "expectation"]
    #[code = "EXPEC"]
    EXPEC(Option<Element>),
    #[doc = "Goal"]
    #[code = "GOL"]
    GOL(Option<Element>),
    #[doc = "goal criterion"]
    #[code = "GOL.CRT"]
    GOLCRT(Option<Element>),
    #[doc = "intent"]
    #[code = "INT"]
    INT(Option<Element>),
    #[doc = "intent criterion"]
    #[code = "INT.CRT"]
    INTCRT(Option<Element>),
    #[doc = "option"]
    #[code = "OPT"]
    OPT(Option<Element>),
    #[doc = "permission"]
    #[code = "PERM"]
    PERM(Option<Element>),
    #[doc = "permission request"]
    #[code = "PERMRQ"]
    PERMRQ(Option<Element>),
    #[doc = "promise"]
    #[code = "PRMS"]
    PRMS(Option<Element>),
    #[doc = "promise criterion"]
    #[code = "PRMS.CRT"]
    PRMSCRT(Option<Element>),
    #[doc = "proposal"]
    #[code = "PRP"]
    PRP(Option<Element>),
    #[doc = "recommendation"]
    #[code = "RMD"]
    RMD(Option<Element>),
    #[doc = "request"]
    #[code = "RQO"]
    RQO(Option<Element>),
    #[doc = "request criterion"]
    #[code = "RQO.CRT"]
    RQOCRT(Option<Element>),
    #[doc = "risk"]
    #[code = "RSK"]
    RSK(Option<Element>),
    #[doc = "risk criterion"]
    #[code = "RSK.CRT"]
    RSKCRT(Option<Element>),
    #[doc = "resource slot"]
    #[code = "SLOT"]
    SLOT(Option<Element>),
    #[doc = "act request"]
    #[code = "_ActMoodActRequest"]
    _ActMoodActRequest(Option<Element>),
    #[doc = "ActMoodCompletionTrack"]
    #[code = "_ActMoodCompletionTrack"]
    _ActMoodCompletionTrack(Option<Element>),
    #[doc = "desire"]
    #[code = "_ActMoodDesire"]
    _ActMoodDesire(Option<Element>),
    #[doc = "potential"]
    #[code = "_ActMoodPotential"]
    _ActMoodPotential(Option<Element>),
    #[doc = "ActMoodPredicate"]
    #[code = "_ActMoodPredicate"]
    _ActMoodPredicate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Inactive {
    fn default() -> Self {
        Inactive::Null(None)
    }
}
impl TryFrom<String> for Inactive {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "APT" => Ok(Inactive::APT(None)),
            "ARQ" => Ok(Inactive::ARQ(None)),
            "CRT" => Ok(Inactive::CRT(None)),
            "DEF" => Ok(Inactive::DEF(None)),
            "EVN" => Ok(Inactive::EVN(None)),
            "EVN.CRT" => Ok(Inactive::EVNCRT(None)),
            "EXPEC" => Ok(Inactive::EXPEC(None)),
            "GOL" => Ok(Inactive::GOL(None)),
            "GOL.CRT" => Ok(Inactive::GOLCRT(None)),
            "INT" => Ok(Inactive::INT(None)),
            "INT.CRT" => Ok(Inactive::INTCRT(None)),
            "OPT" => Ok(Inactive::OPT(None)),
            "PERM" => Ok(Inactive::PERM(None)),
            "PERMRQ" => Ok(Inactive::PERMRQ(None)),
            "PRMS" => Ok(Inactive::PRMS(None)),
            "PRMS.CRT" => Ok(Inactive::PRMSCRT(None)),
            "PRP" => Ok(Inactive::PRP(None)),
            "RMD" => Ok(Inactive::RMD(None)),
            "RQO" => Ok(Inactive::RQO(None)),
            "RQO.CRT" => Ok(Inactive::RQOCRT(None)),
            "RSK" => Ok(Inactive::RSK(None)),
            "RSK.CRT" => Ok(Inactive::RSKCRT(None)),
            "SLOT" => Ok(Inactive::SLOT(None)),
            "_ActMoodActRequest" => Ok(Inactive::_ActMoodActRequest(None)),
            "_ActMoodCompletionTrack" => Ok(Inactive::_ActMoodCompletionTrack(None)),
            "_ActMoodDesire" => Ok(Inactive::_ActMoodDesire(None)),
            "_ActMoodPotential" => Ok(Inactive::_ActMoodPotential(None)),
            "_ActMoodPredicate" => Ok(Inactive::_ActMoodPredicate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Inactive {
    fn into(self) -> Option<String> {
        match self {
            Inactive::APT(_) => Some("APT".to_string()),
            Inactive::ARQ(_) => Some("ARQ".to_string()),
            Inactive::CRT(_) => Some("CRT".to_string()),
            Inactive::DEF(_) => Some("DEF".to_string()),
            Inactive::EVN(_) => Some("EVN".to_string()),
            Inactive::EVNCRT(_) => Some("EVN.CRT".to_string()),
            Inactive::EXPEC(_) => Some("EXPEC".to_string()),
            Inactive::GOL(_) => Some("GOL".to_string()),
            Inactive::GOLCRT(_) => Some("GOL.CRT".to_string()),
            Inactive::INT(_) => Some("INT".to_string()),
            Inactive::INTCRT(_) => Some("INT.CRT".to_string()),
            Inactive::OPT(_) => Some("OPT".to_string()),
            Inactive::PERM(_) => Some("PERM".to_string()),
            Inactive::PERMRQ(_) => Some("PERMRQ".to_string()),
            Inactive::PRMS(_) => Some("PRMS".to_string()),
            Inactive::PRMSCRT(_) => Some("PRMS.CRT".to_string()),
            Inactive::PRP(_) => Some("PRP".to_string()),
            Inactive::RMD(_) => Some("RMD".to_string()),
            Inactive::RQO(_) => Some("RQO".to_string()),
            Inactive::RQOCRT(_) => Some("RQO.CRT".to_string()),
            Inactive::RSK(_) => Some("RSK".to_string()),
            Inactive::RSKCRT(_) => Some("RSK.CRT".to_string()),
            Inactive::SLOT(_) => Some("SLOT".to_string()),
            Inactive::_ActMoodActRequest(_) => Some("_ActMoodActRequest".to_string()),
            Inactive::_ActMoodCompletionTrack(_) => Some("_ActMoodCompletionTrack".to_string()),
            Inactive::_ActMoodDesire(_) => Some("_ActMoodDesire".to_string()),
            Inactive::_ActMoodPotential(_) => Some("_ActMoodPotential".to_string()),
            Inactive::_ActMoodPredicate(_) => Some("_ActMoodPredicate".to_string()),
            Inactive::Null(_) => None,
        }
    }
}
impl MetaValue for Inactive {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Inactive::APT(Some(e)) => e.get_field(field),
                Inactive::ARQ(Some(e)) => e.get_field(field),
                Inactive::CRT(Some(e)) => e.get_field(field),
                Inactive::DEF(Some(e)) => e.get_field(field),
                Inactive::EVN(Some(e)) => e.get_field(field),
                Inactive::EVNCRT(Some(e)) => e.get_field(field),
                Inactive::EXPEC(Some(e)) => e.get_field(field),
                Inactive::GOL(Some(e)) => e.get_field(field),
                Inactive::GOLCRT(Some(e)) => e.get_field(field),
                Inactive::INT(Some(e)) => e.get_field(field),
                Inactive::INTCRT(Some(e)) => e.get_field(field),
                Inactive::OPT(Some(e)) => e.get_field(field),
                Inactive::PERM(Some(e)) => e.get_field(field),
                Inactive::PERMRQ(Some(e)) => e.get_field(field),
                Inactive::PRMS(Some(e)) => e.get_field(field),
                Inactive::PRMSCRT(Some(e)) => e.get_field(field),
                Inactive::PRP(Some(e)) => e.get_field(field),
                Inactive::RMD(Some(e)) => e.get_field(field),
                Inactive::RQO(Some(e)) => e.get_field(field),
                Inactive::RQOCRT(Some(e)) => e.get_field(field),
                Inactive::RSK(Some(e)) => e.get_field(field),
                Inactive::RSKCRT(Some(e)) => e.get_field(field),
                Inactive::SLOT(Some(e)) => e.get_field(field),
                Inactive::_ActMoodActRequest(Some(e)) => e.get_field(field),
                Inactive::_ActMoodCompletionTrack(Some(e)) => e.get_field(field),
                Inactive::_ActMoodDesire(Some(e)) => e.get_field(field),
                Inactive::_ActMoodPotential(Some(e)) => e.get_field(field),
                Inactive::_ActMoodPredicate(Some(e)) => e.get_field(field),
                Inactive::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Inactive::APT(Some(e)) => e.get_field_mut(field),
                Inactive::ARQ(Some(e)) => e.get_field_mut(field),
                Inactive::CRT(Some(e)) => e.get_field_mut(field),
                Inactive::DEF(Some(e)) => e.get_field_mut(field),
                Inactive::EVN(Some(e)) => e.get_field_mut(field),
                Inactive::EVNCRT(Some(e)) => e.get_field_mut(field),
                Inactive::EXPEC(Some(e)) => e.get_field_mut(field),
                Inactive::GOL(Some(e)) => e.get_field_mut(field),
                Inactive::GOLCRT(Some(e)) => e.get_field_mut(field),
                Inactive::INT(Some(e)) => e.get_field_mut(field),
                Inactive::INTCRT(Some(e)) => e.get_field_mut(field),
                Inactive::OPT(Some(e)) => e.get_field_mut(field),
                Inactive::PERM(Some(e)) => e.get_field_mut(field),
                Inactive::PERMRQ(Some(e)) => e.get_field_mut(field),
                Inactive::PRMS(Some(e)) => e.get_field_mut(field),
                Inactive::PRMSCRT(Some(e)) => e.get_field_mut(field),
                Inactive::PRP(Some(e)) => e.get_field_mut(field),
                Inactive::RMD(Some(e)) => e.get_field_mut(field),
                Inactive::RQO(Some(e)) => e.get_field_mut(field),
                Inactive::RQOCRT(Some(e)) => e.get_field_mut(field),
                Inactive::RSK(Some(e)) => e.get_field_mut(field),
                Inactive::RSKCRT(Some(e)) => e.get_field_mut(field),
                Inactive::SLOT(Some(e)) => e.get_field_mut(field),
                Inactive::_ActMoodActRequest(Some(e)) => e.get_field_mut(field),
                Inactive::_ActMoodCompletionTrack(Some(e)) => e.get_field_mut(field),
                Inactive::_ActMoodDesire(Some(e)) => e.get_field_mut(field),
                Inactive::_ActMoodPotential(Some(e)) => e.get_field_mut(field),
                Inactive::_ActMoodPredicate(Some(e)) => e.get_field_mut(field),
                Inactive::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InstanceAvailability {
    #[code = "NEARLINE"]
    NEARLINE(Option<Element>),
    #[code = "OFFLINE"]
    OFFLINE(Option<Element>),
    #[code = "ONLINE"]
    ONLINE(Option<Element>),
    #[code = "UNAVAILABLE"]
    UNAVAILABLE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InstanceAvailability {
    fn default() -> Self {
        InstanceAvailability::Null(None)
    }
}
impl TryFrom<String> for InstanceAvailability {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "NEARLINE" => Ok(InstanceAvailability::NEARLINE(None)),
            "OFFLINE" => Ok(InstanceAvailability::OFFLINE(None)),
            "ONLINE" => Ok(InstanceAvailability::ONLINE(None)),
            "UNAVAILABLE" => Ok(InstanceAvailability::UNAVAILABLE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InstanceAvailability {
    fn into(self) -> Option<String> {
        match self {
            InstanceAvailability::NEARLINE(_) => Some("NEARLINE".to_string()),
            InstanceAvailability::OFFLINE(_) => Some("OFFLINE".to_string()),
            InstanceAvailability::ONLINE(_) => Some("ONLINE".to_string()),
            InstanceAvailability::UNAVAILABLE(_) => Some("UNAVAILABLE".to_string()),
            InstanceAvailability::Null(_) => None,
        }
    }
}
impl MetaValue for InstanceAvailability {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InstanceAvailability::NEARLINE(Some(e)) => e.get_field(field),
                InstanceAvailability::OFFLINE(Some(e)) => e.get_field(field),
                InstanceAvailability::ONLINE(Some(e)) => e.get_field(field),
                InstanceAvailability::UNAVAILABLE(Some(e)) => e.get_field(field),
                InstanceAvailability::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InstanceAvailability::NEARLINE(Some(e)) => e.get_field_mut(field),
                InstanceAvailability::OFFLINE(Some(e)) => e.get_field_mut(field),
                InstanceAvailability::ONLINE(Some(e)) => e.get_field_mut(field),
                InstanceAvailability::UNAVAILABLE(Some(e)) => e.get_field_mut(field),
                InstanceAvailability::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InsuranceplanApplicability {
    #[doc = "In Network"]
    #[code = "in-network"]
    InNetwork(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Out of Network"]
    #[code = "out-of-network"]
    OutOfNetwork(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InsuranceplanApplicability {
    fn default() -> Self {
        InsuranceplanApplicability::Null(None)
    }
}
impl TryFrom<String> for InsuranceplanApplicability {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "in-network" => Ok(InsuranceplanApplicability::InNetwork(None)),
            "other" => Ok(InsuranceplanApplicability::Other(None)),
            "out-of-network" => Ok(InsuranceplanApplicability::OutOfNetwork(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InsuranceplanApplicability {
    fn into(self) -> Option<String> {
        match self {
            InsuranceplanApplicability::InNetwork(_) => Some("in-network".to_string()),
            InsuranceplanApplicability::Other(_) => Some("other".to_string()),
            InsuranceplanApplicability::OutOfNetwork(_) => Some("out-of-network".to_string()),
            InsuranceplanApplicability::Null(_) => None,
        }
    }
}
impl MetaValue for InsuranceplanApplicability {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InsuranceplanApplicability::InNetwork(Some(e)) => e.get_field(field),
                InsuranceplanApplicability::Other(Some(e)) => e.get_field(field),
                InsuranceplanApplicability::OutOfNetwork(Some(e)) => e.get_field(field),
                InsuranceplanApplicability::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InsuranceplanApplicability::InNetwork(Some(e)) => e.get_field_mut(field),
                InsuranceplanApplicability::Other(Some(e)) => e.get_field_mut(field),
                InsuranceplanApplicability::OutOfNetwork(Some(e)) => e.get_field_mut(field),
                InsuranceplanApplicability::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InsuranceplanType {
    #[doc = "Drug"]
    #[code = "Drug"]
    Drug(Option<Element>),
    #[doc = "Dental"]
    #[code = "dental"]
    Dental(Option<Element>),
    #[doc = "Home Health"]
    #[code = "home"]
    Home(Option<Element>),
    #[doc = "Hospice"]
    #[code = "hospice"]
    Hospice(Option<Element>),
    #[doc = "Long Term Care"]
    #[code = "long-term"]
    LongTerm(Option<Element>),
    #[doc = "Medical"]
    #[code = "medical"]
    Medical(Option<Element>),
    #[doc = "Mental Health"]
    #[code = "mental"]
    Mental(Option<Element>),
    #[doc = "Short Term"]
    #[code = "short-term"]
    ShortTerm(Option<Element>),
    #[doc = "Substance Abuse"]
    #[code = "subst-ab"]
    SubstAb(Option<Element>),
    #[doc = "Vision"]
    #[code = "vision"]
    Vision(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InsuranceplanType {
    fn default() -> Self {
        InsuranceplanType::Null(None)
    }
}
impl TryFrom<String> for InsuranceplanType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Drug" => Ok(InsuranceplanType::Drug(None)),
            "dental" => Ok(InsuranceplanType::Dental(None)),
            "home" => Ok(InsuranceplanType::Home(None)),
            "hospice" => Ok(InsuranceplanType::Hospice(None)),
            "long-term" => Ok(InsuranceplanType::LongTerm(None)),
            "medical" => Ok(InsuranceplanType::Medical(None)),
            "mental" => Ok(InsuranceplanType::Mental(None)),
            "short-term" => Ok(InsuranceplanType::ShortTerm(None)),
            "subst-ab" => Ok(InsuranceplanType::SubstAb(None)),
            "vision" => Ok(InsuranceplanType::Vision(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InsuranceplanType {
    fn into(self) -> Option<String> {
        match self {
            InsuranceplanType::Drug(_) => Some("Drug".to_string()),
            InsuranceplanType::Dental(_) => Some("dental".to_string()),
            InsuranceplanType::Home(_) => Some("home".to_string()),
            InsuranceplanType::Hospice(_) => Some("hospice".to_string()),
            InsuranceplanType::LongTerm(_) => Some("long-term".to_string()),
            InsuranceplanType::Medical(_) => Some("medical".to_string()),
            InsuranceplanType::Mental(_) => Some("mental".to_string()),
            InsuranceplanType::ShortTerm(_) => Some("short-term".to_string()),
            InsuranceplanType::SubstAb(_) => Some("subst-ab".to_string()),
            InsuranceplanType::Vision(_) => Some("vision".to_string()),
            InsuranceplanType::Null(_) => None,
        }
    }
}
impl MetaValue for InsuranceplanType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InsuranceplanType::Drug(Some(e)) => e.get_field(field),
                InsuranceplanType::Dental(Some(e)) => e.get_field(field),
                InsuranceplanType::Home(Some(e)) => e.get_field(field),
                InsuranceplanType::Hospice(Some(e)) => e.get_field(field),
                InsuranceplanType::LongTerm(Some(e)) => e.get_field(field),
                InsuranceplanType::Medical(Some(e)) => e.get_field(field),
                InsuranceplanType::Mental(Some(e)) => e.get_field(field),
                InsuranceplanType::ShortTerm(Some(e)) => e.get_field(field),
                InsuranceplanType::SubstAb(Some(e)) => e.get_field(field),
                InsuranceplanType::Vision(Some(e)) => e.get_field(field),
                InsuranceplanType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InsuranceplanType::Drug(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Dental(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Home(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Hospice(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::LongTerm(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Medical(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Mental(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::ShortTerm(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::SubstAb(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Vision(Some(e)) => e.get_field_mut(field),
                InsuranceplanType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Intervention {
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Intervention {
    fn default() -> Self {
        Intervention::Null(None)
    }
}
impl TryFrom<String> for Intervention {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "other" => Ok(Intervention::Other(None)),
            "unknown" => Ok(Intervention::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Intervention {
    fn into(self) -> Option<String> {
        match self {
            Intervention::Other(_) => Some("other".to_string()),
            Intervention::Unknown(_) => Some("unknown".to_string()),
            Intervention::Null(_) => None,
        }
    }
}
impl MetaValue for Intervention {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Intervention::Other(Some(e)) => e.get_field(field),
                Intervention::Unknown(Some(e)) => e.get_field(field),
                Intervention::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Intervention::Other(Some(e)) => e.get_field_mut(field),
                Intervention::Unknown(Some(e)) => e.get_field_mut(field),
                Intervention::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InvestigationSets {
    #[doc = "History/symptoms"]
    #[code = "160237006"]
    V160237006(Option<Element>),
    #[doc = "Examination / signs"]
    #[code = "271336007"]
    V271336007(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InvestigationSets {
    fn default() -> Self {
        InvestigationSets::Null(None)
    }
}
impl TryFrom<String> for InvestigationSets {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "160237006" => Ok(InvestigationSets::V160237006(None)),
            "271336007" => Ok(InvestigationSets::V271336007(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InvestigationSets {
    fn into(self) -> Option<String> {
        match self {
            InvestigationSets::V160237006(_) => Some("160237006".to_string()),
            InvestigationSets::V271336007(_) => Some("271336007".to_string()),
            InvestigationSets::Null(_) => None,
        }
    }
}
impl MetaValue for InvestigationSets {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InvestigationSets::V160237006(Some(e)) => e.get_field(field),
                InvestigationSets::V271336007(Some(e)) => e.get_field(field),
                InvestigationSets::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InvestigationSets::V160237006(Some(e)) => e.get_field_mut(field),
                InvestigationSets::V271336007(Some(e)) => e.get_field_mut(field),
                InvestigationSets::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InvoicePriceComponentType {
    #[doc = "base price"]
    #[code = "base"]
    Base(Option<Element>),
    #[doc = "deduction"]
    #[code = "deduction"]
    Deduction(Option<Element>),
    #[doc = "discount"]
    #[code = "discount"]
    Discount(Option<Element>),
    #[doc = "informational"]
    #[code = "informational"]
    Informational(Option<Element>),
    #[doc = "surcharge"]
    #[code = "surcharge"]
    Surcharge(Option<Element>),
    #[doc = "tax"]
    #[code = "tax"]
    Tax(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InvoicePriceComponentType {
    fn default() -> Self {
        InvoicePriceComponentType::Null(None)
    }
}
impl TryFrom<String> for InvoicePriceComponentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "base" => Ok(InvoicePriceComponentType::Base(None)),
            "deduction" => Ok(InvoicePriceComponentType::Deduction(None)),
            "discount" => Ok(InvoicePriceComponentType::Discount(None)),
            "informational" => Ok(InvoicePriceComponentType::Informational(None)),
            "surcharge" => Ok(InvoicePriceComponentType::Surcharge(None)),
            "tax" => Ok(InvoicePriceComponentType::Tax(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InvoicePriceComponentType {
    fn into(self) -> Option<String> {
        match self {
            InvoicePriceComponentType::Base(_) => Some("base".to_string()),
            InvoicePriceComponentType::Deduction(_) => Some("deduction".to_string()),
            InvoicePriceComponentType::Discount(_) => Some("discount".to_string()),
            InvoicePriceComponentType::Informational(_) => Some("informational".to_string()),
            InvoicePriceComponentType::Surcharge(_) => Some("surcharge".to_string()),
            InvoicePriceComponentType::Tax(_) => Some("tax".to_string()),
            InvoicePriceComponentType::Null(_) => None,
        }
    }
}
impl MetaValue for InvoicePriceComponentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InvoicePriceComponentType::Base(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Deduction(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Discount(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Informational(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Surcharge(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Tax(Some(e)) => e.get_field(field),
                InvoicePriceComponentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InvoicePriceComponentType::Base(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Deduction(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Discount(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Informational(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Surcharge(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Tax(Some(e)) => e.get_field_mut(field),
                InvoicePriceComponentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum InvoiceStatus {
    #[doc = "balanced"]
    #[code = "balanced"]
    Balanced(Option<Element>),
    #[doc = "cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "entered in error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "issued"]
    #[code = "issued"]
    Issued(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for InvoiceStatus {
    fn default() -> Self {
        InvoiceStatus::Null(None)
    }
}
impl TryFrom<String> for InvoiceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "balanced" => Ok(InvoiceStatus::Balanced(None)),
            "cancelled" => Ok(InvoiceStatus::Cancelled(None)),
            "draft" => Ok(InvoiceStatus::Draft(None)),
            "entered-in-error" => Ok(InvoiceStatus::EnteredInError(None)),
            "issued" => Ok(InvoiceStatus::Issued(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &InvoiceStatus {
    fn into(self) -> Option<String> {
        match self {
            InvoiceStatus::Balanced(_) => Some("balanced".to_string()),
            InvoiceStatus::Cancelled(_) => Some("cancelled".to_string()),
            InvoiceStatus::Draft(_) => Some("draft".to_string()),
            InvoiceStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            InvoiceStatus::Issued(_) => Some("issued".to_string()),
            InvoiceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for InvoiceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                InvoiceStatus::Balanced(Some(e)) => e.get_field(field),
                InvoiceStatus::Cancelled(Some(e)) => e.get_field(field),
                InvoiceStatus::Draft(Some(e)) => e.get_field(field),
                InvoiceStatus::EnteredInError(Some(e)) => e.get_field(field),
                InvoiceStatus::Issued(Some(e)) => e.get_field(field),
                InvoiceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                InvoiceStatus::Balanced(Some(e)) => e.get_field_mut(field),
                InvoiceStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                InvoiceStatus::Draft(Some(e)) => e.get_field_mut(field),
                InvoiceStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                InvoiceStatus::Issued(Some(e)) => e.get_field_mut(field),
                InvoiceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IssueSeverity {
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Fatal"]
    #[code = "fatal"]
    Fatal(Option<Element>),
    #[doc = "Information"]
    #[code = "information"]
    Information(Option<Element>),
    #[doc = "Warning"]
    #[code = "warning"]
    Warning(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IssueSeverity {
    fn default() -> Self {
        IssueSeverity::Null(None)
    }
}
impl TryFrom<String> for IssueSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "error" => Ok(IssueSeverity::Error(None)),
            "fatal" => Ok(IssueSeverity::Fatal(None)),
            "information" => Ok(IssueSeverity::Information(None)),
            "warning" => Ok(IssueSeverity::Warning(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IssueSeverity {
    fn into(self) -> Option<String> {
        match self {
            IssueSeverity::Error(_) => Some("error".to_string()),
            IssueSeverity::Fatal(_) => Some("fatal".to_string()),
            IssueSeverity::Information(_) => Some("information".to_string()),
            IssueSeverity::Warning(_) => Some("warning".to_string()),
            IssueSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for IssueSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IssueSeverity::Error(Some(e)) => e.get_field(field),
                IssueSeverity::Fatal(Some(e)) => e.get_field(field),
                IssueSeverity::Information(Some(e)) => e.get_field(field),
                IssueSeverity::Warning(Some(e)) => e.get_field(field),
                IssueSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IssueSeverity::Error(Some(e)) => e.get_field_mut(field),
                IssueSeverity::Fatal(Some(e)) => e.get_field_mut(field),
                IssueSeverity::Information(Some(e)) => e.get_field_mut(field),
                IssueSeverity::Warning(Some(e)) => e.get_field_mut(field),
                IssueSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IssueType {
    #[doc = "Business Rule Violation"]
    #[code = "business-rule"]
    BusinessRule(Option<Element>),
    #[doc = "Invalid Code"]
    #[code = "code-invalid"]
    CodeInvalid(Option<Element>),
    #[doc = "Edit Version Conflict"]
    #[code = "conflict"]
    Conflict(Option<Element>),
    #[doc = "Deleted"]
    #[code = "deleted"]
    Deleted(Option<Element>),
    #[doc = "Duplicate"]
    #[code = "duplicate"]
    Duplicate(Option<Element>),
    #[doc = "Exception"]
    #[code = "exception"]
    Exception(Option<Element>),
    #[doc = "Session Expired"]
    #[code = "expired"]
    Expired(Option<Element>),
    #[doc = "Unacceptable Extension"]
    #[code = "extension"]
    Extension(Option<Element>),
    #[doc = "Forbidden"]
    #[code = "forbidden"]
    Forbidden(Option<Element>),
    #[doc = "Incomplete Results"]
    #[code = "incomplete"]
    Incomplete(Option<Element>),
    #[doc = "Informational Note"]
    #[code = "informational"]
    Informational(Option<Element>),
    #[doc = "Invalid Content"]
    #[code = "invalid"]
    Invalid(Option<Element>),
    #[doc = "Validation rule failed"]
    #[code = "invariant"]
    Invariant(Option<Element>),
    #[doc = "Lock Error"]
    #[code = "lock-error"]
    LockError(Option<Element>),
    #[doc = "Login Required"]
    #[code = "login"]
    Login(Option<Element>),
    #[doc = "Multiple Matches"]
    #[code = "multiple-matches"]
    MultipleMatches(Option<Element>),
    #[doc = "No Store Available"]
    #[code = "no-store"]
    NoStore(Option<Element>),
    #[doc = "Not Found"]
    #[code = "not-found"]
    NotFound(Option<Element>),
    #[doc = "Content not supported"]
    #[code = "not-supported"]
    NotSupported(Option<Element>),
    #[doc = "Processing Failure"]
    #[code = "processing"]
    Processing(Option<Element>),
    #[doc = "Required element missing"]
    #[code = "required"]
    Required(Option<Element>),
    #[doc = "Security Problem"]
    #[code = "security"]
    Security(Option<Element>),
    #[doc = "Structural Issue"]
    #[code = "structure"]
    Structure(Option<Element>),
    #[doc = "Information  Suppressed"]
    #[code = "suppressed"]
    Suppressed(Option<Element>),
    #[doc = "Throttled"]
    #[code = "throttled"]
    Throttled(Option<Element>),
    #[doc = "Timeout"]
    #[code = "timeout"]
    Timeout(Option<Element>),
    #[doc = "Operation Too Costly"]
    #[code = "too-costly"]
    TooCostly(Option<Element>),
    #[doc = "Content Too Long"]
    #[code = "too-long"]
    TooLong(Option<Element>),
    #[doc = "Transient Issue"]
    #[code = "transient"]
    Transient(Option<Element>),
    #[doc = "Unknown User"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "Element value invalid"]
    #[code = "value"]
    Value(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IssueType {
    fn default() -> Self {
        IssueType::Null(None)
    }
}
impl TryFrom<String> for IssueType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "business-rule" => Ok(IssueType::BusinessRule(None)),
            "code-invalid" => Ok(IssueType::CodeInvalid(None)),
            "conflict" => Ok(IssueType::Conflict(None)),
            "deleted" => Ok(IssueType::Deleted(None)),
            "duplicate" => Ok(IssueType::Duplicate(None)),
            "exception" => Ok(IssueType::Exception(None)),
            "expired" => Ok(IssueType::Expired(None)),
            "extension" => Ok(IssueType::Extension(None)),
            "forbidden" => Ok(IssueType::Forbidden(None)),
            "incomplete" => Ok(IssueType::Incomplete(None)),
            "informational" => Ok(IssueType::Informational(None)),
            "invalid" => Ok(IssueType::Invalid(None)),
            "invariant" => Ok(IssueType::Invariant(None)),
            "lock-error" => Ok(IssueType::LockError(None)),
            "login" => Ok(IssueType::Login(None)),
            "multiple-matches" => Ok(IssueType::MultipleMatches(None)),
            "no-store" => Ok(IssueType::NoStore(None)),
            "not-found" => Ok(IssueType::NotFound(None)),
            "not-supported" => Ok(IssueType::NotSupported(None)),
            "processing" => Ok(IssueType::Processing(None)),
            "required" => Ok(IssueType::Required(None)),
            "security" => Ok(IssueType::Security(None)),
            "structure" => Ok(IssueType::Structure(None)),
            "suppressed" => Ok(IssueType::Suppressed(None)),
            "throttled" => Ok(IssueType::Throttled(None)),
            "timeout" => Ok(IssueType::Timeout(None)),
            "too-costly" => Ok(IssueType::TooCostly(None)),
            "too-long" => Ok(IssueType::TooLong(None)),
            "transient" => Ok(IssueType::Transient(None)),
            "unknown" => Ok(IssueType::Unknown(None)),
            "value" => Ok(IssueType::Value(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IssueType {
    fn into(self) -> Option<String> {
        match self {
            IssueType::BusinessRule(_) => Some("business-rule".to_string()),
            IssueType::CodeInvalid(_) => Some("code-invalid".to_string()),
            IssueType::Conflict(_) => Some("conflict".to_string()),
            IssueType::Deleted(_) => Some("deleted".to_string()),
            IssueType::Duplicate(_) => Some("duplicate".to_string()),
            IssueType::Exception(_) => Some("exception".to_string()),
            IssueType::Expired(_) => Some("expired".to_string()),
            IssueType::Extension(_) => Some("extension".to_string()),
            IssueType::Forbidden(_) => Some("forbidden".to_string()),
            IssueType::Incomplete(_) => Some("incomplete".to_string()),
            IssueType::Informational(_) => Some("informational".to_string()),
            IssueType::Invalid(_) => Some("invalid".to_string()),
            IssueType::Invariant(_) => Some("invariant".to_string()),
            IssueType::LockError(_) => Some("lock-error".to_string()),
            IssueType::Login(_) => Some("login".to_string()),
            IssueType::MultipleMatches(_) => Some("multiple-matches".to_string()),
            IssueType::NoStore(_) => Some("no-store".to_string()),
            IssueType::NotFound(_) => Some("not-found".to_string()),
            IssueType::NotSupported(_) => Some("not-supported".to_string()),
            IssueType::Processing(_) => Some("processing".to_string()),
            IssueType::Required(_) => Some("required".to_string()),
            IssueType::Security(_) => Some("security".to_string()),
            IssueType::Structure(_) => Some("structure".to_string()),
            IssueType::Suppressed(_) => Some("suppressed".to_string()),
            IssueType::Throttled(_) => Some("throttled".to_string()),
            IssueType::Timeout(_) => Some("timeout".to_string()),
            IssueType::TooCostly(_) => Some("too-costly".to_string()),
            IssueType::TooLong(_) => Some("too-long".to_string()),
            IssueType::Transient(_) => Some("transient".to_string()),
            IssueType::Unknown(_) => Some("unknown".to_string()),
            IssueType::Value(_) => Some("value".to_string()),
            IssueType::Null(_) => None,
        }
    }
}
impl MetaValue for IssueType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IssueType::BusinessRule(Some(e)) => e.get_field(field),
                IssueType::CodeInvalid(Some(e)) => e.get_field(field),
                IssueType::Conflict(Some(e)) => e.get_field(field),
                IssueType::Deleted(Some(e)) => e.get_field(field),
                IssueType::Duplicate(Some(e)) => e.get_field(field),
                IssueType::Exception(Some(e)) => e.get_field(field),
                IssueType::Expired(Some(e)) => e.get_field(field),
                IssueType::Extension(Some(e)) => e.get_field(field),
                IssueType::Forbidden(Some(e)) => e.get_field(field),
                IssueType::Incomplete(Some(e)) => e.get_field(field),
                IssueType::Informational(Some(e)) => e.get_field(field),
                IssueType::Invalid(Some(e)) => e.get_field(field),
                IssueType::Invariant(Some(e)) => e.get_field(field),
                IssueType::LockError(Some(e)) => e.get_field(field),
                IssueType::Login(Some(e)) => e.get_field(field),
                IssueType::MultipleMatches(Some(e)) => e.get_field(field),
                IssueType::NoStore(Some(e)) => e.get_field(field),
                IssueType::NotFound(Some(e)) => e.get_field(field),
                IssueType::NotSupported(Some(e)) => e.get_field(field),
                IssueType::Processing(Some(e)) => e.get_field(field),
                IssueType::Required(Some(e)) => e.get_field(field),
                IssueType::Security(Some(e)) => e.get_field(field),
                IssueType::Structure(Some(e)) => e.get_field(field),
                IssueType::Suppressed(Some(e)) => e.get_field(field),
                IssueType::Throttled(Some(e)) => e.get_field(field),
                IssueType::Timeout(Some(e)) => e.get_field(field),
                IssueType::TooCostly(Some(e)) => e.get_field(field),
                IssueType::TooLong(Some(e)) => e.get_field(field),
                IssueType::Transient(Some(e)) => e.get_field(field),
                IssueType::Unknown(Some(e)) => e.get_field(field),
                IssueType::Value(Some(e)) => e.get_field(field),
                IssueType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IssueType::BusinessRule(Some(e)) => e.get_field_mut(field),
                IssueType::CodeInvalid(Some(e)) => e.get_field_mut(field),
                IssueType::Conflict(Some(e)) => e.get_field_mut(field),
                IssueType::Deleted(Some(e)) => e.get_field_mut(field),
                IssueType::Duplicate(Some(e)) => e.get_field_mut(field),
                IssueType::Exception(Some(e)) => e.get_field_mut(field),
                IssueType::Expired(Some(e)) => e.get_field_mut(field),
                IssueType::Extension(Some(e)) => e.get_field_mut(field),
                IssueType::Forbidden(Some(e)) => e.get_field_mut(field),
                IssueType::Incomplete(Some(e)) => e.get_field_mut(field),
                IssueType::Informational(Some(e)) => e.get_field_mut(field),
                IssueType::Invalid(Some(e)) => e.get_field_mut(field),
                IssueType::Invariant(Some(e)) => e.get_field_mut(field),
                IssueType::LockError(Some(e)) => e.get_field_mut(field),
                IssueType::Login(Some(e)) => e.get_field_mut(field),
                IssueType::MultipleMatches(Some(e)) => e.get_field_mut(field),
                IssueType::NoStore(Some(e)) => e.get_field_mut(field),
                IssueType::NotFound(Some(e)) => e.get_field_mut(field),
                IssueType::NotSupported(Some(e)) => e.get_field_mut(field),
                IssueType::Processing(Some(e)) => e.get_field_mut(field),
                IssueType::Required(Some(e)) => e.get_field_mut(field),
                IssueType::Security(Some(e)) => e.get_field_mut(field),
                IssueType::Structure(Some(e)) => e.get_field_mut(field),
                IssueType::Suppressed(Some(e)) => e.get_field_mut(field),
                IssueType::Throttled(Some(e)) => e.get_field_mut(field),
                IssueType::Timeout(Some(e)) => e.get_field_mut(field),
                IssueType::TooCostly(Some(e)) => e.get_field_mut(field),
                IssueType::TooLong(Some(e)) => e.get_field_mut(field),
                IssueType::Transient(Some(e)) => e.get_field_mut(field),
                IssueType::Unknown(Some(e)) => e.get_field_mut(field),
                IssueType::Value(Some(e)) => e.get_field_mut(field),
                IssueType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ItemType {
    #[doc = "Attachment"]
    #[code = "attachment"]
    Attachment(Option<Element>),
    #[doc = "Boolean"]
    #[code = "boolean"]
    Boolean(Option<Element>),
    #[doc = "Choice"]
    #[code = "choice"]
    Choice(Option<Element>),
    #[doc = "Date"]
    #[code = "date"]
    Date(Option<Element>),
    #[doc = "Date Time"]
    #[code = "dateTime"]
    DateTime(Option<Element>),
    #[doc = "Decimal"]
    #[code = "decimal"]
    Decimal(Option<Element>),
    #[doc = "Display"]
    #[code = "display"]
    Display(Option<Element>),
    #[doc = "Group"]
    #[code = "group"]
    Group(Option<Element>),
    #[doc = "Integer"]
    #[code = "integer"]
    Integer(Option<Element>),
    #[doc = "Open Choice"]
    #[code = "open-choice"]
    OpenChoice(Option<Element>),
    #[doc = "Quantity"]
    #[code = "quantity"]
    Quantity(Option<Element>),
    #[doc = "Question"]
    #[code = "question"]
    Question(Option<Element>),
    #[doc = "Reference"]
    #[code = "reference"]
    Reference(Option<Element>),
    #[doc = "String"]
    #[code = "string"]
    String(Option<Element>),
    #[doc = "Text"]
    #[code = "text"]
    Text(Option<Element>),
    #[doc = "Time"]
    #[code = "time"]
    Time(Option<Element>),
    #[doc = "Url"]
    #[code = "url"]
    Url(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ItemType {
    fn default() -> Self {
        ItemType::Null(None)
    }
}
impl TryFrom<String> for ItemType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "attachment" => Ok(ItemType::Attachment(None)),
            "boolean" => Ok(ItemType::Boolean(None)),
            "choice" => Ok(ItemType::Choice(None)),
            "date" => Ok(ItemType::Date(None)),
            "dateTime" => Ok(ItemType::DateTime(None)),
            "decimal" => Ok(ItemType::Decimal(None)),
            "display" => Ok(ItemType::Display(None)),
            "group" => Ok(ItemType::Group(None)),
            "integer" => Ok(ItemType::Integer(None)),
            "open-choice" => Ok(ItemType::OpenChoice(None)),
            "quantity" => Ok(ItemType::Quantity(None)),
            "question" => Ok(ItemType::Question(None)),
            "reference" => Ok(ItemType::Reference(None)),
            "string" => Ok(ItemType::String(None)),
            "text" => Ok(ItemType::Text(None)),
            "time" => Ok(ItemType::Time(None)),
            "url" => Ok(ItemType::Url(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ItemType {
    fn into(self) -> Option<String> {
        match self {
            ItemType::Attachment(_) => Some("attachment".to_string()),
            ItemType::Boolean(_) => Some("boolean".to_string()),
            ItemType::Choice(_) => Some("choice".to_string()),
            ItemType::Date(_) => Some("date".to_string()),
            ItemType::DateTime(_) => Some("dateTime".to_string()),
            ItemType::Decimal(_) => Some("decimal".to_string()),
            ItemType::Display(_) => Some("display".to_string()),
            ItemType::Group(_) => Some("group".to_string()),
            ItemType::Integer(_) => Some("integer".to_string()),
            ItemType::OpenChoice(_) => Some("open-choice".to_string()),
            ItemType::Quantity(_) => Some("quantity".to_string()),
            ItemType::Question(_) => Some("question".to_string()),
            ItemType::Reference(_) => Some("reference".to_string()),
            ItemType::String(_) => Some("string".to_string()),
            ItemType::Text(_) => Some("text".to_string()),
            ItemType::Time(_) => Some("time".to_string()),
            ItemType::Url(_) => Some("url".to_string()),
            ItemType::Null(_) => None,
        }
    }
}
impl MetaValue for ItemType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ItemType::Attachment(Some(e)) => e.get_field(field),
                ItemType::Boolean(Some(e)) => e.get_field(field),
                ItemType::Choice(Some(e)) => e.get_field(field),
                ItemType::Date(Some(e)) => e.get_field(field),
                ItemType::DateTime(Some(e)) => e.get_field(field),
                ItemType::Decimal(Some(e)) => e.get_field(field),
                ItemType::Display(Some(e)) => e.get_field(field),
                ItemType::Group(Some(e)) => e.get_field(field),
                ItemType::Integer(Some(e)) => e.get_field(field),
                ItemType::OpenChoice(Some(e)) => e.get_field(field),
                ItemType::Quantity(Some(e)) => e.get_field(field),
                ItemType::Question(Some(e)) => e.get_field(field),
                ItemType::Reference(Some(e)) => e.get_field(field),
                ItemType::String(Some(e)) => e.get_field(field),
                ItemType::Text(Some(e)) => e.get_field(field),
                ItemType::Time(Some(e)) => e.get_field(field),
                ItemType::Url(Some(e)) => e.get_field(field),
                ItemType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ItemType::Attachment(Some(e)) => e.get_field_mut(field),
                ItemType::Boolean(Some(e)) => e.get_field_mut(field),
                ItemType::Choice(Some(e)) => e.get_field_mut(field),
                ItemType::Date(Some(e)) => e.get_field_mut(field),
                ItemType::DateTime(Some(e)) => e.get_field_mut(field),
                ItemType::Decimal(Some(e)) => e.get_field_mut(field),
                ItemType::Display(Some(e)) => e.get_field_mut(field),
                ItemType::Group(Some(e)) => e.get_field_mut(field),
                ItemType::Integer(Some(e)) => e.get_field_mut(field),
                ItemType::OpenChoice(Some(e)) => e.get_field_mut(field),
                ItemType::Quantity(Some(e)) => e.get_field_mut(field),
                ItemType::Question(Some(e)) => e.get_field_mut(field),
                ItemType::Reference(Some(e)) => e.get_field_mut(field),
                ItemType::String(Some(e)) => e.get_field_mut(field),
                ItemType::Text(Some(e)) => e.get_field_mut(field),
                ItemType::Time(Some(e)) => e.get_field_mut(field),
                ItemType::Url(Some(e)) => e.get_field_mut(field),
                ItemType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum KnowledgeResourceTypes {
    #[doc = "ActivityDefinition"]
    #[code = "ActivityDefinition"]
    ActivityDefinition(Option<Element>),
    #[doc = "CodeSystem"]
    #[code = "CodeSystem"]
    CodeSystem(Option<Element>),
    #[doc = "ConceptMap"]
    #[code = "ConceptMap"]
    ConceptMap(Option<Element>),
    #[doc = "Library"]
    #[code = "Library"]
    Library(Option<Element>),
    #[doc = "Measure"]
    #[code = "Measure"]
    Measure(Option<Element>),
    #[doc = "PlanDefinition"]
    #[code = "PlanDefinition"]
    PlanDefinition(Option<Element>),
    #[doc = "StructureDefinition"]
    #[code = "StructureDefinition"]
    StructureDefinition(Option<Element>),
    #[doc = "StructureMap"]
    #[code = "StructureMap"]
    StructureMap(Option<Element>),
    #[doc = "ValueSet"]
    #[code = "ValueSet"]
    ValueSet(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for KnowledgeResourceTypes {
    fn default() -> Self {
        KnowledgeResourceTypes::Null(None)
    }
}
impl TryFrom<String> for KnowledgeResourceTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ActivityDefinition" => Ok(KnowledgeResourceTypes::ActivityDefinition(None)),
            "CodeSystem" => Ok(KnowledgeResourceTypes::CodeSystem(None)),
            "ConceptMap" => Ok(KnowledgeResourceTypes::ConceptMap(None)),
            "Library" => Ok(KnowledgeResourceTypes::Library(None)),
            "Measure" => Ok(KnowledgeResourceTypes::Measure(None)),
            "PlanDefinition" => Ok(KnowledgeResourceTypes::PlanDefinition(None)),
            "StructureDefinition" => Ok(KnowledgeResourceTypes::StructureDefinition(None)),
            "StructureMap" => Ok(KnowledgeResourceTypes::StructureMap(None)),
            "ValueSet" => Ok(KnowledgeResourceTypes::ValueSet(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &KnowledgeResourceTypes {
    fn into(self) -> Option<String> {
        match self {
            KnowledgeResourceTypes::ActivityDefinition(_) => Some("ActivityDefinition".to_string()),
            KnowledgeResourceTypes::CodeSystem(_) => Some("CodeSystem".to_string()),
            KnowledgeResourceTypes::ConceptMap(_) => Some("ConceptMap".to_string()),
            KnowledgeResourceTypes::Library(_) => Some("Library".to_string()),
            KnowledgeResourceTypes::Measure(_) => Some("Measure".to_string()),
            KnowledgeResourceTypes::PlanDefinition(_) => Some("PlanDefinition".to_string()),
            KnowledgeResourceTypes::StructureDefinition(_) => {
                Some("StructureDefinition".to_string())
            }
            KnowledgeResourceTypes::StructureMap(_) => Some("StructureMap".to_string()),
            KnowledgeResourceTypes::ValueSet(_) => Some("ValueSet".to_string()),
            KnowledgeResourceTypes::Null(_) => None,
        }
    }
}
impl MetaValue for KnowledgeResourceTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                KnowledgeResourceTypes::ActivityDefinition(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::CodeSystem(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::ConceptMap(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::Library(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::Measure(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::PlanDefinition(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::StructureDefinition(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::StructureMap(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::ValueSet(Some(e)) => e.get_field(field),
                KnowledgeResourceTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                KnowledgeResourceTypes::ActivityDefinition(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::CodeSystem(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::ConceptMap(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::Library(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::Measure(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::PlanDefinition(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::StructureDefinition(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::StructureMap(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::ValueSet(Some(e)) => e.get_field_mut(field),
                KnowledgeResourceTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LanguagePreferenceType {
    #[doc = "verbal"]
    #[code = "verbal"]
    Verbal(Option<Element>),
    #[doc = "written"]
    #[code = "written"]
    Written(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LanguagePreferenceType {
    fn default() -> Self {
        LanguagePreferenceType::Null(None)
    }
}
impl TryFrom<String> for LanguagePreferenceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "verbal" => Ok(LanguagePreferenceType::Verbal(None)),
            "written" => Ok(LanguagePreferenceType::Written(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LanguagePreferenceType {
    fn into(self) -> Option<String> {
        match self {
            LanguagePreferenceType::Verbal(_) => Some("verbal".to_string()),
            LanguagePreferenceType::Written(_) => Some("written".to_string()),
            LanguagePreferenceType::Null(_) => None,
        }
    }
}
impl MetaValue for LanguagePreferenceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LanguagePreferenceType::Verbal(Some(e)) => e.get_field(field),
                LanguagePreferenceType::Written(Some(e)) => e.get_field(field),
                LanguagePreferenceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LanguagePreferenceType::Verbal(Some(e)) => e.get_field_mut(field),
                LanguagePreferenceType::Written(Some(e)) => e.get_field_mut(field),
                LanguagePreferenceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Languages {
    #[doc = "Arabic"]
    #[code = "ar"]
    Ar(Option<Element>),
    #[doc = "Bengali"]
    #[code = "bn"]
    Bn(Option<Element>),
    #[doc = "Czech"]
    #[code = "cs"]
    Cs(Option<Element>),
    #[doc = "Danish"]
    #[code = "da"]
    Da(Option<Element>),
    #[doc = "German"]
    #[code = "de"]
    De(Option<Element>),
    #[doc = "German (Austria)"]
    #[code = "de-AT"]
    DeAT(Option<Element>),
    #[doc = "German (Switzerland)"]
    #[code = "de-CH"]
    DeCH(Option<Element>),
    #[doc = "German (Germany)"]
    #[code = "de-DE"]
    DeDE(Option<Element>),
    #[doc = "Greek"]
    #[code = "el"]
    El(Option<Element>),
    #[doc = "English"]
    #[code = "en"]
    En(Option<Element>),
    #[doc = "English (Australia)"]
    #[code = "en-AU"]
    EnAU(Option<Element>),
    #[doc = "English (Canada)"]
    #[code = "en-CA"]
    EnCA(Option<Element>),
    #[doc = "English (Great Britain)"]
    #[code = "en-GB"]
    EnGB(Option<Element>),
    #[doc = "English (India)"]
    #[code = "en-IN"]
    EnIN(Option<Element>),
    #[doc = "English (New Zeland)"]
    #[code = "en-NZ"]
    EnNZ(Option<Element>),
    #[doc = "English (Singapore)"]
    #[code = "en-SG"]
    EnSG(Option<Element>),
    #[doc = "English (United States)"]
    #[code = "en-US"]
    EnUS(Option<Element>),
    #[doc = "Spanish"]
    #[code = "es"]
    Es(Option<Element>),
    #[doc = "Spanish (Argentina)"]
    #[code = "es-AR"]
    EsAR(Option<Element>),
    #[doc = "Spanish (Spain)"]
    #[code = "es-ES"]
    EsES(Option<Element>),
    #[doc = "Spanish (Uruguay)"]
    #[code = "es-UY"]
    EsUY(Option<Element>),
    #[doc = "Finnish"]
    #[code = "fi"]
    Fi(Option<Element>),
    #[doc = "French"]
    #[code = "fr"]
    Fr(Option<Element>),
    #[doc = "French (Belgium)"]
    #[code = "fr-BE"]
    FrBE(Option<Element>),
    #[doc = "French (Switzerland)"]
    #[code = "fr-CH"]
    FrCH(Option<Element>),
    #[doc = "French (France)"]
    #[code = "fr-FR"]
    FrFR(Option<Element>),
    #[doc = "Frysian"]
    #[code = "fy"]
    Fy(Option<Element>),
    #[doc = "Frysian (Netherlands)"]
    #[code = "fy-NL"]
    FyNL(Option<Element>),
    #[doc = "Hindi"]
    #[code = "hi"]
    Hi(Option<Element>),
    #[doc = "Croatian"]
    #[code = "hr"]
    Hr(Option<Element>),
    #[doc = "Italian"]
    #[code = "it"]
    It(Option<Element>),
    #[doc = "Italian (Switzerland)"]
    #[code = "it-CH"]
    ItCH(Option<Element>),
    #[doc = "Italian (Italy)"]
    #[code = "it-IT"]
    ItIT(Option<Element>),
    #[doc = "Japanese"]
    #[code = "ja"]
    Ja(Option<Element>),
    #[doc = "Korean"]
    #[code = "ko"]
    Ko(Option<Element>),
    #[doc = "Dutch"]
    #[code = "nl"]
    Nl(Option<Element>),
    #[doc = "Dutch (Belgium)"]
    #[code = "nl-BE"]
    NlBE(Option<Element>),
    #[doc = "Dutch (Netherlands)"]
    #[code = "nl-NL"]
    NlNL(Option<Element>),
    #[doc = "Norwegian"]
    #[code = "no"]
    No(Option<Element>),
    #[doc = "Norwegian (Norway)"]
    #[code = "no-NO"]
    NoNO(Option<Element>),
    #[doc = "Punjabi"]
    #[code = "pa"]
    Pa(Option<Element>),
    #[doc = "Polish"]
    #[code = "pl"]
    Pl(Option<Element>),
    #[doc = "Portuguese"]
    #[code = "pt"]
    Pt(Option<Element>),
    #[doc = "Portuguese (Brazil)"]
    #[code = "pt-BR"]
    PtBR(Option<Element>),
    #[doc = "Russian"]
    #[code = "ru"]
    Ru(Option<Element>),
    #[doc = "Russian (Russia)"]
    #[code = "ru-RU"]
    RuRU(Option<Element>),
    #[doc = "Serbian"]
    #[code = "sr"]
    Sr(Option<Element>),
    #[doc = "Serbian (Serbia)"]
    #[code = "sr-RS"]
    SrRS(Option<Element>),
    #[doc = "Swedish"]
    #[code = "sv"]
    Sv(Option<Element>),
    #[doc = "Swedish (Sweden)"]
    #[code = "sv-SE"]
    SvSE(Option<Element>),
    #[doc = "Telegu"]
    #[code = "te"]
    Te(Option<Element>),
    #[doc = "Chinese"]
    #[code = "zh"]
    Zh(Option<Element>),
    #[doc = "Chinese (China)"]
    #[code = "zh-CN"]
    ZhCN(Option<Element>),
    #[doc = "Chinese (Hong Kong)"]
    #[code = "zh-HK"]
    ZhHK(Option<Element>),
    #[doc = "Chinese (Singapore)"]
    #[code = "zh-SG"]
    ZhSG(Option<Element>),
    #[doc = "Chinese (Taiwan)"]
    #[code = "zh-TW"]
    ZhTW(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Languages {
    fn default() -> Self {
        Languages::Null(None)
    }
}
impl TryFrom<String> for Languages {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ar" => Ok(Languages::Ar(None)),
            "bn" => Ok(Languages::Bn(None)),
            "cs" => Ok(Languages::Cs(None)),
            "da" => Ok(Languages::Da(None)),
            "de" => Ok(Languages::De(None)),
            "de-AT" => Ok(Languages::DeAT(None)),
            "de-CH" => Ok(Languages::DeCH(None)),
            "de-DE" => Ok(Languages::DeDE(None)),
            "el" => Ok(Languages::El(None)),
            "en" => Ok(Languages::En(None)),
            "en-AU" => Ok(Languages::EnAU(None)),
            "en-CA" => Ok(Languages::EnCA(None)),
            "en-GB" => Ok(Languages::EnGB(None)),
            "en-IN" => Ok(Languages::EnIN(None)),
            "en-NZ" => Ok(Languages::EnNZ(None)),
            "en-SG" => Ok(Languages::EnSG(None)),
            "en-US" => Ok(Languages::EnUS(None)),
            "es" => Ok(Languages::Es(None)),
            "es-AR" => Ok(Languages::EsAR(None)),
            "es-ES" => Ok(Languages::EsES(None)),
            "es-UY" => Ok(Languages::EsUY(None)),
            "fi" => Ok(Languages::Fi(None)),
            "fr" => Ok(Languages::Fr(None)),
            "fr-BE" => Ok(Languages::FrBE(None)),
            "fr-CH" => Ok(Languages::FrCH(None)),
            "fr-FR" => Ok(Languages::FrFR(None)),
            "fy" => Ok(Languages::Fy(None)),
            "fy-NL" => Ok(Languages::FyNL(None)),
            "hi" => Ok(Languages::Hi(None)),
            "hr" => Ok(Languages::Hr(None)),
            "it" => Ok(Languages::It(None)),
            "it-CH" => Ok(Languages::ItCH(None)),
            "it-IT" => Ok(Languages::ItIT(None)),
            "ja" => Ok(Languages::Ja(None)),
            "ko" => Ok(Languages::Ko(None)),
            "nl" => Ok(Languages::Nl(None)),
            "nl-BE" => Ok(Languages::NlBE(None)),
            "nl-NL" => Ok(Languages::NlNL(None)),
            "no" => Ok(Languages::No(None)),
            "no-NO" => Ok(Languages::NoNO(None)),
            "pa" => Ok(Languages::Pa(None)),
            "pl" => Ok(Languages::Pl(None)),
            "pt" => Ok(Languages::Pt(None)),
            "pt-BR" => Ok(Languages::PtBR(None)),
            "ru" => Ok(Languages::Ru(None)),
            "ru-RU" => Ok(Languages::RuRU(None)),
            "sr" => Ok(Languages::Sr(None)),
            "sr-RS" => Ok(Languages::SrRS(None)),
            "sv" => Ok(Languages::Sv(None)),
            "sv-SE" => Ok(Languages::SvSE(None)),
            "te" => Ok(Languages::Te(None)),
            "zh" => Ok(Languages::Zh(None)),
            "zh-CN" => Ok(Languages::ZhCN(None)),
            "zh-HK" => Ok(Languages::ZhHK(None)),
            "zh-SG" => Ok(Languages::ZhSG(None)),
            "zh-TW" => Ok(Languages::ZhTW(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Languages {
    fn into(self) -> Option<String> {
        match self {
            Languages::Ar(_) => Some("ar".to_string()),
            Languages::Bn(_) => Some("bn".to_string()),
            Languages::Cs(_) => Some("cs".to_string()),
            Languages::Da(_) => Some("da".to_string()),
            Languages::De(_) => Some("de".to_string()),
            Languages::DeAT(_) => Some("de-AT".to_string()),
            Languages::DeCH(_) => Some("de-CH".to_string()),
            Languages::DeDE(_) => Some("de-DE".to_string()),
            Languages::El(_) => Some("el".to_string()),
            Languages::En(_) => Some("en".to_string()),
            Languages::EnAU(_) => Some("en-AU".to_string()),
            Languages::EnCA(_) => Some("en-CA".to_string()),
            Languages::EnGB(_) => Some("en-GB".to_string()),
            Languages::EnIN(_) => Some("en-IN".to_string()),
            Languages::EnNZ(_) => Some("en-NZ".to_string()),
            Languages::EnSG(_) => Some("en-SG".to_string()),
            Languages::EnUS(_) => Some("en-US".to_string()),
            Languages::Es(_) => Some("es".to_string()),
            Languages::EsAR(_) => Some("es-AR".to_string()),
            Languages::EsES(_) => Some("es-ES".to_string()),
            Languages::EsUY(_) => Some("es-UY".to_string()),
            Languages::Fi(_) => Some("fi".to_string()),
            Languages::Fr(_) => Some("fr".to_string()),
            Languages::FrBE(_) => Some("fr-BE".to_string()),
            Languages::FrCH(_) => Some("fr-CH".to_string()),
            Languages::FrFR(_) => Some("fr-FR".to_string()),
            Languages::Fy(_) => Some("fy".to_string()),
            Languages::FyNL(_) => Some("fy-NL".to_string()),
            Languages::Hi(_) => Some("hi".to_string()),
            Languages::Hr(_) => Some("hr".to_string()),
            Languages::It(_) => Some("it".to_string()),
            Languages::ItCH(_) => Some("it-CH".to_string()),
            Languages::ItIT(_) => Some("it-IT".to_string()),
            Languages::Ja(_) => Some("ja".to_string()),
            Languages::Ko(_) => Some("ko".to_string()),
            Languages::Nl(_) => Some("nl".to_string()),
            Languages::NlBE(_) => Some("nl-BE".to_string()),
            Languages::NlNL(_) => Some("nl-NL".to_string()),
            Languages::No(_) => Some("no".to_string()),
            Languages::NoNO(_) => Some("no-NO".to_string()),
            Languages::Pa(_) => Some("pa".to_string()),
            Languages::Pl(_) => Some("pl".to_string()),
            Languages::Pt(_) => Some("pt".to_string()),
            Languages::PtBR(_) => Some("pt-BR".to_string()),
            Languages::Ru(_) => Some("ru".to_string()),
            Languages::RuRU(_) => Some("ru-RU".to_string()),
            Languages::Sr(_) => Some("sr".to_string()),
            Languages::SrRS(_) => Some("sr-RS".to_string()),
            Languages::Sv(_) => Some("sv".to_string()),
            Languages::SvSE(_) => Some("sv-SE".to_string()),
            Languages::Te(_) => Some("te".to_string()),
            Languages::Zh(_) => Some("zh".to_string()),
            Languages::ZhCN(_) => Some("zh-CN".to_string()),
            Languages::ZhHK(_) => Some("zh-HK".to_string()),
            Languages::ZhSG(_) => Some("zh-SG".to_string()),
            Languages::ZhTW(_) => Some("zh-TW".to_string()),
            Languages::Null(_) => None,
        }
    }
}
impl MetaValue for Languages {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Languages::Ar(Some(e)) => e.get_field(field),
                Languages::Bn(Some(e)) => e.get_field(field),
                Languages::Cs(Some(e)) => e.get_field(field),
                Languages::Da(Some(e)) => e.get_field(field),
                Languages::De(Some(e)) => e.get_field(field),
                Languages::DeAT(Some(e)) => e.get_field(field),
                Languages::DeCH(Some(e)) => e.get_field(field),
                Languages::DeDE(Some(e)) => e.get_field(field),
                Languages::El(Some(e)) => e.get_field(field),
                Languages::En(Some(e)) => e.get_field(field),
                Languages::EnAU(Some(e)) => e.get_field(field),
                Languages::EnCA(Some(e)) => e.get_field(field),
                Languages::EnGB(Some(e)) => e.get_field(field),
                Languages::EnIN(Some(e)) => e.get_field(field),
                Languages::EnNZ(Some(e)) => e.get_field(field),
                Languages::EnSG(Some(e)) => e.get_field(field),
                Languages::EnUS(Some(e)) => e.get_field(field),
                Languages::Es(Some(e)) => e.get_field(field),
                Languages::EsAR(Some(e)) => e.get_field(field),
                Languages::EsES(Some(e)) => e.get_field(field),
                Languages::EsUY(Some(e)) => e.get_field(field),
                Languages::Fi(Some(e)) => e.get_field(field),
                Languages::Fr(Some(e)) => e.get_field(field),
                Languages::FrBE(Some(e)) => e.get_field(field),
                Languages::FrCH(Some(e)) => e.get_field(field),
                Languages::FrFR(Some(e)) => e.get_field(field),
                Languages::Fy(Some(e)) => e.get_field(field),
                Languages::FyNL(Some(e)) => e.get_field(field),
                Languages::Hi(Some(e)) => e.get_field(field),
                Languages::Hr(Some(e)) => e.get_field(field),
                Languages::It(Some(e)) => e.get_field(field),
                Languages::ItCH(Some(e)) => e.get_field(field),
                Languages::ItIT(Some(e)) => e.get_field(field),
                Languages::Ja(Some(e)) => e.get_field(field),
                Languages::Ko(Some(e)) => e.get_field(field),
                Languages::Nl(Some(e)) => e.get_field(field),
                Languages::NlBE(Some(e)) => e.get_field(field),
                Languages::NlNL(Some(e)) => e.get_field(field),
                Languages::No(Some(e)) => e.get_field(field),
                Languages::NoNO(Some(e)) => e.get_field(field),
                Languages::Pa(Some(e)) => e.get_field(field),
                Languages::Pl(Some(e)) => e.get_field(field),
                Languages::Pt(Some(e)) => e.get_field(field),
                Languages::PtBR(Some(e)) => e.get_field(field),
                Languages::Ru(Some(e)) => e.get_field(field),
                Languages::RuRU(Some(e)) => e.get_field(field),
                Languages::Sr(Some(e)) => e.get_field(field),
                Languages::SrRS(Some(e)) => e.get_field(field),
                Languages::Sv(Some(e)) => e.get_field(field),
                Languages::SvSE(Some(e)) => e.get_field(field),
                Languages::Te(Some(e)) => e.get_field(field),
                Languages::Zh(Some(e)) => e.get_field(field),
                Languages::ZhCN(Some(e)) => e.get_field(field),
                Languages::ZhHK(Some(e)) => e.get_field(field),
                Languages::ZhSG(Some(e)) => e.get_field(field),
                Languages::ZhTW(Some(e)) => e.get_field(field),
                Languages::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Languages::Ar(Some(e)) => e.get_field_mut(field),
                Languages::Bn(Some(e)) => e.get_field_mut(field),
                Languages::Cs(Some(e)) => e.get_field_mut(field),
                Languages::Da(Some(e)) => e.get_field_mut(field),
                Languages::De(Some(e)) => e.get_field_mut(field),
                Languages::DeAT(Some(e)) => e.get_field_mut(field),
                Languages::DeCH(Some(e)) => e.get_field_mut(field),
                Languages::DeDE(Some(e)) => e.get_field_mut(field),
                Languages::El(Some(e)) => e.get_field_mut(field),
                Languages::En(Some(e)) => e.get_field_mut(field),
                Languages::EnAU(Some(e)) => e.get_field_mut(field),
                Languages::EnCA(Some(e)) => e.get_field_mut(field),
                Languages::EnGB(Some(e)) => e.get_field_mut(field),
                Languages::EnIN(Some(e)) => e.get_field_mut(field),
                Languages::EnNZ(Some(e)) => e.get_field_mut(field),
                Languages::EnSG(Some(e)) => e.get_field_mut(field),
                Languages::EnUS(Some(e)) => e.get_field_mut(field),
                Languages::Es(Some(e)) => e.get_field_mut(field),
                Languages::EsAR(Some(e)) => e.get_field_mut(field),
                Languages::EsES(Some(e)) => e.get_field_mut(field),
                Languages::EsUY(Some(e)) => e.get_field_mut(field),
                Languages::Fi(Some(e)) => e.get_field_mut(field),
                Languages::Fr(Some(e)) => e.get_field_mut(field),
                Languages::FrBE(Some(e)) => e.get_field_mut(field),
                Languages::FrCH(Some(e)) => e.get_field_mut(field),
                Languages::FrFR(Some(e)) => e.get_field_mut(field),
                Languages::Fy(Some(e)) => e.get_field_mut(field),
                Languages::FyNL(Some(e)) => e.get_field_mut(field),
                Languages::Hi(Some(e)) => e.get_field_mut(field),
                Languages::Hr(Some(e)) => e.get_field_mut(field),
                Languages::It(Some(e)) => e.get_field_mut(field),
                Languages::ItCH(Some(e)) => e.get_field_mut(field),
                Languages::ItIT(Some(e)) => e.get_field_mut(field),
                Languages::Ja(Some(e)) => e.get_field_mut(field),
                Languages::Ko(Some(e)) => e.get_field_mut(field),
                Languages::Nl(Some(e)) => e.get_field_mut(field),
                Languages::NlBE(Some(e)) => e.get_field_mut(field),
                Languages::NlNL(Some(e)) => e.get_field_mut(field),
                Languages::No(Some(e)) => e.get_field_mut(field),
                Languages::NoNO(Some(e)) => e.get_field_mut(field),
                Languages::Pa(Some(e)) => e.get_field_mut(field),
                Languages::Pl(Some(e)) => e.get_field_mut(field),
                Languages::Pt(Some(e)) => e.get_field_mut(field),
                Languages::PtBR(Some(e)) => e.get_field_mut(field),
                Languages::Ru(Some(e)) => e.get_field_mut(field),
                Languages::RuRU(Some(e)) => e.get_field_mut(field),
                Languages::Sr(Some(e)) => e.get_field_mut(field),
                Languages::SrRS(Some(e)) => e.get_field_mut(field),
                Languages::Sv(Some(e)) => e.get_field_mut(field),
                Languages::SvSE(Some(e)) => e.get_field_mut(field),
                Languages::Te(Some(e)) => e.get_field_mut(field),
                Languages::Zh(Some(e)) => e.get_field_mut(field),
                Languages::ZhCN(Some(e)) => e.get_field_mut(field),
                Languages::ZhHK(Some(e)) => e.get_field_mut(field),
                Languages::ZhSG(Some(e)) => e.get_field_mut(field),
                Languages::ZhTW(Some(e)) => e.get_field_mut(field),
                Languages::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LdlcholesterolCodes {
    #[doc = "Cholesterol in LDL [Mass/volume] in Serum or Plasma by calculation"]
    #[code = "13457-7"]
    V134577(Option<Element>),
    #[doc = "LDL Cholesterol (Assay)"]
    #[code = "18262-6"]
    V182626(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LdlcholesterolCodes {
    fn default() -> Self {
        LdlcholesterolCodes::Null(None)
    }
}
impl TryFrom<String> for LdlcholesterolCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "13457-7" => Ok(LdlcholesterolCodes::V134577(None)),
            "18262-6" => Ok(LdlcholesterolCodes::V182626(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LdlcholesterolCodes {
    fn into(self) -> Option<String> {
        match self {
            LdlcholesterolCodes::V134577(_) => Some("13457-7".to_string()),
            LdlcholesterolCodes::V182626(_) => Some("18262-6".to_string()),
            LdlcholesterolCodes::Null(_) => None,
        }
    }
}
impl MetaValue for LdlcholesterolCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LdlcholesterolCodes::V134577(Some(e)) => e.get_field(field),
                LdlcholesterolCodes::V182626(Some(e)) => e.get_field(field),
                LdlcholesterolCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LdlcholesterolCodes::V134577(Some(e)) => e.get_field_mut(field),
                LdlcholesterolCodes::V182626(Some(e)) => e.get_field_mut(field),
                LdlcholesterolCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LibraryType {
    #[doc = "Asset Collection"]
    #[code = "asset-collection"]
    AssetCollection(Option<Element>),
    #[doc = "Logic Library"]
    #[code = "logic-library"]
    LogicLibrary(Option<Element>),
    #[doc = "Model Definition"]
    #[code = "model-definition"]
    ModelDefinition(Option<Element>),
    #[doc = "Module Definition"]
    #[code = "module-definition"]
    ModuleDefinition(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LibraryType {
    fn default() -> Self {
        LibraryType::Null(None)
    }
}
impl TryFrom<String> for LibraryType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "asset-collection" => Ok(LibraryType::AssetCollection(None)),
            "logic-library" => Ok(LibraryType::LogicLibrary(None)),
            "model-definition" => Ok(LibraryType::ModelDefinition(None)),
            "module-definition" => Ok(LibraryType::ModuleDefinition(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LibraryType {
    fn into(self) -> Option<String> {
        match self {
            LibraryType::AssetCollection(_) => Some("asset-collection".to_string()),
            LibraryType::LogicLibrary(_) => Some("logic-library".to_string()),
            LibraryType::ModelDefinition(_) => Some("model-definition".to_string()),
            LibraryType::ModuleDefinition(_) => Some("module-definition".to_string()),
            LibraryType::Null(_) => None,
        }
    }
}
impl MetaValue for LibraryType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LibraryType::AssetCollection(Some(e)) => e.get_field(field),
                LibraryType::LogicLibrary(Some(e)) => e.get_field(field),
                LibraryType::ModelDefinition(Some(e)) => e.get_field(field),
                LibraryType::ModuleDefinition(Some(e)) => e.get_field(field),
                LibraryType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LibraryType::AssetCollection(Some(e)) => e.get_field_mut(field),
                LibraryType::LogicLibrary(Some(e)) => e.get_field_mut(field),
                LibraryType::ModelDefinition(Some(e)) => e.get_field_mut(field),
                LibraryType::ModuleDefinition(Some(e)) => e.get_field_mut(field),
                LibraryType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LinkType {
    #[doc = "Refer"]
    #[code = "refer"]
    Refer(Option<Element>),
    #[doc = "Replaced-by"]
    #[code = "replaced-by"]
    ReplacedBy(Option<Element>),
    #[doc = "Replaces"]
    #[code = "replaces"]
    Replaces(Option<Element>),
    #[doc = "See also"]
    #[code = "seealso"]
    Seealso(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LinkType {
    fn default() -> Self {
        LinkType::Null(None)
    }
}
impl TryFrom<String> for LinkType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "refer" => Ok(LinkType::Refer(None)),
            "replaced-by" => Ok(LinkType::ReplacedBy(None)),
            "replaces" => Ok(LinkType::Replaces(None)),
            "seealso" => Ok(LinkType::Seealso(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LinkType {
    fn into(self) -> Option<String> {
        match self {
            LinkType::Refer(_) => Some("refer".to_string()),
            LinkType::ReplacedBy(_) => Some("replaced-by".to_string()),
            LinkType::Replaces(_) => Some("replaces".to_string()),
            LinkType::Seealso(_) => Some("seealso".to_string()),
            LinkType::Null(_) => None,
        }
    }
}
impl MetaValue for LinkType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LinkType::Refer(Some(e)) => e.get_field(field),
                LinkType::ReplacedBy(Some(e)) => e.get_field(field),
                LinkType::Replaces(Some(e)) => e.get_field(field),
                LinkType::Seealso(Some(e)) => e.get_field(field),
                LinkType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LinkType::Refer(Some(e)) => e.get_field_mut(field),
                LinkType::ReplacedBy(Some(e)) => e.get_field_mut(field),
                LinkType::Replaces(Some(e)) => e.get_field_mut(field),
                LinkType::Seealso(Some(e)) => e.get_field_mut(field),
                LinkType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LinkageType {
    #[doc = "Alternate Record"]
    #[code = "alternate"]
    Alternate(Option<Element>),
    #[doc = "Historical/Obsolete Record"]
    #[code = "historical"]
    Historical(Option<Element>),
    #[doc = "Source of Truth"]
    #[code = "source"]
    Source(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LinkageType {
    fn default() -> Self {
        LinkageType::Null(None)
    }
}
impl TryFrom<String> for LinkageType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alternate" => Ok(LinkageType::Alternate(None)),
            "historical" => Ok(LinkageType::Historical(None)),
            "source" => Ok(LinkageType::Source(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LinkageType {
    fn into(self) -> Option<String> {
        match self {
            LinkageType::Alternate(_) => Some("alternate".to_string()),
            LinkageType::Historical(_) => Some("historical".to_string()),
            LinkageType::Source(_) => Some("source".to_string()),
            LinkageType::Null(_) => None,
        }
    }
}
impl MetaValue for LinkageType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LinkageType::Alternate(Some(e)) => e.get_field(field),
                LinkageType::Historical(Some(e)) => e.get_field(field),
                LinkageType::Source(Some(e)) => e.get_field(field),
                LinkageType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LinkageType::Alternate(Some(e)) => e.get_field_mut(field),
                LinkageType::Historical(Some(e)) => e.get_field_mut(field),
                LinkageType::Source(Some(e)) => e.get_field_mut(field),
                LinkageType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListEmptyReason {
    #[doc = "Closed"]
    #[code = "closed"]
    Closed(Option<Element>),
    #[doc = "Nil Known"]
    #[code = "nilknown"]
    Nilknown(Option<Element>),
    #[doc = "Not Asked"]
    #[code = "notasked"]
    Notasked(Option<Element>),
    #[doc = "Not Started"]
    #[code = "notstarted"]
    Notstarted(Option<Element>),
    #[doc = "Unavailable"]
    #[code = "unavailable"]
    Unavailable(Option<Element>),
    #[doc = "Information Withheld"]
    #[code = "withheld"]
    Withheld(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListEmptyReason {
    fn default() -> Self {
        ListEmptyReason::Null(None)
    }
}
impl TryFrom<String> for ListEmptyReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "closed" => Ok(ListEmptyReason::Closed(None)),
            "nilknown" => Ok(ListEmptyReason::Nilknown(None)),
            "notasked" => Ok(ListEmptyReason::Notasked(None)),
            "notstarted" => Ok(ListEmptyReason::Notstarted(None)),
            "unavailable" => Ok(ListEmptyReason::Unavailable(None)),
            "withheld" => Ok(ListEmptyReason::Withheld(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListEmptyReason {
    fn into(self) -> Option<String> {
        match self {
            ListEmptyReason::Closed(_) => Some("closed".to_string()),
            ListEmptyReason::Nilknown(_) => Some("nilknown".to_string()),
            ListEmptyReason::Notasked(_) => Some("notasked".to_string()),
            ListEmptyReason::Notstarted(_) => Some("notstarted".to_string()),
            ListEmptyReason::Unavailable(_) => Some("unavailable".to_string()),
            ListEmptyReason::Withheld(_) => Some("withheld".to_string()),
            ListEmptyReason::Null(_) => None,
        }
    }
}
impl MetaValue for ListEmptyReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListEmptyReason::Closed(Some(e)) => e.get_field(field),
                ListEmptyReason::Nilknown(Some(e)) => e.get_field(field),
                ListEmptyReason::Notasked(Some(e)) => e.get_field(field),
                ListEmptyReason::Notstarted(Some(e)) => e.get_field(field),
                ListEmptyReason::Unavailable(Some(e)) => e.get_field(field),
                ListEmptyReason::Withheld(Some(e)) => e.get_field(field),
                ListEmptyReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListEmptyReason::Closed(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Nilknown(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Notasked(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Notstarted(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Unavailable(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Withheld(Some(e)) => e.get_field_mut(field),
                ListEmptyReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListExampleCodes {
    #[doc = "Adverse Reactions"]
    #[code = "adverserxns"]
    Adverserxns(Option<Element>),
    #[doc = "Alerts"]
    #[code = "alerts"]
    Alerts(Option<Element>),
    #[doc = "Allergies"]
    #[code = "allergies"]
    Allergies(Option<Element>),
    #[doc = "Medication List"]
    #[code = "medications"]
    Medications(Option<Element>),
    #[doc = "Care Plans"]
    #[code = "plans"]
    Plans(Option<Element>),
    #[doc = "Problem List"]
    #[code = "problems"]
    Problems(Option<Element>),
    #[doc = "Protocols"]
    #[code = "protocols"]
    Protocols(Option<Element>),
    #[doc = "Waiting List"]
    #[code = "waiting"]
    Waiting(Option<Element>),
    #[doc = "Worklist"]
    #[code = "worklist"]
    Worklist(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListExampleCodes {
    fn default() -> Self {
        ListExampleCodes::Null(None)
    }
}
impl TryFrom<String> for ListExampleCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "adverserxns" => Ok(ListExampleCodes::Adverserxns(None)),
            "alerts" => Ok(ListExampleCodes::Alerts(None)),
            "allergies" => Ok(ListExampleCodes::Allergies(None)),
            "medications" => Ok(ListExampleCodes::Medications(None)),
            "plans" => Ok(ListExampleCodes::Plans(None)),
            "problems" => Ok(ListExampleCodes::Problems(None)),
            "protocols" => Ok(ListExampleCodes::Protocols(None)),
            "waiting" => Ok(ListExampleCodes::Waiting(None)),
            "worklist" => Ok(ListExampleCodes::Worklist(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListExampleCodes {
    fn into(self) -> Option<String> {
        match self {
            ListExampleCodes::Adverserxns(_) => Some("adverserxns".to_string()),
            ListExampleCodes::Alerts(_) => Some("alerts".to_string()),
            ListExampleCodes::Allergies(_) => Some("allergies".to_string()),
            ListExampleCodes::Medications(_) => Some("medications".to_string()),
            ListExampleCodes::Plans(_) => Some("plans".to_string()),
            ListExampleCodes::Problems(_) => Some("problems".to_string()),
            ListExampleCodes::Protocols(_) => Some("protocols".to_string()),
            ListExampleCodes::Waiting(_) => Some("waiting".to_string()),
            ListExampleCodes::Worklist(_) => Some("worklist".to_string()),
            ListExampleCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ListExampleCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListExampleCodes::Adverserxns(Some(e)) => e.get_field(field),
                ListExampleCodes::Alerts(Some(e)) => e.get_field(field),
                ListExampleCodes::Allergies(Some(e)) => e.get_field(field),
                ListExampleCodes::Medications(Some(e)) => e.get_field(field),
                ListExampleCodes::Plans(Some(e)) => e.get_field(field),
                ListExampleCodes::Problems(Some(e)) => e.get_field(field),
                ListExampleCodes::Protocols(Some(e)) => e.get_field(field),
                ListExampleCodes::Waiting(Some(e)) => e.get_field(field),
                ListExampleCodes::Worklist(Some(e)) => e.get_field(field),
                ListExampleCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListExampleCodes::Adverserxns(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Alerts(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Allergies(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Medications(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Plans(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Problems(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Protocols(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Waiting(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Worklist(Some(e)) => e.get_field_mut(field),
                ListExampleCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListItemFlag {
    #[doc = "Unchanged"]
    #[code = "01"]
    V01(Option<Element>),
    #[doc = "Changed"]
    #[code = "02"]
    V02(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "03"]
    V03(Option<Element>),
    #[doc = "Prescribed"]
    #[code = "04"]
    V04(Option<Element>),
    #[doc = "Ceased"]
    #[code = "05"]
    V05(Option<Element>),
    #[doc = "Suspended"]
    #[code = "06"]
    V06(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListItemFlag {
    fn default() -> Self {
        ListItemFlag::Null(None)
    }
}
impl TryFrom<String> for ListItemFlag {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "01" => Ok(ListItemFlag::V01(None)),
            "02" => Ok(ListItemFlag::V02(None)),
            "03" => Ok(ListItemFlag::V03(None)),
            "04" => Ok(ListItemFlag::V04(None)),
            "05" => Ok(ListItemFlag::V05(None)),
            "06" => Ok(ListItemFlag::V06(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListItemFlag {
    fn into(self) -> Option<String> {
        match self {
            ListItemFlag::V01(_) => Some("01".to_string()),
            ListItemFlag::V02(_) => Some("02".to_string()),
            ListItemFlag::V03(_) => Some("03".to_string()),
            ListItemFlag::V04(_) => Some("04".to_string()),
            ListItemFlag::V05(_) => Some("05".to_string()),
            ListItemFlag::V06(_) => Some("06".to_string()),
            ListItemFlag::Null(_) => None,
        }
    }
}
impl MetaValue for ListItemFlag {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListItemFlag::V01(Some(e)) => e.get_field(field),
                ListItemFlag::V02(Some(e)) => e.get_field(field),
                ListItemFlag::V03(Some(e)) => e.get_field(field),
                ListItemFlag::V04(Some(e)) => e.get_field(field),
                ListItemFlag::V05(Some(e)) => e.get_field(field),
                ListItemFlag::V06(Some(e)) => e.get_field(field),
                ListItemFlag::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListItemFlag::V01(Some(e)) => e.get_field_mut(field),
                ListItemFlag::V02(Some(e)) => e.get_field_mut(field),
                ListItemFlag::V03(Some(e)) => e.get_field_mut(field),
                ListItemFlag::V04(Some(e)) => e.get_field_mut(field),
                ListItemFlag::V05(Some(e)) => e.get_field_mut(field),
                ListItemFlag::V06(Some(e)) => e.get_field_mut(field),
                ListItemFlag::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListMode {
    #[doc = "Change List"]
    #[code = "changes"]
    Changes(Option<Element>),
    #[doc = "Snapshot List"]
    #[code = "snapshot"]
    Snapshot(Option<Element>),
    #[doc = "Working List"]
    #[code = "working"]
    Working(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListMode {
    fn default() -> Self {
        ListMode::Null(None)
    }
}
impl TryFrom<String> for ListMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "changes" => Ok(ListMode::Changes(None)),
            "snapshot" => Ok(ListMode::Snapshot(None)),
            "working" => Ok(ListMode::Working(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListMode {
    fn into(self) -> Option<String> {
        match self {
            ListMode::Changes(_) => Some("changes".to_string()),
            ListMode::Snapshot(_) => Some("snapshot".to_string()),
            ListMode::Working(_) => Some("working".to_string()),
            ListMode::Null(_) => None,
        }
    }
}
impl MetaValue for ListMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListMode::Changes(Some(e)) => e.get_field(field),
                ListMode::Snapshot(Some(e)) => e.get_field(field),
                ListMode::Working(Some(e)) => e.get_field(field),
                ListMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListMode::Changes(Some(e)) => e.get_field_mut(field),
                ListMode::Snapshot(Some(e)) => e.get_field_mut(field),
                ListMode::Working(Some(e)) => e.get_field_mut(field),
                ListMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListOrder {
    #[doc = "Sorted Alphabetically"]
    #[code = "alphabetic"]
    Alphabetic(Option<Element>),
    #[doc = "Sorted by Category"]
    #[code = "category"]
    Category(Option<Element>),
    #[doc = "Sorted by Item Date"]
    #[code = "entry-date"]
    EntryDate(Option<Element>),
    #[doc = "Sorted by Event Date"]
    #[code = "event-date"]
    EventDate(Option<Element>),
    #[doc = "Sorted by Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Sorted by Priority"]
    #[code = "priority"]
    Priority(Option<Element>),
    #[doc = "Sorted by System"]
    #[code = "system"]
    System(Option<Element>),
    #[doc = "Sorted by User"]
    #[code = "user"]
    User(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListOrder {
    fn default() -> Self {
        ListOrder::Null(None)
    }
}
impl TryFrom<String> for ListOrder {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alphabetic" => Ok(ListOrder::Alphabetic(None)),
            "category" => Ok(ListOrder::Category(None)),
            "entry-date" => Ok(ListOrder::EntryDate(None)),
            "event-date" => Ok(ListOrder::EventDate(None)),
            "patient" => Ok(ListOrder::Patient(None)),
            "priority" => Ok(ListOrder::Priority(None)),
            "system" => Ok(ListOrder::System(None)),
            "user" => Ok(ListOrder::User(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListOrder {
    fn into(self) -> Option<String> {
        match self {
            ListOrder::Alphabetic(_) => Some("alphabetic".to_string()),
            ListOrder::Category(_) => Some("category".to_string()),
            ListOrder::EntryDate(_) => Some("entry-date".to_string()),
            ListOrder::EventDate(_) => Some("event-date".to_string()),
            ListOrder::Patient(_) => Some("patient".to_string()),
            ListOrder::Priority(_) => Some("priority".to_string()),
            ListOrder::System(_) => Some("system".to_string()),
            ListOrder::User(_) => Some("user".to_string()),
            ListOrder::Null(_) => None,
        }
    }
}
impl MetaValue for ListOrder {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListOrder::Alphabetic(Some(e)) => e.get_field(field),
                ListOrder::Category(Some(e)) => e.get_field(field),
                ListOrder::EntryDate(Some(e)) => e.get_field(field),
                ListOrder::EventDate(Some(e)) => e.get_field(field),
                ListOrder::Patient(Some(e)) => e.get_field(field),
                ListOrder::Priority(Some(e)) => e.get_field(field),
                ListOrder::System(Some(e)) => e.get_field(field),
                ListOrder::User(Some(e)) => e.get_field(field),
                ListOrder::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListOrder::Alphabetic(Some(e)) => e.get_field_mut(field),
                ListOrder::Category(Some(e)) => e.get_field_mut(field),
                ListOrder::EntryDate(Some(e)) => e.get_field_mut(field),
                ListOrder::EventDate(Some(e)) => e.get_field_mut(field),
                ListOrder::Patient(Some(e)) => e.get_field_mut(field),
                ListOrder::Priority(Some(e)) => e.get_field_mut(field),
                ListOrder::System(Some(e)) => e.get_field_mut(field),
                ListOrder::User(Some(e)) => e.get_field_mut(field),
                ListOrder::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ListStatus {
    #[doc = "Current"]
    #[code = "current"]
    Current(Option<Element>),
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Retired"]
    #[code = "retired"]
    Retired(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ListStatus {
    fn default() -> Self {
        ListStatus::Null(None)
    }
}
impl TryFrom<String> for ListStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "current" => Ok(ListStatus::Current(None)),
            "entered-in-error" => Ok(ListStatus::EnteredInError(None)),
            "retired" => Ok(ListStatus::Retired(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ListStatus {
    fn into(self) -> Option<String> {
        match self {
            ListStatus::Current(_) => Some("current".to_string()),
            ListStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ListStatus::Retired(_) => Some("retired".to_string()),
            ListStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ListStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ListStatus::Current(Some(e)) => e.get_field(field),
                ListStatus::EnteredInError(Some(e)) => e.get_field(field),
                ListStatus::Retired(Some(e)) => e.get_field(field),
                ListStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ListStatus::Current(Some(e)) => e.get_field_mut(field),
                ListStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ListStatus::Retired(Some(e)) => e.get_field_mut(field),
                ListStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LocationMode {
    #[doc = "Instance"]
    #[code = "instance"]
    Instance(Option<Element>),
    #[doc = "Kind"]
    #[code = "kind"]
    Kind(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LocationMode {
    fn default() -> Self {
        LocationMode::Null(None)
    }
}
impl TryFrom<String> for LocationMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "instance" => Ok(LocationMode::Instance(None)),
            "kind" => Ok(LocationMode::Kind(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LocationMode {
    fn into(self) -> Option<String> {
        match self {
            LocationMode::Instance(_) => Some("instance".to_string()),
            LocationMode::Kind(_) => Some("kind".to_string()),
            LocationMode::Null(_) => None,
        }
    }
}
impl MetaValue for LocationMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LocationMode::Instance(Some(e)) => e.get_field(field),
                LocationMode::Kind(Some(e)) => e.get_field(field),
                LocationMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LocationMode::Instance(Some(e)) => e.get_field_mut(field),
                LocationMode::Kind(Some(e)) => e.get_field_mut(field),
                LocationMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LocationPhysicalType {
    #[doc = "Area"]
    #[code = "area"]
    Area(Option<Element>),
    #[doc = "Bed"]
    #[code = "bd"]
    Bd(Option<Element>),
    #[doc = "Building"]
    #[code = "bu"]
    Bu(Option<Element>),
    #[doc = "Cabinet"]
    #[code = "ca"]
    Ca(Option<Element>),
    #[doc = "Corridor"]
    #[code = "co"]
    Co(Option<Element>),
    #[doc = "House"]
    #[code = "ho"]
    Ho(Option<Element>),
    #[doc = "Jurisdiction"]
    #[code = "jdn"]
    Jdn(Option<Element>),
    #[doc = "Level"]
    #[code = "lvl"]
    Lvl(Option<Element>),
    #[doc = "Road"]
    #[code = "rd"]
    Rd(Option<Element>),
    #[doc = "Room"]
    #[code = "ro"]
    Ro(Option<Element>),
    #[doc = "Site"]
    #[code = "si"]
    Si(Option<Element>),
    #[doc = "Vehicle"]
    #[code = "ve"]
    Ve(Option<Element>),
    #[doc = "Ward"]
    #[code = "wa"]
    Wa(Option<Element>),
    #[doc = "Wing"]
    #[code = "wi"]
    Wi(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LocationPhysicalType {
    fn default() -> Self {
        LocationPhysicalType::Null(None)
    }
}
impl TryFrom<String> for LocationPhysicalType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "area" => Ok(LocationPhysicalType::Area(None)),
            "bd" => Ok(LocationPhysicalType::Bd(None)),
            "bu" => Ok(LocationPhysicalType::Bu(None)),
            "ca" => Ok(LocationPhysicalType::Ca(None)),
            "co" => Ok(LocationPhysicalType::Co(None)),
            "ho" => Ok(LocationPhysicalType::Ho(None)),
            "jdn" => Ok(LocationPhysicalType::Jdn(None)),
            "lvl" => Ok(LocationPhysicalType::Lvl(None)),
            "rd" => Ok(LocationPhysicalType::Rd(None)),
            "ro" => Ok(LocationPhysicalType::Ro(None)),
            "si" => Ok(LocationPhysicalType::Si(None)),
            "ve" => Ok(LocationPhysicalType::Ve(None)),
            "wa" => Ok(LocationPhysicalType::Wa(None)),
            "wi" => Ok(LocationPhysicalType::Wi(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LocationPhysicalType {
    fn into(self) -> Option<String> {
        match self {
            LocationPhysicalType::Area(_) => Some("area".to_string()),
            LocationPhysicalType::Bd(_) => Some("bd".to_string()),
            LocationPhysicalType::Bu(_) => Some("bu".to_string()),
            LocationPhysicalType::Ca(_) => Some("ca".to_string()),
            LocationPhysicalType::Co(_) => Some("co".to_string()),
            LocationPhysicalType::Ho(_) => Some("ho".to_string()),
            LocationPhysicalType::Jdn(_) => Some("jdn".to_string()),
            LocationPhysicalType::Lvl(_) => Some("lvl".to_string()),
            LocationPhysicalType::Rd(_) => Some("rd".to_string()),
            LocationPhysicalType::Ro(_) => Some("ro".to_string()),
            LocationPhysicalType::Si(_) => Some("si".to_string()),
            LocationPhysicalType::Ve(_) => Some("ve".to_string()),
            LocationPhysicalType::Wa(_) => Some("wa".to_string()),
            LocationPhysicalType::Wi(_) => Some("wi".to_string()),
            LocationPhysicalType::Null(_) => None,
        }
    }
}
impl MetaValue for LocationPhysicalType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LocationPhysicalType::Area(Some(e)) => e.get_field(field),
                LocationPhysicalType::Bd(Some(e)) => e.get_field(field),
                LocationPhysicalType::Bu(Some(e)) => e.get_field(field),
                LocationPhysicalType::Ca(Some(e)) => e.get_field(field),
                LocationPhysicalType::Co(Some(e)) => e.get_field(field),
                LocationPhysicalType::Ho(Some(e)) => e.get_field(field),
                LocationPhysicalType::Jdn(Some(e)) => e.get_field(field),
                LocationPhysicalType::Lvl(Some(e)) => e.get_field(field),
                LocationPhysicalType::Rd(Some(e)) => e.get_field(field),
                LocationPhysicalType::Ro(Some(e)) => e.get_field(field),
                LocationPhysicalType::Si(Some(e)) => e.get_field(field),
                LocationPhysicalType::Ve(Some(e)) => e.get_field(field),
                LocationPhysicalType::Wa(Some(e)) => e.get_field(field),
                LocationPhysicalType::Wi(Some(e)) => e.get_field(field),
                LocationPhysicalType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LocationPhysicalType::Area(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Bd(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Bu(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Ca(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Co(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Ho(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Jdn(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Lvl(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Rd(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Ro(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Si(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Ve(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Wa(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Wi(Some(e)) => e.get_field_mut(field),
                LocationPhysicalType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum LocationStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "Suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for LocationStatus {
    fn default() -> Self {
        LocationStatus::Null(None)
    }
}
impl TryFrom<String> for LocationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(LocationStatus::Active(None)),
            "inactive" => Ok(LocationStatus::Inactive(None)),
            "suspended" => Ok(LocationStatus::Suspended(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &LocationStatus {
    fn into(self) -> Option<String> {
        match self {
            LocationStatus::Active(_) => Some("active".to_string()),
            LocationStatus::Inactive(_) => Some("inactive".to_string()),
            LocationStatus::Suspended(_) => Some("suspended".to_string()),
            LocationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for LocationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                LocationStatus::Active(Some(e)) => e.get_field(field),
                LocationStatus::Inactive(Some(e)) => e.get_field(field),
                LocationStatus::Suspended(Some(e)) => e.get_field(field),
                LocationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                LocationStatus::Active(Some(e)) => e.get_field_mut(field),
                LocationStatus::Inactive(Some(e)) => e.get_field_mut(field),
                LocationStatus::Suspended(Some(e)) => e.get_field_mut(field),
                LocationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapContextType {
    #[doc = "Type"]
    #[code = "type"]
    Type(Option<Element>),
    #[doc = "Variable"]
    #[code = "variable"]
    Variable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapContextType {
    fn default() -> Self {
        MapContextType::Null(None)
    }
}
impl TryFrom<String> for MapContextType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "type" => Ok(MapContextType::Type(None)),
            "variable" => Ok(MapContextType::Variable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapContextType {
    fn into(self) -> Option<String> {
        match self {
            MapContextType::Type(_) => Some("type".to_string()),
            MapContextType::Variable(_) => Some("variable".to_string()),
            MapContextType::Null(_) => None,
        }
    }
}
impl MetaValue for MapContextType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapContextType::Type(Some(e)) => e.get_field(field),
                MapContextType::Variable(Some(e)) => e.get_field(field),
                MapContextType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapContextType::Type(Some(e)) => e.get_field_mut(field),
                MapContextType::Variable(Some(e)) => e.get_field_mut(field),
                MapContextType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapGroupTypeMode {
    #[doc = "Not a Default"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "Default for type + combination"]
    #[code = "type-and-types"]
    TypeAndTypes(Option<Element>),
    #[doc = "Default for Type Combination"]
    #[code = "types"]
    Types(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapGroupTypeMode {
    fn default() -> Self {
        MapGroupTypeMode::Null(None)
    }
}
impl TryFrom<String> for MapGroupTypeMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "none" => Ok(MapGroupTypeMode::None(None)),
            "type-and-types" => Ok(MapGroupTypeMode::TypeAndTypes(None)),
            "types" => Ok(MapGroupTypeMode::Types(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapGroupTypeMode {
    fn into(self) -> Option<String> {
        match self {
            MapGroupTypeMode::None(_) => Some("none".to_string()),
            MapGroupTypeMode::TypeAndTypes(_) => Some("type-and-types".to_string()),
            MapGroupTypeMode::Types(_) => Some("types".to_string()),
            MapGroupTypeMode::Null(_) => None,
        }
    }
}
impl MetaValue for MapGroupTypeMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapGroupTypeMode::None(Some(e)) => e.get_field(field),
                MapGroupTypeMode::TypeAndTypes(Some(e)) => e.get_field(field),
                MapGroupTypeMode::Types(Some(e)) => e.get_field(field),
                MapGroupTypeMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapGroupTypeMode::None(Some(e)) => e.get_field_mut(field),
                MapGroupTypeMode::TypeAndTypes(Some(e)) => e.get_field_mut(field),
                MapGroupTypeMode::Types(Some(e)) => e.get_field_mut(field),
                MapGroupTypeMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapInputMode {
    #[doc = "Source Instance"]
    #[code = "source"]
    Source(Option<Element>),
    #[doc = "Target Instance"]
    #[code = "target"]
    Target(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapInputMode {
    fn default() -> Self {
        MapInputMode::Null(None)
    }
}
impl TryFrom<String> for MapInputMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "source" => Ok(MapInputMode::Source(None)),
            "target" => Ok(MapInputMode::Target(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapInputMode {
    fn into(self) -> Option<String> {
        match self {
            MapInputMode::Source(_) => Some("source".to_string()),
            MapInputMode::Target(_) => Some("target".to_string()),
            MapInputMode::Null(_) => None,
        }
    }
}
impl MetaValue for MapInputMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapInputMode::Source(Some(e)) => e.get_field(field),
                MapInputMode::Target(Some(e)) => e.get_field(field),
                MapInputMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapInputMode::Source(Some(e)) => e.get_field_mut(field),
                MapInputMode::Target(Some(e)) => e.get_field_mut(field),
                MapInputMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapModelMode {
    #[doc = "Produced Structure Definition"]
    #[code = "produced"]
    Produced(Option<Element>),
    #[doc = "Queried Structure Definition"]
    #[code = "queried"]
    Queried(Option<Element>),
    #[doc = "Source Structure Definition"]
    #[code = "source"]
    Source(Option<Element>),
    #[doc = "Target Structure Definition"]
    #[code = "target"]
    Target(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapModelMode {
    fn default() -> Self {
        MapModelMode::Null(None)
    }
}
impl TryFrom<String> for MapModelMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "produced" => Ok(MapModelMode::Produced(None)),
            "queried" => Ok(MapModelMode::Queried(None)),
            "source" => Ok(MapModelMode::Source(None)),
            "target" => Ok(MapModelMode::Target(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapModelMode {
    fn into(self) -> Option<String> {
        match self {
            MapModelMode::Produced(_) => Some("produced".to_string()),
            MapModelMode::Queried(_) => Some("queried".to_string()),
            MapModelMode::Source(_) => Some("source".to_string()),
            MapModelMode::Target(_) => Some("target".to_string()),
            MapModelMode::Null(_) => None,
        }
    }
}
impl MetaValue for MapModelMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapModelMode::Produced(Some(e)) => e.get_field(field),
                MapModelMode::Queried(Some(e)) => e.get_field(field),
                MapModelMode::Source(Some(e)) => e.get_field(field),
                MapModelMode::Target(Some(e)) => e.get_field(field),
                MapModelMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapModelMode::Produced(Some(e)) => e.get_field_mut(field),
                MapModelMode::Queried(Some(e)) => e.get_field_mut(field),
                MapModelMode::Source(Some(e)) => e.get_field_mut(field),
                MapModelMode::Target(Some(e)) => e.get_field_mut(field),
                MapModelMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapSourceListMode {
    #[doc = "First"]
    #[code = "first"]
    First(Option<Element>),
    #[doc = "Last"]
    #[code = "last"]
    Last(Option<Element>),
    #[doc = "All but the first"]
    #[code = "not_first"]
    Not_first(Option<Element>),
    #[doc = "All but the last"]
    #[code = "not_last"]
    Not_last(Option<Element>),
    #[doc = "Enforce only one"]
    #[code = "only_one"]
    Only_one(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapSourceListMode {
    fn default() -> Self {
        MapSourceListMode::Null(None)
    }
}
impl TryFrom<String> for MapSourceListMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "first" => Ok(MapSourceListMode::First(None)),
            "last" => Ok(MapSourceListMode::Last(None)),
            "not_first" => Ok(MapSourceListMode::Not_first(None)),
            "not_last" => Ok(MapSourceListMode::Not_last(None)),
            "only_one" => Ok(MapSourceListMode::Only_one(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapSourceListMode {
    fn into(self) -> Option<String> {
        match self {
            MapSourceListMode::First(_) => Some("first".to_string()),
            MapSourceListMode::Last(_) => Some("last".to_string()),
            MapSourceListMode::Not_first(_) => Some("not_first".to_string()),
            MapSourceListMode::Not_last(_) => Some("not_last".to_string()),
            MapSourceListMode::Only_one(_) => Some("only_one".to_string()),
            MapSourceListMode::Null(_) => None,
        }
    }
}
impl MetaValue for MapSourceListMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapSourceListMode::First(Some(e)) => e.get_field(field),
                MapSourceListMode::Last(Some(e)) => e.get_field(field),
                MapSourceListMode::Not_first(Some(e)) => e.get_field(field),
                MapSourceListMode::Not_last(Some(e)) => e.get_field(field),
                MapSourceListMode::Only_one(Some(e)) => e.get_field(field),
                MapSourceListMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapSourceListMode::First(Some(e)) => e.get_field_mut(field),
                MapSourceListMode::Last(Some(e)) => e.get_field_mut(field),
                MapSourceListMode::Not_first(Some(e)) => e.get_field_mut(field),
                MapSourceListMode::Not_last(Some(e)) => e.get_field_mut(field),
                MapSourceListMode::Only_one(Some(e)) => e.get_field_mut(field),
                MapSourceListMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapTargetListMode {
    #[doc = "Collate"]
    #[code = "collate"]
    Collate(Option<Element>),
    #[doc = "First"]
    #[code = "first"]
    First(Option<Element>),
    #[doc = "Last"]
    #[code = "last"]
    Last(Option<Element>),
    #[doc = "Share"]
    #[code = "share"]
    Share(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapTargetListMode {
    fn default() -> Self {
        MapTargetListMode::Null(None)
    }
}
impl TryFrom<String> for MapTargetListMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "collate" => Ok(MapTargetListMode::Collate(None)),
            "first" => Ok(MapTargetListMode::First(None)),
            "last" => Ok(MapTargetListMode::Last(None)),
            "share" => Ok(MapTargetListMode::Share(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapTargetListMode {
    fn into(self) -> Option<String> {
        match self {
            MapTargetListMode::Collate(_) => Some("collate".to_string()),
            MapTargetListMode::First(_) => Some("first".to_string()),
            MapTargetListMode::Last(_) => Some("last".to_string()),
            MapTargetListMode::Share(_) => Some("share".to_string()),
            MapTargetListMode::Null(_) => None,
        }
    }
}
impl MetaValue for MapTargetListMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapTargetListMode::Collate(Some(e)) => e.get_field(field),
                MapTargetListMode::First(Some(e)) => e.get_field(field),
                MapTargetListMode::Last(Some(e)) => e.get_field(field),
                MapTargetListMode::Share(Some(e)) => e.get_field(field),
                MapTargetListMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapTargetListMode::Collate(Some(e)) => e.get_field_mut(field),
                MapTargetListMode::First(Some(e)) => e.get_field_mut(field),
                MapTargetListMode::Last(Some(e)) => e.get_field_mut(field),
                MapTargetListMode::Share(Some(e)) => e.get_field_mut(field),
                MapTargetListMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MapTransform {
    #[doc = "append"]
    #[code = "append"]
    Append(Option<Element>),
    #[doc = "c"]
    #[code = "c"]
    C(Option<Element>),
    #[doc = "cast"]
    #[code = "cast"]
    Cast(Option<Element>),
    #[doc = "cc"]
    #[code = "cc"]
    Cc(Option<Element>),
    #[doc = "copy"]
    #[code = "copy"]
    Copy(Option<Element>),
    #[doc = "cp"]
    #[code = "cp"]
    Cp(Option<Element>),
    #[doc = "create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "dateOp"]
    #[code = "dateOp"]
    DateOp(Option<Element>),
    #[doc = "escape"]
    #[code = "escape"]
    Escape(Option<Element>),
    #[doc = "evaluate"]
    #[code = "evaluate"]
    Evaluate(Option<Element>),
    #[doc = "id"]
    #[code = "id"]
    Id(Option<Element>),
    #[doc = "pointer"]
    #[code = "pointer"]
    Pointer(Option<Element>),
    #[doc = "qty"]
    #[code = "qty"]
    Qty(Option<Element>),
    #[doc = "reference"]
    #[code = "reference"]
    Reference(Option<Element>),
    #[doc = "translate"]
    #[code = "translate"]
    Translate(Option<Element>),
    #[doc = "truncate"]
    #[code = "truncate"]
    Truncate(Option<Element>),
    #[doc = "uuid"]
    #[code = "uuid"]
    Uuid(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MapTransform {
    fn default() -> Self {
        MapTransform::Null(None)
    }
}
impl TryFrom<String> for MapTransform {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "append" => Ok(MapTransform::Append(None)),
            "c" => Ok(MapTransform::C(None)),
            "cast" => Ok(MapTransform::Cast(None)),
            "cc" => Ok(MapTransform::Cc(None)),
            "copy" => Ok(MapTransform::Copy(None)),
            "cp" => Ok(MapTransform::Cp(None)),
            "create" => Ok(MapTransform::Create(None)),
            "dateOp" => Ok(MapTransform::DateOp(None)),
            "escape" => Ok(MapTransform::Escape(None)),
            "evaluate" => Ok(MapTransform::Evaluate(None)),
            "id" => Ok(MapTransform::Id(None)),
            "pointer" => Ok(MapTransform::Pointer(None)),
            "qty" => Ok(MapTransform::Qty(None)),
            "reference" => Ok(MapTransform::Reference(None)),
            "translate" => Ok(MapTransform::Translate(None)),
            "truncate" => Ok(MapTransform::Truncate(None)),
            "uuid" => Ok(MapTransform::Uuid(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MapTransform {
    fn into(self) -> Option<String> {
        match self {
            MapTransform::Append(_) => Some("append".to_string()),
            MapTransform::C(_) => Some("c".to_string()),
            MapTransform::Cast(_) => Some("cast".to_string()),
            MapTransform::Cc(_) => Some("cc".to_string()),
            MapTransform::Copy(_) => Some("copy".to_string()),
            MapTransform::Cp(_) => Some("cp".to_string()),
            MapTransform::Create(_) => Some("create".to_string()),
            MapTransform::DateOp(_) => Some("dateOp".to_string()),
            MapTransform::Escape(_) => Some("escape".to_string()),
            MapTransform::Evaluate(_) => Some("evaluate".to_string()),
            MapTransform::Id(_) => Some("id".to_string()),
            MapTransform::Pointer(_) => Some("pointer".to_string()),
            MapTransform::Qty(_) => Some("qty".to_string()),
            MapTransform::Reference(_) => Some("reference".to_string()),
            MapTransform::Translate(_) => Some("translate".to_string()),
            MapTransform::Truncate(_) => Some("truncate".to_string()),
            MapTransform::Uuid(_) => Some("uuid".to_string()),
            MapTransform::Null(_) => None,
        }
    }
}
impl MetaValue for MapTransform {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MapTransform::Append(Some(e)) => e.get_field(field),
                MapTransform::C(Some(e)) => e.get_field(field),
                MapTransform::Cast(Some(e)) => e.get_field(field),
                MapTransform::Cc(Some(e)) => e.get_field(field),
                MapTransform::Copy(Some(e)) => e.get_field(field),
                MapTransform::Cp(Some(e)) => e.get_field(field),
                MapTransform::Create(Some(e)) => e.get_field(field),
                MapTransform::DateOp(Some(e)) => e.get_field(field),
                MapTransform::Escape(Some(e)) => e.get_field(field),
                MapTransform::Evaluate(Some(e)) => e.get_field(field),
                MapTransform::Id(Some(e)) => e.get_field(field),
                MapTransform::Pointer(Some(e)) => e.get_field(field),
                MapTransform::Qty(Some(e)) => e.get_field(field),
                MapTransform::Reference(Some(e)) => e.get_field(field),
                MapTransform::Translate(Some(e)) => e.get_field(field),
                MapTransform::Truncate(Some(e)) => e.get_field(field),
                MapTransform::Uuid(Some(e)) => e.get_field(field),
                MapTransform::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MapTransform::Append(Some(e)) => e.get_field_mut(field),
                MapTransform::C(Some(e)) => e.get_field_mut(field),
                MapTransform::Cast(Some(e)) => e.get_field_mut(field),
                MapTransform::Cc(Some(e)) => e.get_field_mut(field),
                MapTransform::Copy(Some(e)) => e.get_field_mut(field),
                MapTransform::Cp(Some(e)) => e.get_field_mut(field),
                MapTransform::Create(Some(e)) => e.get_field_mut(field),
                MapTransform::DateOp(Some(e)) => e.get_field_mut(field),
                MapTransform::Escape(Some(e)) => e.get_field_mut(field),
                MapTransform::Evaluate(Some(e)) => e.get_field_mut(field),
                MapTransform::Id(Some(e)) => e.get_field_mut(field),
                MapTransform::Pointer(Some(e)) => e.get_field_mut(field),
                MapTransform::Qty(Some(e)) => e.get_field_mut(field),
                MapTransform::Reference(Some(e)) => e.get_field_mut(field),
                MapTransform::Translate(Some(e)) => e.get_field_mut(field),
                MapTransform::Truncate(Some(e)) => e.get_field_mut(field),
                MapTransform::Uuid(Some(e)) => e.get_field_mut(field),
                MapTransform::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MaritalStatus {
    #[doc = "Annulled"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Divorced"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Interlocutory"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Legally Separated"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Married"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "Polygamous"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "Never Married"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Domestic partner"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "unmarried"]
    #[code = "U"]
    U(Option<Element>),
    #[code = "UNK"]
    UNK(Option<Element>),
    #[doc = "Widowed"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MaritalStatus {
    fn default() -> Self {
        MaritalStatus::Null(None)
    }
}
impl TryFrom<String> for MaritalStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(MaritalStatus::A(None)),
            "D" => Ok(MaritalStatus::D(None)),
            "I" => Ok(MaritalStatus::I(None)),
            "L" => Ok(MaritalStatus::L(None)),
            "M" => Ok(MaritalStatus::M(None)),
            "P" => Ok(MaritalStatus::P(None)),
            "S" => Ok(MaritalStatus::S(None)),
            "T" => Ok(MaritalStatus::T(None)),
            "U" => Ok(MaritalStatus::U(None)),
            "UNK" => Ok(MaritalStatus::UNK(None)),
            "W" => Ok(MaritalStatus::W(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MaritalStatus {
    fn into(self) -> Option<String> {
        match self {
            MaritalStatus::A(_) => Some("A".to_string()),
            MaritalStatus::D(_) => Some("D".to_string()),
            MaritalStatus::I(_) => Some("I".to_string()),
            MaritalStatus::L(_) => Some("L".to_string()),
            MaritalStatus::M(_) => Some("M".to_string()),
            MaritalStatus::P(_) => Some("P".to_string()),
            MaritalStatus::S(_) => Some("S".to_string()),
            MaritalStatus::T(_) => Some("T".to_string()),
            MaritalStatus::U(_) => Some("U".to_string()),
            MaritalStatus::UNK(_) => Some("UNK".to_string()),
            MaritalStatus::W(_) => Some("W".to_string()),
            MaritalStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MaritalStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MaritalStatus::A(Some(e)) => e.get_field(field),
                MaritalStatus::D(Some(e)) => e.get_field(field),
                MaritalStatus::I(Some(e)) => e.get_field(field),
                MaritalStatus::L(Some(e)) => e.get_field(field),
                MaritalStatus::M(Some(e)) => e.get_field(field),
                MaritalStatus::P(Some(e)) => e.get_field(field),
                MaritalStatus::S(Some(e)) => e.get_field(field),
                MaritalStatus::T(Some(e)) => e.get_field(field),
                MaritalStatus::U(Some(e)) => e.get_field(field),
                MaritalStatus::UNK(Some(e)) => e.get_field(field),
                MaritalStatus::W(Some(e)) => e.get_field(field),
                MaritalStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MaritalStatus::A(Some(e)) => e.get_field_mut(field),
                MaritalStatus::D(Some(e)) => e.get_field_mut(field),
                MaritalStatus::I(Some(e)) => e.get_field_mut(field),
                MaritalStatus::L(Some(e)) => e.get_field_mut(field),
                MaritalStatus::M(Some(e)) => e.get_field_mut(field),
                MaritalStatus::P(Some(e)) => e.get_field_mut(field),
                MaritalStatus::S(Some(e)) => e.get_field_mut(field),
                MaritalStatus::T(Some(e)) => e.get_field_mut(field),
                MaritalStatus::U(Some(e)) => e.get_field_mut(field),
                MaritalStatus::UNK(Some(e)) => e.get_field_mut(field),
                MaritalStatus::W(Some(e)) => e.get_field_mut(field),
                MaritalStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MatchGrade {
    #[doc = "Certain Match"]
    #[code = "certain"]
    Certain(Option<Element>),
    #[doc = "Certainly Not a Match"]
    #[code = "certainly-not"]
    CertainlyNot(Option<Element>),
    #[doc = "Possible Match"]
    #[code = "possible"]
    Possible(Option<Element>),
    #[doc = "Probable Match"]
    #[code = "probable"]
    Probable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MatchGrade {
    fn default() -> Self {
        MatchGrade::Null(None)
    }
}
impl TryFrom<String> for MatchGrade {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "certain" => Ok(MatchGrade::Certain(None)),
            "certainly-not" => Ok(MatchGrade::CertainlyNot(None)),
            "possible" => Ok(MatchGrade::Possible(None)),
            "probable" => Ok(MatchGrade::Probable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MatchGrade {
    fn into(self) -> Option<String> {
        match self {
            MatchGrade::Certain(_) => Some("certain".to_string()),
            MatchGrade::CertainlyNot(_) => Some("certainly-not".to_string()),
            MatchGrade::Possible(_) => Some("possible".to_string()),
            MatchGrade::Probable(_) => Some("probable".to_string()),
            MatchGrade::Null(_) => None,
        }
    }
}
impl MetaValue for MatchGrade {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MatchGrade::Certain(Some(e)) => e.get_field(field),
                MatchGrade::CertainlyNot(Some(e)) => e.get_field(field),
                MatchGrade::Possible(Some(e)) => e.get_field(field),
                MatchGrade::Probable(Some(e)) => e.get_field(field),
                MatchGrade::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MatchGrade::Certain(Some(e)) => e.get_field_mut(field),
                MatchGrade::CertainlyNot(Some(e)) => e.get_field_mut(field),
                MatchGrade::Possible(Some(e)) => e.get_field_mut(field),
                MatchGrade::Probable(Some(e)) => e.get_field_mut(field),
                MatchGrade::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureDataUsage {
    #[doc = "Risk Adjustment Factor"]
    #[code = "risk-adjustment-factor"]
    RiskAdjustmentFactor(Option<Element>),
    #[doc = "Supplemental Data"]
    #[code = "supplemental-data"]
    SupplementalData(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureDataUsage {
    fn default() -> Self {
        MeasureDataUsage::Null(None)
    }
}
impl TryFrom<String> for MeasureDataUsage {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "risk-adjustment-factor" => Ok(MeasureDataUsage::RiskAdjustmentFactor(None)),
            "supplemental-data" => Ok(MeasureDataUsage::SupplementalData(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureDataUsage {
    fn into(self) -> Option<String> {
        match self {
            MeasureDataUsage::RiskAdjustmentFactor(_) => Some("risk-adjustment-factor".to_string()),
            MeasureDataUsage::SupplementalData(_) => Some("supplemental-data".to_string()),
            MeasureDataUsage::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureDataUsage {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureDataUsage::RiskAdjustmentFactor(Some(e)) => e.get_field(field),
                MeasureDataUsage::SupplementalData(Some(e)) => e.get_field(field),
                MeasureDataUsage::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureDataUsage::RiskAdjustmentFactor(Some(e)) => e.get_field_mut(field),
                MeasureDataUsage::SupplementalData(Some(e)) => e.get_field_mut(field),
                MeasureDataUsage::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureImprovementNotation {
    #[doc = "Decreased score indicates improvement"]
    #[code = "decrease"]
    Decrease(Option<Element>),
    #[doc = "Increased score indicates improvement"]
    #[code = "increase"]
    Increase(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureImprovementNotation {
    fn default() -> Self {
        MeasureImprovementNotation::Null(None)
    }
}
impl TryFrom<String> for MeasureImprovementNotation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "decrease" => Ok(MeasureImprovementNotation::Decrease(None)),
            "increase" => Ok(MeasureImprovementNotation::Increase(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureImprovementNotation {
    fn into(self) -> Option<String> {
        match self {
            MeasureImprovementNotation::Decrease(_) => Some("decrease".to_string()),
            MeasureImprovementNotation::Increase(_) => Some("increase".to_string()),
            MeasureImprovementNotation::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureImprovementNotation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureImprovementNotation::Decrease(Some(e)) => e.get_field(field),
                MeasureImprovementNotation::Increase(Some(e)) => e.get_field(field),
                MeasureImprovementNotation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureImprovementNotation::Decrease(Some(e)) => e.get_field_mut(field),
                MeasureImprovementNotation::Increase(Some(e)) => e.get_field_mut(field),
                MeasureImprovementNotation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasurePopulation {
    #[doc = "Denominator"]
    #[code = "denominator"]
    Denominator(Option<Element>),
    #[doc = "Denominator Exception"]
    #[code = "denominator-exception"]
    DenominatorException(Option<Element>),
    #[doc = "Denominator Exclusion"]
    #[code = "denominator-exclusion"]
    DenominatorExclusion(Option<Element>),
    #[doc = "Initial Population"]
    #[code = "initial-population"]
    InitialPopulation(Option<Element>),
    #[doc = "Measure Observation"]
    #[code = "measure-observation"]
    MeasureObservation(Option<Element>),
    #[doc = "Measure Population"]
    #[code = "measure-population"]
    MeasurePopulation(Option<Element>),
    #[doc = "Measure Population Exclusion"]
    #[code = "measure-population-exclusion"]
    MeasurePopulationExclusion(Option<Element>),
    #[doc = "Numerator"]
    #[code = "numerator"]
    Numerator(Option<Element>),
    #[doc = "Numerator Exclusion"]
    #[code = "numerator-exclusion"]
    NumeratorExclusion(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasurePopulation {
    fn default() -> Self {
        MeasurePopulation::Null(None)
    }
}
impl TryFrom<String> for MeasurePopulation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "denominator" => Ok(MeasurePopulation::Denominator(None)),
            "denominator-exception" => Ok(MeasurePopulation::DenominatorException(None)),
            "denominator-exclusion" => Ok(MeasurePopulation::DenominatorExclusion(None)),
            "initial-population" => Ok(MeasurePopulation::InitialPopulation(None)),
            "measure-observation" => Ok(MeasurePopulation::MeasureObservation(None)),
            "measure-population" => Ok(MeasurePopulation::MeasurePopulation(None)),
            "measure-population-exclusion" => {
                Ok(MeasurePopulation::MeasurePopulationExclusion(None))
            }
            "numerator" => Ok(MeasurePopulation::Numerator(None)),
            "numerator-exclusion" => Ok(MeasurePopulation::NumeratorExclusion(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasurePopulation {
    fn into(self) -> Option<String> {
        match self {
            MeasurePopulation::Denominator(_) => Some("denominator".to_string()),
            MeasurePopulation::DenominatorException(_) => Some("denominator-exception".to_string()),
            MeasurePopulation::DenominatorExclusion(_) => Some("denominator-exclusion".to_string()),
            MeasurePopulation::InitialPopulation(_) => Some("initial-population".to_string()),
            MeasurePopulation::MeasureObservation(_) => Some("measure-observation".to_string()),
            MeasurePopulation::MeasurePopulation(_) => Some("measure-population".to_string()),
            MeasurePopulation::MeasurePopulationExclusion(_) => {
                Some("measure-population-exclusion".to_string())
            }
            MeasurePopulation::Numerator(_) => Some("numerator".to_string()),
            MeasurePopulation::NumeratorExclusion(_) => Some("numerator-exclusion".to_string()),
            MeasurePopulation::Null(_) => None,
        }
    }
}
impl MetaValue for MeasurePopulation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasurePopulation::Denominator(Some(e)) => e.get_field(field),
                MeasurePopulation::DenominatorException(Some(e)) => e.get_field(field),
                MeasurePopulation::DenominatorExclusion(Some(e)) => e.get_field(field),
                MeasurePopulation::InitialPopulation(Some(e)) => e.get_field(field),
                MeasurePopulation::MeasureObservation(Some(e)) => e.get_field(field),
                MeasurePopulation::MeasurePopulation(Some(e)) => e.get_field(field),
                MeasurePopulation::MeasurePopulationExclusion(Some(e)) => e.get_field(field),
                MeasurePopulation::Numerator(Some(e)) => e.get_field(field),
                MeasurePopulation::NumeratorExclusion(Some(e)) => e.get_field(field),
                MeasurePopulation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasurePopulation::Denominator(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::DenominatorException(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::DenominatorExclusion(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::InitialPopulation(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::MeasureObservation(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::MeasurePopulation(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::MeasurePopulationExclusion(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::Numerator(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::NumeratorExclusion(Some(e)) => e.get_field_mut(field),
                MeasurePopulation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureReportStatus {
    #[doc = "Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureReportStatus {
    fn default() -> Self {
        MeasureReportStatus::Null(None)
    }
}
impl TryFrom<String> for MeasureReportStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(MeasureReportStatus::Complete(None)),
            "error" => Ok(MeasureReportStatus::Error(None)),
            "pending" => Ok(MeasureReportStatus::Pending(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureReportStatus {
    fn into(self) -> Option<String> {
        match self {
            MeasureReportStatus::Complete(_) => Some("complete".to_string()),
            MeasureReportStatus::Error(_) => Some("error".to_string()),
            MeasureReportStatus::Pending(_) => Some("pending".to_string()),
            MeasureReportStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureReportStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureReportStatus::Complete(Some(e)) => e.get_field(field),
                MeasureReportStatus::Error(Some(e)) => e.get_field(field),
                MeasureReportStatus::Pending(Some(e)) => e.get_field(field),
                MeasureReportStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureReportStatus::Complete(Some(e)) => e.get_field_mut(field),
                MeasureReportStatus::Error(Some(e)) => e.get_field_mut(field),
                MeasureReportStatus::Pending(Some(e)) => e.get_field_mut(field),
                MeasureReportStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureReportType {
    #[doc = "Data Collection"]
    #[code = "data-collection"]
    DataCollection(Option<Element>),
    #[doc = "Individual"]
    #[code = "individual"]
    Individual(Option<Element>),
    #[doc = "Subject List"]
    #[code = "subject-list"]
    SubjectList(Option<Element>),
    #[doc = "Summary"]
    #[code = "summary"]
    Summary(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureReportType {
    fn default() -> Self {
        MeasureReportType::Null(None)
    }
}
impl TryFrom<String> for MeasureReportType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "data-collection" => Ok(MeasureReportType::DataCollection(None)),
            "individual" => Ok(MeasureReportType::Individual(None)),
            "subject-list" => Ok(MeasureReportType::SubjectList(None)),
            "summary" => Ok(MeasureReportType::Summary(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureReportType {
    fn into(self) -> Option<String> {
        match self {
            MeasureReportType::DataCollection(_) => Some("data-collection".to_string()),
            MeasureReportType::Individual(_) => Some("individual".to_string()),
            MeasureReportType::SubjectList(_) => Some("subject-list".to_string()),
            MeasureReportType::Summary(_) => Some("summary".to_string()),
            MeasureReportType::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureReportType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureReportType::DataCollection(Some(e)) => e.get_field(field),
                MeasureReportType::Individual(Some(e)) => e.get_field(field),
                MeasureReportType::SubjectList(Some(e)) => e.get_field(field),
                MeasureReportType::Summary(Some(e)) => e.get_field(field),
                MeasureReportType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureReportType::DataCollection(Some(e)) => e.get_field_mut(field),
                MeasureReportType::Individual(Some(e)) => e.get_field_mut(field),
                MeasureReportType::SubjectList(Some(e)) => e.get_field_mut(field),
                MeasureReportType::Summary(Some(e)) => e.get_field_mut(field),
                MeasureReportType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureScoring {
    #[doc = "Cohort"]
    #[code = "cohort"]
    Cohort(Option<Element>),
    #[doc = "Continuous Variable"]
    #[code = "continuous-variable"]
    ContinuousVariable(Option<Element>),
    #[doc = "Proportion"]
    #[code = "proportion"]
    Proportion(Option<Element>),
    #[doc = "Ratio"]
    #[code = "ratio"]
    Ratio(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureScoring {
    fn default() -> Self {
        MeasureScoring::Null(None)
    }
}
impl TryFrom<String> for MeasureScoring {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cohort" => Ok(MeasureScoring::Cohort(None)),
            "continuous-variable" => Ok(MeasureScoring::ContinuousVariable(None)),
            "proportion" => Ok(MeasureScoring::Proportion(None)),
            "ratio" => Ok(MeasureScoring::Ratio(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureScoring {
    fn into(self) -> Option<String> {
        match self {
            MeasureScoring::Cohort(_) => Some("cohort".to_string()),
            MeasureScoring::ContinuousVariable(_) => Some("continuous-variable".to_string()),
            MeasureScoring::Proportion(_) => Some("proportion".to_string()),
            MeasureScoring::Ratio(_) => Some("ratio".to_string()),
            MeasureScoring::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureScoring {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureScoring::Cohort(Some(e)) => e.get_field(field),
                MeasureScoring::ContinuousVariable(Some(e)) => e.get_field(field),
                MeasureScoring::Proportion(Some(e)) => e.get_field(field),
                MeasureScoring::Ratio(Some(e)) => e.get_field(field),
                MeasureScoring::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureScoring::Cohort(Some(e)) => e.get_field_mut(field),
                MeasureScoring::ContinuousVariable(Some(e)) => e.get_field_mut(field),
                MeasureScoring::Proportion(Some(e)) => e.get_field_mut(field),
                MeasureScoring::Ratio(Some(e)) => e.get_field_mut(field),
                MeasureScoring::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MeasureType {
    #[doc = "Composite"]
    #[code = "composite"]
    Composite(Option<Element>),
    #[doc = "Outcome"]
    #[code = "outcome"]
    Outcome(Option<Element>),
    #[doc = "Patient Reported Outcome"]
    #[code = "patient-reported-outcome"]
    PatientReportedOutcome(Option<Element>),
    #[doc = "Process"]
    #[code = "process"]
    Process(Option<Element>),
    #[doc = "Structure"]
    #[code = "structure"]
    Structure(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MeasureType {
    fn default() -> Self {
        MeasureType::Null(None)
    }
}
impl TryFrom<String> for MeasureType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "composite" => Ok(MeasureType::Composite(None)),
            "outcome" => Ok(MeasureType::Outcome(None)),
            "patient-reported-outcome" => Ok(MeasureType::PatientReportedOutcome(None)),
            "process" => Ok(MeasureType::Process(None)),
            "structure" => Ok(MeasureType::Structure(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MeasureType {
    fn into(self) -> Option<String> {
        match self {
            MeasureType::Composite(_) => Some("composite".to_string()),
            MeasureType::Outcome(_) => Some("outcome".to_string()),
            MeasureType::PatientReportedOutcome(_) => Some("patient-reported-outcome".to_string()),
            MeasureType::Process(_) => Some("process".to_string()),
            MeasureType::Structure(_) => Some("structure".to_string()),
            MeasureType::Null(_) => None,
        }
    }
}
impl MetaValue for MeasureType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MeasureType::Composite(Some(e)) => e.get_field(field),
                MeasureType::Outcome(Some(e)) => e.get_field(field),
                MeasureType::PatientReportedOutcome(Some(e)) => e.get_field(field),
                MeasureType::Process(Some(e)) => e.get_field(field),
                MeasureType::Structure(Some(e)) => e.get_field(field),
                MeasureType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MeasureType::Composite(Some(e)) => e.get_field_mut(field),
                MeasureType::Outcome(Some(e)) => e.get_field_mut(field),
                MeasureType::PatientReportedOutcome(Some(e)) => e.get_field_mut(field),
                MeasureType::Process(Some(e)) => e.get_field_mut(field),
                MeasureType::Structure(Some(e)) => e.get_field_mut(field),
                MeasureType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedAdminPerformFunction {
    #[doc = "Performer"]
    #[code = "performer"]
    Performer(Option<Element>),
    #[doc = "Verifier"]
    #[code = "verifier"]
    Verifier(Option<Element>),
    #[doc = "Witness"]
    #[code = "witness"]
    Witness(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedAdminPerformFunction {
    fn default() -> Self {
        MedAdminPerformFunction::Null(None)
    }
}
impl TryFrom<String> for MedAdminPerformFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "performer" => Ok(MedAdminPerformFunction::Performer(None)),
            "verifier" => Ok(MedAdminPerformFunction::Verifier(None)),
            "witness" => Ok(MedAdminPerformFunction::Witness(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedAdminPerformFunction {
    fn into(self) -> Option<String> {
        match self {
            MedAdminPerformFunction::Performer(_) => Some("performer".to_string()),
            MedAdminPerformFunction::Verifier(_) => Some("verifier".to_string()),
            MedAdminPerformFunction::Witness(_) => Some("witness".to_string()),
            MedAdminPerformFunction::Null(_) => None,
        }
    }
}
impl MetaValue for MedAdminPerformFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedAdminPerformFunction::Performer(Some(e)) => e.get_field(field),
                MedAdminPerformFunction::Verifier(Some(e)) => e.get_field(field),
                MedAdminPerformFunction::Witness(Some(e)) => e.get_field(field),
                MedAdminPerformFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedAdminPerformFunction::Performer(Some(e)) => e.get_field_mut(field),
                MedAdminPerformFunction::Verifier(Some(e)) => e.get_field_mut(field),
                MedAdminPerformFunction::Witness(Some(e)) => e.get_field_mut(field),
                MedAdminPerformFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MediaType {
    #[doc = "Audio"]
    #[code = "audio"]
    Audio(Option<Element>),
    #[doc = "Image"]
    #[code = "image"]
    Image(Option<Element>),
    #[doc = "Video"]
    #[code = "video"]
    Video(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MediaType {
    fn default() -> Self {
        MediaType::Null(None)
    }
}
impl TryFrom<String> for MediaType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "audio" => Ok(MediaType::Audio(None)),
            "image" => Ok(MediaType::Image(None)),
            "video" => Ok(MediaType::Video(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MediaType {
    fn into(self) -> Option<String> {
        match self {
            MediaType::Audio(_) => Some("audio".to_string()),
            MediaType::Image(_) => Some("image".to_string()),
            MediaType::Video(_) => Some("video".to_string()),
            MediaType::Null(_) => None,
        }
    }
}
impl MetaValue for MediaType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MediaType::Audio(Some(e)) => e.get_field(field),
                MediaType::Image(Some(e)) => e.get_field(field),
                MediaType::Video(Some(e)) => e.get_field(field),
                MediaType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MediaType::Audio(Some(e)) => e.get_field_mut(field),
                MediaType::Image(Some(e)) => e.get_field_mut(field),
                MediaType::Video(Some(e)) => e.get_field_mut(field),
                MediaType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationAdminCategory {
    #[doc = "Community"]
    #[code = "community"]
    Community(Option<Element>),
    #[doc = "Inpatient"]
    #[code = "inpatient"]
    Inpatient(Option<Element>),
    #[doc = "Outpatient"]
    #[code = "outpatient"]
    Outpatient(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationAdminCategory {
    fn default() -> Self {
        MedicationAdminCategory::Null(None)
    }
}
impl TryFrom<String> for MedicationAdminCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "community" => Ok(MedicationAdminCategory::Community(None)),
            "inpatient" => Ok(MedicationAdminCategory::Inpatient(None)),
            "outpatient" => Ok(MedicationAdminCategory::Outpatient(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationAdminCategory {
    fn into(self) -> Option<String> {
        match self {
            MedicationAdminCategory::Community(_) => Some("community".to_string()),
            MedicationAdminCategory::Inpatient(_) => Some("inpatient".to_string()),
            MedicationAdminCategory::Outpatient(_) => Some("outpatient".to_string()),
            MedicationAdminCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationAdminCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationAdminCategory::Community(Some(e)) => e.get_field(field),
                MedicationAdminCategory::Inpatient(Some(e)) => e.get_field(field),
                MedicationAdminCategory::Outpatient(Some(e)) => e.get_field(field),
                MedicationAdminCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationAdminCategory::Community(Some(e)) => e.get_field_mut(field),
                MedicationAdminCategory::Inpatient(Some(e)) => e.get_field_mut(field),
                MedicationAdminCategory::Outpatient(Some(e)) => e.get_field_mut(field),
                MedicationAdminCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationAdminStatus {
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Not Done"]
    #[code = "not-done"]
    NotDone(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationAdminStatus {
    fn default() -> Self {
        MedicationAdminStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationAdminStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(MedicationAdminStatus::Completed(None)),
            "entered-in-error" => Ok(MedicationAdminStatus::EnteredInError(None)),
            "in-progress" => Ok(MedicationAdminStatus::InProgress(None)),
            "not-done" => Ok(MedicationAdminStatus::NotDone(None)),
            "on-hold" => Ok(MedicationAdminStatus::OnHold(None)),
            "stopped" => Ok(MedicationAdminStatus::Stopped(None)),
            "unknown" => Ok(MedicationAdminStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationAdminStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationAdminStatus::Completed(_) => Some("completed".to_string()),
            MedicationAdminStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationAdminStatus::InProgress(_) => Some("in-progress".to_string()),
            MedicationAdminStatus::NotDone(_) => Some("not-done".to_string()),
            MedicationAdminStatus::OnHold(_) => Some("on-hold".to_string()),
            MedicationAdminStatus::Stopped(_) => Some("stopped".to_string()),
            MedicationAdminStatus::Unknown(_) => Some("unknown".to_string()),
            MedicationAdminStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationAdminStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationAdminStatus::Completed(Some(e)) => e.get_field(field),
                MedicationAdminStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationAdminStatus::InProgress(Some(e)) => e.get_field(field),
                MedicationAdminStatus::NotDone(Some(e)) => e.get_field(field),
                MedicationAdminStatus::OnHold(Some(e)) => e.get_field(field),
                MedicationAdminStatus::Stopped(Some(e)) => e.get_field(field),
                MedicationAdminStatus::Unknown(Some(e)) => e.get_field(field),
                MedicationAdminStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationAdminStatus::Completed(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::InProgress(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::NotDone(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::OnHold(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::Stopped(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::Unknown(Some(e)) => e.get_field_mut(field),
                MedicationAdminStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationStatementCategory {
    #[doc = "Community"]
    #[code = "community"]
    Community(Option<Element>),
    #[doc = "Inpatient"]
    #[code = "inpatient"]
    Inpatient(Option<Element>),
    #[doc = "Outpatient"]
    #[code = "outpatient"]
    Outpatient(Option<Element>),
    #[doc = "Patient Specified"]
    #[code = "patientspecified"]
    Patientspecified(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationStatementCategory {
    fn default() -> Self {
        MedicationStatementCategory::Null(None)
    }
}
impl TryFrom<String> for MedicationStatementCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "community" => Ok(MedicationStatementCategory::Community(None)),
            "inpatient" => Ok(MedicationStatementCategory::Inpatient(None)),
            "outpatient" => Ok(MedicationStatementCategory::Outpatient(None)),
            "patientspecified" => Ok(MedicationStatementCategory::Patientspecified(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationStatementCategory {
    fn into(self) -> Option<String> {
        match self {
            MedicationStatementCategory::Community(_) => Some("community".to_string()),
            MedicationStatementCategory::Inpatient(_) => Some("inpatient".to_string()),
            MedicationStatementCategory::Outpatient(_) => Some("outpatient".to_string()),
            MedicationStatementCategory::Patientspecified(_) => {
                Some("patientspecified".to_string())
            }
            MedicationStatementCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationStatementCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationStatementCategory::Community(Some(e)) => e.get_field(field),
                MedicationStatementCategory::Inpatient(Some(e)) => e.get_field(field),
                MedicationStatementCategory::Outpatient(Some(e)) => e.get_field(field),
                MedicationStatementCategory::Patientspecified(Some(e)) => e.get_field(field),
                MedicationStatementCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationStatementCategory::Community(Some(e)) => e.get_field_mut(field),
                MedicationStatementCategory::Inpatient(Some(e)) => e.get_field_mut(field),
                MedicationStatementCategory::Outpatient(Some(e)) => e.get_field_mut(field),
                MedicationStatementCategory::Patientspecified(Some(e)) => e.get_field_mut(field),
                MedicationStatementCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationStatementStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Intended"]
    #[code = "intended"]
    Intended(Option<Element>),
    #[doc = "Not Taken"]
    #[code = "not-taken"]
    NotTaken(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationStatementStatus {
    fn default() -> Self {
        MedicationStatementStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationStatementStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(MedicationStatementStatus::Active(None)),
            "completed" => Ok(MedicationStatementStatus::Completed(None)),
            "entered-in-error" => Ok(MedicationStatementStatus::EnteredInError(None)),
            "intended" => Ok(MedicationStatementStatus::Intended(None)),
            "not-taken" => Ok(MedicationStatementStatus::NotTaken(None)),
            "on-hold" => Ok(MedicationStatementStatus::OnHold(None)),
            "stopped" => Ok(MedicationStatementStatus::Stopped(None)),
            "unknown" => Ok(MedicationStatementStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationStatementStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationStatementStatus::Active(_) => Some("active".to_string()),
            MedicationStatementStatus::Completed(_) => Some("completed".to_string()),
            MedicationStatementStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationStatementStatus::Intended(_) => Some("intended".to_string()),
            MedicationStatementStatus::NotTaken(_) => Some("not-taken".to_string()),
            MedicationStatementStatus::OnHold(_) => Some("on-hold".to_string()),
            MedicationStatementStatus::Stopped(_) => Some("stopped".to_string()),
            MedicationStatementStatus::Unknown(_) => Some("unknown".to_string()),
            MedicationStatementStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationStatementStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationStatementStatus::Active(Some(e)) => e.get_field(field),
                MedicationStatementStatus::Completed(Some(e)) => e.get_field(field),
                MedicationStatementStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationStatementStatus::Intended(Some(e)) => e.get_field(field),
                MedicationStatementStatus::NotTaken(Some(e)) => e.get_field(field),
                MedicationStatementStatus::OnHold(Some(e)) => e.get_field(field),
                MedicationStatementStatus::Stopped(Some(e)) => e.get_field(field),
                MedicationStatementStatus::Unknown(Some(e)) => e.get_field(field),
                MedicationStatementStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationStatementStatus::Active(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::Completed(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::Intended(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::NotTaken(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::OnHold(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::Stopped(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::Unknown(Some(e)) => e.get_field_mut(field),
                MedicationStatementStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationStatus {
    fn default() -> Self {
        MedicationStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(MedicationStatus::Active(None)),
            "entered-in-error" => Ok(MedicationStatus::EnteredInError(None)),
            "inactive" => Ok(MedicationStatus::Inactive(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationStatus::Active(_) => Some("active".to_string()),
            MedicationStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationStatus::Inactive(_) => Some("inactive".to_string()),
            MedicationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationStatus::Active(Some(e)) => e.get_field(field),
                MedicationStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationStatus::Inactive(Some(e)) => e.get_field(field),
                MedicationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationStatus::Active(Some(e)) => e.get_field_mut(field),
                MedicationStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationStatus::Inactive(Some(e)) => e.get_field_mut(field),
                MedicationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationdispenseCategory {
    #[doc = "Community"]
    #[code = "community"]
    Community(Option<Element>),
    #[doc = "Discharge"]
    #[code = "discharge"]
    Discharge(Option<Element>),
    #[doc = "Inpatient"]
    #[code = "inpatient"]
    Inpatient(Option<Element>),
    #[doc = "Outpatient"]
    #[code = "outpatient"]
    Outpatient(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationdispenseCategory {
    fn default() -> Self {
        MedicationdispenseCategory::Null(None)
    }
}
impl TryFrom<String> for MedicationdispenseCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "community" => Ok(MedicationdispenseCategory::Community(None)),
            "discharge" => Ok(MedicationdispenseCategory::Discharge(None)),
            "inpatient" => Ok(MedicationdispenseCategory::Inpatient(None)),
            "outpatient" => Ok(MedicationdispenseCategory::Outpatient(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationdispenseCategory {
    fn into(self) -> Option<String> {
        match self {
            MedicationdispenseCategory::Community(_) => Some("community".to_string()),
            MedicationdispenseCategory::Discharge(_) => Some("discharge".to_string()),
            MedicationdispenseCategory::Inpatient(_) => Some("inpatient".to_string()),
            MedicationdispenseCategory::Outpatient(_) => Some("outpatient".to_string()),
            MedicationdispenseCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationdispenseCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationdispenseCategory::Community(Some(e)) => e.get_field(field),
                MedicationdispenseCategory::Discharge(Some(e)) => e.get_field(field),
                MedicationdispenseCategory::Inpatient(Some(e)) => e.get_field(field),
                MedicationdispenseCategory::Outpatient(Some(e)) => e.get_field(field),
                MedicationdispenseCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationdispenseCategory::Community(Some(e)) => e.get_field_mut(field),
                MedicationdispenseCategory::Discharge(Some(e)) => e.get_field_mut(field),
                MedicationdispenseCategory::Inpatient(Some(e)) => e.get_field_mut(field),
                MedicationdispenseCategory::Outpatient(Some(e)) => e.get_field_mut(field),
                MedicationdispenseCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationdispensePerformerFunction {
    #[doc = "Checker"]
    #[code = "checker"]
    Checker(Option<Element>),
    #[doc = "Data Enterer"]
    #[code = "dataenterer"]
    Dataenterer(Option<Element>),
    #[doc = "Final Checker"]
    #[code = "finalchecker"]
    Finalchecker(Option<Element>),
    #[doc = "Packager"]
    #[code = "packager"]
    Packager(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationdispensePerformerFunction {
    fn default() -> Self {
        MedicationdispensePerformerFunction::Null(None)
    }
}
impl TryFrom<String> for MedicationdispensePerformerFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "checker" => Ok(MedicationdispensePerformerFunction::Checker(None)),
            "dataenterer" => Ok(MedicationdispensePerformerFunction::Dataenterer(None)),
            "finalchecker" => Ok(MedicationdispensePerformerFunction::Finalchecker(None)),
            "packager" => Ok(MedicationdispensePerformerFunction::Packager(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationdispensePerformerFunction {
    fn into(self) -> Option<String> {
        match self {
            MedicationdispensePerformerFunction::Checker(_) => Some("checker".to_string()),
            MedicationdispensePerformerFunction::Dataenterer(_) => Some("dataenterer".to_string()),
            MedicationdispensePerformerFunction::Finalchecker(_) => {
                Some("finalchecker".to_string())
            }
            MedicationdispensePerformerFunction::Packager(_) => Some("packager".to_string()),
            MedicationdispensePerformerFunction::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationdispensePerformerFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationdispensePerformerFunction::Checker(Some(e)) => e.get_field(field),
                MedicationdispensePerformerFunction::Dataenterer(Some(e)) => e.get_field(field),
                MedicationdispensePerformerFunction::Finalchecker(Some(e)) => e.get_field(field),
                MedicationdispensePerformerFunction::Packager(Some(e)) => e.get_field(field),
                MedicationdispensePerformerFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationdispensePerformerFunction::Checker(Some(e)) => e.get_field_mut(field),
                MedicationdispensePerformerFunction::Dataenterer(Some(e)) => e.get_field_mut(field),
                MedicationdispensePerformerFunction::Finalchecker(Some(e)) => {
                    e.get_field_mut(field)
                }
                MedicationdispensePerformerFunction::Packager(Some(e)) => e.get_field_mut(field),
                MedicationdispensePerformerFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationdispenseStatus {
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Declined"]
    #[code = "declined"]
    Declined(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Preparation"]
    #[code = "preparation"]
    Preparation(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationdispenseStatus {
    fn default() -> Self {
        MedicationdispenseStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationdispenseStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cancelled" => Ok(MedicationdispenseStatus::Cancelled(None)),
            "completed" => Ok(MedicationdispenseStatus::Completed(None)),
            "declined" => Ok(MedicationdispenseStatus::Declined(None)),
            "entered-in-error" => Ok(MedicationdispenseStatus::EnteredInError(None)),
            "in-progress" => Ok(MedicationdispenseStatus::InProgress(None)),
            "on-hold" => Ok(MedicationdispenseStatus::OnHold(None)),
            "preparation" => Ok(MedicationdispenseStatus::Preparation(None)),
            "stopped" => Ok(MedicationdispenseStatus::Stopped(None)),
            "unknown" => Ok(MedicationdispenseStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationdispenseStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationdispenseStatus::Cancelled(_) => Some("cancelled".to_string()),
            MedicationdispenseStatus::Completed(_) => Some("completed".to_string()),
            MedicationdispenseStatus::Declined(_) => Some("declined".to_string()),
            MedicationdispenseStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationdispenseStatus::InProgress(_) => Some("in-progress".to_string()),
            MedicationdispenseStatus::OnHold(_) => Some("on-hold".to_string()),
            MedicationdispenseStatus::Preparation(_) => Some("preparation".to_string()),
            MedicationdispenseStatus::Stopped(_) => Some("stopped".to_string()),
            MedicationdispenseStatus::Unknown(_) => Some("unknown".to_string()),
            MedicationdispenseStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationdispenseStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationdispenseStatus::Cancelled(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Completed(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Declined(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::InProgress(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::OnHold(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Preparation(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Stopped(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Unknown(Some(e)) => e.get_field(field),
                MedicationdispenseStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationdispenseStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Completed(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Declined(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::InProgress(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::OnHold(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Preparation(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Stopped(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Unknown(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationdispenseStatusReason {
    #[doc = "Try another treatment first"]
    #[code = "altchoice"]
    Altchoice(Option<Element>),
    #[doc = "Prescription/Request requires clarification"]
    #[code = "clarif"]
    Clarif(Option<Element>),
    #[doc = "Drug level too high"]
    #[code = "drughigh"]
    Drughigh(Option<Element>),
    #[doc = "Order Stopped"]
    #[code = "frr01"]
    Frr01(Option<Element>),
    #[doc = "Stale-dated Order"]
    #[code = "frr02"]
    Frr02(Option<Element>),
    #[doc = "Incomplete data"]
    #[code = "frr03"]
    Frr03(Option<Element>),
    #[doc = "Product unavailable"]
    #[code = "frr04"]
    Frr04(Option<Element>),
    #[doc = "Ethical/religious"]
    #[code = "frr05"]
    Frr05(Option<Element>),
    #[doc = "Unable to provide care"]
    #[code = "frr06"]
    Frr06(Option<Element>),
    #[doc = "Admission to hospital"]
    #[code = "hospadm"]
    Hospadm(Option<Element>),
    #[doc = "Lab interference issues"]
    #[code = "labint"]
    Labint(Option<Element>),
    #[doc = "Patient not available"]
    #[code = "non-avail"]
    NonAvail(Option<Element>),
    #[doc = "Drug not available - off market"]
    #[code = "offmarket"]
    Offmarket(Option<Element>),
    #[doc = "Drug not available - out of stock"]
    #[code = "outofstock"]
    Outofstock(Option<Element>),
    #[doc = "Patient is pregnant or breastfeeding"]
    #[code = "preg"]
    Preg(Option<Element>),
    #[doc = "Allergy"]
    #[code = "saig"]
    Saig(Option<Element>),
    #[doc = "Drug interacts with another drug"]
    #[code = "sddi"]
    Sddi(Option<Element>),
    #[doc = "Duplicate therapy"]
    #[code = "sdupther"]
    Sdupther(Option<Element>),
    #[doc = "Suspected intolerance"]
    #[code = "sintol"]
    Sintol(Option<Element>),
    #[doc = "Patient scheduled for surgery"]
    #[code = "surg"]
    Surg(Option<Element>),
    #[doc = "Washout"]
    #[code = "washout"]
    Washout(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationdispenseStatusReason {
    fn default() -> Self {
        MedicationdispenseStatusReason::Null(None)
    }
}
impl TryFrom<String> for MedicationdispenseStatusReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "altchoice" => Ok(MedicationdispenseStatusReason::Altchoice(None)),
            "clarif" => Ok(MedicationdispenseStatusReason::Clarif(None)),
            "drughigh" => Ok(MedicationdispenseStatusReason::Drughigh(None)),
            "frr01" => Ok(MedicationdispenseStatusReason::Frr01(None)),
            "frr02" => Ok(MedicationdispenseStatusReason::Frr02(None)),
            "frr03" => Ok(MedicationdispenseStatusReason::Frr03(None)),
            "frr04" => Ok(MedicationdispenseStatusReason::Frr04(None)),
            "frr05" => Ok(MedicationdispenseStatusReason::Frr05(None)),
            "frr06" => Ok(MedicationdispenseStatusReason::Frr06(None)),
            "hospadm" => Ok(MedicationdispenseStatusReason::Hospadm(None)),
            "labint" => Ok(MedicationdispenseStatusReason::Labint(None)),
            "non-avail" => Ok(MedicationdispenseStatusReason::NonAvail(None)),
            "offmarket" => Ok(MedicationdispenseStatusReason::Offmarket(None)),
            "outofstock" => Ok(MedicationdispenseStatusReason::Outofstock(None)),
            "preg" => Ok(MedicationdispenseStatusReason::Preg(None)),
            "saig" => Ok(MedicationdispenseStatusReason::Saig(None)),
            "sddi" => Ok(MedicationdispenseStatusReason::Sddi(None)),
            "sdupther" => Ok(MedicationdispenseStatusReason::Sdupther(None)),
            "sintol" => Ok(MedicationdispenseStatusReason::Sintol(None)),
            "surg" => Ok(MedicationdispenseStatusReason::Surg(None)),
            "washout" => Ok(MedicationdispenseStatusReason::Washout(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationdispenseStatusReason {
    fn into(self) -> Option<String> {
        match self {
            MedicationdispenseStatusReason::Altchoice(_) => Some("altchoice".to_string()),
            MedicationdispenseStatusReason::Clarif(_) => Some("clarif".to_string()),
            MedicationdispenseStatusReason::Drughigh(_) => Some("drughigh".to_string()),
            MedicationdispenseStatusReason::Frr01(_) => Some("frr01".to_string()),
            MedicationdispenseStatusReason::Frr02(_) => Some("frr02".to_string()),
            MedicationdispenseStatusReason::Frr03(_) => Some("frr03".to_string()),
            MedicationdispenseStatusReason::Frr04(_) => Some("frr04".to_string()),
            MedicationdispenseStatusReason::Frr05(_) => Some("frr05".to_string()),
            MedicationdispenseStatusReason::Frr06(_) => Some("frr06".to_string()),
            MedicationdispenseStatusReason::Hospadm(_) => Some("hospadm".to_string()),
            MedicationdispenseStatusReason::Labint(_) => Some("labint".to_string()),
            MedicationdispenseStatusReason::NonAvail(_) => Some("non-avail".to_string()),
            MedicationdispenseStatusReason::Offmarket(_) => Some("offmarket".to_string()),
            MedicationdispenseStatusReason::Outofstock(_) => Some("outofstock".to_string()),
            MedicationdispenseStatusReason::Preg(_) => Some("preg".to_string()),
            MedicationdispenseStatusReason::Saig(_) => Some("saig".to_string()),
            MedicationdispenseStatusReason::Sddi(_) => Some("sddi".to_string()),
            MedicationdispenseStatusReason::Sdupther(_) => Some("sdupther".to_string()),
            MedicationdispenseStatusReason::Sintol(_) => Some("sintol".to_string()),
            MedicationdispenseStatusReason::Surg(_) => Some("surg".to_string()),
            MedicationdispenseStatusReason::Washout(_) => Some("washout".to_string()),
            MedicationdispenseStatusReason::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationdispenseStatusReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationdispenseStatusReason::Altchoice(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Clarif(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Drughigh(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr01(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr02(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr03(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr04(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr05(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Frr06(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Hospadm(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Labint(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::NonAvail(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Offmarket(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Outofstock(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Preg(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Saig(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Sddi(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Sdupther(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Sintol(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Surg(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Washout(Some(e)) => e.get_field(field),
                MedicationdispenseStatusReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationdispenseStatusReason::Altchoice(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Clarif(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Drughigh(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr01(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr02(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr03(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr04(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr05(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Frr06(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Hospadm(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Labint(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::NonAvail(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Offmarket(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Outofstock(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Preg(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Saig(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Sddi(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Sdupther(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Sintol(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Surg(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Washout(Some(e)) => e.get_field_mut(field),
                MedicationdispenseStatusReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationknowledgeCharacteristic {
    #[doc = "Coating"]
    #[code = "coating"]
    Coating(Option<Element>),
    #[doc = "Color"]
    #[code = "color"]
    Color(Option<Element>),
    #[doc = "Imprint Code"]
    #[code = "imprintcd"]
    Imprintcd(Option<Element>),
    #[doc = "Logo"]
    #[code = "logo"]
    Logo(Option<Element>),
    #[doc = "Scoring"]
    #[code = "scoring"]
    Scoring(Option<Element>),
    #[doc = "Shape"]
    #[code = "shape"]
    Shape(Option<Element>),
    #[doc = "Size"]
    #[code = "size"]
    Size(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationknowledgeCharacteristic {
    fn default() -> Self {
        MedicationknowledgeCharacteristic::Null(None)
    }
}
impl TryFrom<String> for MedicationknowledgeCharacteristic {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "coating" => Ok(MedicationknowledgeCharacteristic::Coating(None)),
            "color" => Ok(MedicationknowledgeCharacteristic::Color(None)),
            "imprintcd" => Ok(MedicationknowledgeCharacteristic::Imprintcd(None)),
            "logo" => Ok(MedicationknowledgeCharacteristic::Logo(None)),
            "scoring" => Ok(MedicationknowledgeCharacteristic::Scoring(None)),
            "shape" => Ok(MedicationknowledgeCharacteristic::Shape(None)),
            "size" => Ok(MedicationknowledgeCharacteristic::Size(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationknowledgeCharacteristic {
    fn into(self) -> Option<String> {
        match self {
            MedicationknowledgeCharacteristic::Coating(_) => Some("coating".to_string()),
            MedicationknowledgeCharacteristic::Color(_) => Some("color".to_string()),
            MedicationknowledgeCharacteristic::Imprintcd(_) => Some("imprintcd".to_string()),
            MedicationknowledgeCharacteristic::Logo(_) => Some("logo".to_string()),
            MedicationknowledgeCharacteristic::Scoring(_) => Some("scoring".to_string()),
            MedicationknowledgeCharacteristic::Shape(_) => Some("shape".to_string()),
            MedicationknowledgeCharacteristic::Size(_) => Some("size".to_string()),
            MedicationknowledgeCharacteristic::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationknowledgeCharacteristic {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationknowledgeCharacteristic::Coating(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Color(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Imprintcd(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Logo(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Scoring(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Shape(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Size(Some(e)) => e.get_field(field),
                MedicationknowledgeCharacteristic::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationknowledgeCharacteristic::Coating(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Color(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Imprintcd(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Logo(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Scoring(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Shape(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Size(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeCharacteristic::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationknowledgePackageType {
    #[doc = "Ampule"]
    #[code = "amp"]
    Amp(Option<Element>),
    #[doc = "Bag"]
    #[code = "bag"]
    Bag(Option<Element>),
    #[doc = "Blister Pack"]
    #[code = "blstrpk"]
    Blstrpk(Option<Element>),
    #[doc = "Bottle"]
    #[code = "bot"]
    Bot(Option<Element>),
    #[doc = "Box"]
    #[code = "box"]
    Box(Option<Element>),
    #[doc = "Can"]
    #[code = "can"]
    Can(Option<Element>),
    #[doc = "Cartridge"]
    #[code = "cart"]
    Cart(Option<Element>),
    #[doc = "Disk"]
    #[code = "disk"]
    Disk(Option<Element>),
    #[doc = "Dosette"]
    #[code = "doset"]
    Doset(Option<Element>),
    #[doc = "Jar"]
    #[code = "jar"]
    Jar(Option<Element>),
    #[doc = "Jug"]
    #[code = "jug"]
    Jug(Option<Element>),
    #[doc = "Minim"]
    #[code = "minim"]
    Minim(Option<Element>),
    #[doc = "Nebule Amp"]
    #[code = "nebamp"]
    Nebamp(Option<Element>),
    #[doc = "Ovule"]
    #[code = "ovul"]
    Ovul(Option<Element>),
    #[doc = "Pouch"]
    #[code = "pch"]
    Pch(Option<Element>),
    #[doc = "Packet"]
    #[code = "pkt"]
    Pkt(Option<Element>),
    #[doc = "Sashet"]
    #[code = "sash"]
    Sash(Option<Element>),
    #[doc = "Strip"]
    #[code = "strip"]
    Strip(Option<Element>),
    #[doc = "Tin"]
    #[code = "tin"]
    Tin(Option<Element>),
    #[doc = "Tub"]
    #[code = "tub"]
    Tub(Option<Element>),
    #[doc = "Tube"]
    #[code = "tube"]
    Tube(Option<Element>),
    #[doc = "Vial"]
    #[code = "vial"]
    Vial(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationknowledgePackageType {
    fn default() -> Self {
        MedicationknowledgePackageType::Null(None)
    }
}
impl TryFrom<String> for MedicationknowledgePackageType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amp" => Ok(MedicationknowledgePackageType::Amp(None)),
            "bag" => Ok(MedicationknowledgePackageType::Bag(None)),
            "blstrpk" => Ok(MedicationknowledgePackageType::Blstrpk(None)),
            "bot" => Ok(MedicationknowledgePackageType::Bot(None)),
            "box" => Ok(MedicationknowledgePackageType::Box(None)),
            "can" => Ok(MedicationknowledgePackageType::Can(None)),
            "cart" => Ok(MedicationknowledgePackageType::Cart(None)),
            "disk" => Ok(MedicationknowledgePackageType::Disk(None)),
            "doset" => Ok(MedicationknowledgePackageType::Doset(None)),
            "jar" => Ok(MedicationknowledgePackageType::Jar(None)),
            "jug" => Ok(MedicationknowledgePackageType::Jug(None)),
            "minim" => Ok(MedicationknowledgePackageType::Minim(None)),
            "nebamp" => Ok(MedicationknowledgePackageType::Nebamp(None)),
            "ovul" => Ok(MedicationknowledgePackageType::Ovul(None)),
            "pch" => Ok(MedicationknowledgePackageType::Pch(None)),
            "pkt" => Ok(MedicationknowledgePackageType::Pkt(None)),
            "sash" => Ok(MedicationknowledgePackageType::Sash(None)),
            "strip" => Ok(MedicationknowledgePackageType::Strip(None)),
            "tin" => Ok(MedicationknowledgePackageType::Tin(None)),
            "tub" => Ok(MedicationknowledgePackageType::Tub(None)),
            "tube" => Ok(MedicationknowledgePackageType::Tube(None)),
            "vial" => Ok(MedicationknowledgePackageType::Vial(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationknowledgePackageType {
    fn into(self) -> Option<String> {
        match self {
            MedicationknowledgePackageType::Amp(_) => Some("amp".to_string()),
            MedicationknowledgePackageType::Bag(_) => Some("bag".to_string()),
            MedicationknowledgePackageType::Blstrpk(_) => Some("blstrpk".to_string()),
            MedicationknowledgePackageType::Bot(_) => Some("bot".to_string()),
            MedicationknowledgePackageType::Box(_) => Some("box".to_string()),
            MedicationknowledgePackageType::Can(_) => Some("can".to_string()),
            MedicationknowledgePackageType::Cart(_) => Some("cart".to_string()),
            MedicationknowledgePackageType::Disk(_) => Some("disk".to_string()),
            MedicationknowledgePackageType::Doset(_) => Some("doset".to_string()),
            MedicationknowledgePackageType::Jar(_) => Some("jar".to_string()),
            MedicationknowledgePackageType::Jug(_) => Some("jug".to_string()),
            MedicationknowledgePackageType::Minim(_) => Some("minim".to_string()),
            MedicationknowledgePackageType::Nebamp(_) => Some("nebamp".to_string()),
            MedicationknowledgePackageType::Ovul(_) => Some("ovul".to_string()),
            MedicationknowledgePackageType::Pch(_) => Some("pch".to_string()),
            MedicationknowledgePackageType::Pkt(_) => Some("pkt".to_string()),
            MedicationknowledgePackageType::Sash(_) => Some("sash".to_string()),
            MedicationknowledgePackageType::Strip(_) => Some("strip".to_string()),
            MedicationknowledgePackageType::Tin(_) => Some("tin".to_string()),
            MedicationknowledgePackageType::Tub(_) => Some("tub".to_string()),
            MedicationknowledgePackageType::Tube(_) => Some("tube".to_string()),
            MedicationknowledgePackageType::Vial(_) => Some("vial".to_string()),
            MedicationknowledgePackageType::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationknowledgePackageType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationknowledgePackageType::Amp(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Bag(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Blstrpk(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Bot(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Box(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Can(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Cart(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Disk(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Doset(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Jar(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Jug(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Minim(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Nebamp(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Ovul(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Pch(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Pkt(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Sash(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Strip(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Tin(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Tub(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Tube(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Vial(Some(e)) => e.get_field(field),
                MedicationknowledgePackageType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationknowledgePackageType::Amp(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Bag(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Blstrpk(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Bot(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Box(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Can(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Cart(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Disk(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Doset(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Jar(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Jug(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Minim(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Nebamp(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Ovul(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Pch(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Pkt(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Sash(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Strip(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Tin(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Tub(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Tube(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Vial(Some(e)) => e.get_field_mut(field),
                MedicationknowledgePackageType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationknowledgeStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationknowledgeStatus {
    fn default() -> Self {
        MedicationknowledgeStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationknowledgeStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(MedicationknowledgeStatus::Active(None)),
            "entered-in-error" => Ok(MedicationknowledgeStatus::EnteredInError(None)),
            "inactive" => Ok(MedicationknowledgeStatus::Inactive(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationknowledgeStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationknowledgeStatus::Active(_) => Some("active".to_string()),
            MedicationknowledgeStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationknowledgeStatus::Inactive(_) => Some("inactive".to_string()),
            MedicationknowledgeStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationknowledgeStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationknowledgeStatus::Active(Some(e)) => e.get_field(field),
                MedicationknowledgeStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationknowledgeStatus::Inactive(Some(e)) => e.get_field(field),
                MedicationknowledgeStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationknowledgeStatus::Active(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeStatus::Inactive(Some(e)) => e.get_field_mut(field),
                MedicationknowledgeStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationrequestCategory {
    #[doc = "Community"]
    #[code = "community"]
    Community(Option<Element>),
    #[doc = "Discharge"]
    #[code = "discharge"]
    Discharge(Option<Element>),
    #[doc = "Inpatient"]
    #[code = "inpatient"]
    Inpatient(Option<Element>),
    #[doc = "Outpatient"]
    #[code = "outpatient"]
    Outpatient(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationrequestCategory {
    fn default() -> Self {
        MedicationrequestCategory::Null(None)
    }
}
impl TryFrom<String> for MedicationrequestCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "community" => Ok(MedicationrequestCategory::Community(None)),
            "discharge" => Ok(MedicationrequestCategory::Discharge(None)),
            "inpatient" => Ok(MedicationrequestCategory::Inpatient(None)),
            "outpatient" => Ok(MedicationrequestCategory::Outpatient(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationrequestCategory {
    fn into(self) -> Option<String> {
        match self {
            MedicationrequestCategory::Community(_) => Some("community".to_string()),
            MedicationrequestCategory::Discharge(_) => Some("discharge".to_string()),
            MedicationrequestCategory::Inpatient(_) => Some("inpatient".to_string()),
            MedicationrequestCategory::Outpatient(_) => Some("outpatient".to_string()),
            MedicationrequestCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationrequestCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationrequestCategory::Community(Some(e)) => e.get_field(field),
                MedicationrequestCategory::Discharge(Some(e)) => e.get_field(field),
                MedicationrequestCategory::Inpatient(Some(e)) => e.get_field(field),
                MedicationrequestCategory::Outpatient(Some(e)) => e.get_field(field),
                MedicationrequestCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationrequestCategory::Community(Some(e)) => e.get_field_mut(field),
                MedicationrequestCategory::Discharge(Some(e)) => e.get_field_mut(field),
                MedicationrequestCategory::Inpatient(Some(e)) => e.get_field_mut(field),
                MedicationrequestCategory::Outpatient(Some(e)) => e.get_field_mut(field),
                MedicationrequestCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationrequestCourseOfTherapy {
    #[doc = "Short course (acute) therapy"]
    #[code = "acute"]
    Acute(Option<Element>),
    #[doc = "Continuous long term therapy"]
    #[code = "continuous"]
    Continuous(Option<Element>),
    #[doc = "Seasonal"]
    #[code = "seasonal"]
    Seasonal(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationrequestCourseOfTherapy {
    fn default() -> Self {
        MedicationrequestCourseOfTherapy::Null(None)
    }
}
impl TryFrom<String> for MedicationrequestCourseOfTherapy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "acute" => Ok(MedicationrequestCourseOfTherapy::Acute(None)),
            "continuous" => Ok(MedicationrequestCourseOfTherapy::Continuous(None)),
            "seasonal" => Ok(MedicationrequestCourseOfTherapy::Seasonal(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationrequestCourseOfTherapy {
    fn into(self) -> Option<String> {
        match self {
            MedicationrequestCourseOfTherapy::Acute(_) => Some("acute".to_string()),
            MedicationrequestCourseOfTherapy::Continuous(_) => Some("continuous".to_string()),
            MedicationrequestCourseOfTherapy::Seasonal(_) => Some("seasonal".to_string()),
            MedicationrequestCourseOfTherapy::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationrequestCourseOfTherapy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationrequestCourseOfTherapy::Acute(Some(e)) => e.get_field(field),
                MedicationrequestCourseOfTherapy::Continuous(Some(e)) => e.get_field(field),
                MedicationrequestCourseOfTherapy::Seasonal(Some(e)) => e.get_field(field),
                MedicationrequestCourseOfTherapy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationrequestCourseOfTherapy::Acute(Some(e)) => e.get_field_mut(field),
                MedicationrequestCourseOfTherapy::Continuous(Some(e)) => e.get_field_mut(field),
                MedicationrequestCourseOfTherapy::Seasonal(Some(e)) => e.get_field_mut(field),
                MedicationrequestCourseOfTherapy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationrequestIntent {
    #[doc = "Filler Order"]
    #[code = "filler-order"]
    FillerOrder(Option<Element>),
    #[doc = "Instance Order"]
    #[code = "instance-order"]
    InstanceOrder(Option<Element>),
    #[doc = "Option"]
    #[code = "option"]
    Option(Option<Element>),
    #[doc = "Order"]
    #[code = "order"]
    Order(Option<Element>),
    #[doc = "Original Order"]
    #[code = "original-order"]
    OriginalOrder(Option<Element>),
    #[doc = "Plan"]
    #[code = "plan"]
    Plan(Option<Element>),
    #[doc = "Proposal"]
    #[code = "proposal"]
    Proposal(Option<Element>),
    #[doc = "Reflex Order"]
    #[code = "reflex-order"]
    ReflexOrder(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationrequestIntent {
    fn default() -> Self {
        MedicationrequestIntent::Null(None)
    }
}
impl TryFrom<String> for MedicationrequestIntent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "filler-order" => Ok(MedicationrequestIntent::FillerOrder(None)),
            "instance-order" => Ok(MedicationrequestIntent::InstanceOrder(None)),
            "option" => Ok(MedicationrequestIntent::Option(None)),
            "order" => Ok(MedicationrequestIntent::Order(None)),
            "original-order" => Ok(MedicationrequestIntent::OriginalOrder(None)),
            "plan" => Ok(MedicationrequestIntent::Plan(None)),
            "proposal" => Ok(MedicationrequestIntent::Proposal(None)),
            "reflex-order" => Ok(MedicationrequestIntent::ReflexOrder(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationrequestIntent {
    fn into(self) -> Option<String> {
        match self {
            MedicationrequestIntent::FillerOrder(_) => Some("filler-order".to_string()),
            MedicationrequestIntent::InstanceOrder(_) => Some("instance-order".to_string()),
            MedicationrequestIntent::Option(_) => Some("option".to_string()),
            MedicationrequestIntent::Order(_) => Some("order".to_string()),
            MedicationrequestIntent::OriginalOrder(_) => Some("original-order".to_string()),
            MedicationrequestIntent::Plan(_) => Some("plan".to_string()),
            MedicationrequestIntent::Proposal(_) => Some("proposal".to_string()),
            MedicationrequestIntent::ReflexOrder(_) => Some("reflex-order".to_string()),
            MedicationrequestIntent::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationrequestIntent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationrequestIntent::FillerOrder(Some(e)) => e.get_field(field),
                MedicationrequestIntent::InstanceOrder(Some(e)) => e.get_field(field),
                MedicationrequestIntent::Option(Some(e)) => e.get_field(field),
                MedicationrequestIntent::Order(Some(e)) => e.get_field(field),
                MedicationrequestIntent::OriginalOrder(Some(e)) => e.get_field(field),
                MedicationrequestIntent::Plan(Some(e)) => e.get_field(field),
                MedicationrequestIntent::Proposal(Some(e)) => e.get_field(field),
                MedicationrequestIntent::ReflexOrder(Some(e)) => e.get_field(field),
                MedicationrequestIntent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationrequestIntent::FillerOrder(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::InstanceOrder(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::Option(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::Order(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::OriginalOrder(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::Plan(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::Proposal(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::ReflexOrder(Some(e)) => e.get_field_mut(field),
                MedicationrequestIntent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationrequestStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationrequestStatus {
    fn default() -> Self {
        MedicationrequestStatus::Null(None)
    }
}
impl TryFrom<String> for MedicationrequestStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(MedicationrequestStatus::Active(None)),
            "cancelled" => Ok(MedicationrequestStatus::Cancelled(None)),
            "completed" => Ok(MedicationrequestStatus::Completed(None)),
            "draft" => Ok(MedicationrequestStatus::Draft(None)),
            "entered-in-error" => Ok(MedicationrequestStatus::EnteredInError(None)),
            "on-hold" => Ok(MedicationrequestStatus::OnHold(None)),
            "stopped" => Ok(MedicationrequestStatus::Stopped(None)),
            "unknown" => Ok(MedicationrequestStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationrequestStatus {
    fn into(self) -> Option<String> {
        match self {
            MedicationrequestStatus::Active(_) => Some("active".to_string()),
            MedicationrequestStatus::Cancelled(_) => Some("cancelled".to_string()),
            MedicationrequestStatus::Completed(_) => Some("completed".to_string()),
            MedicationrequestStatus::Draft(_) => Some("draft".to_string()),
            MedicationrequestStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MedicationrequestStatus::OnHold(_) => Some("on-hold".to_string()),
            MedicationrequestStatus::Stopped(_) => Some("stopped".to_string()),
            MedicationrequestStatus::Unknown(_) => Some("unknown".to_string()),
            MedicationrequestStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationrequestStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationrequestStatus::Active(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Cancelled(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Completed(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Draft(Some(e)) => e.get_field(field),
                MedicationrequestStatus::EnteredInError(Some(e)) => e.get_field(field),
                MedicationrequestStatus::OnHold(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Stopped(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Unknown(Some(e)) => e.get_field(field),
                MedicationrequestStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationrequestStatus::Active(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Completed(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Draft(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::OnHold(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Stopped(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Unknown(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MedicationrequestStatusReason {
    #[doc = "Try another treatment first"]
    #[code = "altchoice"]
    Altchoice(Option<Element>),
    #[doc = "Prescription requires clarification"]
    #[code = "clarif"]
    Clarif(Option<Element>),
    #[doc = "Drug level too high"]
    #[code = "drughigh"]
    Drughigh(Option<Element>),
    #[doc = "Admission to hospital"]
    #[code = "hospadm"]
    Hospadm(Option<Element>),
    #[doc = "Lab interference issues"]
    #[code = "labint"]
    Labint(Option<Element>),
    #[doc = "Patient not available"]
    #[code = "non-avail"]
    NonAvail(Option<Element>),
    #[doc = "Parent is pregnant/breast feeding"]
    #[code = "preg"]
    Preg(Option<Element>),
    #[doc = "Allergy"]
    #[code = "salg"]
    Salg(Option<Element>),
    #[doc = "Drug interacts with another drug"]
    #[code = "sddi"]
    Sddi(Option<Element>),
    #[doc = "Duplicate therapy"]
    #[code = "sdupther"]
    Sdupther(Option<Element>),
    #[doc = "Suspected intolerance"]
    #[code = "sintol"]
    Sintol(Option<Element>),
    #[doc = "Patient scheduled for surgery."]
    #[code = "surg"]
    Surg(Option<Element>),
    #[doc = "Waiting for old drug to wash out"]
    #[code = "washout"]
    Washout(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MedicationrequestStatusReason {
    fn default() -> Self {
        MedicationrequestStatusReason::Null(None)
    }
}
impl TryFrom<String> for MedicationrequestStatusReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "altchoice" => Ok(MedicationrequestStatusReason::Altchoice(None)),
            "clarif" => Ok(MedicationrequestStatusReason::Clarif(None)),
            "drughigh" => Ok(MedicationrequestStatusReason::Drughigh(None)),
            "hospadm" => Ok(MedicationrequestStatusReason::Hospadm(None)),
            "labint" => Ok(MedicationrequestStatusReason::Labint(None)),
            "non-avail" => Ok(MedicationrequestStatusReason::NonAvail(None)),
            "preg" => Ok(MedicationrequestStatusReason::Preg(None)),
            "salg" => Ok(MedicationrequestStatusReason::Salg(None)),
            "sddi" => Ok(MedicationrequestStatusReason::Sddi(None)),
            "sdupther" => Ok(MedicationrequestStatusReason::Sdupther(None)),
            "sintol" => Ok(MedicationrequestStatusReason::Sintol(None)),
            "surg" => Ok(MedicationrequestStatusReason::Surg(None)),
            "washout" => Ok(MedicationrequestStatusReason::Washout(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MedicationrequestStatusReason {
    fn into(self) -> Option<String> {
        match self {
            MedicationrequestStatusReason::Altchoice(_) => Some("altchoice".to_string()),
            MedicationrequestStatusReason::Clarif(_) => Some("clarif".to_string()),
            MedicationrequestStatusReason::Drughigh(_) => Some("drughigh".to_string()),
            MedicationrequestStatusReason::Hospadm(_) => Some("hospadm".to_string()),
            MedicationrequestStatusReason::Labint(_) => Some("labint".to_string()),
            MedicationrequestStatusReason::NonAvail(_) => Some("non-avail".to_string()),
            MedicationrequestStatusReason::Preg(_) => Some("preg".to_string()),
            MedicationrequestStatusReason::Salg(_) => Some("salg".to_string()),
            MedicationrequestStatusReason::Sddi(_) => Some("sddi".to_string()),
            MedicationrequestStatusReason::Sdupther(_) => Some("sdupther".to_string()),
            MedicationrequestStatusReason::Sintol(_) => Some("sintol".to_string()),
            MedicationrequestStatusReason::Surg(_) => Some("surg".to_string()),
            MedicationrequestStatusReason::Washout(_) => Some("washout".to_string()),
            MedicationrequestStatusReason::Null(_) => None,
        }
    }
}
impl MetaValue for MedicationrequestStatusReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MedicationrequestStatusReason::Altchoice(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Clarif(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Drughigh(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Hospadm(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Labint(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::NonAvail(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Preg(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Salg(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Sddi(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Sdupther(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Sintol(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Surg(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Washout(Some(e)) => e.get_field(field),
                MedicationrequestStatusReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MedicationrequestStatusReason::Altchoice(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Clarif(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Drughigh(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Hospadm(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Labint(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::NonAvail(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Preg(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Salg(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Sddi(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Sdupther(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Sintol(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Surg(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Washout(Some(e)) => e.get_field_mut(field),
                MedicationrequestStatusReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MessageReasonEncounter {
    #[doc = "Absent"]
    #[code = "absent"]
    Absent(Option<Element>),
    #[doc = "Admit"]
    #[code = "admit"]
    Admit(Option<Element>),
    #[doc = "Discharge"]
    #[code = "discharge"]
    Discharge(Option<Element>),
    #[doc = "Edit"]
    #[code = "edit"]
    Edit(Option<Element>),
    #[doc = "Moved"]
    #[code = "moved"]
    Moved(Option<Element>),
    #[doc = "Returned"]
    #[code = "return"]
    Return(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MessageReasonEncounter {
    fn default() -> Self {
        MessageReasonEncounter::Null(None)
    }
}
impl TryFrom<String> for MessageReasonEncounter {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "absent" => Ok(MessageReasonEncounter::Absent(None)),
            "admit" => Ok(MessageReasonEncounter::Admit(None)),
            "discharge" => Ok(MessageReasonEncounter::Discharge(None)),
            "edit" => Ok(MessageReasonEncounter::Edit(None)),
            "moved" => Ok(MessageReasonEncounter::Moved(None)),
            "return" => Ok(MessageReasonEncounter::Return(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MessageReasonEncounter {
    fn into(self) -> Option<String> {
        match self {
            MessageReasonEncounter::Absent(_) => Some("absent".to_string()),
            MessageReasonEncounter::Admit(_) => Some("admit".to_string()),
            MessageReasonEncounter::Discharge(_) => Some("discharge".to_string()),
            MessageReasonEncounter::Edit(_) => Some("edit".to_string()),
            MessageReasonEncounter::Moved(_) => Some("moved".to_string()),
            MessageReasonEncounter::Return(_) => Some("return".to_string()),
            MessageReasonEncounter::Null(_) => None,
        }
    }
}
impl MetaValue for MessageReasonEncounter {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MessageReasonEncounter::Absent(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Admit(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Discharge(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Edit(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Moved(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Return(Some(e)) => e.get_field(field),
                MessageReasonEncounter::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MessageReasonEncounter::Absent(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Admit(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Discharge(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Edit(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Moved(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Return(Some(e)) => e.get_field_mut(field),
                MessageReasonEncounter::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MessageSignificanceCategory {
    #[doc = "Consequence"]
    #[code = "consequence"]
    Consequence(Option<Element>),
    #[doc = "Currency"]
    #[code = "currency"]
    Currency(Option<Element>),
    #[doc = "Notification"]
    #[code = "notification"]
    Notification(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MessageSignificanceCategory {
    fn default() -> Self {
        MessageSignificanceCategory::Null(None)
    }
}
impl TryFrom<String> for MessageSignificanceCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "consequence" => Ok(MessageSignificanceCategory::Consequence(None)),
            "currency" => Ok(MessageSignificanceCategory::Currency(None)),
            "notification" => Ok(MessageSignificanceCategory::Notification(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MessageSignificanceCategory {
    fn into(self) -> Option<String> {
        match self {
            MessageSignificanceCategory::Consequence(_) => Some("consequence".to_string()),
            MessageSignificanceCategory::Currency(_) => Some("currency".to_string()),
            MessageSignificanceCategory::Notification(_) => Some("notification".to_string()),
            MessageSignificanceCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MessageSignificanceCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MessageSignificanceCategory::Consequence(Some(e)) => e.get_field(field),
                MessageSignificanceCategory::Currency(Some(e)) => e.get_field(field),
                MessageSignificanceCategory::Notification(Some(e)) => e.get_field(field),
                MessageSignificanceCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MessageSignificanceCategory::Consequence(Some(e)) => e.get_field_mut(field),
                MessageSignificanceCategory::Currency(Some(e)) => e.get_field_mut(field),
                MessageSignificanceCategory::Notification(Some(e)) => e.get_field_mut(field),
                MessageSignificanceCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MessageTransport {
    #[doc = "FTP"]
    #[code = "ftp"]
    Ftp(Option<Element>),
    #[doc = "HTTP"]
    #[code = "http"]
    Http(Option<Element>),
    #[doc = "MLLP"]
    #[code = "mllp"]
    Mllp(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MessageTransport {
    fn default() -> Self {
        MessageTransport::Null(None)
    }
}
impl TryFrom<String> for MessageTransport {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ftp" => Ok(MessageTransport::Ftp(None)),
            "http" => Ok(MessageTransport::Http(None)),
            "mllp" => Ok(MessageTransport::Mllp(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MessageTransport {
    fn into(self) -> Option<String> {
        match self {
            MessageTransport::Ftp(_) => Some("ftp".to_string()),
            MessageTransport::Http(_) => Some("http".to_string()),
            MessageTransport::Mllp(_) => Some("mllp".to_string()),
            MessageTransport::Null(_) => None,
        }
    }
}
impl MetaValue for MessageTransport {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MessageTransport::Ftp(Some(e)) => e.get_field(field),
                MessageTransport::Http(Some(e)) => e.get_field(field),
                MessageTransport::Mllp(Some(e)) => e.get_field(field),
                MessageTransport::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MessageTransport::Ftp(Some(e)) => e.get_field_mut(field),
                MessageTransport::Http(Some(e)) => e.get_field_mut(field),
                MessageTransport::Mllp(Some(e)) => e.get_field_mut(field),
                MessageTransport::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MessageheaderResponseRequest {
    #[doc = "Always"]
    #[code = "always"]
    Always(Option<Element>),
    #[doc = "Never"]
    #[code = "never"]
    Never(Option<Element>),
    #[doc = "Error/reject conditions only"]
    #[code = "on-error"]
    OnError(Option<Element>),
    #[doc = "Successful completion only"]
    #[code = "on-success"]
    OnSuccess(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MessageheaderResponseRequest {
    fn default() -> Self {
        MessageheaderResponseRequest::Null(None)
    }
}
impl TryFrom<String> for MessageheaderResponseRequest {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "always" => Ok(MessageheaderResponseRequest::Always(None)),
            "never" => Ok(MessageheaderResponseRequest::Never(None)),
            "on-error" => Ok(MessageheaderResponseRequest::OnError(None)),
            "on-success" => Ok(MessageheaderResponseRequest::OnSuccess(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MessageheaderResponseRequest {
    fn into(self) -> Option<String> {
        match self {
            MessageheaderResponseRequest::Always(_) => Some("always".to_string()),
            MessageheaderResponseRequest::Never(_) => Some("never".to_string()),
            MessageheaderResponseRequest::OnError(_) => Some("on-error".to_string()),
            MessageheaderResponseRequest::OnSuccess(_) => Some("on-success".to_string()),
            MessageheaderResponseRequest::Null(_) => None,
        }
    }
}
impl MetaValue for MessageheaderResponseRequest {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MessageheaderResponseRequest::Always(Some(e)) => e.get_field(field),
                MessageheaderResponseRequest::Never(Some(e)) => e.get_field(field),
                MessageheaderResponseRequest::OnError(Some(e)) => e.get_field(field),
                MessageheaderResponseRequest::OnSuccess(Some(e)) => e.get_field(field),
                MessageheaderResponseRequest::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MessageheaderResponseRequest::Always(Some(e)) => e.get_field_mut(field),
                MessageheaderResponseRequest::Never(Some(e)) => e.get_field_mut(field),
                MessageheaderResponseRequest::OnError(Some(e)) => e.get_field_mut(field),
                MessageheaderResponseRequest::OnSuccess(Some(e)) => e.get_field_mut(field),
                MessageheaderResponseRequest::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MetricCalibrationState {
    #[doc = "Calibrated"]
    #[code = "calibrated"]
    Calibrated(Option<Element>),
    #[doc = "Calibration Required"]
    #[code = "calibration-required"]
    CalibrationRequired(Option<Element>),
    #[doc = "Not Calibrated"]
    #[code = "not-calibrated"]
    NotCalibrated(Option<Element>),
    #[doc = "Unspecified"]
    #[code = "unspecified"]
    Unspecified(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MetricCalibrationState {
    fn default() -> Self {
        MetricCalibrationState::Null(None)
    }
}
impl TryFrom<String> for MetricCalibrationState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "calibrated" => Ok(MetricCalibrationState::Calibrated(None)),
            "calibration-required" => Ok(MetricCalibrationState::CalibrationRequired(None)),
            "not-calibrated" => Ok(MetricCalibrationState::NotCalibrated(None)),
            "unspecified" => Ok(MetricCalibrationState::Unspecified(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MetricCalibrationState {
    fn into(self) -> Option<String> {
        match self {
            MetricCalibrationState::Calibrated(_) => Some("calibrated".to_string()),
            MetricCalibrationState::CalibrationRequired(_) => {
                Some("calibration-required".to_string())
            }
            MetricCalibrationState::NotCalibrated(_) => Some("not-calibrated".to_string()),
            MetricCalibrationState::Unspecified(_) => Some("unspecified".to_string()),
            MetricCalibrationState::Null(_) => None,
        }
    }
}
impl MetaValue for MetricCalibrationState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MetricCalibrationState::Calibrated(Some(e)) => e.get_field(field),
                MetricCalibrationState::CalibrationRequired(Some(e)) => e.get_field(field),
                MetricCalibrationState::NotCalibrated(Some(e)) => e.get_field(field),
                MetricCalibrationState::Unspecified(Some(e)) => e.get_field(field),
                MetricCalibrationState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MetricCalibrationState::Calibrated(Some(e)) => e.get_field_mut(field),
                MetricCalibrationState::CalibrationRequired(Some(e)) => e.get_field_mut(field),
                MetricCalibrationState::NotCalibrated(Some(e)) => e.get_field_mut(field),
                MetricCalibrationState::Unspecified(Some(e)) => e.get_field_mut(field),
                MetricCalibrationState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MetricCalibrationType {
    #[doc = "Gain"]
    #[code = "gain"]
    Gain(Option<Element>),
    #[doc = "Offset"]
    #[code = "offset"]
    Offset(Option<Element>),
    #[doc = "Two Point"]
    #[code = "two-point"]
    TwoPoint(Option<Element>),
    #[doc = "Unspecified"]
    #[code = "unspecified"]
    Unspecified(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MetricCalibrationType {
    fn default() -> Self {
        MetricCalibrationType::Null(None)
    }
}
impl TryFrom<String> for MetricCalibrationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "gain" => Ok(MetricCalibrationType::Gain(None)),
            "offset" => Ok(MetricCalibrationType::Offset(None)),
            "two-point" => Ok(MetricCalibrationType::TwoPoint(None)),
            "unspecified" => Ok(MetricCalibrationType::Unspecified(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MetricCalibrationType {
    fn into(self) -> Option<String> {
        match self {
            MetricCalibrationType::Gain(_) => Some("gain".to_string()),
            MetricCalibrationType::Offset(_) => Some("offset".to_string()),
            MetricCalibrationType::TwoPoint(_) => Some("two-point".to_string()),
            MetricCalibrationType::Unspecified(_) => Some("unspecified".to_string()),
            MetricCalibrationType::Null(_) => None,
        }
    }
}
impl MetaValue for MetricCalibrationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MetricCalibrationType::Gain(Some(e)) => e.get_field(field),
                MetricCalibrationType::Offset(Some(e)) => e.get_field(field),
                MetricCalibrationType::TwoPoint(Some(e)) => e.get_field(field),
                MetricCalibrationType::Unspecified(Some(e)) => e.get_field(field),
                MetricCalibrationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MetricCalibrationType::Gain(Some(e)) => e.get_field_mut(field),
                MetricCalibrationType::Offset(Some(e)) => e.get_field_mut(field),
                MetricCalibrationType::TwoPoint(Some(e)) => e.get_field_mut(field),
                MetricCalibrationType::Unspecified(Some(e)) => e.get_field_mut(field),
                MetricCalibrationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MetricCategory {
    #[doc = "Calculation"]
    #[code = "calculation"]
    Calculation(Option<Element>),
    #[doc = "Measurement"]
    #[code = "measurement"]
    Measurement(Option<Element>),
    #[doc = "Setting"]
    #[code = "setting"]
    Setting(Option<Element>),
    #[doc = "Unspecified"]
    #[code = "unspecified"]
    Unspecified(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MetricCategory {
    fn default() -> Self {
        MetricCategory::Null(None)
    }
}
impl TryFrom<String> for MetricCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "calculation" => Ok(MetricCategory::Calculation(None)),
            "measurement" => Ok(MetricCategory::Measurement(None)),
            "setting" => Ok(MetricCategory::Setting(None)),
            "unspecified" => Ok(MetricCategory::Unspecified(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MetricCategory {
    fn into(self) -> Option<String> {
        match self {
            MetricCategory::Calculation(_) => Some("calculation".to_string()),
            MetricCategory::Measurement(_) => Some("measurement".to_string()),
            MetricCategory::Setting(_) => Some("setting".to_string()),
            MetricCategory::Unspecified(_) => Some("unspecified".to_string()),
            MetricCategory::Null(_) => None,
        }
    }
}
impl MetaValue for MetricCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MetricCategory::Calculation(Some(e)) => e.get_field(field),
                MetricCategory::Measurement(Some(e)) => e.get_field(field),
                MetricCategory::Setting(Some(e)) => e.get_field(field),
                MetricCategory::Unspecified(Some(e)) => e.get_field(field),
                MetricCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MetricCategory::Calculation(Some(e)) => e.get_field_mut(field),
                MetricCategory::Measurement(Some(e)) => e.get_field_mut(field),
                MetricCategory::Setting(Some(e)) => e.get_field_mut(field),
                MetricCategory::Unspecified(Some(e)) => e.get_field_mut(field),
                MetricCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MetricColor {
    #[doc = "Color Black"]
    #[code = "black"]
    Black(Option<Element>),
    #[doc = "Color Blue"]
    #[code = "blue"]
    Blue(Option<Element>),
    #[doc = "Color Cyan"]
    #[code = "cyan"]
    Cyan(Option<Element>),
    #[doc = "Color Green"]
    #[code = "green"]
    Green(Option<Element>),
    #[doc = "Color Magenta"]
    #[code = "magenta"]
    Magenta(Option<Element>),
    #[doc = "Color Red"]
    #[code = "red"]
    Red(Option<Element>),
    #[doc = "Color White"]
    #[code = "white"]
    White(Option<Element>),
    #[doc = "Color Yellow"]
    #[code = "yellow"]
    Yellow(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MetricColor {
    fn default() -> Self {
        MetricColor::Null(None)
    }
}
impl TryFrom<String> for MetricColor {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "black" => Ok(MetricColor::Black(None)),
            "blue" => Ok(MetricColor::Blue(None)),
            "cyan" => Ok(MetricColor::Cyan(None)),
            "green" => Ok(MetricColor::Green(None)),
            "magenta" => Ok(MetricColor::Magenta(None)),
            "red" => Ok(MetricColor::Red(None)),
            "white" => Ok(MetricColor::White(None)),
            "yellow" => Ok(MetricColor::Yellow(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MetricColor {
    fn into(self) -> Option<String> {
        match self {
            MetricColor::Black(_) => Some("black".to_string()),
            MetricColor::Blue(_) => Some("blue".to_string()),
            MetricColor::Cyan(_) => Some("cyan".to_string()),
            MetricColor::Green(_) => Some("green".to_string()),
            MetricColor::Magenta(_) => Some("magenta".to_string()),
            MetricColor::Red(_) => Some("red".to_string()),
            MetricColor::White(_) => Some("white".to_string()),
            MetricColor::Yellow(_) => Some("yellow".to_string()),
            MetricColor::Null(_) => None,
        }
    }
}
impl MetaValue for MetricColor {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MetricColor::Black(Some(e)) => e.get_field(field),
                MetricColor::Blue(Some(e)) => e.get_field(field),
                MetricColor::Cyan(Some(e)) => e.get_field(field),
                MetricColor::Green(Some(e)) => e.get_field(field),
                MetricColor::Magenta(Some(e)) => e.get_field(field),
                MetricColor::Red(Some(e)) => e.get_field(field),
                MetricColor::White(Some(e)) => e.get_field(field),
                MetricColor::Yellow(Some(e)) => e.get_field(field),
                MetricColor::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MetricColor::Black(Some(e)) => e.get_field_mut(field),
                MetricColor::Blue(Some(e)) => e.get_field_mut(field),
                MetricColor::Cyan(Some(e)) => e.get_field_mut(field),
                MetricColor::Green(Some(e)) => e.get_field_mut(field),
                MetricColor::Magenta(Some(e)) => e.get_field_mut(field),
                MetricColor::Red(Some(e)) => e.get_field_mut(field),
                MetricColor::White(Some(e)) => e.get_field_mut(field),
                MetricColor::Yellow(Some(e)) => e.get_field_mut(field),
                MetricColor::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MetricOperationalStatus {
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Off"]
    #[code = "off"]
    Off(Option<Element>),
    #[doc = "On"]
    #[code = "on"]
    On(Option<Element>),
    #[doc = "Standby"]
    #[code = "standby"]
    Standby(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MetricOperationalStatus {
    fn default() -> Self {
        MetricOperationalStatus::Null(None)
    }
}
impl TryFrom<String> for MetricOperationalStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "entered-in-error" => Ok(MetricOperationalStatus::EnteredInError(None)),
            "off" => Ok(MetricOperationalStatus::Off(None)),
            "on" => Ok(MetricOperationalStatus::On(None)),
            "standby" => Ok(MetricOperationalStatus::Standby(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MetricOperationalStatus {
    fn into(self) -> Option<String> {
        match self {
            MetricOperationalStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            MetricOperationalStatus::Off(_) => Some("off".to_string()),
            MetricOperationalStatus::On(_) => Some("on".to_string()),
            MetricOperationalStatus::Standby(_) => Some("standby".to_string()),
            MetricOperationalStatus::Null(_) => None,
        }
    }
}
impl MetaValue for MetricOperationalStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MetricOperationalStatus::EnteredInError(Some(e)) => e.get_field(field),
                MetricOperationalStatus::Off(Some(e)) => e.get_field(field),
                MetricOperationalStatus::On(Some(e)) => e.get_field(field),
                MetricOperationalStatus::Standby(Some(e)) => e.get_field(field),
                MetricOperationalStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MetricOperationalStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                MetricOperationalStatus::Off(Some(e)) => e.get_field_mut(field),
                MetricOperationalStatus::On(Some(e)) => e.get_field_mut(field),
                MetricOperationalStatus::Standby(Some(e)) => e.get_field_mut(field),
                MetricOperationalStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MissingToothReason {
    #[doc = "C"]
    #[code = "c"]
    C(Option<Element>),
    #[doc = "E"]
    #[code = "e"]
    E(Option<Element>),
    #[doc = "O"]
    #[code = "o"]
    O(Option<Element>),
    #[doc = "U"]
    #[code = "u"]
    U(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MissingToothReason {
    fn default() -> Self {
        MissingToothReason::Null(None)
    }
}
impl TryFrom<String> for MissingToothReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "c" => Ok(MissingToothReason::C(None)),
            "e" => Ok(MissingToothReason::E(None)),
            "o" => Ok(MissingToothReason::O(None)),
            "u" => Ok(MissingToothReason::U(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MissingToothReason {
    fn into(self) -> Option<String> {
        match self {
            MissingToothReason::C(_) => Some("c".to_string()),
            MissingToothReason::E(_) => Some("e".to_string()),
            MissingToothReason::O(_) => Some("o".to_string()),
            MissingToothReason::U(_) => Some("u".to_string()),
            MissingToothReason::Null(_) => None,
        }
    }
}
impl MetaValue for MissingToothReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MissingToothReason::C(Some(e)) => e.get_field(field),
                MissingToothReason::E(Some(e)) => e.get_field(field),
                MissingToothReason::O(Some(e)) => e.get_field(field),
                MissingToothReason::U(Some(e)) => e.get_field(field),
                MissingToothReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MissingToothReason::C(Some(e)) => e.get_field_mut(field),
                MissingToothReason::E(Some(e)) => e.get_field_mut(field),
                MissingToothReason::O(Some(e)) => e.get_field_mut(field),
                MissingToothReason::U(Some(e)) => e.get_field_mut(field),
                MissingToothReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ModifiedFoodtype {
    #[doc = "Eggs"]
    #[code = "102263004"]
    V102263004(Option<Element>),
    #[doc = "Starchy food"]
    #[code = "226529007"]
    V226529007(Option<Element>),
    #[doc = "Dairy foods"]
    #[code = "226760005"]
    V226760005(Option<Element>),
    #[doc = "Dietary Fats and Oils"]
    #[code = "226887002"]
    V226887002(Option<Element>),
    #[doc = "Vegetables plus herbs and spices"]
    #[code = "227210005"]
    V227210005(Option<Element>),
    #[doc = "Fruit Nuts and Seeds"]
    #[code = "227415002"]
    V227415002(Option<Element>),
    #[doc = "Sauce seasonings and soups"]
    #[code = "227518002"]
    V227518002(Option<Element>),
    #[doc = "Vegetables"]
    #[code = "22836000"]
    V22836000(Option<Element>),
    #[doc = "Foods"]
    #[code = "255620007"]
    V255620007(Option<Element>),
    #[doc = "Grain"]
    #[code = "264331002"]
    V264331002(Option<Element>),
    #[doc = "Meat"]
    #[code = "28647000"]
    V28647000(Option<Element>),
    #[doc = "Seafood"]
    #[code = "44027008"]
    V44027008(Option<Element>),
    #[doc = "Fruit"]
    #[code = "72511004"]
    V72511004(Option<Element>),
    #[doc = "Food Starch"]
    #[code = "74242007"]
    V74242007(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ModifiedFoodtype {
    fn default() -> Self {
        ModifiedFoodtype::Null(None)
    }
}
impl TryFrom<String> for ModifiedFoodtype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "102263004" => Ok(ModifiedFoodtype::V102263004(None)),
            "226529007" => Ok(ModifiedFoodtype::V226529007(None)),
            "226760005" => Ok(ModifiedFoodtype::V226760005(None)),
            "226887002" => Ok(ModifiedFoodtype::V226887002(None)),
            "227210005" => Ok(ModifiedFoodtype::V227210005(None)),
            "227415002" => Ok(ModifiedFoodtype::V227415002(None)),
            "227518002" => Ok(ModifiedFoodtype::V227518002(None)),
            "22836000" => Ok(ModifiedFoodtype::V22836000(None)),
            "255620007" => Ok(ModifiedFoodtype::V255620007(None)),
            "264331002" => Ok(ModifiedFoodtype::V264331002(None)),
            "28647000" => Ok(ModifiedFoodtype::V28647000(None)),
            "44027008" => Ok(ModifiedFoodtype::V44027008(None)),
            "72511004" => Ok(ModifiedFoodtype::V72511004(None)),
            "74242007" => Ok(ModifiedFoodtype::V74242007(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ModifiedFoodtype {
    fn into(self) -> Option<String> {
        match self {
            ModifiedFoodtype::V102263004(_) => Some("102263004".to_string()),
            ModifiedFoodtype::V226529007(_) => Some("226529007".to_string()),
            ModifiedFoodtype::V226760005(_) => Some("226760005".to_string()),
            ModifiedFoodtype::V226887002(_) => Some("226887002".to_string()),
            ModifiedFoodtype::V227210005(_) => Some("227210005".to_string()),
            ModifiedFoodtype::V227415002(_) => Some("227415002".to_string()),
            ModifiedFoodtype::V227518002(_) => Some("227518002".to_string()),
            ModifiedFoodtype::V22836000(_) => Some("22836000".to_string()),
            ModifiedFoodtype::V255620007(_) => Some("255620007".to_string()),
            ModifiedFoodtype::V264331002(_) => Some("264331002".to_string()),
            ModifiedFoodtype::V28647000(_) => Some("28647000".to_string()),
            ModifiedFoodtype::V44027008(_) => Some("44027008".to_string()),
            ModifiedFoodtype::V72511004(_) => Some("72511004".to_string()),
            ModifiedFoodtype::V74242007(_) => Some("74242007".to_string()),
            ModifiedFoodtype::Null(_) => None,
        }
    }
}
impl MetaValue for ModifiedFoodtype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ModifiedFoodtype::V102263004(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V226529007(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V226760005(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V226887002(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V227210005(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V227415002(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V227518002(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V22836000(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V255620007(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V264331002(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V28647000(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V44027008(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V72511004(Some(e)) => e.get_field(field),
                ModifiedFoodtype::V74242007(Some(e)) => e.get_field(field),
                ModifiedFoodtype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ModifiedFoodtype::V102263004(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V226529007(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V226760005(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V226887002(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V227210005(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V227415002(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V227518002(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V22836000(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V255620007(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V264331002(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V28647000(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V44027008(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V72511004(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::V74242007(Some(e)) => e.get_field_mut(field),
                ModifiedFoodtype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NameAssemblyOrder {
    #[doc = "Prefix Family Given Suffix"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "Prefix Given Family Suffix"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "Own Name"]
    #[code = "NL1"]
    NL1(Option<Element>),
    #[doc = "Partner Name"]
    #[code = "NL2"]
    NL2(Option<Element>),
    #[doc = "Partner Name followed by Maiden Name"]
    #[code = "NL3"]
    NL3(Option<Element>),
    #[doc = "Own Name followed by Partner Name"]
    #[code = "NL4"]
    NL4(Option<Element>),
    #[doc = "Unknown"]
    #[code = "UNK"]
    UNK(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NameAssemblyOrder {
    fn default() -> Self {
        NameAssemblyOrder::Null(None)
    }
}
impl TryFrom<String> for NameAssemblyOrder {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "F" => Ok(NameAssemblyOrder::F(None)),
            "G" => Ok(NameAssemblyOrder::G(None)),
            "NL1" => Ok(NameAssemblyOrder::NL1(None)),
            "NL2" => Ok(NameAssemblyOrder::NL2(None)),
            "NL3" => Ok(NameAssemblyOrder::NL3(None)),
            "NL4" => Ok(NameAssemblyOrder::NL4(None)),
            "UNK" => Ok(NameAssemblyOrder::UNK(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NameAssemblyOrder {
    fn into(self) -> Option<String> {
        match self {
            NameAssemblyOrder::F(_) => Some("F".to_string()),
            NameAssemblyOrder::G(_) => Some("G".to_string()),
            NameAssemblyOrder::NL1(_) => Some("NL1".to_string()),
            NameAssemblyOrder::NL2(_) => Some("NL2".to_string()),
            NameAssemblyOrder::NL3(_) => Some("NL3".to_string()),
            NameAssemblyOrder::NL4(_) => Some("NL4".to_string()),
            NameAssemblyOrder::UNK(_) => Some("UNK".to_string()),
            NameAssemblyOrder::Null(_) => None,
        }
    }
}
impl MetaValue for NameAssemblyOrder {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NameAssemblyOrder::F(Some(e)) => e.get_field(field),
                NameAssemblyOrder::G(Some(e)) => e.get_field(field),
                NameAssemblyOrder::NL1(Some(e)) => e.get_field(field),
                NameAssemblyOrder::NL2(Some(e)) => e.get_field(field),
                NameAssemblyOrder::NL3(Some(e)) => e.get_field(field),
                NameAssemblyOrder::NL4(Some(e)) => e.get_field(field),
                NameAssemblyOrder::UNK(Some(e)) => e.get_field(field),
                NameAssemblyOrder::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NameAssemblyOrder::F(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::G(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::NL1(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::NL2(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::NL3(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::NL4(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::UNK(Some(e)) => e.get_field_mut(field),
                NameAssemblyOrder::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NamePartQualifier {
    #[doc = "Academic"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "Acquired"]
    #[code = "AD"]
    AD(Option<Element>),
    #[doc = "Birth"]
    #[code = "BR"]
    BR(Option<Element>),
    #[doc = "Call me"]
    #[code = "CL"]
    CL(Option<Element>),
    #[doc = "Honorific"]
    #[code = "HON"]
    HON(Option<Element>),
    #[doc = "Initial"]
    #[code = "IN"]
    IN(Option<Element>),
    #[doc = "Legal status"]
    #[code = "LS"]
    LS(Option<Element>),
    #[doc = "Middle Name"]
    #[code = "MID"]
    MID(Option<Element>),
    #[doc = "Nobility"]
    #[code = "NB"]
    NB(Option<Element>),
    #[doc = "Professional"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "Spouse"]
    #[code = "SP"]
    SP(Option<Element>),
    #[doc = "Voorvoegsel"]
    #[code = "VV"]
    VV(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NamePartQualifier {
    fn default() -> Self {
        NamePartQualifier::Null(None)
    }
}
impl TryFrom<String> for NamePartQualifier {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AC" => Ok(NamePartQualifier::AC(None)),
            "AD" => Ok(NamePartQualifier::AD(None)),
            "BR" => Ok(NamePartQualifier::BR(None)),
            "CL" => Ok(NamePartQualifier::CL(None)),
            "HON" => Ok(NamePartQualifier::HON(None)),
            "IN" => Ok(NamePartQualifier::IN(None)),
            "LS" => Ok(NamePartQualifier::LS(None)),
            "MID" => Ok(NamePartQualifier::MID(None)),
            "NB" => Ok(NamePartQualifier::NB(None)),
            "PR" => Ok(NamePartQualifier::PR(None)),
            "SP" => Ok(NamePartQualifier::SP(None)),
            "VV" => Ok(NamePartQualifier::VV(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NamePartQualifier {
    fn into(self) -> Option<String> {
        match self {
            NamePartQualifier::AC(_) => Some("AC".to_string()),
            NamePartQualifier::AD(_) => Some("AD".to_string()),
            NamePartQualifier::BR(_) => Some("BR".to_string()),
            NamePartQualifier::CL(_) => Some("CL".to_string()),
            NamePartQualifier::HON(_) => Some("HON".to_string()),
            NamePartQualifier::IN(_) => Some("IN".to_string()),
            NamePartQualifier::LS(_) => Some("LS".to_string()),
            NamePartQualifier::MID(_) => Some("MID".to_string()),
            NamePartQualifier::NB(_) => Some("NB".to_string()),
            NamePartQualifier::PR(_) => Some("PR".to_string()),
            NamePartQualifier::SP(_) => Some("SP".to_string()),
            NamePartQualifier::VV(_) => Some("VV".to_string()),
            NamePartQualifier::Null(_) => None,
        }
    }
}
impl MetaValue for NamePartQualifier {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NamePartQualifier::AC(Some(e)) => e.get_field(field),
                NamePartQualifier::AD(Some(e)) => e.get_field(field),
                NamePartQualifier::BR(Some(e)) => e.get_field(field),
                NamePartQualifier::CL(Some(e)) => e.get_field(field),
                NamePartQualifier::HON(Some(e)) => e.get_field(field),
                NamePartQualifier::IN(Some(e)) => e.get_field(field),
                NamePartQualifier::LS(Some(e)) => e.get_field(field),
                NamePartQualifier::MID(Some(e)) => e.get_field(field),
                NamePartQualifier::NB(Some(e)) => e.get_field(field),
                NamePartQualifier::PR(Some(e)) => e.get_field(field),
                NamePartQualifier::SP(Some(e)) => e.get_field(field),
                NamePartQualifier::VV(Some(e)) => e.get_field(field),
                NamePartQualifier::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NamePartQualifier::AC(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::AD(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::BR(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::CL(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::HON(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::IN(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::LS(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::MID(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::NB(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::PR(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::SP(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::VV(Some(e)) => e.get_field_mut(field),
                NamePartQualifier::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NameUse {
    #[doc = "Anonymous"]
    #[code = "anonymous"]
    Anonymous(Option<Element>),
    #[doc = "Name changed for Marriage"]
    #[code = "maiden"]
    Maiden(Option<Element>),
    #[doc = "Nickname"]
    #[code = "nickname"]
    Nickname(Option<Element>),
    #[doc = "Official"]
    #[code = "official"]
    Official(Option<Element>),
    #[doc = "Old"]
    #[code = "old"]
    Old(Option<Element>),
    #[doc = "Temp"]
    #[code = "temp"]
    Temp(Option<Element>),
    #[doc = "Usual"]
    #[code = "usual"]
    Usual(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NameUse {
    fn default() -> Self {
        NameUse::Null(None)
    }
}
impl TryFrom<String> for NameUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "anonymous" => Ok(NameUse::Anonymous(None)),
            "maiden" => Ok(NameUse::Maiden(None)),
            "nickname" => Ok(NameUse::Nickname(None)),
            "official" => Ok(NameUse::Official(None)),
            "old" => Ok(NameUse::Old(None)),
            "temp" => Ok(NameUse::Temp(None)),
            "usual" => Ok(NameUse::Usual(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NameUse {
    fn into(self) -> Option<String> {
        match self {
            NameUse::Anonymous(_) => Some("anonymous".to_string()),
            NameUse::Maiden(_) => Some("maiden".to_string()),
            NameUse::Nickname(_) => Some("nickname".to_string()),
            NameUse::Official(_) => Some("official".to_string()),
            NameUse::Old(_) => Some("old".to_string()),
            NameUse::Temp(_) => Some("temp".to_string()),
            NameUse::Usual(_) => Some("usual".to_string()),
            NameUse::Null(_) => None,
        }
    }
}
impl MetaValue for NameUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NameUse::Anonymous(Some(e)) => e.get_field(field),
                NameUse::Maiden(Some(e)) => e.get_field(field),
                NameUse::Nickname(Some(e)) => e.get_field(field),
                NameUse::Official(Some(e)) => e.get_field(field),
                NameUse::Old(Some(e)) => e.get_field(field),
                NameUse::Temp(Some(e)) => e.get_field(field),
                NameUse::Usual(Some(e)) => e.get_field(field),
                NameUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NameUse::Anonymous(Some(e)) => e.get_field_mut(field),
                NameUse::Maiden(Some(e)) => e.get_field_mut(field),
                NameUse::Nickname(Some(e)) => e.get_field_mut(field),
                NameUse::Official(Some(e)) => e.get_field_mut(field),
                NameUse::Old(Some(e)) => e.get_field_mut(field),
                NameUse::Temp(Some(e)) => e.get_field_mut(field),
                NameUse::Usual(Some(e)) => e.get_field_mut(field),
                NameUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NameV3Representation {
    #[code = "ABC"]
    ABC(Option<Element>),
    #[code = "IDE"]
    IDE(Option<Element>),
    #[code = "SYL"]
    SYL(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NameV3Representation {
    fn default() -> Self {
        NameV3Representation::Null(None)
    }
}
impl TryFrom<String> for NameV3Representation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ABC" => Ok(NameV3Representation::ABC(None)),
            "IDE" => Ok(NameV3Representation::IDE(None)),
            "SYL" => Ok(NameV3Representation::SYL(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NameV3Representation {
    fn into(self) -> Option<String> {
        match self {
            NameV3Representation::ABC(_) => Some("ABC".to_string()),
            NameV3Representation::IDE(_) => Some("IDE".to_string()),
            NameV3Representation::SYL(_) => Some("SYL".to_string()),
            NameV3Representation::Null(_) => None,
        }
    }
}
impl MetaValue for NameV3Representation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NameV3Representation::ABC(Some(e)) => e.get_field(field),
                NameV3Representation::IDE(Some(e)) => e.get_field(field),
                NameV3Representation::SYL(Some(e)) => e.get_field(field),
                NameV3Representation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NameV3Representation::ABC(Some(e)) => e.get_field_mut(field),
                NameV3Representation::IDE(Some(e)) => e.get_field_mut(field),
                NameV3Representation::SYL(Some(e)) => e.get_field_mut(field),
                NameV3Representation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NamingsystemIdentifierType {
    #[doc = "OID"]
    #[code = "oid"]
    Oid(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "URI"]
    #[code = "uri"]
    Uri(Option<Element>),
    #[doc = "UUID"]
    #[code = "uuid"]
    Uuid(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NamingsystemIdentifierType {
    fn default() -> Self {
        NamingsystemIdentifierType::Null(None)
    }
}
impl TryFrom<String> for NamingsystemIdentifierType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "oid" => Ok(NamingsystemIdentifierType::Oid(None)),
            "other" => Ok(NamingsystemIdentifierType::Other(None)),
            "uri" => Ok(NamingsystemIdentifierType::Uri(None)),
            "uuid" => Ok(NamingsystemIdentifierType::Uuid(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NamingsystemIdentifierType {
    fn into(self) -> Option<String> {
        match self {
            NamingsystemIdentifierType::Oid(_) => Some("oid".to_string()),
            NamingsystemIdentifierType::Other(_) => Some("other".to_string()),
            NamingsystemIdentifierType::Uri(_) => Some("uri".to_string()),
            NamingsystemIdentifierType::Uuid(_) => Some("uuid".to_string()),
            NamingsystemIdentifierType::Null(_) => None,
        }
    }
}
impl MetaValue for NamingsystemIdentifierType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NamingsystemIdentifierType::Oid(Some(e)) => e.get_field(field),
                NamingsystemIdentifierType::Other(Some(e)) => e.get_field(field),
                NamingsystemIdentifierType::Uri(Some(e)) => e.get_field(field),
                NamingsystemIdentifierType::Uuid(Some(e)) => e.get_field(field),
                NamingsystemIdentifierType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NamingsystemIdentifierType::Oid(Some(e)) => e.get_field_mut(field),
                NamingsystemIdentifierType::Other(Some(e)) => e.get_field_mut(field),
                NamingsystemIdentifierType::Uri(Some(e)) => e.get_field_mut(field),
                NamingsystemIdentifierType::Uuid(Some(e)) => e.get_field_mut(field),
                NamingsystemIdentifierType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NamingsystemType {
    #[doc = "Code System"]
    #[code = "codesystem"]
    Codesystem(Option<Element>),
    #[doc = "Identifier"]
    #[code = "identifier"]
    Identifier(Option<Element>),
    #[doc = "Root"]
    #[code = "root"]
    Root(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NamingsystemType {
    fn default() -> Self {
        NamingsystemType::Null(None)
    }
}
impl TryFrom<String> for NamingsystemType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "codesystem" => Ok(NamingsystemType::Codesystem(None)),
            "identifier" => Ok(NamingsystemType::Identifier(None)),
            "root" => Ok(NamingsystemType::Root(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NamingsystemType {
    fn into(self) -> Option<String> {
        match self {
            NamingsystemType::Codesystem(_) => Some("codesystem".to_string()),
            NamingsystemType::Identifier(_) => Some("identifier".to_string()),
            NamingsystemType::Root(_) => Some("root".to_string()),
            NamingsystemType::Null(_) => None,
        }
    }
}
impl MetaValue for NamingsystemType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NamingsystemType::Codesystem(Some(e)) => e.get_field(field),
                NamingsystemType::Identifier(Some(e)) => e.get_field(field),
                NamingsystemType::Root(Some(e)) => e.get_field(field),
                NamingsystemType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NamingsystemType::Codesystem(Some(e)) => e.get_field_mut(field),
                NamingsystemType::Identifier(Some(e)) => e.get_field_mut(field),
                NamingsystemType::Root(Some(e)) => e.get_field_mut(field),
                NamingsystemType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NarrativeStatus {
    #[doc = "Additional"]
    #[code = "additional"]
    Additional(Option<Element>),
    #[doc = "Empty"]
    #[code = "empty"]
    Empty(Option<Element>),
    #[doc = "Extensions"]
    #[code = "extensions"]
    Extensions(Option<Element>),
    #[doc = "Generated"]
    #[code = "generated"]
    Generated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NarrativeStatus {
    fn default() -> Self {
        NarrativeStatus::Null(None)
    }
}
impl TryFrom<String> for NarrativeStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "additional" => Ok(NarrativeStatus::Additional(None)),
            "empty" => Ok(NarrativeStatus::Empty(None)),
            "extensions" => Ok(NarrativeStatus::Extensions(None)),
            "generated" => Ok(NarrativeStatus::Generated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NarrativeStatus {
    fn into(self) -> Option<String> {
        match self {
            NarrativeStatus::Additional(_) => Some("additional".to_string()),
            NarrativeStatus::Empty(_) => Some("empty".to_string()),
            NarrativeStatus::Extensions(_) => Some("extensions".to_string()),
            NarrativeStatus::Generated(_) => Some("generated".to_string()),
            NarrativeStatus::Null(_) => None,
        }
    }
}
impl MetaValue for NarrativeStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NarrativeStatus::Additional(Some(e)) => e.get_field(field),
                NarrativeStatus::Empty(Some(e)) => e.get_field(field),
                NarrativeStatus::Extensions(Some(e)) => e.get_field(field),
                NarrativeStatus::Generated(Some(e)) => e.get_field(field),
                NarrativeStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NarrativeStatus::Additional(Some(e)) => e.get_field_mut(field),
                NarrativeStatus::Empty(Some(e)) => e.get_field_mut(field),
                NarrativeStatus::Extensions(Some(e)) => e.get_field_mut(field),
                NarrativeStatus::Generated(Some(e)) => e.get_field_mut(field),
                NarrativeStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NetworkType {
    #[doc = "Machine Name"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "IP Address"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Telephone Number"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Email address"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "URI"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NetworkType {
    fn default() -> Self {
        NetworkType::Null(None)
    }
}
impl TryFrom<String> for NetworkType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(NetworkType::V1(None)),
            "2" => Ok(NetworkType::V2(None)),
            "3" => Ok(NetworkType::V3(None)),
            "4" => Ok(NetworkType::V4(None)),
            "5" => Ok(NetworkType::V5(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NetworkType {
    fn into(self) -> Option<String> {
        match self {
            NetworkType::V1(_) => Some("1".to_string()),
            NetworkType::V2(_) => Some("2".to_string()),
            NetworkType::V3(_) => Some("3".to_string()),
            NetworkType::V4(_) => Some("4".to_string()),
            NetworkType::V5(_) => Some("5".to_string()),
            NetworkType::Null(_) => None,
        }
    }
}
impl MetaValue for NetworkType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NetworkType::V1(Some(e)) => e.get_field(field),
                NetworkType::V2(Some(e)) => e.get_field(field),
                NetworkType::V3(Some(e)) => e.get_field(field),
                NetworkType::V4(Some(e)) => e.get_field(field),
                NetworkType::V5(Some(e)) => e.get_field(field),
                NetworkType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NetworkType::V1(Some(e)) => e.get_field_mut(field),
                NetworkType::V2(Some(e)) => e.get_field_mut(field),
                NetworkType::V3(Some(e)) => e.get_field_mut(field),
                NetworkType::V4(Some(e)) => e.get_field_mut(field),
                NetworkType::V5(Some(e)) => e.get_field_mut(field),
                NetworkType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NhinPurposeofuse {
    #[doc = "Abuse"]
    #[code = "ABUSE"]
    ABUSE(Option<Element>),
    #[doc = "Coverage"]
    #[code = "COVERAGE"]
    COVERAGE(Option<Element>),
    #[doc = "Deceased"]
    #[code = "DECEASED"]
    DECEASED(Option<Element>),
    #[doc = "Directory"]
    #[code = "DIRECTORY"]
    DIRECTORY(Option<Element>),
    #[doc = "Disaster"]
    #[code = "DISASTER"]
    DISASTER(Option<Element>),
    #[doc = "Donation"]
    #[code = "DONATION"]
    DONATION(Option<Element>),
    #[doc = "Emergency"]
    #[code = "EMERGENCY"]
    EMERGENCY(Option<Element>),
    #[doc = "Family"]
    #[code = "FAMILY"]
    FAMILY(Option<Element>),
    #[doc = "Fraud"]
    #[code = "FRAUD"]
    FRAUD(Option<Element>),
    #[doc = "Government"]
    #[code = "GOVERNMENT"]
    GOVERNMENT(Option<Element>),
    #[doc = "Judicial"]
    #[code = "JUDICIAL"]
    JUDICIAL(Option<Element>),
    #[doc = "Law Enforcement"]
    #[code = "LAW"]
    LAW(Option<Element>),
    #[doc = "Legal"]
    #[code = "LEGAL"]
    LEGAL(Option<Element>),
    #[doc = "Marketing"]
    #[code = "MARKETING"]
    MARKETING(Option<Element>),
    #[doc = "Operations"]
    #[code = "OPERATIONS"]
    OPERATIONS(Option<Element>),
    #[doc = "Oversight"]
    #[code = "OVERSIGHT"]
    OVERSIGHT(Option<Element>),
    #[doc = "Payment"]
    #[code = "PAYMENT"]
    PAYMENT(Option<Element>),
    #[doc = "Present"]
    #[code = "PRESENT"]
    PRESENT(Option<Element>),
    #[doc = "Psychotherapy"]
    #[code = "PSYCHOTHERAPY"]
    PSYCHOTHERAPY(Option<Element>),
    #[doc = "Public Health"]
    #[code = "PUBLICHEALTH"]
    PUBLICHEALTH(Option<Element>),
    #[doc = "Request"]
    #[code = "REQUEST"]
    REQUEST(Option<Element>),
    #[doc = "Research"]
    #[code = "RESEARCH"]
    RESEARCH(Option<Element>),
    #[doc = "Sysadmin"]
    #[code = "SYSADMIN"]
    SYSADMIN(Option<Element>),
    #[doc = "Threat"]
    #[code = "THREAT"]
    THREAT(Option<Element>),
    #[doc = "Training"]
    #[code = "TRAINING"]
    TRAINING(Option<Element>),
    #[doc = "Treatment"]
    #[code = "TREATMENT"]
    TREATMENT(Option<Element>),
    #[doc = "Worker's Comp"]
    #[code = "WORKERSCOMP"]
    WORKERSCOMP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NhinPurposeofuse {
    fn default() -> Self {
        NhinPurposeofuse::Null(None)
    }
}
impl TryFrom<String> for NhinPurposeofuse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ABUSE" => Ok(NhinPurposeofuse::ABUSE(None)),
            "COVERAGE" => Ok(NhinPurposeofuse::COVERAGE(None)),
            "DECEASED" => Ok(NhinPurposeofuse::DECEASED(None)),
            "DIRECTORY" => Ok(NhinPurposeofuse::DIRECTORY(None)),
            "DISASTER" => Ok(NhinPurposeofuse::DISASTER(None)),
            "DONATION" => Ok(NhinPurposeofuse::DONATION(None)),
            "EMERGENCY" => Ok(NhinPurposeofuse::EMERGENCY(None)),
            "FAMILY" => Ok(NhinPurposeofuse::FAMILY(None)),
            "FRAUD" => Ok(NhinPurposeofuse::FRAUD(None)),
            "GOVERNMENT" => Ok(NhinPurposeofuse::GOVERNMENT(None)),
            "JUDICIAL" => Ok(NhinPurposeofuse::JUDICIAL(None)),
            "LAW" => Ok(NhinPurposeofuse::LAW(None)),
            "LEGAL" => Ok(NhinPurposeofuse::LEGAL(None)),
            "MARKETING" => Ok(NhinPurposeofuse::MARKETING(None)),
            "OPERATIONS" => Ok(NhinPurposeofuse::OPERATIONS(None)),
            "OVERSIGHT" => Ok(NhinPurposeofuse::OVERSIGHT(None)),
            "PAYMENT" => Ok(NhinPurposeofuse::PAYMENT(None)),
            "PRESENT" => Ok(NhinPurposeofuse::PRESENT(None)),
            "PSYCHOTHERAPY" => Ok(NhinPurposeofuse::PSYCHOTHERAPY(None)),
            "PUBLICHEALTH" => Ok(NhinPurposeofuse::PUBLICHEALTH(None)),
            "REQUEST" => Ok(NhinPurposeofuse::REQUEST(None)),
            "RESEARCH" => Ok(NhinPurposeofuse::RESEARCH(None)),
            "SYSADMIN" => Ok(NhinPurposeofuse::SYSADMIN(None)),
            "THREAT" => Ok(NhinPurposeofuse::THREAT(None)),
            "TRAINING" => Ok(NhinPurposeofuse::TRAINING(None)),
            "TREATMENT" => Ok(NhinPurposeofuse::TREATMENT(None)),
            "WORKERSCOMP" => Ok(NhinPurposeofuse::WORKERSCOMP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NhinPurposeofuse {
    fn into(self) -> Option<String> {
        match self {
            NhinPurposeofuse::ABUSE(_) => Some("ABUSE".to_string()),
            NhinPurposeofuse::COVERAGE(_) => Some("COVERAGE".to_string()),
            NhinPurposeofuse::DECEASED(_) => Some("DECEASED".to_string()),
            NhinPurposeofuse::DIRECTORY(_) => Some("DIRECTORY".to_string()),
            NhinPurposeofuse::DISASTER(_) => Some("DISASTER".to_string()),
            NhinPurposeofuse::DONATION(_) => Some("DONATION".to_string()),
            NhinPurposeofuse::EMERGENCY(_) => Some("EMERGENCY".to_string()),
            NhinPurposeofuse::FAMILY(_) => Some("FAMILY".to_string()),
            NhinPurposeofuse::FRAUD(_) => Some("FRAUD".to_string()),
            NhinPurposeofuse::GOVERNMENT(_) => Some("GOVERNMENT".to_string()),
            NhinPurposeofuse::JUDICIAL(_) => Some("JUDICIAL".to_string()),
            NhinPurposeofuse::LAW(_) => Some("LAW".to_string()),
            NhinPurposeofuse::LEGAL(_) => Some("LEGAL".to_string()),
            NhinPurposeofuse::MARKETING(_) => Some("MARKETING".to_string()),
            NhinPurposeofuse::OPERATIONS(_) => Some("OPERATIONS".to_string()),
            NhinPurposeofuse::OVERSIGHT(_) => Some("OVERSIGHT".to_string()),
            NhinPurposeofuse::PAYMENT(_) => Some("PAYMENT".to_string()),
            NhinPurposeofuse::PRESENT(_) => Some("PRESENT".to_string()),
            NhinPurposeofuse::PSYCHOTHERAPY(_) => Some("PSYCHOTHERAPY".to_string()),
            NhinPurposeofuse::PUBLICHEALTH(_) => Some("PUBLICHEALTH".to_string()),
            NhinPurposeofuse::REQUEST(_) => Some("REQUEST".to_string()),
            NhinPurposeofuse::RESEARCH(_) => Some("RESEARCH".to_string()),
            NhinPurposeofuse::SYSADMIN(_) => Some("SYSADMIN".to_string()),
            NhinPurposeofuse::THREAT(_) => Some("THREAT".to_string()),
            NhinPurposeofuse::TRAINING(_) => Some("TRAINING".to_string()),
            NhinPurposeofuse::TREATMENT(_) => Some("TREATMENT".to_string()),
            NhinPurposeofuse::WORKERSCOMP(_) => Some("WORKERSCOMP".to_string()),
            NhinPurposeofuse::Null(_) => None,
        }
    }
}
impl MetaValue for NhinPurposeofuse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NhinPurposeofuse::ABUSE(Some(e)) => e.get_field(field),
                NhinPurposeofuse::COVERAGE(Some(e)) => e.get_field(field),
                NhinPurposeofuse::DECEASED(Some(e)) => e.get_field(field),
                NhinPurposeofuse::DIRECTORY(Some(e)) => e.get_field(field),
                NhinPurposeofuse::DISASTER(Some(e)) => e.get_field(field),
                NhinPurposeofuse::DONATION(Some(e)) => e.get_field(field),
                NhinPurposeofuse::EMERGENCY(Some(e)) => e.get_field(field),
                NhinPurposeofuse::FAMILY(Some(e)) => e.get_field(field),
                NhinPurposeofuse::FRAUD(Some(e)) => e.get_field(field),
                NhinPurposeofuse::GOVERNMENT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::JUDICIAL(Some(e)) => e.get_field(field),
                NhinPurposeofuse::LAW(Some(e)) => e.get_field(field),
                NhinPurposeofuse::LEGAL(Some(e)) => e.get_field(field),
                NhinPurposeofuse::MARKETING(Some(e)) => e.get_field(field),
                NhinPurposeofuse::OPERATIONS(Some(e)) => e.get_field(field),
                NhinPurposeofuse::OVERSIGHT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::PAYMENT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::PRESENT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::PSYCHOTHERAPY(Some(e)) => e.get_field(field),
                NhinPurposeofuse::PUBLICHEALTH(Some(e)) => e.get_field(field),
                NhinPurposeofuse::REQUEST(Some(e)) => e.get_field(field),
                NhinPurposeofuse::RESEARCH(Some(e)) => e.get_field(field),
                NhinPurposeofuse::SYSADMIN(Some(e)) => e.get_field(field),
                NhinPurposeofuse::THREAT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::TRAINING(Some(e)) => e.get_field(field),
                NhinPurposeofuse::TREATMENT(Some(e)) => e.get_field(field),
                NhinPurposeofuse::WORKERSCOMP(Some(e)) => e.get_field(field),
                NhinPurposeofuse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NhinPurposeofuse::ABUSE(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::COVERAGE(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::DECEASED(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::DIRECTORY(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::DISASTER(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::DONATION(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::EMERGENCY(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::FAMILY(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::FRAUD(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::GOVERNMENT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::JUDICIAL(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::LAW(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::LEGAL(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::MARKETING(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::OPERATIONS(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::OVERSIGHT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::PAYMENT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::PRESENT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::PSYCHOTHERAPY(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::PUBLICHEALTH(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::REQUEST(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::RESEARCH(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::SYSADMIN(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::THREAT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::TRAINING(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::TREATMENT(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::WORKERSCOMP(Some(e)) => e.get_field_mut(field),
                NhinPurposeofuse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum NoteType {
    #[doc = "Display"]
    #[code = "display"]
    Display(Option<Element>),
    #[doc = "Print (Form)"]
    #[code = "print"]
    Print(Option<Element>),
    #[doc = "Print (Operator)"]
    #[code = "printoper"]
    Printoper(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for NoteType {
    fn default() -> Self {
        NoteType::Null(None)
    }
}
impl TryFrom<String> for NoteType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "display" => Ok(NoteType::Display(None)),
            "print" => Ok(NoteType::Print(None)),
            "printoper" => Ok(NoteType::Printoper(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &NoteType {
    fn into(self) -> Option<String> {
        match self {
            NoteType::Display(_) => Some("display".to_string()),
            NoteType::Print(_) => Some("print".to_string()),
            NoteType::Printoper(_) => Some("printoper".to_string()),
            NoteType::Null(_) => None,
        }
    }
}
impl MetaValue for NoteType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                NoteType::Display(Some(e)) => e.get_field(field),
                NoteType::Print(Some(e)) => e.get_field(field),
                NoteType::Printoper(Some(e)) => e.get_field(field),
                NoteType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                NoteType::Display(Some(e)) => e.get_field_mut(field),
                NoteType::Print(Some(e)) => e.get_field_mut(field),
                NoteType::Printoper(Some(e)) => e.get_field_mut(field),
                NoteType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObjectLifecycleEvents {
    #[doc = "Origination / Creation"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Export"]
    #[code = "10"]
    V10(Option<Element>),
    #[doc = "Disclosure"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "Receipt of disclosure"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "Archiving"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "Logical deletion"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "Permanent erasure / Physical destruction"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "Import / Copy"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Amendment"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Verification"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Translation"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "Access / Use"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "De-identification"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "Aggregation / summarization / derivation"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "Report"]
    #[code = "9"]
    V9(Option<Element>),
    #[doc = "Access/View Record Lifecycle Event"]
    #[code = "access"]
    Access(Option<Element>),
    #[doc = "Amend (Update) Record Lifecycle Event"]
    #[code = "amend"]
    Amend(Option<Element>),
    #[doc = "Archive Record Lifecycle Event"]
    #[code = "archive"]
    Archive(Option<Element>),
    #[doc = "Attest Record Lifecycle Event"]
    #[code = "attest"]
    Attest(Option<Element>),
    #[doc = "Decrypt Record Lifecycle Event"]
    #[code = "decrypt"]
    Decrypt(Option<Element>),
    #[doc = "De-Identify (Anononymize) Record Lifecycle Event"]
    #[code = "deidentify"]
    Deidentify(Option<Element>),
    #[doc = "Deprecate Record Lifecycle Event"]
    #[code = "deprecate"]
    Deprecate(Option<Element>),
    #[doc = "Destroy/Delete Record Lifecycle Event"]
    #[code = "destroy"]
    Destroy(Option<Element>),
    #[doc = "Disclose Record Lifecycle Event"]
    #[code = "disclose"]
    Disclose(Option<Element>),
    #[doc = "Encrypt Record Lifecycle Event"]
    #[code = "encrypt"]
    Encrypt(Option<Element>),
    #[doc = "Extract Record Lifecycle Event"]
    #[code = "extract"]
    Extract(Option<Element>),
    #[doc = "Add Legal Hold Record Lifecycle Event"]
    #[code = "hold"]
    Hold(Option<Element>),
    #[doc = "Link Record Lifecycle Event"]
    #[code = "link"]
    Link(Option<Element>),
    #[doc = "Merge Record Lifecycle Event"]
    #[code = "merge"]
    Merge(Option<Element>),
    #[doc = "Originate/Retain Record Lifecycle Event"]
    #[code = "originate"]
    Originate(Option<Element>),
    #[doc = "Pseudonymize Record Lifecycle Event"]
    #[code = "pseudonymize"]
    Pseudonymize(Option<Element>),
    #[doc = "Re-activate Record Lifecycle Event"]
    #[code = "reactivate"]
    Reactivate(Option<Element>),
    #[doc = "Receive/Retain Record Lifecycle Event"]
    #[code = "receive"]
    Receive(Option<Element>),
    #[doc = "Re-identify Record Lifecycle Event"]
    #[code = "reidentify"]
    Reidentify(Option<Element>),
    #[doc = "Report (Output) Record Lifecycle Event"]
    #[code = "report"]
    Report(Option<Element>),
    #[doc = "Restore Record Lifecycle Event"]
    #[code = "restore"]
    Restore(Option<Element>),
    #[doc = "Transform/Translate Record Lifecycle Event"]
    #[code = "transform"]
    Transform(Option<Element>),
    #[doc = "Transmit Record Lifecycle Event"]
    #[code = "transmit"]
    Transmit(Option<Element>),
    #[doc = "Remove Legal Hold Record Lifecycle Event"]
    #[code = "unhold"]
    Unhold(Option<Element>),
    #[doc = "Unlink Record Lifecycle Event"]
    #[code = "unlink"]
    Unlink(Option<Element>),
    #[doc = "Unmerge Record Lifecycle Event"]
    #[code = "unmerge"]
    Unmerge(Option<Element>),
    #[doc = "Verify Record Lifecycle Event"]
    #[code = "verify"]
    Verify(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObjectLifecycleEvents {
    fn default() -> Self {
        ObjectLifecycleEvents::Null(None)
    }
}
impl TryFrom<String> for ObjectLifecycleEvents {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(ObjectLifecycleEvents::V1(None)),
            "10" => Ok(ObjectLifecycleEvents::V10(None)),
            "11" => Ok(ObjectLifecycleEvents::V11(None)),
            "12" => Ok(ObjectLifecycleEvents::V12(None)),
            "13" => Ok(ObjectLifecycleEvents::V13(None)),
            "14" => Ok(ObjectLifecycleEvents::V14(None)),
            "15" => Ok(ObjectLifecycleEvents::V15(None)),
            "2" => Ok(ObjectLifecycleEvents::V2(None)),
            "3" => Ok(ObjectLifecycleEvents::V3(None)),
            "4" => Ok(ObjectLifecycleEvents::V4(None)),
            "5" => Ok(ObjectLifecycleEvents::V5(None)),
            "6" => Ok(ObjectLifecycleEvents::V6(None)),
            "7" => Ok(ObjectLifecycleEvents::V7(None)),
            "8" => Ok(ObjectLifecycleEvents::V8(None)),
            "9" => Ok(ObjectLifecycleEvents::V9(None)),
            "access" => Ok(ObjectLifecycleEvents::Access(None)),
            "amend" => Ok(ObjectLifecycleEvents::Amend(None)),
            "archive" => Ok(ObjectLifecycleEvents::Archive(None)),
            "attest" => Ok(ObjectLifecycleEvents::Attest(None)),
            "decrypt" => Ok(ObjectLifecycleEvents::Decrypt(None)),
            "deidentify" => Ok(ObjectLifecycleEvents::Deidentify(None)),
            "deprecate" => Ok(ObjectLifecycleEvents::Deprecate(None)),
            "destroy" => Ok(ObjectLifecycleEvents::Destroy(None)),
            "disclose" => Ok(ObjectLifecycleEvents::Disclose(None)),
            "encrypt" => Ok(ObjectLifecycleEvents::Encrypt(None)),
            "extract" => Ok(ObjectLifecycleEvents::Extract(None)),
            "hold" => Ok(ObjectLifecycleEvents::Hold(None)),
            "link" => Ok(ObjectLifecycleEvents::Link(None)),
            "merge" => Ok(ObjectLifecycleEvents::Merge(None)),
            "originate" => Ok(ObjectLifecycleEvents::Originate(None)),
            "pseudonymize" => Ok(ObjectLifecycleEvents::Pseudonymize(None)),
            "reactivate" => Ok(ObjectLifecycleEvents::Reactivate(None)),
            "receive" => Ok(ObjectLifecycleEvents::Receive(None)),
            "reidentify" => Ok(ObjectLifecycleEvents::Reidentify(None)),
            "report" => Ok(ObjectLifecycleEvents::Report(None)),
            "restore" => Ok(ObjectLifecycleEvents::Restore(None)),
            "transform" => Ok(ObjectLifecycleEvents::Transform(None)),
            "transmit" => Ok(ObjectLifecycleEvents::Transmit(None)),
            "unhold" => Ok(ObjectLifecycleEvents::Unhold(None)),
            "unlink" => Ok(ObjectLifecycleEvents::Unlink(None)),
            "unmerge" => Ok(ObjectLifecycleEvents::Unmerge(None)),
            "verify" => Ok(ObjectLifecycleEvents::Verify(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObjectLifecycleEvents {
    fn into(self) -> Option<String> {
        match self {
            ObjectLifecycleEvents::V1(_) => Some("1".to_string()),
            ObjectLifecycleEvents::V10(_) => Some("10".to_string()),
            ObjectLifecycleEvents::V11(_) => Some("11".to_string()),
            ObjectLifecycleEvents::V12(_) => Some("12".to_string()),
            ObjectLifecycleEvents::V13(_) => Some("13".to_string()),
            ObjectLifecycleEvents::V14(_) => Some("14".to_string()),
            ObjectLifecycleEvents::V15(_) => Some("15".to_string()),
            ObjectLifecycleEvents::V2(_) => Some("2".to_string()),
            ObjectLifecycleEvents::V3(_) => Some("3".to_string()),
            ObjectLifecycleEvents::V4(_) => Some("4".to_string()),
            ObjectLifecycleEvents::V5(_) => Some("5".to_string()),
            ObjectLifecycleEvents::V6(_) => Some("6".to_string()),
            ObjectLifecycleEvents::V7(_) => Some("7".to_string()),
            ObjectLifecycleEvents::V8(_) => Some("8".to_string()),
            ObjectLifecycleEvents::V9(_) => Some("9".to_string()),
            ObjectLifecycleEvents::Access(_) => Some("access".to_string()),
            ObjectLifecycleEvents::Amend(_) => Some("amend".to_string()),
            ObjectLifecycleEvents::Archive(_) => Some("archive".to_string()),
            ObjectLifecycleEvents::Attest(_) => Some("attest".to_string()),
            ObjectLifecycleEvents::Decrypt(_) => Some("decrypt".to_string()),
            ObjectLifecycleEvents::Deidentify(_) => Some("deidentify".to_string()),
            ObjectLifecycleEvents::Deprecate(_) => Some("deprecate".to_string()),
            ObjectLifecycleEvents::Destroy(_) => Some("destroy".to_string()),
            ObjectLifecycleEvents::Disclose(_) => Some("disclose".to_string()),
            ObjectLifecycleEvents::Encrypt(_) => Some("encrypt".to_string()),
            ObjectLifecycleEvents::Extract(_) => Some("extract".to_string()),
            ObjectLifecycleEvents::Hold(_) => Some("hold".to_string()),
            ObjectLifecycleEvents::Link(_) => Some("link".to_string()),
            ObjectLifecycleEvents::Merge(_) => Some("merge".to_string()),
            ObjectLifecycleEvents::Originate(_) => Some("originate".to_string()),
            ObjectLifecycleEvents::Pseudonymize(_) => Some("pseudonymize".to_string()),
            ObjectLifecycleEvents::Reactivate(_) => Some("reactivate".to_string()),
            ObjectLifecycleEvents::Receive(_) => Some("receive".to_string()),
            ObjectLifecycleEvents::Reidentify(_) => Some("reidentify".to_string()),
            ObjectLifecycleEvents::Report(_) => Some("report".to_string()),
            ObjectLifecycleEvents::Restore(_) => Some("restore".to_string()),
            ObjectLifecycleEvents::Transform(_) => Some("transform".to_string()),
            ObjectLifecycleEvents::Transmit(_) => Some("transmit".to_string()),
            ObjectLifecycleEvents::Unhold(_) => Some("unhold".to_string()),
            ObjectLifecycleEvents::Unlink(_) => Some("unlink".to_string()),
            ObjectLifecycleEvents::Unmerge(_) => Some("unmerge".to_string()),
            ObjectLifecycleEvents::Verify(_) => Some("verify".to_string()),
            ObjectLifecycleEvents::Null(_) => None,
        }
    }
}
impl MetaValue for ObjectLifecycleEvents {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObjectLifecycleEvents::V1(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V10(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V11(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V12(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V13(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V14(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V15(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V2(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V3(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V4(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V5(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V6(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V7(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V8(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::V9(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Access(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Amend(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Archive(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Attest(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Decrypt(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Deidentify(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Deprecate(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Destroy(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Disclose(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Encrypt(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Extract(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Hold(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Link(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Merge(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Originate(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Pseudonymize(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Reactivate(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Receive(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Reidentify(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Report(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Restore(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Transform(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Transmit(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Unhold(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Unlink(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Unmerge(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Verify(Some(e)) => e.get_field(field),
                ObjectLifecycleEvents::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObjectLifecycleEvents::V1(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V10(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V11(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V12(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V13(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V14(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V15(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V2(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V3(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V4(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V5(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V6(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V7(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V8(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::V9(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Access(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Amend(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Archive(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Attest(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Decrypt(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Deidentify(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Deprecate(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Destroy(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Disclose(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Encrypt(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Extract(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Hold(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Link(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Merge(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Originate(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Pseudonymize(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Reactivate(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Receive(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Reidentify(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Report(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Restore(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Transform(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Transmit(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Unhold(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Unlink(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Unmerge(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Verify(Some(e)) => e.get_field_mut(field),
                ObjectLifecycleEvents::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObjectRole {
    #[doc = "Patient"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Guarantor"]
    #[code = "10"]
    V10(Option<Element>),
    #[doc = "Security User Entity"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "Security User Group"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "Security Resource"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "Security Granularity Definition"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "Data Destination"]
    #[code = "16"]
    V16(Option<Element>),
    #[doc = "Data Repository"]
    #[code = "17"]
    V17(Option<Element>),
    #[doc = "Schedule"]
    #[code = "18"]
    V18(Option<Element>),
    #[doc = "Customer"]
    #[code = "19"]
    V19(Option<Element>),
    #[doc = "Location"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Job"]
    #[code = "20"]
    V20(Option<Element>),
    #[doc = "Job Stream"]
    #[code = "21"]
    V21(Option<Element>),
    #[doc = "Table"]
    #[code = "22"]
    V22(Option<Element>),
    #[doc = "Routing Criteria"]
    #[code = "23"]
    V23(Option<Element>),
    #[doc = "Query"]
    #[code = "24"]
    V24(Option<Element>),
    #[doc = "Report"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Domain Resource"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Master file"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "User"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "List"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "Doctor"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "Subscriber"]
    #[code = "9"]
    V9(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObjectRole {
    fn default() -> Self {
        ObjectRole::Null(None)
    }
}
impl TryFrom<String> for ObjectRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(ObjectRole::V1(None)),
            "10" => Ok(ObjectRole::V10(None)),
            "11" => Ok(ObjectRole::V11(None)),
            "12" => Ok(ObjectRole::V12(None)),
            "13" => Ok(ObjectRole::V13(None)),
            "14" => Ok(ObjectRole::V14(None)),
            "15" => Ok(ObjectRole::V15(None)),
            "16" => Ok(ObjectRole::V16(None)),
            "17" => Ok(ObjectRole::V17(None)),
            "18" => Ok(ObjectRole::V18(None)),
            "19" => Ok(ObjectRole::V19(None)),
            "2" => Ok(ObjectRole::V2(None)),
            "20" => Ok(ObjectRole::V20(None)),
            "21" => Ok(ObjectRole::V21(None)),
            "22" => Ok(ObjectRole::V22(None)),
            "23" => Ok(ObjectRole::V23(None)),
            "24" => Ok(ObjectRole::V24(None)),
            "3" => Ok(ObjectRole::V3(None)),
            "4" => Ok(ObjectRole::V4(None)),
            "5" => Ok(ObjectRole::V5(None)),
            "6" => Ok(ObjectRole::V6(None)),
            "7" => Ok(ObjectRole::V7(None)),
            "8" => Ok(ObjectRole::V8(None)),
            "9" => Ok(ObjectRole::V9(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObjectRole {
    fn into(self) -> Option<String> {
        match self {
            ObjectRole::V1(_) => Some("1".to_string()),
            ObjectRole::V10(_) => Some("10".to_string()),
            ObjectRole::V11(_) => Some("11".to_string()),
            ObjectRole::V12(_) => Some("12".to_string()),
            ObjectRole::V13(_) => Some("13".to_string()),
            ObjectRole::V14(_) => Some("14".to_string()),
            ObjectRole::V15(_) => Some("15".to_string()),
            ObjectRole::V16(_) => Some("16".to_string()),
            ObjectRole::V17(_) => Some("17".to_string()),
            ObjectRole::V18(_) => Some("18".to_string()),
            ObjectRole::V19(_) => Some("19".to_string()),
            ObjectRole::V2(_) => Some("2".to_string()),
            ObjectRole::V20(_) => Some("20".to_string()),
            ObjectRole::V21(_) => Some("21".to_string()),
            ObjectRole::V22(_) => Some("22".to_string()),
            ObjectRole::V23(_) => Some("23".to_string()),
            ObjectRole::V24(_) => Some("24".to_string()),
            ObjectRole::V3(_) => Some("3".to_string()),
            ObjectRole::V4(_) => Some("4".to_string()),
            ObjectRole::V5(_) => Some("5".to_string()),
            ObjectRole::V6(_) => Some("6".to_string()),
            ObjectRole::V7(_) => Some("7".to_string()),
            ObjectRole::V8(_) => Some("8".to_string()),
            ObjectRole::V9(_) => Some("9".to_string()),
            ObjectRole::Null(_) => None,
        }
    }
}
impl MetaValue for ObjectRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObjectRole::V1(Some(e)) => e.get_field(field),
                ObjectRole::V10(Some(e)) => e.get_field(field),
                ObjectRole::V11(Some(e)) => e.get_field(field),
                ObjectRole::V12(Some(e)) => e.get_field(field),
                ObjectRole::V13(Some(e)) => e.get_field(field),
                ObjectRole::V14(Some(e)) => e.get_field(field),
                ObjectRole::V15(Some(e)) => e.get_field(field),
                ObjectRole::V16(Some(e)) => e.get_field(field),
                ObjectRole::V17(Some(e)) => e.get_field(field),
                ObjectRole::V18(Some(e)) => e.get_field(field),
                ObjectRole::V19(Some(e)) => e.get_field(field),
                ObjectRole::V2(Some(e)) => e.get_field(field),
                ObjectRole::V20(Some(e)) => e.get_field(field),
                ObjectRole::V21(Some(e)) => e.get_field(field),
                ObjectRole::V22(Some(e)) => e.get_field(field),
                ObjectRole::V23(Some(e)) => e.get_field(field),
                ObjectRole::V24(Some(e)) => e.get_field(field),
                ObjectRole::V3(Some(e)) => e.get_field(field),
                ObjectRole::V4(Some(e)) => e.get_field(field),
                ObjectRole::V5(Some(e)) => e.get_field(field),
                ObjectRole::V6(Some(e)) => e.get_field(field),
                ObjectRole::V7(Some(e)) => e.get_field(field),
                ObjectRole::V8(Some(e)) => e.get_field(field),
                ObjectRole::V9(Some(e)) => e.get_field(field),
                ObjectRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObjectRole::V1(Some(e)) => e.get_field_mut(field),
                ObjectRole::V10(Some(e)) => e.get_field_mut(field),
                ObjectRole::V11(Some(e)) => e.get_field_mut(field),
                ObjectRole::V12(Some(e)) => e.get_field_mut(field),
                ObjectRole::V13(Some(e)) => e.get_field_mut(field),
                ObjectRole::V14(Some(e)) => e.get_field_mut(field),
                ObjectRole::V15(Some(e)) => e.get_field_mut(field),
                ObjectRole::V16(Some(e)) => e.get_field_mut(field),
                ObjectRole::V17(Some(e)) => e.get_field_mut(field),
                ObjectRole::V18(Some(e)) => e.get_field_mut(field),
                ObjectRole::V19(Some(e)) => e.get_field_mut(field),
                ObjectRole::V2(Some(e)) => e.get_field_mut(field),
                ObjectRole::V20(Some(e)) => e.get_field_mut(field),
                ObjectRole::V21(Some(e)) => e.get_field_mut(field),
                ObjectRole::V22(Some(e)) => e.get_field_mut(field),
                ObjectRole::V23(Some(e)) => e.get_field_mut(field),
                ObjectRole::V24(Some(e)) => e.get_field_mut(field),
                ObjectRole::V3(Some(e)) => e.get_field_mut(field),
                ObjectRole::V4(Some(e)) => e.get_field_mut(field),
                ObjectRole::V5(Some(e)) => e.get_field_mut(field),
                ObjectRole::V6(Some(e)) => e.get_field_mut(field),
                ObjectRole::V7(Some(e)) => e.get_field_mut(field),
                ObjectRole::V8(Some(e)) => e.get_field_mut(field),
                ObjectRole::V9(Some(e)) => e.get_field_mut(field),
                ObjectRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationCategory {
    #[doc = "Activity"]
    #[code = "activity"]
    Activity(Option<Element>),
    #[doc = "Exam"]
    #[code = "exam"]
    Exam(Option<Element>),
    #[doc = "Imaging"]
    #[code = "imaging"]
    Imaging(Option<Element>),
    #[doc = "Laboratory"]
    #[code = "laboratory"]
    Laboratory(Option<Element>),
    #[doc = "Procedure"]
    #[code = "procedure"]
    Procedure(Option<Element>),
    #[doc = "Social History"]
    #[code = "social-history"]
    SocialHistory(Option<Element>),
    #[doc = "Survey"]
    #[code = "survey"]
    Survey(Option<Element>),
    #[doc = "Therapy"]
    #[code = "therapy"]
    Therapy(Option<Element>),
    #[doc = "Vital Signs"]
    #[code = "vital-signs"]
    VitalSigns(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationCategory {
    fn default() -> Self {
        ObservationCategory::Null(None)
    }
}
impl TryFrom<String> for ObservationCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "activity" => Ok(ObservationCategory::Activity(None)),
            "exam" => Ok(ObservationCategory::Exam(None)),
            "imaging" => Ok(ObservationCategory::Imaging(None)),
            "laboratory" => Ok(ObservationCategory::Laboratory(None)),
            "procedure" => Ok(ObservationCategory::Procedure(None)),
            "social-history" => Ok(ObservationCategory::SocialHistory(None)),
            "survey" => Ok(ObservationCategory::Survey(None)),
            "therapy" => Ok(ObservationCategory::Therapy(None)),
            "vital-signs" => Ok(ObservationCategory::VitalSigns(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationCategory {
    fn into(self) -> Option<String> {
        match self {
            ObservationCategory::Activity(_) => Some("activity".to_string()),
            ObservationCategory::Exam(_) => Some("exam".to_string()),
            ObservationCategory::Imaging(_) => Some("imaging".to_string()),
            ObservationCategory::Laboratory(_) => Some("laboratory".to_string()),
            ObservationCategory::Procedure(_) => Some("procedure".to_string()),
            ObservationCategory::SocialHistory(_) => Some("social-history".to_string()),
            ObservationCategory::Survey(_) => Some("survey".to_string()),
            ObservationCategory::Therapy(_) => Some("therapy".to_string()),
            ObservationCategory::VitalSigns(_) => Some("vital-signs".to_string()),
            ObservationCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationCategory::Activity(Some(e)) => e.get_field(field),
                ObservationCategory::Exam(Some(e)) => e.get_field(field),
                ObservationCategory::Imaging(Some(e)) => e.get_field(field),
                ObservationCategory::Laboratory(Some(e)) => e.get_field(field),
                ObservationCategory::Procedure(Some(e)) => e.get_field(field),
                ObservationCategory::SocialHistory(Some(e)) => e.get_field(field),
                ObservationCategory::Survey(Some(e)) => e.get_field(field),
                ObservationCategory::Therapy(Some(e)) => e.get_field(field),
                ObservationCategory::VitalSigns(Some(e)) => e.get_field(field),
                ObservationCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationCategory::Activity(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Exam(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Imaging(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Laboratory(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Procedure(Some(e)) => e.get_field_mut(field),
                ObservationCategory::SocialHistory(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Survey(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Therapy(Some(e)) => e.get_field_mut(field),
                ObservationCategory::VitalSigns(Some(e)) => e.get_field_mut(field),
                ObservationCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationInterpretation {
    #[doc = "Off scale low"]
    #[code = "<"]
    Greater(Option<Element>),
    #[doc = "Off scale high"]
    #[code = ">"]
    Less(Option<Element>),
    #[doc = "Abnormal"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Critical abnormal"]
    #[code = "AA"]
    AA(Option<Element>),
    #[doc = "Anti-complementary substances present"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "Better"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "Carrier"]
    #[code = "CAR"]
    CAR(Option<Element>),
    #[doc = "Carrier"]
    #[code = "Carrier"]
    Carrier(Option<Element>),
    #[doc = "Significant change down"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Detected"]
    #[code = "DET"]
    DET(Option<Element>),
    #[doc = "Equivocal"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "outside threshold"]
    #[code = "EX"]
    EX(Option<Element>),
    #[doc = "Expected"]
    #[code = "EXP"]
    EXP(Option<Element>),
    #[doc = "High"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "Significantly high"]
    #[code = "H>"]
    HLess(Option<Element>),
    #[doc = "Critical high"]
    #[code = "HH"]
    HH(Option<Element>),
    #[doc = "Hold for Medical Review"]
    #[code = "HM"]
    HM(Option<Element>),
    #[doc = "Significantly high"]
    #[code = "HU"]
    HU(Option<Element>),
    #[doc = "above high threshold"]
    #[code = "HX"]
    HX(Option<Element>),
    #[doc = "Intermediate"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Insufficient evidence"]
    #[code = "IE"]
    IE(Option<Element>),
    #[doc = "Indeterminate"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "Low"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Significantly low"]
    #[code = "L<"]
    LGreater(Option<Element>),
    #[doc = "Critical low"]
    #[code = "LL"]
    LL(Option<Element>),
    #[doc = "Significantly low"]
    #[code = "LU"]
    LU(Option<Element>),
    #[doc = "below low threshold"]
    #[code = "LX"]
    LX(Option<Element>),
    #[doc = "moderately susceptible"]
    #[code = "MS"]
    MS(Option<Element>),
    #[doc = "Normal"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "No CLSI defined breakpoint"]
    #[code = "NCL"]
    NCL(Option<Element>),
    #[doc = "Not detected"]
    #[code = "ND"]
    ND(Option<Element>),
    #[doc = "Negative"]
    #[code = "NEG"]
    NEG(Option<Element>),
    #[doc = "Non-reactive"]
    #[code = "NR"]
    NR(Option<Element>),
    #[doc = "Non-susceptible"]
    #[code = "NS"]
    NS(Option<Element>),
    #[doc = "Interpretation qualifiers in separate OBX segments"]
    #[code = "OBX"]
    OBX(Option<Element>),
    #[doc = "ObservationInterpretationDetection"]
    #[code = "ObservationInterpretationDetection"]
    ObservationInterpretationDetection(Option<Element>),
    #[doc = "ObservationInterpretationExpectation"]
    #[code = "ObservationInterpretationExpectation"]
    ObservationInterpretationExpectation(Option<Element>),
    #[doc = "Positive"]
    #[code = "POS"]
    POS(Option<Element>),
    #[doc = "Quality control failure"]
    #[code = "QCF"]
    QCF(Option<Element>),
    #[doc = "Resistant"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Reactive"]
    #[code = "RR"]
    RR(Option<Element>),
    #[doc = "ReactivityObservationInterpretation"]
    #[code = "ReactivityObservationInterpretation"]
    ReactivityObservationInterpretation(Option<Element>),
    #[doc = "Susceptible"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Susceptible-dose dependent"]
    #[code = "SDD"]
    SDD(Option<Element>),
    #[doc = "Synergy - resistant"]
    #[code = "SYN-R"]
    SYNR(Option<Element>),
    #[doc = "Synergy - susceptible"]
    #[code = "SYN-S"]
    SYNS(Option<Element>),
    #[doc = "Cytotoxic substance present"]
    #[code = "TOX"]
    TOX(Option<Element>),
    #[doc = "Significant change up"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "Unexpected"]
    #[code = "UNE"]
    UNE(Option<Element>),
    #[doc = "very susceptible"]
    #[code = "VS"]
    VS(Option<Element>),
    #[doc = "Worse"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "Weakly reactive"]
    #[code = "WR"]
    WR(Option<Element>),
    #[doc = "GeneticObservationInterpretation"]
    #[code = "_GeneticObservationInterpretation"]
    _GeneticObservationInterpretation(Option<Element>),
    #[doc = "ObservationInterpretationChange"]
    #[code = "_ObservationInterpretationChange"]
    _ObservationInterpretationChange(Option<Element>),
    #[doc = "ObservationInterpretationExceptions"]
    #[code = "_ObservationInterpretationExceptions"]
    _ObservationInterpretationExceptions(Option<Element>),
    #[doc = "ObservationInterpretationNormality"]
    #[code = "_ObservationInterpretationNormality"]
    _ObservationInterpretationNormality(Option<Element>),
    #[doc = "ObservationInterpretationSusceptibility"]
    #[code = "_ObservationInterpretationSusceptibility"]
    _ObservationInterpretationSusceptibility(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationInterpretation {
    fn default() -> Self {
        ObservationInterpretation::Null(None)
    }
}
impl TryFrom<String> for ObservationInterpretation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "<" => Ok(ObservationInterpretation::Greater(None)),
            ">" => Ok(ObservationInterpretation::Less(None)),
            "A" => Ok(ObservationInterpretation::A(None)),
            "AA" => Ok(ObservationInterpretation::AA(None)),
            "AC" => Ok(ObservationInterpretation::AC(None)),
            "B" => Ok(ObservationInterpretation::B(None)),
            "CAR" => Ok(ObservationInterpretation::CAR(None)),
            "Carrier" => Ok(ObservationInterpretation::Carrier(None)),
            "D" => Ok(ObservationInterpretation::D(None)),
            "DET" => Ok(ObservationInterpretation::DET(None)),
            "E" => Ok(ObservationInterpretation::E(None)),
            "EX" => Ok(ObservationInterpretation::EX(None)),
            "EXP" => Ok(ObservationInterpretation::EXP(None)),
            "H" => Ok(ObservationInterpretation::H(None)),
            "H>" => Ok(ObservationInterpretation::HLess(None)),
            "HH" => Ok(ObservationInterpretation::HH(None)),
            "HM" => Ok(ObservationInterpretation::HM(None)),
            "HU" => Ok(ObservationInterpretation::HU(None)),
            "HX" => Ok(ObservationInterpretation::HX(None)),
            "I" => Ok(ObservationInterpretation::I(None)),
            "IE" => Ok(ObservationInterpretation::IE(None)),
            "IND" => Ok(ObservationInterpretation::IND(None)),
            "L" => Ok(ObservationInterpretation::L(None)),
            "L<" => Ok(ObservationInterpretation::LGreater(None)),
            "LL" => Ok(ObservationInterpretation::LL(None)),
            "LU" => Ok(ObservationInterpretation::LU(None)),
            "LX" => Ok(ObservationInterpretation::LX(None)),
            "MS" => Ok(ObservationInterpretation::MS(None)),
            "N" => Ok(ObservationInterpretation::N(None)),
            "NCL" => Ok(ObservationInterpretation::NCL(None)),
            "ND" => Ok(ObservationInterpretation::ND(None)),
            "NEG" => Ok(ObservationInterpretation::NEG(None)),
            "NR" => Ok(ObservationInterpretation::NR(None)),
            "NS" => Ok(ObservationInterpretation::NS(None)),
            "OBX" => Ok(ObservationInterpretation::OBX(None)),
            "ObservationInterpretationDetection" => {
                Ok(ObservationInterpretation::ObservationInterpretationDetection(None))
            }
            "ObservationInterpretationExpectation" => {
                Ok(ObservationInterpretation::ObservationInterpretationExpectation(None))
            }
            "POS" => Ok(ObservationInterpretation::POS(None)),
            "QCF" => Ok(ObservationInterpretation::QCF(None)),
            "R" => Ok(ObservationInterpretation::R(None)),
            "RR" => Ok(ObservationInterpretation::RR(None)),
            "ReactivityObservationInterpretation" => {
                Ok(ObservationInterpretation::ReactivityObservationInterpretation(None))
            }
            "S" => Ok(ObservationInterpretation::S(None)),
            "SDD" => Ok(ObservationInterpretation::SDD(None)),
            "SYN-R" => Ok(ObservationInterpretation::SYNR(None)),
            "SYN-S" => Ok(ObservationInterpretation::SYNS(None)),
            "TOX" => Ok(ObservationInterpretation::TOX(None)),
            "U" => Ok(ObservationInterpretation::U(None)),
            "UNE" => Ok(ObservationInterpretation::UNE(None)),
            "VS" => Ok(ObservationInterpretation::VS(None)),
            "W" => Ok(ObservationInterpretation::W(None)),
            "WR" => Ok(ObservationInterpretation::WR(None)),
            "_GeneticObservationInterpretation" => {
                Ok(ObservationInterpretation::_GeneticObservationInterpretation(None))
            }
            "_ObservationInterpretationChange" => Ok(
                ObservationInterpretation::_ObservationInterpretationChange(None),
            ),
            "_ObservationInterpretationExceptions" => {
                Ok(ObservationInterpretation::_ObservationInterpretationExceptions(None))
            }
            "_ObservationInterpretationNormality" => {
                Ok(ObservationInterpretation::_ObservationInterpretationNormality(None))
            }
            "_ObservationInterpretationSusceptibility" => {
                Ok(ObservationInterpretation::_ObservationInterpretationSusceptibility(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationInterpretation {
    fn into(self) -> Option<String> {
        match self {
            ObservationInterpretation::Greater(_) => Some("<".to_string()),
            ObservationInterpretation::Less(_) => Some(">".to_string()),
            ObservationInterpretation::A(_) => Some("A".to_string()),
            ObservationInterpretation::AA(_) => Some("AA".to_string()),
            ObservationInterpretation::AC(_) => Some("AC".to_string()),
            ObservationInterpretation::B(_) => Some("B".to_string()),
            ObservationInterpretation::CAR(_) => Some("CAR".to_string()),
            ObservationInterpretation::Carrier(_) => Some("Carrier".to_string()),
            ObservationInterpretation::D(_) => Some("D".to_string()),
            ObservationInterpretation::DET(_) => Some("DET".to_string()),
            ObservationInterpretation::E(_) => Some("E".to_string()),
            ObservationInterpretation::EX(_) => Some("EX".to_string()),
            ObservationInterpretation::EXP(_) => Some("EXP".to_string()),
            ObservationInterpretation::H(_) => Some("H".to_string()),
            ObservationInterpretation::HLess(_) => Some("H>".to_string()),
            ObservationInterpretation::HH(_) => Some("HH".to_string()),
            ObservationInterpretation::HM(_) => Some("HM".to_string()),
            ObservationInterpretation::HU(_) => Some("HU".to_string()),
            ObservationInterpretation::HX(_) => Some("HX".to_string()),
            ObservationInterpretation::I(_) => Some("I".to_string()),
            ObservationInterpretation::IE(_) => Some("IE".to_string()),
            ObservationInterpretation::IND(_) => Some("IND".to_string()),
            ObservationInterpretation::L(_) => Some("L".to_string()),
            ObservationInterpretation::LGreater(_) => Some("L<".to_string()),
            ObservationInterpretation::LL(_) => Some("LL".to_string()),
            ObservationInterpretation::LU(_) => Some("LU".to_string()),
            ObservationInterpretation::LX(_) => Some("LX".to_string()),
            ObservationInterpretation::MS(_) => Some("MS".to_string()),
            ObservationInterpretation::N(_) => Some("N".to_string()),
            ObservationInterpretation::NCL(_) => Some("NCL".to_string()),
            ObservationInterpretation::ND(_) => Some("ND".to_string()),
            ObservationInterpretation::NEG(_) => Some("NEG".to_string()),
            ObservationInterpretation::NR(_) => Some("NR".to_string()),
            ObservationInterpretation::NS(_) => Some("NS".to_string()),
            ObservationInterpretation::OBX(_) => Some("OBX".to_string()),
            ObservationInterpretation::ObservationInterpretationDetection(_) => {
                Some("ObservationInterpretationDetection".to_string())
            }
            ObservationInterpretation::ObservationInterpretationExpectation(_) => {
                Some("ObservationInterpretationExpectation".to_string())
            }
            ObservationInterpretation::POS(_) => Some("POS".to_string()),
            ObservationInterpretation::QCF(_) => Some("QCF".to_string()),
            ObservationInterpretation::R(_) => Some("R".to_string()),
            ObservationInterpretation::RR(_) => Some("RR".to_string()),
            ObservationInterpretation::ReactivityObservationInterpretation(_) => {
                Some("ReactivityObservationInterpretation".to_string())
            }
            ObservationInterpretation::S(_) => Some("S".to_string()),
            ObservationInterpretation::SDD(_) => Some("SDD".to_string()),
            ObservationInterpretation::SYNR(_) => Some("SYN-R".to_string()),
            ObservationInterpretation::SYNS(_) => Some("SYN-S".to_string()),
            ObservationInterpretation::TOX(_) => Some("TOX".to_string()),
            ObservationInterpretation::U(_) => Some("U".to_string()),
            ObservationInterpretation::UNE(_) => Some("UNE".to_string()),
            ObservationInterpretation::VS(_) => Some("VS".to_string()),
            ObservationInterpretation::W(_) => Some("W".to_string()),
            ObservationInterpretation::WR(_) => Some("WR".to_string()),
            ObservationInterpretation::_GeneticObservationInterpretation(_) => {
                Some("_GeneticObservationInterpretation".to_string())
            }
            ObservationInterpretation::_ObservationInterpretationChange(_) => {
                Some("_ObservationInterpretationChange".to_string())
            }
            ObservationInterpretation::_ObservationInterpretationExceptions(_) => {
                Some("_ObservationInterpretationExceptions".to_string())
            }
            ObservationInterpretation::_ObservationInterpretationNormality(_) => {
                Some("_ObservationInterpretationNormality".to_string())
            }
            ObservationInterpretation::_ObservationInterpretationSusceptibility(_) => {
                Some("_ObservationInterpretationSusceptibility".to_string())
            }
            ObservationInterpretation::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationInterpretation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationInterpretation::Greater(Some(e)) => e.get_field(field),
                ObservationInterpretation::Less(Some(e)) => e.get_field(field),
                ObservationInterpretation::A(Some(e)) => e.get_field(field),
                ObservationInterpretation::AA(Some(e)) => e.get_field(field),
                ObservationInterpretation::AC(Some(e)) => e.get_field(field),
                ObservationInterpretation::B(Some(e)) => e.get_field(field),
                ObservationInterpretation::CAR(Some(e)) => e.get_field(field),
                ObservationInterpretation::Carrier(Some(e)) => e.get_field(field),
                ObservationInterpretation::D(Some(e)) => e.get_field(field),
                ObservationInterpretation::DET(Some(e)) => e.get_field(field),
                ObservationInterpretation::E(Some(e)) => e.get_field(field),
                ObservationInterpretation::EX(Some(e)) => e.get_field(field),
                ObservationInterpretation::EXP(Some(e)) => e.get_field(field),
                ObservationInterpretation::H(Some(e)) => e.get_field(field),
                ObservationInterpretation::HLess(Some(e)) => e.get_field(field),
                ObservationInterpretation::HH(Some(e)) => e.get_field(field),
                ObservationInterpretation::HM(Some(e)) => e.get_field(field),
                ObservationInterpretation::HU(Some(e)) => e.get_field(field),
                ObservationInterpretation::HX(Some(e)) => e.get_field(field),
                ObservationInterpretation::I(Some(e)) => e.get_field(field),
                ObservationInterpretation::IE(Some(e)) => e.get_field(field),
                ObservationInterpretation::IND(Some(e)) => e.get_field(field),
                ObservationInterpretation::L(Some(e)) => e.get_field(field),
                ObservationInterpretation::LGreater(Some(e)) => e.get_field(field),
                ObservationInterpretation::LL(Some(e)) => e.get_field(field),
                ObservationInterpretation::LU(Some(e)) => e.get_field(field),
                ObservationInterpretation::LX(Some(e)) => e.get_field(field),
                ObservationInterpretation::MS(Some(e)) => e.get_field(field),
                ObservationInterpretation::N(Some(e)) => e.get_field(field),
                ObservationInterpretation::NCL(Some(e)) => e.get_field(field),
                ObservationInterpretation::ND(Some(e)) => e.get_field(field),
                ObservationInterpretation::NEG(Some(e)) => e.get_field(field),
                ObservationInterpretation::NR(Some(e)) => e.get_field(field),
                ObservationInterpretation::NS(Some(e)) => e.get_field(field),
                ObservationInterpretation::OBX(Some(e)) => e.get_field(field),
                ObservationInterpretation::ObservationInterpretationDetection(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::ObservationInterpretationExpectation(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::POS(Some(e)) => e.get_field(field),
                ObservationInterpretation::QCF(Some(e)) => e.get_field(field),
                ObservationInterpretation::R(Some(e)) => e.get_field(field),
                ObservationInterpretation::RR(Some(e)) => e.get_field(field),
                ObservationInterpretation::ReactivityObservationInterpretation(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::S(Some(e)) => e.get_field(field),
                ObservationInterpretation::SDD(Some(e)) => e.get_field(field),
                ObservationInterpretation::SYNR(Some(e)) => e.get_field(field),
                ObservationInterpretation::SYNS(Some(e)) => e.get_field(field),
                ObservationInterpretation::TOX(Some(e)) => e.get_field(field),
                ObservationInterpretation::U(Some(e)) => e.get_field(field),
                ObservationInterpretation::UNE(Some(e)) => e.get_field(field),
                ObservationInterpretation::VS(Some(e)) => e.get_field(field),
                ObservationInterpretation::W(Some(e)) => e.get_field(field),
                ObservationInterpretation::WR(Some(e)) => e.get_field(field),
                ObservationInterpretation::_GeneticObservationInterpretation(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::_ObservationInterpretationChange(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::_ObservationInterpretationExceptions(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::_ObservationInterpretationNormality(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::_ObservationInterpretationSusceptibility(Some(e)) => {
                    e.get_field(field)
                }
                ObservationInterpretation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationInterpretation::Greater(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::Less(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::A(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::AA(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::AC(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::B(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::CAR(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::Carrier(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::D(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::DET(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::E(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::EX(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::EXP(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::H(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::HLess(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::HH(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::HM(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::HU(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::HX(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::I(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::IE(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::IND(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::L(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::LGreater(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::LL(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::LU(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::LX(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::MS(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::N(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::NCL(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::ND(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::NEG(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::NR(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::NS(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::OBX(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::ObservationInterpretationDetection(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::ObservationInterpretationExpectation(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::POS(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::QCF(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::R(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::RR(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::ReactivityObservationInterpretation(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::S(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::SDD(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::SYNR(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::SYNS(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::TOX(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::U(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::UNE(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::VS(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::W(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::WR(Some(e)) => e.get_field_mut(field),
                ObservationInterpretation::_GeneticObservationInterpretation(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::_ObservationInterpretationChange(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::_ObservationInterpretationExceptions(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::_ObservationInterpretationNormality(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::_ObservationInterpretationSusceptibility(Some(e)) => {
                    e.get_field_mut(field)
                }
                ObservationInterpretation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationRangeCategory {
    #[doc = "absolute range"]
    #[code = "absolute"]
    Absolute(Option<Element>),
    #[doc = "critical range"]
    #[code = "critical"]
    Critical(Option<Element>),
    #[doc = "reference range"]
    #[code = "reference"]
    Reference(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationRangeCategory {
    fn default() -> Self {
        ObservationRangeCategory::Null(None)
    }
}
impl TryFrom<String> for ObservationRangeCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "absolute" => Ok(ObservationRangeCategory::Absolute(None)),
            "critical" => Ok(ObservationRangeCategory::Critical(None)),
            "reference" => Ok(ObservationRangeCategory::Reference(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationRangeCategory {
    fn into(self) -> Option<String> {
        match self {
            ObservationRangeCategory::Absolute(_) => Some("absolute".to_string()),
            ObservationRangeCategory::Critical(_) => Some("critical".to_string()),
            ObservationRangeCategory::Reference(_) => Some("reference".to_string()),
            ObservationRangeCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationRangeCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationRangeCategory::Absolute(Some(e)) => e.get_field(field),
                ObservationRangeCategory::Critical(Some(e)) => e.get_field(field),
                ObservationRangeCategory::Reference(Some(e)) => e.get_field(field),
                ObservationRangeCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationRangeCategory::Absolute(Some(e)) => e.get_field_mut(field),
                ObservationRangeCategory::Critical(Some(e)) => e.get_field_mut(field),
                ObservationRangeCategory::Reference(Some(e)) => e.get_field_mut(field),
                ObservationRangeCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationStatistics {
    #[doc = "20th Percentile"]
    #[code = "20-percent"]
    V20Percent(Option<Element>),
    #[doc = "Quartile Deviation"]
    #[code = "4-dev"]
    V4Dev(Option<Element>),
    #[doc = "Lower Quartile"]
    #[code = "4-lower"]
    V4Lower(Option<Element>),
    #[doc = "Upper Quartile"]
    #[code = "4-upper"]
    V4Upper(Option<Element>),
    #[doc = "1st Quintile"]
    #[code = "5-1"]
    V51(Option<Element>),
    #[doc = "2nd Quintile"]
    #[code = "5-2"]
    V52(Option<Element>),
    #[doc = "3rd Quintile"]
    #[code = "5-3"]
    V53(Option<Element>),
    #[doc = "4th Quintile"]
    #[code = "5-4"]
    V54(Option<Element>),
    #[doc = "80th Percentile"]
    #[code = "80-percent"]
    V80Percent(Option<Element>),
    #[doc = "Average"]
    #[code = "average"]
    Average(Option<Element>),
    #[doc = "Count"]
    #[code = "count"]
    Count(Option<Element>),
    #[doc = "Kurtosis"]
    #[code = "kurtosis"]
    Kurtosis(Option<Element>),
    #[doc = "Maximum"]
    #[code = "maximum"]
    Maximum(Option<Element>),
    #[doc = "Median"]
    #[code = "median"]
    Median(Option<Element>),
    #[doc = "Minimum"]
    #[code = "minimum"]
    Minimum(Option<Element>),
    #[doc = "Regression"]
    #[code = "regression"]
    Regression(Option<Element>),
    #[doc = "Skew"]
    #[code = "skew"]
    Skew(Option<Element>),
    #[doc = "Standard Deviation"]
    #[code = "std-dev"]
    StdDev(Option<Element>),
    #[doc = "Sum"]
    #[code = "sum"]
    Sum(Option<Element>),
    #[doc = "Total Count"]
    #[code = "total-count"]
    TotalCount(Option<Element>),
    #[doc = "Variance"]
    #[code = "variance"]
    Variance(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationStatistics {
    fn default() -> Self {
        ObservationStatistics::Null(None)
    }
}
impl TryFrom<String> for ObservationStatistics {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "20-percent" => Ok(ObservationStatistics::V20Percent(None)),
            "4-dev" => Ok(ObservationStatistics::V4Dev(None)),
            "4-lower" => Ok(ObservationStatistics::V4Lower(None)),
            "4-upper" => Ok(ObservationStatistics::V4Upper(None)),
            "5-1" => Ok(ObservationStatistics::V51(None)),
            "5-2" => Ok(ObservationStatistics::V52(None)),
            "5-3" => Ok(ObservationStatistics::V53(None)),
            "5-4" => Ok(ObservationStatistics::V54(None)),
            "80-percent" => Ok(ObservationStatistics::V80Percent(None)),
            "average" => Ok(ObservationStatistics::Average(None)),
            "count" => Ok(ObservationStatistics::Count(None)),
            "kurtosis" => Ok(ObservationStatistics::Kurtosis(None)),
            "maximum" => Ok(ObservationStatistics::Maximum(None)),
            "median" => Ok(ObservationStatistics::Median(None)),
            "minimum" => Ok(ObservationStatistics::Minimum(None)),
            "regression" => Ok(ObservationStatistics::Regression(None)),
            "skew" => Ok(ObservationStatistics::Skew(None)),
            "std-dev" => Ok(ObservationStatistics::StdDev(None)),
            "sum" => Ok(ObservationStatistics::Sum(None)),
            "total-count" => Ok(ObservationStatistics::TotalCount(None)),
            "variance" => Ok(ObservationStatistics::Variance(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationStatistics {
    fn into(self) -> Option<String> {
        match self {
            ObservationStatistics::V20Percent(_) => Some("20-percent".to_string()),
            ObservationStatistics::V4Dev(_) => Some("4-dev".to_string()),
            ObservationStatistics::V4Lower(_) => Some("4-lower".to_string()),
            ObservationStatistics::V4Upper(_) => Some("4-upper".to_string()),
            ObservationStatistics::V51(_) => Some("5-1".to_string()),
            ObservationStatistics::V52(_) => Some("5-2".to_string()),
            ObservationStatistics::V53(_) => Some("5-3".to_string()),
            ObservationStatistics::V54(_) => Some("5-4".to_string()),
            ObservationStatistics::V80Percent(_) => Some("80-percent".to_string()),
            ObservationStatistics::Average(_) => Some("average".to_string()),
            ObservationStatistics::Count(_) => Some("count".to_string()),
            ObservationStatistics::Kurtosis(_) => Some("kurtosis".to_string()),
            ObservationStatistics::Maximum(_) => Some("maximum".to_string()),
            ObservationStatistics::Median(_) => Some("median".to_string()),
            ObservationStatistics::Minimum(_) => Some("minimum".to_string()),
            ObservationStatistics::Regression(_) => Some("regression".to_string()),
            ObservationStatistics::Skew(_) => Some("skew".to_string()),
            ObservationStatistics::StdDev(_) => Some("std-dev".to_string()),
            ObservationStatistics::Sum(_) => Some("sum".to_string()),
            ObservationStatistics::TotalCount(_) => Some("total-count".to_string()),
            ObservationStatistics::Variance(_) => Some("variance".to_string()),
            ObservationStatistics::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationStatistics {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationStatistics::V20Percent(Some(e)) => e.get_field(field),
                ObservationStatistics::V4Dev(Some(e)) => e.get_field(field),
                ObservationStatistics::V4Lower(Some(e)) => e.get_field(field),
                ObservationStatistics::V4Upper(Some(e)) => e.get_field(field),
                ObservationStatistics::V51(Some(e)) => e.get_field(field),
                ObservationStatistics::V52(Some(e)) => e.get_field(field),
                ObservationStatistics::V53(Some(e)) => e.get_field(field),
                ObservationStatistics::V54(Some(e)) => e.get_field(field),
                ObservationStatistics::V80Percent(Some(e)) => e.get_field(field),
                ObservationStatistics::Average(Some(e)) => e.get_field(field),
                ObservationStatistics::Count(Some(e)) => e.get_field(field),
                ObservationStatistics::Kurtosis(Some(e)) => e.get_field(field),
                ObservationStatistics::Maximum(Some(e)) => e.get_field(field),
                ObservationStatistics::Median(Some(e)) => e.get_field(field),
                ObservationStatistics::Minimum(Some(e)) => e.get_field(field),
                ObservationStatistics::Regression(Some(e)) => e.get_field(field),
                ObservationStatistics::Skew(Some(e)) => e.get_field(field),
                ObservationStatistics::StdDev(Some(e)) => e.get_field(field),
                ObservationStatistics::Sum(Some(e)) => e.get_field(field),
                ObservationStatistics::TotalCount(Some(e)) => e.get_field(field),
                ObservationStatistics::Variance(Some(e)) => e.get_field(field),
                ObservationStatistics::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationStatistics::V20Percent(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V4Dev(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V4Lower(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V4Upper(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V51(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V52(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V53(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V54(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::V80Percent(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Average(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Count(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Kurtosis(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Maximum(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Median(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Minimum(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Regression(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Skew(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::StdDev(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Sum(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::TotalCount(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Variance(Some(e)) => e.get_field_mut(field),
                ObservationStatistics::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationStatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Corrected"]
    #[code = "corrected"]
    Corrected(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Final"]
    #[code = "final"]
    Final(Option<Element>),
    #[doc = "Preliminary"]
    #[code = "preliminary"]
    Preliminary(Option<Element>),
    #[doc = "Registered"]
    #[code = "registered"]
    Registered(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationStatus {
    fn default() -> Self {
        ObservationStatus::Null(None)
    }
}
impl TryFrom<String> for ObservationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(ObservationStatus::Amended(None)),
            "cancelled" => Ok(ObservationStatus::Cancelled(None)),
            "corrected" => Ok(ObservationStatus::Corrected(None)),
            "entered-in-error" => Ok(ObservationStatus::EnteredInError(None)),
            "final" => Ok(ObservationStatus::Final(None)),
            "preliminary" => Ok(ObservationStatus::Preliminary(None)),
            "registered" => Ok(ObservationStatus::Registered(None)),
            "unknown" => Ok(ObservationStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationStatus {
    fn into(self) -> Option<String> {
        match self {
            ObservationStatus::Amended(_) => Some("amended".to_string()),
            ObservationStatus::Cancelled(_) => Some("cancelled".to_string()),
            ObservationStatus::Corrected(_) => Some("corrected".to_string()),
            ObservationStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            ObservationStatus::Final(_) => Some("final".to_string()),
            ObservationStatus::Preliminary(_) => Some("preliminary".to_string()),
            ObservationStatus::Registered(_) => Some("registered".to_string()),
            ObservationStatus::Unknown(_) => Some("unknown".to_string()),
            ObservationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationStatus::Amended(Some(e)) => e.get_field(field),
                ObservationStatus::Cancelled(Some(e)) => e.get_field(field),
                ObservationStatus::Corrected(Some(e)) => e.get_field(field),
                ObservationStatus::EnteredInError(Some(e)) => e.get_field(field),
                ObservationStatus::Final(Some(e)) => e.get_field(field),
                ObservationStatus::Preliminary(Some(e)) => e.get_field(field),
                ObservationStatus::Registered(Some(e)) => e.get_field(field),
                ObservationStatus::Unknown(Some(e)) => e.get_field(field),
                ObservationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationStatus::Amended(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Corrected(Some(e)) => e.get_field_mut(field),
                ObservationStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Final(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Preliminary(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Registered(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Unknown(Some(e)) => e.get_field_mut(field),
                ObservationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ObservationVitalsignresult {
    #[code = "2708-6"]
    V27086(Option<Element>),
    #[code = "29463-7"]
    V294637(Option<Element>),
    #[code = "39156-5"]
    V391565(Option<Element>),
    #[code = "8302-2"]
    V83022(Option<Element>),
    #[code = "8310-5"]
    V83105(Option<Element>),
    #[code = "8462-4"]
    V84624(Option<Element>),
    #[code = "8478-0"]
    V84780(Option<Element>),
    #[code = "8480-6"]
    V84806(Option<Element>),
    #[code = "85353-1"]
    V853531(Option<Element>),
    #[code = "85354-9"]
    V853549(Option<Element>),
    #[code = "8867-4"]
    V88674(Option<Element>),
    #[code = "9279-1"]
    V92791(Option<Element>),
    #[code = "9843-4"]
    V98434(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ObservationVitalsignresult {
    fn default() -> Self {
        ObservationVitalsignresult::Null(None)
    }
}
impl TryFrom<String> for ObservationVitalsignresult {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "2708-6" => Ok(ObservationVitalsignresult::V27086(None)),
            "29463-7" => Ok(ObservationVitalsignresult::V294637(None)),
            "39156-5" => Ok(ObservationVitalsignresult::V391565(None)),
            "8302-2" => Ok(ObservationVitalsignresult::V83022(None)),
            "8310-5" => Ok(ObservationVitalsignresult::V83105(None)),
            "8462-4" => Ok(ObservationVitalsignresult::V84624(None)),
            "8478-0" => Ok(ObservationVitalsignresult::V84780(None)),
            "8480-6" => Ok(ObservationVitalsignresult::V84806(None)),
            "85353-1" => Ok(ObservationVitalsignresult::V853531(None)),
            "85354-9" => Ok(ObservationVitalsignresult::V853549(None)),
            "8867-4" => Ok(ObservationVitalsignresult::V88674(None)),
            "9279-1" => Ok(ObservationVitalsignresult::V92791(None)),
            "9843-4" => Ok(ObservationVitalsignresult::V98434(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ObservationVitalsignresult {
    fn into(self) -> Option<String> {
        match self {
            ObservationVitalsignresult::V27086(_) => Some("2708-6".to_string()),
            ObservationVitalsignresult::V294637(_) => Some("29463-7".to_string()),
            ObservationVitalsignresult::V391565(_) => Some("39156-5".to_string()),
            ObservationVitalsignresult::V83022(_) => Some("8302-2".to_string()),
            ObservationVitalsignresult::V83105(_) => Some("8310-5".to_string()),
            ObservationVitalsignresult::V84624(_) => Some("8462-4".to_string()),
            ObservationVitalsignresult::V84780(_) => Some("8478-0".to_string()),
            ObservationVitalsignresult::V84806(_) => Some("8480-6".to_string()),
            ObservationVitalsignresult::V853531(_) => Some("85353-1".to_string()),
            ObservationVitalsignresult::V853549(_) => Some("85354-9".to_string()),
            ObservationVitalsignresult::V88674(_) => Some("8867-4".to_string()),
            ObservationVitalsignresult::V92791(_) => Some("9279-1".to_string()),
            ObservationVitalsignresult::V98434(_) => Some("9843-4".to_string()),
            ObservationVitalsignresult::Null(_) => None,
        }
    }
}
impl MetaValue for ObservationVitalsignresult {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ObservationVitalsignresult::V27086(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V294637(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V391565(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V83022(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V83105(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V84624(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V84780(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V84806(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V853531(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V853549(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V88674(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V92791(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::V98434(Some(e)) => e.get_field(field),
                ObservationVitalsignresult::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ObservationVitalsignresult::V27086(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V294637(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V391565(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V83022(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V83105(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V84624(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V84780(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V84806(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V853531(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V853549(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V88674(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V92791(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::V98434(Some(e)) => e.get_field_mut(field),
                ObservationVitalsignresult::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OperationKind {
    #[doc = "Operation"]
    #[code = "operation"]
    Operation(Option<Element>),
    #[doc = "Query"]
    #[code = "query"]
    Query(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OperationKind {
    fn default() -> Self {
        OperationKind::Null(None)
    }
}
impl TryFrom<String> for OperationKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "operation" => Ok(OperationKind::Operation(None)),
            "query" => Ok(OperationKind::Query(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OperationKind {
    fn into(self) -> Option<String> {
        match self {
            OperationKind::Operation(_) => Some("operation".to_string()),
            OperationKind::Query(_) => Some("query".to_string()),
            OperationKind::Null(_) => None,
        }
    }
}
impl MetaValue for OperationKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OperationKind::Operation(Some(e)) => e.get_field(field),
                OperationKind::Query(Some(e)) => e.get_field(field),
                OperationKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OperationKind::Operation(Some(e)) => e.get_field_mut(field),
                OperationKind::Query(Some(e)) => e.get_field_mut(field),
                OperationKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OperationOutcome {
    #[doc = "Error: Multiple matches exist for the conditional delete"]
    #[code = "DELETE_MULTIPLE_MATCHES"]
    DELETE_MULTIPLE_MATCHES(Option<Element>),
    #[doc = "You must authenticate before you can use this service"]
    #[code = "MSG_AUTH_REQUIRED"]
    MSG_AUTH_REQUIRED(Option<Element>),
    #[doc = "Bad Syntax: \"%s\" must be a %s'"]
    #[code = "MSG_BAD_FORMAT"]
    MSG_BAD_FORMAT(Option<Element>),
    #[doc = "Bad Syntax in %s"]
    #[code = "MSG_BAD_SYNTAX"]
    MSG_BAD_SYNTAX(Option<Element>),
    #[doc = "Unable to parse feed (entry content type = \"%s\")"]
    #[code = "MSG_CANT_PARSE_CONTENT"]
    MSG_CANT_PARSE_CONTENT(Option<Element>),
    #[doc = "Unable to parse feed (root element name = \"%s\")"]
    #[code = "MSG_CANT_PARSE_ROOT"]
    MSG_CANT_PARSE_ROOT(Option<Element>),
    #[doc = "New resource created"]
    #[code = "MSG_CREATED"]
    MSG_CREATED(Option<Element>),
    #[doc = "The Date value %s is not in the correct format (Xml Date Format required)"]
    #[code = "MSG_DATE_FORMAT"]
    MSG_DATE_FORMAT(Option<Element>),
    #[doc = "This resource has been deleted"]
    #[code = "MSG_DELETED"]
    MSG_DELETED(Option<Element>),
    #[doc = "Resource deleted"]
    #[code = "MSG_DELETED_DONE"]
    MSG_DELETED_DONE(Option<Element>),
    #[doc = "The resource \"%s\" has been deleted"]
    #[code = "MSG_DELETED_ID"]
    MSG_DELETED_ID(Option<Element>),
    #[doc = "Duplicate Id %s for resource type %s"]
    #[code = "MSG_DUPLICATE_ID"]
    MSG_DUPLICATE_ID(Option<Element>),
    #[doc = "Error parsing resource Xml (%s)"]
    #[code = "MSG_ERROR_PARSING"]
    MSG_ERROR_PARSING(Option<Element>),
    #[doc = "Id \"%s\" has an invalid character \"%s\""]
    #[code = "MSG_ID_INVALID"]
    MSG_ID_INVALID(Option<Element>),
    #[doc = "Id \"%s\" too long (length limit 36)"]
    #[code = "MSG_ID_TOO_LONG"]
    MSG_ID_TOO_LONG(Option<Element>),
    #[doc = "Id not accepted"]
    #[code = "MSG_INVALID_ID"]
    MSG_INVALID_ID(Option<Element>),
    #[doc = "Json Source for a resource should start with an object"]
    #[code = "MSG_JSON_OBJECT"]
    MSG_JSON_OBJECT(Option<Element>),
    #[doc = "Unable to resolve local reference to resource %s"]
    #[code = "MSG_LOCAL_FAIL"]
    MSG_LOCAL_FAIL(Option<Element>),
    #[doc = "Resource Id \"%s\" does not exist"]
    #[code = "MSG_NO_EXIST"]
    MSG_NO_EXIST(Option<Element>),
    #[doc = "No Resource found matching the query \"%s\""]
    #[code = "MSG_NO_MATCH"]
    MSG_NO_MATCH(Option<Element>),
    #[doc = "No module could be found to handle the request \"%s\""]
    #[code = "MSG_NO_MODULE"]
    MSG_NO_MODULE(Option<Element>),
    #[doc = "No Summary for this resource"]
    #[code = "MSG_NO_SUMMARY"]
    MSG_NO_SUMMARY(Option<Element>),
    #[doc = "Operation %s not allowed for resource %s (due to local configuration)"]
    #[code = "MSG_OP_NOT_ALLOWED"]
    MSG_OP_NOT_ALLOWED(Option<Element>),
    #[doc = "Unknown chained parameter name \"%s\""]
    #[code = "MSG_PARAM_CHAINED"]
    MSG_PARAM_CHAINED(Option<Element>),
    #[doc = "Parameter \"%s\" content is invalid"]
    #[code = "MSG_PARAM_INVALID"]
    MSG_PARAM_INVALID(Option<Element>),
    #[doc = "Parameter \"%s\" modifier is invalid"]
    #[code = "MSG_PARAM_MODIFIER_INVALID"]
    MSG_PARAM_MODIFIER_INVALID(Option<Element>),
    #[doc = "Parameter \"%s\" is not allowed to repeat"]
    #[code = "MSG_PARAM_NO_REPEAT"]
    MSG_PARAM_NO_REPEAT(Option<Element>),
    #[doc = "Parameter \"%s\" not understood"]
    #[code = "MSG_PARAM_UNKNOWN"]
    MSG_PARAM_UNKNOWN(Option<Element>),
    #[doc = "Resources with identity \"example\" cannot be deleted (for testing/training purposes)"]
    #[code = "MSG_RESOURCE_EXAMPLE_PROTECTED"]
    MSG_RESOURCE_EXAMPLE_PROTECTED(Option<Element>),
    #[doc = "unable to allocate resource id"]
    #[code = "MSG_RESOURCE_ID_FAIL"]
    MSG_RESOURCE_ID_FAIL(Option<Element>),
    #[doc = "Resource Id Mismatch"]
    #[code = "MSG_RESOURCE_ID_MISMATCH"]
    MSG_RESOURCE_ID_MISMATCH(Option<Element>),
    #[doc = "Resource Id Missing"]
    #[code = "MSG_RESOURCE_ID_MISSING"]
    MSG_RESOURCE_ID_MISSING(Option<Element>),
    #[doc = "Not allowed to submit a resource for this operation"]
    #[code = "MSG_RESOURCE_NOT_ALLOWED"]
    MSG_RESOURCE_NOT_ALLOWED(Option<Element>),
    #[doc = "A resource is required"]
    #[code = "MSG_RESOURCE_REQUIRED"]
    MSG_RESOURCE_REQUIRED(Option<Element>),
    #[doc = "Resource Type Mismatch"]
    #[code = "MSG_RESOURCE_TYPE_MISMATCH"]
    MSG_RESOURCE_TYPE_MISMATCH(Option<Element>),
    #[doc = "Unknown sort parameter name \"%s\""]
    #[code = "MSG_SORT_UNKNOWN"]
    MSG_SORT_UNKNOWN(Option<Element>),
    #[doc = "Duplicate Identifier in transaction: %s"]
    #[code = "MSG_TRANSACTION_DUPLICATE_ID"]
    MSG_TRANSACTION_DUPLICATE_ID(Option<Element>),
    #[doc = "Missing Identifier in transaction - an entry.id must be provided"]
    #[code = "MSG_TRANSACTION_MISSING_ID"]
    MSG_TRANSACTION_MISSING_ID(Option<Element>),
    #[doc = "Unhandled xml node type \"%s\""]
    #[code = "MSG_UNHANDLED_NODE_TYPE"]
    MSG_UNHANDLED_NODE_TYPE(Option<Element>),
    #[doc = "Unknown Content (%s) at %s"]
    #[code = "MSG_UNKNOWN_CONTENT"]
    MSG_UNKNOWN_CONTENT(Option<Element>),
    #[doc = "unknown FHIR http operation"]
    #[code = "MSG_UNKNOWN_OPERATION"]
    MSG_UNKNOWN_OPERATION(Option<Element>),
    #[doc = "Resource Type \"%s\" not recognised"]
    #[code = "MSG_UNKNOWN_TYPE"]
    MSG_UNKNOWN_TYPE(Option<Element>),
    #[doc = "existing resource updated"]
    #[code = "MSG_UPDATED"]
    MSG_UPDATED(Option<Element>),
    #[doc = "Version aware updates are required for this resource"]
    #[code = "MSG_VERSION_AWARE"]
    MSG_VERSION_AWARE(Option<Element>),
    #[doc = "Update Conflict (server current version = \"%s\", client version referenced = \"%s\")"]
    #[code = "MSG_VERSION_AWARE_CONFLICT"]
    MSG_VERSION_AWARE_CONFLICT(Option<Element>),
    #[doc = "Version specific URL not recognised"]
    #[code = "MSG_VERSION_AWARE_URL"]
    MSG_VERSION_AWARE_URL(Option<Element>),
    #[doc = "This does not appear to be a FHIR element or resource (wrong namespace \"%s\")"]
    #[code = "MSG_WRONG_NS"]
    MSG_WRONG_NS(Option<Element>),
    #[doc = "Error: Multiple matches exist for %s search parameters \"%s\""]
    #[code = "SEARCH_MULTIPLE"]
    SEARCH_MULTIPLE(Option<Element>),
    #[doc = "Error: no processable search found for %s search parameters \"%s\""]
    #[code = "SEARCH_NONE"]
    SEARCH_NONE(Option<Element>),
    #[doc = "Error: Multiple matches exist for the conditional update"]
    #[code = "UPDATE_MULTIPLE_MATCHES"]
    UPDATE_MULTIPLE_MATCHES(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OperationOutcome {
    fn default() -> Self {
        OperationOutcome::Null(None)
    }
}
impl TryFrom<String> for OperationOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DELETE_MULTIPLE_MATCHES" => Ok(OperationOutcome::DELETE_MULTIPLE_MATCHES(None)),
            "MSG_AUTH_REQUIRED" => Ok(OperationOutcome::MSG_AUTH_REQUIRED(None)),
            "MSG_BAD_FORMAT" => Ok(OperationOutcome::MSG_BAD_FORMAT(None)),
            "MSG_BAD_SYNTAX" => Ok(OperationOutcome::MSG_BAD_SYNTAX(None)),
            "MSG_CANT_PARSE_CONTENT" => Ok(OperationOutcome::MSG_CANT_PARSE_CONTENT(None)),
            "MSG_CANT_PARSE_ROOT" => Ok(OperationOutcome::MSG_CANT_PARSE_ROOT(None)),
            "MSG_CREATED" => Ok(OperationOutcome::MSG_CREATED(None)),
            "MSG_DATE_FORMAT" => Ok(OperationOutcome::MSG_DATE_FORMAT(None)),
            "MSG_DELETED" => Ok(OperationOutcome::MSG_DELETED(None)),
            "MSG_DELETED_DONE" => Ok(OperationOutcome::MSG_DELETED_DONE(None)),
            "MSG_DELETED_ID" => Ok(OperationOutcome::MSG_DELETED_ID(None)),
            "MSG_DUPLICATE_ID" => Ok(OperationOutcome::MSG_DUPLICATE_ID(None)),
            "MSG_ERROR_PARSING" => Ok(OperationOutcome::MSG_ERROR_PARSING(None)),
            "MSG_ID_INVALID" => Ok(OperationOutcome::MSG_ID_INVALID(None)),
            "MSG_ID_TOO_LONG" => Ok(OperationOutcome::MSG_ID_TOO_LONG(None)),
            "MSG_INVALID_ID" => Ok(OperationOutcome::MSG_INVALID_ID(None)),
            "MSG_JSON_OBJECT" => Ok(OperationOutcome::MSG_JSON_OBJECT(None)),
            "MSG_LOCAL_FAIL" => Ok(OperationOutcome::MSG_LOCAL_FAIL(None)),
            "MSG_NO_EXIST" => Ok(OperationOutcome::MSG_NO_EXIST(None)),
            "MSG_NO_MATCH" => Ok(OperationOutcome::MSG_NO_MATCH(None)),
            "MSG_NO_MODULE" => Ok(OperationOutcome::MSG_NO_MODULE(None)),
            "MSG_NO_SUMMARY" => Ok(OperationOutcome::MSG_NO_SUMMARY(None)),
            "MSG_OP_NOT_ALLOWED" => Ok(OperationOutcome::MSG_OP_NOT_ALLOWED(None)),
            "MSG_PARAM_CHAINED" => Ok(OperationOutcome::MSG_PARAM_CHAINED(None)),
            "MSG_PARAM_INVALID" => Ok(OperationOutcome::MSG_PARAM_INVALID(None)),
            "MSG_PARAM_MODIFIER_INVALID" => Ok(OperationOutcome::MSG_PARAM_MODIFIER_INVALID(None)),
            "MSG_PARAM_NO_REPEAT" => Ok(OperationOutcome::MSG_PARAM_NO_REPEAT(None)),
            "MSG_PARAM_UNKNOWN" => Ok(OperationOutcome::MSG_PARAM_UNKNOWN(None)),
            "MSG_RESOURCE_EXAMPLE_PROTECTED" => {
                Ok(OperationOutcome::MSG_RESOURCE_EXAMPLE_PROTECTED(None))
            }
            "MSG_RESOURCE_ID_FAIL" => Ok(OperationOutcome::MSG_RESOURCE_ID_FAIL(None)),
            "MSG_RESOURCE_ID_MISMATCH" => Ok(OperationOutcome::MSG_RESOURCE_ID_MISMATCH(None)),
            "MSG_RESOURCE_ID_MISSING" => Ok(OperationOutcome::MSG_RESOURCE_ID_MISSING(None)),
            "MSG_RESOURCE_NOT_ALLOWED" => Ok(OperationOutcome::MSG_RESOURCE_NOT_ALLOWED(None)),
            "MSG_RESOURCE_REQUIRED" => Ok(OperationOutcome::MSG_RESOURCE_REQUIRED(None)),
            "MSG_RESOURCE_TYPE_MISMATCH" => Ok(OperationOutcome::MSG_RESOURCE_TYPE_MISMATCH(None)),
            "MSG_SORT_UNKNOWN" => Ok(OperationOutcome::MSG_SORT_UNKNOWN(None)),
            "MSG_TRANSACTION_DUPLICATE_ID" => {
                Ok(OperationOutcome::MSG_TRANSACTION_DUPLICATE_ID(None))
            }
            "MSG_TRANSACTION_MISSING_ID" => Ok(OperationOutcome::MSG_TRANSACTION_MISSING_ID(None)),
            "MSG_UNHANDLED_NODE_TYPE" => Ok(OperationOutcome::MSG_UNHANDLED_NODE_TYPE(None)),
            "MSG_UNKNOWN_CONTENT" => Ok(OperationOutcome::MSG_UNKNOWN_CONTENT(None)),
            "MSG_UNKNOWN_OPERATION" => Ok(OperationOutcome::MSG_UNKNOWN_OPERATION(None)),
            "MSG_UNKNOWN_TYPE" => Ok(OperationOutcome::MSG_UNKNOWN_TYPE(None)),
            "MSG_UPDATED" => Ok(OperationOutcome::MSG_UPDATED(None)),
            "MSG_VERSION_AWARE" => Ok(OperationOutcome::MSG_VERSION_AWARE(None)),
            "MSG_VERSION_AWARE_CONFLICT" => Ok(OperationOutcome::MSG_VERSION_AWARE_CONFLICT(None)),
            "MSG_VERSION_AWARE_URL" => Ok(OperationOutcome::MSG_VERSION_AWARE_URL(None)),
            "MSG_WRONG_NS" => Ok(OperationOutcome::MSG_WRONG_NS(None)),
            "SEARCH_MULTIPLE" => Ok(OperationOutcome::SEARCH_MULTIPLE(None)),
            "SEARCH_NONE" => Ok(OperationOutcome::SEARCH_NONE(None)),
            "UPDATE_MULTIPLE_MATCHES" => Ok(OperationOutcome::UPDATE_MULTIPLE_MATCHES(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OperationOutcome {
    fn into(self) -> Option<String> {
        match self {
            OperationOutcome::DELETE_MULTIPLE_MATCHES(_) => {
                Some("DELETE_MULTIPLE_MATCHES".to_string())
            }
            OperationOutcome::MSG_AUTH_REQUIRED(_) => Some("MSG_AUTH_REQUIRED".to_string()),
            OperationOutcome::MSG_BAD_FORMAT(_) => Some("MSG_BAD_FORMAT".to_string()),
            OperationOutcome::MSG_BAD_SYNTAX(_) => Some("MSG_BAD_SYNTAX".to_string()),
            OperationOutcome::MSG_CANT_PARSE_CONTENT(_) => {
                Some("MSG_CANT_PARSE_CONTENT".to_string())
            }
            OperationOutcome::MSG_CANT_PARSE_ROOT(_) => Some("MSG_CANT_PARSE_ROOT".to_string()),
            OperationOutcome::MSG_CREATED(_) => Some("MSG_CREATED".to_string()),
            OperationOutcome::MSG_DATE_FORMAT(_) => Some("MSG_DATE_FORMAT".to_string()),
            OperationOutcome::MSG_DELETED(_) => Some("MSG_DELETED".to_string()),
            OperationOutcome::MSG_DELETED_DONE(_) => Some("MSG_DELETED_DONE".to_string()),
            OperationOutcome::MSG_DELETED_ID(_) => Some("MSG_DELETED_ID".to_string()),
            OperationOutcome::MSG_DUPLICATE_ID(_) => Some("MSG_DUPLICATE_ID".to_string()),
            OperationOutcome::MSG_ERROR_PARSING(_) => Some("MSG_ERROR_PARSING".to_string()),
            OperationOutcome::MSG_ID_INVALID(_) => Some("MSG_ID_INVALID".to_string()),
            OperationOutcome::MSG_ID_TOO_LONG(_) => Some("MSG_ID_TOO_LONG".to_string()),
            OperationOutcome::MSG_INVALID_ID(_) => Some("MSG_INVALID_ID".to_string()),
            OperationOutcome::MSG_JSON_OBJECT(_) => Some("MSG_JSON_OBJECT".to_string()),
            OperationOutcome::MSG_LOCAL_FAIL(_) => Some("MSG_LOCAL_FAIL".to_string()),
            OperationOutcome::MSG_NO_EXIST(_) => Some("MSG_NO_EXIST".to_string()),
            OperationOutcome::MSG_NO_MATCH(_) => Some("MSG_NO_MATCH".to_string()),
            OperationOutcome::MSG_NO_MODULE(_) => Some("MSG_NO_MODULE".to_string()),
            OperationOutcome::MSG_NO_SUMMARY(_) => Some("MSG_NO_SUMMARY".to_string()),
            OperationOutcome::MSG_OP_NOT_ALLOWED(_) => Some("MSG_OP_NOT_ALLOWED".to_string()),
            OperationOutcome::MSG_PARAM_CHAINED(_) => Some("MSG_PARAM_CHAINED".to_string()),
            OperationOutcome::MSG_PARAM_INVALID(_) => Some("MSG_PARAM_INVALID".to_string()),
            OperationOutcome::MSG_PARAM_MODIFIER_INVALID(_) => {
                Some("MSG_PARAM_MODIFIER_INVALID".to_string())
            }
            OperationOutcome::MSG_PARAM_NO_REPEAT(_) => Some("MSG_PARAM_NO_REPEAT".to_string()),
            OperationOutcome::MSG_PARAM_UNKNOWN(_) => Some("MSG_PARAM_UNKNOWN".to_string()),
            OperationOutcome::MSG_RESOURCE_EXAMPLE_PROTECTED(_) => {
                Some("MSG_RESOURCE_EXAMPLE_PROTECTED".to_string())
            }
            OperationOutcome::MSG_RESOURCE_ID_FAIL(_) => Some("MSG_RESOURCE_ID_FAIL".to_string()),
            OperationOutcome::MSG_RESOURCE_ID_MISMATCH(_) => {
                Some("MSG_RESOURCE_ID_MISMATCH".to_string())
            }
            OperationOutcome::MSG_RESOURCE_ID_MISSING(_) => {
                Some("MSG_RESOURCE_ID_MISSING".to_string())
            }
            OperationOutcome::MSG_RESOURCE_NOT_ALLOWED(_) => {
                Some("MSG_RESOURCE_NOT_ALLOWED".to_string())
            }
            OperationOutcome::MSG_RESOURCE_REQUIRED(_) => Some("MSG_RESOURCE_REQUIRED".to_string()),
            OperationOutcome::MSG_RESOURCE_TYPE_MISMATCH(_) => {
                Some("MSG_RESOURCE_TYPE_MISMATCH".to_string())
            }
            OperationOutcome::MSG_SORT_UNKNOWN(_) => Some("MSG_SORT_UNKNOWN".to_string()),
            OperationOutcome::MSG_TRANSACTION_DUPLICATE_ID(_) => {
                Some("MSG_TRANSACTION_DUPLICATE_ID".to_string())
            }
            OperationOutcome::MSG_TRANSACTION_MISSING_ID(_) => {
                Some("MSG_TRANSACTION_MISSING_ID".to_string())
            }
            OperationOutcome::MSG_UNHANDLED_NODE_TYPE(_) => {
                Some("MSG_UNHANDLED_NODE_TYPE".to_string())
            }
            OperationOutcome::MSG_UNKNOWN_CONTENT(_) => Some("MSG_UNKNOWN_CONTENT".to_string()),
            OperationOutcome::MSG_UNKNOWN_OPERATION(_) => Some("MSG_UNKNOWN_OPERATION".to_string()),
            OperationOutcome::MSG_UNKNOWN_TYPE(_) => Some("MSG_UNKNOWN_TYPE".to_string()),
            OperationOutcome::MSG_UPDATED(_) => Some("MSG_UPDATED".to_string()),
            OperationOutcome::MSG_VERSION_AWARE(_) => Some("MSG_VERSION_AWARE".to_string()),
            OperationOutcome::MSG_VERSION_AWARE_CONFLICT(_) => {
                Some("MSG_VERSION_AWARE_CONFLICT".to_string())
            }
            OperationOutcome::MSG_VERSION_AWARE_URL(_) => Some("MSG_VERSION_AWARE_URL".to_string()),
            OperationOutcome::MSG_WRONG_NS(_) => Some("MSG_WRONG_NS".to_string()),
            OperationOutcome::SEARCH_MULTIPLE(_) => Some("SEARCH_MULTIPLE".to_string()),
            OperationOutcome::SEARCH_NONE(_) => Some("SEARCH_NONE".to_string()),
            OperationOutcome::UPDATE_MULTIPLE_MATCHES(_) => {
                Some("UPDATE_MULTIPLE_MATCHES".to_string())
            }
            OperationOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for OperationOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OperationOutcome::DELETE_MULTIPLE_MATCHES(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_AUTH_REQUIRED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_BAD_FORMAT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_BAD_SYNTAX(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_CANT_PARSE_CONTENT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_CANT_PARSE_ROOT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_CREATED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_DATE_FORMAT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_DELETED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_DELETED_DONE(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_DELETED_ID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_DUPLICATE_ID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_ERROR_PARSING(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_ID_INVALID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_ID_TOO_LONG(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_INVALID_ID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_JSON_OBJECT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_LOCAL_FAIL(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_NO_EXIST(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_NO_MATCH(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_NO_MODULE(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_NO_SUMMARY(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_OP_NOT_ALLOWED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_PARAM_CHAINED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_PARAM_INVALID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_PARAM_MODIFIER_INVALID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_PARAM_NO_REPEAT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_PARAM_UNKNOWN(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_EXAMPLE_PROTECTED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_ID_FAIL(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_ID_MISMATCH(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_ID_MISSING(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_NOT_ALLOWED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_REQUIRED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_RESOURCE_TYPE_MISMATCH(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_SORT_UNKNOWN(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_TRANSACTION_DUPLICATE_ID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_TRANSACTION_MISSING_ID(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_UNHANDLED_NODE_TYPE(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_UNKNOWN_CONTENT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_UNKNOWN_OPERATION(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_UNKNOWN_TYPE(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_UPDATED(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_VERSION_AWARE(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_VERSION_AWARE_CONFLICT(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_VERSION_AWARE_URL(Some(e)) => e.get_field(field),
                OperationOutcome::MSG_WRONG_NS(Some(e)) => e.get_field(field),
                OperationOutcome::SEARCH_MULTIPLE(Some(e)) => e.get_field(field),
                OperationOutcome::SEARCH_NONE(Some(e)) => e.get_field(field),
                OperationOutcome::UPDATE_MULTIPLE_MATCHES(Some(e)) => e.get_field(field),
                OperationOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OperationOutcome::DELETE_MULTIPLE_MATCHES(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_AUTH_REQUIRED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_BAD_FORMAT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_BAD_SYNTAX(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_CANT_PARSE_CONTENT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_CANT_PARSE_ROOT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_CREATED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_DATE_FORMAT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_DELETED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_DELETED_DONE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_DELETED_ID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_DUPLICATE_ID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_ERROR_PARSING(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_ID_INVALID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_ID_TOO_LONG(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_INVALID_ID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_JSON_OBJECT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_LOCAL_FAIL(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_NO_EXIST(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_NO_MATCH(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_NO_MODULE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_NO_SUMMARY(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_OP_NOT_ALLOWED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_PARAM_CHAINED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_PARAM_INVALID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_PARAM_MODIFIER_INVALID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_PARAM_NO_REPEAT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_PARAM_UNKNOWN(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_EXAMPLE_PROTECTED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_ID_FAIL(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_ID_MISMATCH(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_ID_MISSING(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_NOT_ALLOWED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_REQUIRED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_RESOURCE_TYPE_MISMATCH(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_SORT_UNKNOWN(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_TRANSACTION_DUPLICATE_ID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_TRANSACTION_MISSING_ID(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_UNHANDLED_NODE_TYPE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_UNKNOWN_CONTENT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_UNKNOWN_OPERATION(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_UNKNOWN_TYPE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_UPDATED(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_VERSION_AWARE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_VERSION_AWARE_CONFLICT(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_VERSION_AWARE_URL(Some(e)) => e.get_field_mut(field),
                OperationOutcome::MSG_WRONG_NS(Some(e)) => e.get_field_mut(field),
                OperationOutcome::SEARCH_MULTIPLE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::SEARCH_NONE(Some(e)) => e.get_field_mut(field),
                OperationOutcome::UPDATE_MULTIPLE_MATCHES(Some(e)) => e.get_field_mut(field),
                OperationOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OperationParameterUse {
    #[doc = "In"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "Out"]
    #[code = "out"]
    Out(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OperationParameterUse {
    fn default() -> Self {
        OperationParameterUse::Null(None)
    }
}
impl TryFrom<String> for OperationParameterUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "in" => Ok(OperationParameterUse::In(None)),
            "out" => Ok(OperationParameterUse::Out(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OperationParameterUse {
    fn into(self) -> Option<String> {
        match self {
            OperationParameterUse::In(_) => Some("in".to_string()),
            OperationParameterUse::Out(_) => Some("out".to_string()),
            OperationParameterUse::Null(_) => None,
        }
    }
}
impl MetaValue for OperationParameterUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OperationParameterUse::In(Some(e)) => e.get_field(field),
                OperationParameterUse::Out(Some(e)) => e.get_field(field),
                OperationParameterUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OperationParameterUse::In(Some(e)) => e.get_field_mut(field),
                OperationParameterUse::Out(Some(e)) => e.get_field_mut(field),
                OperationParameterUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OralProsthodonticMaterial {
    #[doc = "Fixed Bridge"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Maryland Bridge"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Denture Acrylic"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Denture Chrome Cobalt"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OralProsthodonticMaterial {
    fn default() -> Self {
        OralProsthodonticMaterial::Null(None)
    }
}
impl TryFrom<String> for OralProsthodonticMaterial {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(OralProsthodonticMaterial::V1(None)),
            "2" => Ok(OralProsthodonticMaterial::V2(None)),
            "3" => Ok(OralProsthodonticMaterial::V3(None)),
            "4" => Ok(OralProsthodonticMaterial::V4(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OralProsthodonticMaterial {
    fn into(self) -> Option<String> {
        match self {
            OralProsthodonticMaterial::V1(_) => Some("1".to_string()),
            OralProsthodonticMaterial::V2(_) => Some("2".to_string()),
            OralProsthodonticMaterial::V3(_) => Some("3".to_string()),
            OralProsthodonticMaterial::V4(_) => Some("4".to_string()),
            OralProsthodonticMaterial::Null(_) => None,
        }
    }
}
impl MetaValue for OralProsthodonticMaterial {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OralProsthodonticMaterial::V1(Some(e)) => e.get_field(field),
                OralProsthodonticMaterial::V2(Some(e)) => e.get_field(field),
                OralProsthodonticMaterial::V3(Some(e)) => e.get_field(field),
                OralProsthodonticMaterial::V4(Some(e)) => e.get_field(field),
                OralProsthodonticMaterial::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OralProsthodonticMaterial::V1(Some(e)) => e.get_field_mut(field),
                OralProsthodonticMaterial::V2(Some(e)) => e.get_field_mut(field),
                OralProsthodonticMaterial::V3(Some(e)) => e.get_field_mut(field),
                OralProsthodonticMaterial::V4(Some(e)) => e.get_field_mut(field),
                OralProsthodonticMaterial::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OrganizationRole {
    #[doc = "HIE/HIO"]
    #[code = "HIE/HIO"]
    HIE_HIO(Option<Element>),
    #[doc = "Agency"]
    #[code = "agency"]
    Agency(Option<Element>),
    #[doc = "Diagnostics"]
    #[code = "diagnostics"]
    Diagnostics(Option<Element>),
    #[doc = "Member"]
    #[code = "member"]
    Member(Option<Element>),
    #[doc = "Payer"]
    #[code = "payer"]
    Payer(Option<Element>),
    #[doc = "Provider"]
    #[code = "provider"]
    Provider(Option<Element>),
    #[doc = "Research"]
    #[code = "research"]
    Research(Option<Element>),
    #[doc = "Supplier"]
    #[code = "supplier"]
    Supplier(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OrganizationRole {
    fn default() -> Self {
        OrganizationRole::Null(None)
    }
}
impl TryFrom<String> for OrganizationRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "HIE/HIO" => Ok(OrganizationRole::HIE_HIO(None)),
            "agency" => Ok(OrganizationRole::Agency(None)),
            "diagnostics" => Ok(OrganizationRole::Diagnostics(None)),
            "member" => Ok(OrganizationRole::Member(None)),
            "payer" => Ok(OrganizationRole::Payer(None)),
            "provider" => Ok(OrganizationRole::Provider(None)),
            "research" => Ok(OrganizationRole::Research(None)),
            "supplier" => Ok(OrganizationRole::Supplier(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OrganizationRole {
    fn into(self) -> Option<String> {
        match self {
            OrganizationRole::HIE_HIO(_) => Some("HIE/HIO".to_string()),
            OrganizationRole::Agency(_) => Some("agency".to_string()),
            OrganizationRole::Diagnostics(_) => Some("diagnostics".to_string()),
            OrganizationRole::Member(_) => Some("member".to_string()),
            OrganizationRole::Payer(_) => Some("payer".to_string()),
            OrganizationRole::Provider(_) => Some("provider".to_string()),
            OrganizationRole::Research(_) => Some("research".to_string()),
            OrganizationRole::Supplier(_) => Some("supplier".to_string()),
            OrganizationRole::Null(_) => None,
        }
    }
}
impl MetaValue for OrganizationRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OrganizationRole::HIE_HIO(Some(e)) => e.get_field(field),
                OrganizationRole::Agency(Some(e)) => e.get_field(field),
                OrganizationRole::Diagnostics(Some(e)) => e.get_field(field),
                OrganizationRole::Member(Some(e)) => e.get_field(field),
                OrganizationRole::Payer(Some(e)) => e.get_field(field),
                OrganizationRole::Provider(Some(e)) => e.get_field(field),
                OrganizationRole::Research(Some(e)) => e.get_field(field),
                OrganizationRole::Supplier(Some(e)) => e.get_field(field),
                OrganizationRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OrganizationRole::HIE_HIO(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Agency(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Diagnostics(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Member(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Payer(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Provider(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Research(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Supplier(Some(e)) => e.get_field_mut(field),
                OrganizationRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OrganizationType {
    #[doc = "Non-Healthcare Business or Corporation"]
    #[code = "bus"]
    Bus(Option<Element>),
    #[doc = "Community Group"]
    #[code = "cg"]
    Cg(Option<Element>),
    #[doc = "Clinical Research Sponsor"]
    #[code = "crs"]
    Crs(Option<Element>),
    #[doc = "Hospital Department"]
    #[code = "dept"]
    Dept(Option<Element>),
    #[doc = "Educational Institute"]
    #[code = "edu"]
    Edu(Option<Element>),
    #[doc = "Government"]
    #[code = "govt"]
    Govt(Option<Element>),
    #[doc = "Insurance Company"]
    #[code = "ins"]
    Ins(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Payer"]
    #[code = "pay"]
    Pay(Option<Element>),
    #[doc = "Healthcare Provider"]
    #[code = "prov"]
    Prov(Option<Element>),
    #[doc = "Religious Institution"]
    #[code = "reli"]
    Reli(Option<Element>),
    #[doc = "Organizational team"]
    #[code = "team"]
    Team(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OrganizationType {
    fn default() -> Self {
        OrganizationType::Null(None)
    }
}
impl TryFrom<String> for OrganizationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "bus" => Ok(OrganizationType::Bus(None)),
            "cg" => Ok(OrganizationType::Cg(None)),
            "crs" => Ok(OrganizationType::Crs(None)),
            "dept" => Ok(OrganizationType::Dept(None)),
            "edu" => Ok(OrganizationType::Edu(None)),
            "govt" => Ok(OrganizationType::Govt(None)),
            "ins" => Ok(OrganizationType::Ins(None)),
            "other" => Ok(OrganizationType::Other(None)),
            "pay" => Ok(OrganizationType::Pay(None)),
            "prov" => Ok(OrganizationType::Prov(None)),
            "reli" => Ok(OrganizationType::Reli(None)),
            "team" => Ok(OrganizationType::Team(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OrganizationType {
    fn into(self) -> Option<String> {
        match self {
            OrganizationType::Bus(_) => Some("bus".to_string()),
            OrganizationType::Cg(_) => Some("cg".to_string()),
            OrganizationType::Crs(_) => Some("crs".to_string()),
            OrganizationType::Dept(_) => Some("dept".to_string()),
            OrganizationType::Edu(_) => Some("edu".to_string()),
            OrganizationType::Govt(_) => Some("govt".to_string()),
            OrganizationType::Ins(_) => Some("ins".to_string()),
            OrganizationType::Other(_) => Some("other".to_string()),
            OrganizationType::Pay(_) => Some("pay".to_string()),
            OrganizationType::Prov(_) => Some("prov".to_string()),
            OrganizationType::Reli(_) => Some("reli".to_string()),
            OrganizationType::Team(_) => Some("team".to_string()),
            OrganizationType::Null(_) => None,
        }
    }
}
impl MetaValue for OrganizationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OrganizationType::Bus(Some(e)) => e.get_field(field),
                OrganizationType::Cg(Some(e)) => e.get_field(field),
                OrganizationType::Crs(Some(e)) => e.get_field(field),
                OrganizationType::Dept(Some(e)) => e.get_field(field),
                OrganizationType::Edu(Some(e)) => e.get_field(field),
                OrganizationType::Govt(Some(e)) => e.get_field(field),
                OrganizationType::Ins(Some(e)) => e.get_field(field),
                OrganizationType::Other(Some(e)) => e.get_field(field),
                OrganizationType::Pay(Some(e)) => e.get_field(field),
                OrganizationType::Prov(Some(e)) => e.get_field(field),
                OrganizationType::Reli(Some(e)) => e.get_field(field),
                OrganizationType::Team(Some(e)) => e.get_field(field),
                OrganizationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OrganizationType::Bus(Some(e)) => e.get_field_mut(field),
                OrganizationType::Cg(Some(e)) => e.get_field_mut(field),
                OrganizationType::Crs(Some(e)) => e.get_field_mut(field),
                OrganizationType::Dept(Some(e)) => e.get_field_mut(field),
                OrganizationType::Edu(Some(e)) => e.get_field_mut(field),
                OrganizationType::Govt(Some(e)) => e.get_field_mut(field),
                OrganizationType::Ins(Some(e)) => e.get_field_mut(field),
                OrganizationType::Other(Some(e)) => e.get_field_mut(field),
                OrganizationType::Pay(Some(e)) => e.get_field_mut(field),
                OrganizationType::Prov(Some(e)) => e.get_field_mut(field),
                OrganizationType::Reli(Some(e)) => e.get_field_mut(field),
                OrganizationType::Team(Some(e)) => e.get_field_mut(field),
                OrganizationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum OrientationType {
    #[doc = "Antisense orientation of referenceSeq"]
    #[code = "antisense"]
    Antisense(Option<Element>),
    #[doc = "Sense orientation of referenceSeq"]
    #[code = "sense"]
    Sense(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for OrientationType {
    fn default() -> Self {
        OrientationType::Null(None)
    }
}
impl TryFrom<String> for OrientationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "antisense" => Ok(OrientationType::Antisense(None)),
            "sense" => Ok(OrientationType::Sense(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &OrientationType {
    fn into(self) -> Option<String> {
        match self {
            OrientationType::Antisense(_) => Some("antisense".to_string()),
            OrientationType::Sense(_) => Some("sense".to_string()),
            OrientationType::Null(_) => None,
        }
    }
}
impl MetaValue for OrientationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                OrientationType::Antisense(Some(e)) => e.get_field(field),
                OrientationType::Sense(Some(e)) => e.get_field(field),
                OrientationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                OrientationType::Antisense(Some(e)) => e.get_field_mut(field),
                OrientationType::Sense(Some(e)) => e.get_field_mut(field),
                OrientationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ParameterGroup {
    #[doc = "Blood Chemistry Parameter Group"]
    #[code = "blood-chemistry"]
    BloodChemistry(Option<Element>),
    #[doc = "Drug Delivery Parameter Group"]
    #[code = "drug-delivery"]
    DrugDelivery(Option<Element>),
    #[doc = "ECG Parameter Group"]
    #[code = "ecg"]
    Ecg(Option<Element>),
    #[doc = "Fluid Chemistry Parameter Group"]
    #[code = "fluid-chemistry"]
    FluidChemistry(Option<Element>),
    #[doc = "Haemodynamic Parameter Group"]
    #[code = "haemodynamic"]
    Haemodynamic(Option<Element>),
    #[doc = "Miscellaneous Parameter Group"]
    #[code = "miscellaneous"]
    Miscellaneous(Option<Element>),
    #[doc = "Neurological Parameter Group"]
    #[code = "neurological"]
    Neurological(Option<Element>),
    #[doc = "Respiratory Parameter Group"]
    #[code = "respiratory"]
    Respiratory(Option<Element>),
    #[doc = "Ventilation Parameter Group"]
    #[code = "ventilation"]
    Ventilation(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ParameterGroup {
    fn default() -> Self {
        ParameterGroup::Null(None)
    }
}
impl TryFrom<String> for ParameterGroup {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "blood-chemistry" => Ok(ParameterGroup::BloodChemistry(None)),
            "drug-delivery" => Ok(ParameterGroup::DrugDelivery(None)),
            "ecg" => Ok(ParameterGroup::Ecg(None)),
            "fluid-chemistry" => Ok(ParameterGroup::FluidChemistry(None)),
            "haemodynamic" => Ok(ParameterGroup::Haemodynamic(None)),
            "miscellaneous" => Ok(ParameterGroup::Miscellaneous(None)),
            "neurological" => Ok(ParameterGroup::Neurological(None)),
            "respiratory" => Ok(ParameterGroup::Respiratory(None)),
            "ventilation" => Ok(ParameterGroup::Ventilation(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ParameterGroup {
    fn into(self) -> Option<String> {
        match self {
            ParameterGroup::BloodChemistry(_) => Some("blood-chemistry".to_string()),
            ParameterGroup::DrugDelivery(_) => Some("drug-delivery".to_string()),
            ParameterGroup::Ecg(_) => Some("ecg".to_string()),
            ParameterGroup::FluidChemistry(_) => Some("fluid-chemistry".to_string()),
            ParameterGroup::Haemodynamic(_) => Some("haemodynamic".to_string()),
            ParameterGroup::Miscellaneous(_) => Some("miscellaneous".to_string()),
            ParameterGroup::Neurological(_) => Some("neurological".to_string()),
            ParameterGroup::Respiratory(_) => Some("respiratory".to_string()),
            ParameterGroup::Ventilation(_) => Some("ventilation".to_string()),
            ParameterGroup::Null(_) => None,
        }
    }
}
impl MetaValue for ParameterGroup {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ParameterGroup::BloodChemistry(Some(e)) => e.get_field(field),
                ParameterGroup::DrugDelivery(Some(e)) => e.get_field(field),
                ParameterGroup::Ecg(Some(e)) => e.get_field(field),
                ParameterGroup::FluidChemistry(Some(e)) => e.get_field(field),
                ParameterGroup::Haemodynamic(Some(e)) => e.get_field(field),
                ParameterGroup::Miscellaneous(Some(e)) => e.get_field(field),
                ParameterGroup::Neurological(Some(e)) => e.get_field(field),
                ParameterGroup::Respiratory(Some(e)) => e.get_field(field),
                ParameterGroup::Ventilation(Some(e)) => e.get_field(field),
                ParameterGroup::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ParameterGroup::BloodChemistry(Some(e)) => e.get_field_mut(field),
                ParameterGroup::DrugDelivery(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Ecg(Some(e)) => e.get_field_mut(field),
                ParameterGroup::FluidChemistry(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Haemodynamic(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Miscellaneous(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Neurological(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Respiratory(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Ventilation(Some(e)) => e.get_field_mut(field),
                ParameterGroup::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Participantrequired {
    #[doc = "Information Only"]
    #[code = "information-only"]
    InformationOnly(Option<Element>),
    #[doc = "Optional"]
    #[code = "optional"]
    Optional(Option<Element>),
    #[doc = "Required"]
    #[code = "required"]
    Required(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Participantrequired {
    fn default() -> Self {
        Participantrequired::Null(None)
    }
}
impl TryFrom<String> for Participantrequired {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "information-only" => Ok(Participantrequired::InformationOnly(None)),
            "optional" => Ok(Participantrequired::Optional(None)),
            "required" => Ok(Participantrequired::Required(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Participantrequired {
    fn into(self) -> Option<String> {
        match self {
            Participantrequired::InformationOnly(_) => Some("information-only".to_string()),
            Participantrequired::Optional(_) => Some("optional".to_string()),
            Participantrequired::Required(_) => Some("required".to_string()),
            Participantrequired::Null(_) => None,
        }
    }
}
impl MetaValue for Participantrequired {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Participantrequired::InformationOnly(Some(e)) => e.get_field(field),
                Participantrequired::Optional(Some(e)) => e.get_field(field),
                Participantrequired::Required(Some(e)) => e.get_field(field),
                Participantrequired::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Participantrequired::InformationOnly(Some(e)) => e.get_field_mut(field),
                Participantrequired::Optional(Some(e)) => e.get_field_mut(field),
                Participantrequired::Required(Some(e)) => e.get_field_mut(field),
                Participantrequired::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Participationstatus {
    #[doc = "Accepted"]
    #[code = "accepted"]
    Accepted(Option<Element>),
    #[doc = "Declined"]
    #[code = "declined"]
    Declined(Option<Element>),
    #[doc = "Needs Action"]
    #[code = "needs-action"]
    NeedsAction(Option<Element>),
    #[doc = "Tentative"]
    #[code = "tentative"]
    Tentative(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Participationstatus {
    fn default() -> Self {
        Participationstatus::Null(None)
    }
}
impl TryFrom<String> for Participationstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "accepted" => Ok(Participationstatus::Accepted(None)),
            "declined" => Ok(Participationstatus::Declined(None)),
            "needs-action" => Ok(Participationstatus::NeedsAction(None)),
            "tentative" => Ok(Participationstatus::Tentative(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Participationstatus {
    fn into(self) -> Option<String> {
        match self {
            Participationstatus::Accepted(_) => Some("accepted".to_string()),
            Participationstatus::Declined(_) => Some("declined".to_string()),
            Participationstatus::NeedsAction(_) => Some("needs-action".to_string()),
            Participationstatus::Tentative(_) => Some("tentative".to_string()),
            Participationstatus::Null(_) => None,
        }
    }
}
impl MetaValue for Participationstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Participationstatus::Accepted(Some(e)) => e.get_field(field),
                Participationstatus::Declined(Some(e)) => e.get_field(field),
                Participationstatus::NeedsAction(Some(e)) => e.get_field(field),
                Participationstatus::Tentative(Some(e)) => e.get_field(field),
                Participationstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Participationstatus::Accepted(Some(e)) => e.get_field_mut(field),
                Participationstatus::Declined(Some(e)) => e.get_field_mut(field),
                Participationstatus::NeedsAction(Some(e)) => e.get_field_mut(field),
                Participationstatus::Tentative(Some(e)) => e.get_field_mut(field),
                Participationstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Payeetype {
    #[doc = "Provider"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Provider"]
    #[code = "provider"]
    Provider(Option<Element>),
    #[doc = "Subscriber"]
    #[code = "subscriber"]
    Subscriber(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Payeetype {
    fn default() -> Self {
        Payeetype::Null(None)
    }
}
impl TryFrom<String> for Payeetype {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "other" => Ok(Payeetype::Other(None)),
            "provider" => Ok(Payeetype::Provider(None)),
            "subscriber" => Ok(Payeetype::Subscriber(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Payeetype {
    fn into(self) -> Option<String> {
        match self {
            Payeetype::Other(_) => Some("other".to_string()),
            Payeetype::Provider(_) => Some("provider".to_string()),
            Payeetype::Subscriber(_) => Some("subscriber".to_string()),
            Payeetype::Null(_) => None,
        }
    }
}
impl MetaValue for Payeetype {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Payeetype::Other(Some(e)) => e.get_field(field),
                Payeetype::Provider(Some(e)) => e.get_field(field),
                Payeetype::Subscriber(Some(e)) => e.get_field(field),
                Payeetype::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Payeetype::Other(Some(e)) => e.get_field_mut(field),
                Payeetype::Provider(Some(e)) => e.get_field_mut(field),
                Payeetype::Subscriber(Some(e)) => e.get_field_mut(field),
                Payeetype::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PaymentAdjustmentReason {
    #[doc = "Prior Payment Reversal"]
    #[code = "a001"]
    A001(Option<Element>),
    #[doc = "Prior Overpayment"]
    #[code = "a002"]
    A002(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PaymentAdjustmentReason {
    fn default() -> Self {
        PaymentAdjustmentReason::Null(None)
    }
}
impl TryFrom<String> for PaymentAdjustmentReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a001" => Ok(PaymentAdjustmentReason::A001(None)),
            "a002" => Ok(PaymentAdjustmentReason::A002(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PaymentAdjustmentReason {
    fn into(self) -> Option<String> {
        match self {
            PaymentAdjustmentReason::A001(_) => Some("a001".to_string()),
            PaymentAdjustmentReason::A002(_) => Some("a002".to_string()),
            PaymentAdjustmentReason::Null(_) => None,
        }
    }
}
impl MetaValue for PaymentAdjustmentReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PaymentAdjustmentReason::A001(Some(e)) => e.get_field(field),
                PaymentAdjustmentReason::A002(Some(e)) => e.get_field(field),
                PaymentAdjustmentReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PaymentAdjustmentReason::A001(Some(e)) => e.get_field_mut(field),
                PaymentAdjustmentReason::A002(Some(e)) => e.get_field_mut(field),
                PaymentAdjustmentReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PaymentStatus {
    #[doc = "Cleared"]
    #[code = "cleared"]
    Cleared(Option<Element>),
    #[doc = "Paid"]
    #[code = "paid"]
    Paid(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PaymentStatus {
    fn default() -> Self {
        PaymentStatus::Null(None)
    }
}
impl TryFrom<String> for PaymentStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cleared" => Ok(PaymentStatus::Cleared(None)),
            "paid" => Ok(PaymentStatus::Paid(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PaymentStatus {
    fn into(self) -> Option<String> {
        match self {
            PaymentStatus::Cleared(_) => Some("cleared".to_string()),
            PaymentStatus::Paid(_) => Some("paid".to_string()),
            PaymentStatus::Null(_) => None,
        }
    }
}
impl MetaValue for PaymentStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PaymentStatus::Cleared(Some(e)) => e.get_field(field),
                PaymentStatus::Paid(Some(e)) => e.get_field(field),
                PaymentStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PaymentStatus::Cleared(Some(e)) => e.get_field_mut(field),
                PaymentStatus::Paid(Some(e)) => e.get_field_mut(field),
                PaymentStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PaymentType {
    #[doc = "Adjustment"]
    #[code = "adjustment"]
    Adjustment(Option<Element>),
    #[doc = "Advance"]
    #[code = "advance"]
    Advance(Option<Element>),
    #[doc = "Payment"]
    #[code = "payment"]
    Payment(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PaymentType {
    fn default() -> Self {
        PaymentType::Null(None)
    }
}
impl TryFrom<String> for PaymentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "adjustment" => Ok(PaymentType::Adjustment(None)),
            "advance" => Ok(PaymentType::Advance(None)),
            "payment" => Ok(PaymentType::Payment(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PaymentType {
    fn into(self) -> Option<String> {
        match self {
            PaymentType::Adjustment(_) => Some("adjustment".to_string()),
            PaymentType::Advance(_) => Some("advance".to_string()),
            PaymentType::Payment(_) => Some("payment".to_string()),
            PaymentType::Null(_) => None,
        }
    }
}
impl MetaValue for PaymentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PaymentType::Adjustment(Some(e)) => e.get_field(field),
                PaymentType::Advance(Some(e)) => e.get_field(field),
                PaymentType::Payment(Some(e)) => e.get_field(field),
                PaymentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PaymentType::Adjustment(Some(e)) => e.get_field_mut(field),
                PaymentType::Advance(Some(e)) => e.get_field_mut(field),
                PaymentType::Payment(Some(e)) => e.get_field_mut(field),
                PaymentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PerformerFunction {
    #[code = "ATND"]
    ATND(Option<Element>),
    #[code = "AUT"]
    AUT(Option<Element>),
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[code = "CON"]
    CON(Option<Element>),
    #[code = "ENT"]
    ENT(Option<Element>),
    #[code = "INF"]
    INF(Option<Element>),
    #[code = "LA"]
    LA(Option<Element>),
    #[code = "PART"]
    PART(Option<Element>),
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[code = "RESP"]
    RESP(Option<Element>),
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[code = "VRF"]
    VRF(Option<Element>),
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PerformerFunction {
    fn default() -> Self {
        PerformerFunction::Null(None)
    }
}
impl TryFrom<String> for PerformerFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ATND" => Ok(PerformerFunction::ATND(None)),
            "AUT" => Ok(PerformerFunction::AUT(None)),
            "AUTHEN" => Ok(PerformerFunction::AUTHEN(None)),
            "CON" => Ok(PerformerFunction::CON(None)),
            "ENT" => Ok(PerformerFunction::ENT(None)),
            "INF" => Ok(PerformerFunction::INF(None)),
            "LA" => Ok(PerformerFunction::LA(None)),
            "PART" => Ok(PerformerFunction::PART(None)),
            "PPRF" => Ok(PerformerFunction::PPRF(None)),
            "RESP" => Ok(PerformerFunction::RESP(None)),
            "SPRF" => Ok(PerformerFunction::SPRF(None)),
            "TRANS" => Ok(PerformerFunction::TRANS(None)),
            "VRF" => Ok(PerformerFunction::VRF(None)),
            "WIT" => Ok(PerformerFunction::WIT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PerformerFunction {
    fn into(self) -> Option<String> {
        match self {
            PerformerFunction::ATND(_) => Some("ATND".to_string()),
            PerformerFunction::AUT(_) => Some("AUT".to_string()),
            PerformerFunction::AUTHEN(_) => Some("AUTHEN".to_string()),
            PerformerFunction::CON(_) => Some("CON".to_string()),
            PerformerFunction::ENT(_) => Some("ENT".to_string()),
            PerformerFunction::INF(_) => Some("INF".to_string()),
            PerformerFunction::LA(_) => Some("LA".to_string()),
            PerformerFunction::PART(_) => Some("PART".to_string()),
            PerformerFunction::PPRF(_) => Some("PPRF".to_string()),
            PerformerFunction::RESP(_) => Some("RESP".to_string()),
            PerformerFunction::SPRF(_) => Some("SPRF".to_string()),
            PerformerFunction::TRANS(_) => Some("TRANS".to_string()),
            PerformerFunction::VRF(_) => Some("VRF".to_string()),
            PerformerFunction::WIT(_) => Some("WIT".to_string()),
            PerformerFunction::Null(_) => None,
        }
    }
}
impl MetaValue for PerformerFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PerformerFunction::ATND(Some(e)) => e.get_field(field),
                PerformerFunction::AUT(Some(e)) => e.get_field(field),
                PerformerFunction::AUTHEN(Some(e)) => e.get_field(field),
                PerformerFunction::CON(Some(e)) => e.get_field(field),
                PerformerFunction::ENT(Some(e)) => e.get_field(field),
                PerformerFunction::INF(Some(e)) => e.get_field(field),
                PerformerFunction::LA(Some(e)) => e.get_field(field),
                PerformerFunction::PART(Some(e)) => e.get_field(field),
                PerformerFunction::PPRF(Some(e)) => e.get_field(field),
                PerformerFunction::RESP(Some(e)) => e.get_field(field),
                PerformerFunction::SPRF(Some(e)) => e.get_field(field),
                PerformerFunction::TRANS(Some(e)) => e.get_field(field),
                PerformerFunction::VRF(Some(e)) => e.get_field(field),
                PerformerFunction::WIT(Some(e)) => e.get_field(field),
                PerformerFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PerformerFunction::ATND(Some(e)) => e.get_field_mut(field),
                PerformerFunction::AUT(Some(e)) => e.get_field_mut(field),
                PerformerFunction::AUTHEN(Some(e)) => e.get_field_mut(field),
                PerformerFunction::CON(Some(e)) => e.get_field_mut(field),
                PerformerFunction::ENT(Some(e)) => e.get_field_mut(field),
                PerformerFunction::INF(Some(e)) => e.get_field_mut(field),
                PerformerFunction::LA(Some(e)) => e.get_field_mut(field),
                PerformerFunction::PART(Some(e)) => e.get_field_mut(field),
                PerformerFunction::PPRF(Some(e)) => e.get_field_mut(field),
                PerformerFunction::RESP(Some(e)) => e.get_field_mut(field),
                PerformerFunction::SPRF(Some(e)) => e.get_field_mut(field),
                PerformerFunction::TRANS(Some(e)) => e.get_field_mut(field),
                PerformerFunction::VRF(Some(e)) => e.get_field_mut(field),
                PerformerFunction::WIT(Some(e)) => e.get_field_mut(field),
                PerformerFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PermittedDataType {
    #[doc = "CodeableConcept"]
    #[code = "CodeableConcept"]
    CodeableConcept(Option<Element>),
    #[doc = "Period"]
    #[code = "Period"]
    Period(Option<Element>),
    #[doc = "Quantity"]
    #[code = "Quantity"]
    Quantity(Option<Element>),
    #[doc = "Range"]
    #[code = "Range"]
    Range(Option<Element>),
    #[doc = "Ratio"]
    #[code = "Ratio"]
    Ratio(Option<Element>),
    #[doc = "SampledData"]
    #[code = "SampledData"]
    SampledData(Option<Element>),
    #[doc = "boolean"]
    #[code = "boolean"]
    Boolean(Option<Element>),
    #[doc = "dateTime"]
    #[code = "dateTime"]
    DateTime(Option<Element>),
    #[doc = "integer"]
    #[code = "integer"]
    Integer(Option<Element>),
    #[doc = "string"]
    #[code = "string"]
    String(Option<Element>),
    #[doc = "time"]
    #[code = "time"]
    Time(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PermittedDataType {
    fn default() -> Self {
        PermittedDataType::Null(None)
    }
}
impl TryFrom<String> for PermittedDataType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CodeableConcept" => Ok(PermittedDataType::CodeableConcept(None)),
            "Period" => Ok(PermittedDataType::Period(None)),
            "Quantity" => Ok(PermittedDataType::Quantity(None)),
            "Range" => Ok(PermittedDataType::Range(None)),
            "Ratio" => Ok(PermittedDataType::Ratio(None)),
            "SampledData" => Ok(PermittedDataType::SampledData(None)),
            "boolean" => Ok(PermittedDataType::Boolean(None)),
            "dateTime" => Ok(PermittedDataType::DateTime(None)),
            "integer" => Ok(PermittedDataType::Integer(None)),
            "string" => Ok(PermittedDataType::String(None)),
            "time" => Ok(PermittedDataType::Time(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PermittedDataType {
    fn into(self) -> Option<String> {
        match self {
            PermittedDataType::CodeableConcept(_) => Some("CodeableConcept".to_string()),
            PermittedDataType::Period(_) => Some("Period".to_string()),
            PermittedDataType::Quantity(_) => Some("Quantity".to_string()),
            PermittedDataType::Range(_) => Some("Range".to_string()),
            PermittedDataType::Ratio(_) => Some("Ratio".to_string()),
            PermittedDataType::SampledData(_) => Some("SampledData".to_string()),
            PermittedDataType::Boolean(_) => Some("boolean".to_string()),
            PermittedDataType::DateTime(_) => Some("dateTime".to_string()),
            PermittedDataType::Integer(_) => Some("integer".to_string()),
            PermittedDataType::String(_) => Some("string".to_string()),
            PermittedDataType::Time(_) => Some("time".to_string()),
            PermittedDataType::Null(_) => None,
        }
    }
}
impl MetaValue for PermittedDataType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PermittedDataType::CodeableConcept(Some(e)) => e.get_field(field),
                PermittedDataType::Period(Some(e)) => e.get_field(field),
                PermittedDataType::Quantity(Some(e)) => e.get_field(field),
                PermittedDataType::Range(Some(e)) => e.get_field(field),
                PermittedDataType::Ratio(Some(e)) => e.get_field(field),
                PermittedDataType::SampledData(Some(e)) => e.get_field(field),
                PermittedDataType::Boolean(Some(e)) => e.get_field(field),
                PermittedDataType::DateTime(Some(e)) => e.get_field(field),
                PermittedDataType::Integer(Some(e)) => e.get_field(field),
                PermittedDataType::String(Some(e)) => e.get_field(field),
                PermittedDataType::Time(Some(e)) => e.get_field(field),
                PermittedDataType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PermittedDataType::CodeableConcept(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Period(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Quantity(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Range(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Ratio(Some(e)) => e.get_field_mut(field),
                PermittedDataType::SampledData(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Boolean(Some(e)) => e.get_field_mut(field),
                PermittedDataType::DateTime(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Integer(Some(e)) => e.get_field_mut(field),
                PermittedDataType::String(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Time(Some(e)) => e.get_field_mut(field),
                PermittedDataType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PlanDefinitionType {
    #[doc = "Clinical Protocol"]
    #[code = "clinical-protocol"]
    ClinicalProtocol(Option<Element>),
    #[doc = "ECA Rule"]
    #[code = "eca-rule"]
    EcaRule(Option<Element>),
    #[doc = "Order Set"]
    #[code = "order-set"]
    OrderSet(Option<Element>),
    #[doc = "Workflow Definition"]
    #[code = "workflow-definition"]
    WorkflowDefinition(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PlanDefinitionType {
    fn default() -> Self {
        PlanDefinitionType::Null(None)
    }
}
impl TryFrom<String> for PlanDefinitionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "clinical-protocol" => Ok(PlanDefinitionType::ClinicalProtocol(None)),
            "eca-rule" => Ok(PlanDefinitionType::EcaRule(None)),
            "order-set" => Ok(PlanDefinitionType::OrderSet(None)),
            "workflow-definition" => Ok(PlanDefinitionType::WorkflowDefinition(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PlanDefinitionType {
    fn into(self) -> Option<String> {
        match self {
            PlanDefinitionType::ClinicalProtocol(_) => Some("clinical-protocol".to_string()),
            PlanDefinitionType::EcaRule(_) => Some("eca-rule".to_string()),
            PlanDefinitionType::OrderSet(_) => Some("order-set".to_string()),
            PlanDefinitionType::WorkflowDefinition(_) => Some("workflow-definition".to_string()),
            PlanDefinitionType::Null(_) => None,
        }
    }
}
impl MetaValue for PlanDefinitionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PlanDefinitionType::ClinicalProtocol(Some(e)) => e.get_field(field),
                PlanDefinitionType::EcaRule(Some(e)) => e.get_field(field),
                PlanDefinitionType::OrderSet(Some(e)) => e.get_field(field),
                PlanDefinitionType::WorkflowDefinition(Some(e)) => e.get_field(field),
                PlanDefinitionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PlanDefinitionType::ClinicalProtocol(Some(e)) => e.get_field_mut(field),
                PlanDefinitionType::EcaRule(Some(e)) => e.get_field_mut(field),
                PlanDefinitionType::OrderSet(Some(e)) => e.get_field_mut(field),
                PlanDefinitionType::WorkflowDefinition(Some(e)) => e.get_field_mut(field),
                PlanDefinitionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PostalAddressUse {
    #[doc = "bad address"]
    #[code = "BAD"]
    BAD(Option<Element>),
    #[doc = "confidential address"]
    #[code = "CONF"]
    CONF(Option<Element>),
    #[doc = "direct"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "primary home"]
    #[code = "HP"]
    HP(Option<Element>),
    #[doc = "vacation home"]
    #[code = "HV"]
    HV(Option<Element>),
    #[doc = "physical visit address"]
    #[code = "PHYS"]
    PHYS(Option<Element>),
    #[doc = "postal address"]
    #[code = "PST"]
    PST(Option<Element>),
    #[doc = "public"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PostalAddressUse {
    fn default() -> Self {
        PostalAddressUse::Null(None)
    }
}
impl TryFrom<String> for PostalAddressUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BAD" => Ok(PostalAddressUse::BAD(None)),
            "CONF" => Ok(PostalAddressUse::CONF(None)),
            "DIR" => Ok(PostalAddressUse::DIR(None)),
            "HP" => Ok(PostalAddressUse::HP(None)),
            "HV" => Ok(PostalAddressUse::HV(None)),
            "PHYS" => Ok(PostalAddressUse::PHYS(None)),
            "PST" => Ok(PostalAddressUse::PST(None)),
            "PUB" => Ok(PostalAddressUse::PUB(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PostalAddressUse {
    fn into(self) -> Option<String> {
        match self {
            PostalAddressUse::BAD(_) => Some("BAD".to_string()),
            PostalAddressUse::CONF(_) => Some("CONF".to_string()),
            PostalAddressUse::DIR(_) => Some("DIR".to_string()),
            PostalAddressUse::HP(_) => Some("HP".to_string()),
            PostalAddressUse::HV(_) => Some("HV".to_string()),
            PostalAddressUse::PHYS(_) => Some("PHYS".to_string()),
            PostalAddressUse::PST(_) => Some("PST".to_string()),
            PostalAddressUse::PUB(_) => Some("PUB".to_string()),
            PostalAddressUse::Null(_) => None,
        }
    }
}
impl MetaValue for PostalAddressUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PostalAddressUse::BAD(Some(e)) => e.get_field(field),
                PostalAddressUse::CONF(Some(e)) => e.get_field(field),
                PostalAddressUse::DIR(Some(e)) => e.get_field(field),
                PostalAddressUse::HP(Some(e)) => e.get_field(field),
                PostalAddressUse::HV(Some(e)) => e.get_field(field),
                PostalAddressUse::PHYS(Some(e)) => e.get_field(field),
                PostalAddressUse::PST(Some(e)) => e.get_field(field),
                PostalAddressUse::PUB(Some(e)) => e.get_field(field),
                PostalAddressUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PostalAddressUse::BAD(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::CONF(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::DIR(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::HP(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::HV(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::PHYS(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::PST(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::PUB(Some(e)) => e.get_field_mut(field),
                PostalAddressUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PractitionerSpecialty {
    #[doc = "Cardiologist"]
    #[code = "cardio"]
    Cardio(Option<Element>),
    #[doc = "Dentist"]
    #[code = "dent"]
    Dent(Option<Element>),
    #[doc = "Dietary consultant"]
    #[code = "dietary"]
    Dietary(Option<Element>),
    #[doc = "Midwife"]
    #[code = "midw"]
    Midw(Option<Element>),
    #[doc = "Systems architect"]
    #[code = "sysarch"]
    Sysarch(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PractitionerSpecialty {
    fn default() -> Self {
        PractitionerSpecialty::Null(None)
    }
}
impl TryFrom<String> for PractitionerSpecialty {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cardio" => Ok(PractitionerSpecialty::Cardio(None)),
            "dent" => Ok(PractitionerSpecialty::Dent(None)),
            "dietary" => Ok(PractitionerSpecialty::Dietary(None)),
            "midw" => Ok(PractitionerSpecialty::Midw(None)),
            "sysarch" => Ok(PractitionerSpecialty::Sysarch(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PractitionerSpecialty {
    fn into(self) -> Option<String> {
        match self {
            PractitionerSpecialty::Cardio(_) => Some("cardio".to_string()),
            PractitionerSpecialty::Dent(_) => Some("dent".to_string()),
            PractitionerSpecialty::Dietary(_) => Some("dietary".to_string()),
            PractitionerSpecialty::Midw(_) => Some("midw".to_string()),
            PractitionerSpecialty::Sysarch(_) => Some("sysarch".to_string()),
            PractitionerSpecialty::Null(_) => None,
        }
    }
}
impl MetaValue for PractitionerSpecialty {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PractitionerSpecialty::Cardio(Some(e)) => e.get_field(field),
                PractitionerSpecialty::Dent(Some(e)) => e.get_field(field),
                PractitionerSpecialty::Dietary(Some(e)) => e.get_field(field),
                PractitionerSpecialty::Midw(Some(e)) => e.get_field(field),
                PractitionerSpecialty::Sysarch(Some(e)) => e.get_field(field),
                PractitionerSpecialty::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PractitionerSpecialty::Cardio(Some(e)) => e.get_field_mut(field),
                PractitionerSpecialty::Dent(Some(e)) => e.get_field_mut(field),
                PractitionerSpecialty::Dietary(Some(e)) => e.get_field_mut(field),
                PractitionerSpecialty::Midw(Some(e)) => e.get_field_mut(field),
                PractitionerSpecialty::Sysarch(Some(e)) => e.get_field_mut(field),
                PractitionerSpecialty::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PrecisionEstimateType {
    #[doc = "confidence interval"]
    #[code = "CI"]
    CI(Option<Element>),
    #[doc = "interquartile range"]
    #[code = "IQR"]
    IQR(Option<Element>),
    #[doc = "standard deviation"]
    #[code = "SD"]
    SD(Option<Element>),
    #[doc = "standard error"]
    #[code = "SE"]
    SE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PrecisionEstimateType {
    fn default() -> Self {
        PrecisionEstimateType::Null(None)
    }
}
impl TryFrom<String> for PrecisionEstimateType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CI" => Ok(PrecisionEstimateType::CI(None)),
            "IQR" => Ok(PrecisionEstimateType::IQR(None)),
            "SD" => Ok(PrecisionEstimateType::SD(None)),
            "SE" => Ok(PrecisionEstimateType::SE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PrecisionEstimateType {
    fn into(self) -> Option<String> {
        match self {
            PrecisionEstimateType::CI(_) => Some("CI".to_string()),
            PrecisionEstimateType::IQR(_) => Some("IQR".to_string()),
            PrecisionEstimateType::SD(_) => Some("SD".to_string()),
            PrecisionEstimateType::SE(_) => Some("SE".to_string()),
            PrecisionEstimateType::Null(_) => None,
        }
    }
}
impl MetaValue for PrecisionEstimateType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PrecisionEstimateType::CI(Some(e)) => e.get_field(field),
                PrecisionEstimateType::IQR(Some(e)) => e.get_field(field),
                PrecisionEstimateType::SD(Some(e)) => e.get_field(field),
                PrecisionEstimateType::SE(Some(e)) => e.get_field(field),
                PrecisionEstimateType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PrecisionEstimateType::CI(Some(e)) => e.get_field_mut(field),
                PrecisionEstimateType::IQR(Some(e)) => e.get_field_mut(field),
                PrecisionEstimateType::SD(Some(e)) => e.get_field_mut(field),
                PrecisionEstimateType::SE(Some(e)) => e.get_field_mut(field),
                PrecisionEstimateType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProbabilityDistributionType {
    #[doc = "beta"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "exponential"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "F"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "(gamma)"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "log-normal"]
    #[code = "LN"]
    LN(Option<Element>),
    #[doc = "normal (Gaussian)"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "T"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "uniform"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "chi square"]
    #[code = "X2"]
    X2(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProbabilityDistributionType {
    fn default() -> Self {
        ProbabilityDistributionType::Null(None)
    }
}
impl TryFrom<String> for ProbabilityDistributionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(ProbabilityDistributionType::B(None)),
            "E" => Ok(ProbabilityDistributionType::E(None)),
            "F" => Ok(ProbabilityDistributionType::F(None)),
            "G" => Ok(ProbabilityDistributionType::G(None)),
            "LN" => Ok(ProbabilityDistributionType::LN(None)),
            "N" => Ok(ProbabilityDistributionType::N(None)),
            "T" => Ok(ProbabilityDistributionType::T(None)),
            "U" => Ok(ProbabilityDistributionType::U(None)),
            "X2" => Ok(ProbabilityDistributionType::X2(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProbabilityDistributionType {
    fn into(self) -> Option<String> {
        match self {
            ProbabilityDistributionType::B(_) => Some("B".to_string()),
            ProbabilityDistributionType::E(_) => Some("E".to_string()),
            ProbabilityDistributionType::F(_) => Some("F".to_string()),
            ProbabilityDistributionType::G(_) => Some("G".to_string()),
            ProbabilityDistributionType::LN(_) => Some("LN".to_string()),
            ProbabilityDistributionType::N(_) => Some("N".to_string()),
            ProbabilityDistributionType::T(_) => Some("T".to_string()),
            ProbabilityDistributionType::U(_) => Some("U".to_string()),
            ProbabilityDistributionType::X2(_) => Some("X2".to_string()),
            ProbabilityDistributionType::Null(_) => None,
        }
    }
}
impl MetaValue for ProbabilityDistributionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProbabilityDistributionType::B(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::E(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::F(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::G(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::LN(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::N(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::T(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::U(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::X2(Some(e)) => e.get_field(field),
                ProbabilityDistributionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProbabilityDistributionType::B(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::E(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::F(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::G(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::LN(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::N(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::T(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::U(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::X2(Some(e)) => e.get_field_mut(field),
                ProbabilityDistributionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProcedureCategory {
    #[code = "103693007"]
    V103693007(Option<Element>),
    #[code = "24642003"]
    V24642003(Option<Element>),
    #[code = "387713003"]
    V387713003(Option<Element>),
    #[code = "409063005"]
    V409063005(Option<Element>),
    #[code = "409073007"]
    V409073007(Option<Element>),
    #[code = "410606002"]
    V410606002(Option<Element>),
    #[code = "46947000"]
    V46947000(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProcedureCategory {
    fn default() -> Self {
        ProcedureCategory::Null(None)
    }
}
impl TryFrom<String> for ProcedureCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "103693007" => Ok(ProcedureCategory::V103693007(None)),
            "24642003" => Ok(ProcedureCategory::V24642003(None)),
            "387713003" => Ok(ProcedureCategory::V387713003(None)),
            "409063005" => Ok(ProcedureCategory::V409063005(None)),
            "409073007" => Ok(ProcedureCategory::V409073007(None)),
            "410606002" => Ok(ProcedureCategory::V410606002(None)),
            "46947000" => Ok(ProcedureCategory::V46947000(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProcedureCategory {
    fn into(self) -> Option<String> {
        match self {
            ProcedureCategory::V103693007(_) => Some("103693007".to_string()),
            ProcedureCategory::V24642003(_) => Some("24642003".to_string()),
            ProcedureCategory::V387713003(_) => Some("387713003".to_string()),
            ProcedureCategory::V409063005(_) => Some("409063005".to_string()),
            ProcedureCategory::V409073007(_) => Some("409073007".to_string()),
            ProcedureCategory::V410606002(_) => Some("410606002".to_string()),
            ProcedureCategory::V46947000(_) => Some("46947000".to_string()),
            ProcedureCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ProcedureCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProcedureCategory::V103693007(Some(e)) => e.get_field(field),
                ProcedureCategory::V24642003(Some(e)) => e.get_field(field),
                ProcedureCategory::V387713003(Some(e)) => e.get_field(field),
                ProcedureCategory::V409063005(Some(e)) => e.get_field(field),
                ProcedureCategory::V409073007(Some(e)) => e.get_field(field),
                ProcedureCategory::V410606002(Some(e)) => e.get_field(field),
                ProcedureCategory::V46947000(Some(e)) => e.get_field(field),
                ProcedureCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProcedureCategory::V103693007(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V24642003(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V387713003(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V409063005(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V409073007(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V410606002(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::V46947000(Some(e)) => e.get_field_mut(field),
                ProcedureCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProcedureFollowup {
    #[code = "18949003"]
    V18949003(Option<Element>),
    #[code = "225164002"]
    V225164002(Option<Element>),
    #[code = "229506003"]
    V229506003(Option<Element>),
    #[code = "241031001"]
    V241031001(Option<Element>),
    #[code = "274441001"]
    V274441001(Option<Element>),
    #[code = "30549001"]
    V30549001(Option<Element>),
    #[code = "35963001"]
    V35963001(Option<Element>),
    #[code = "359825008"]
    V359825008(Option<Element>),
    #[code = "394725008"]
    V394725008(Option<Element>),
    #[code = "447346005"]
    V447346005(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProcedureFollowup {
    fn default() -> Self {
        ProcedureFollowup::Null(None)
    }
}
impl TryFrom<String> for ProcedureFollowup {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "18949003" => Ok(ProcedureFollowup::V18949003(None)),
            "225164002" => Ok(ProcedureFollowup::V225164002(None)),
            "229506003" => Ok(ProcedureFollowup::V229506003(None)),
            "241031001" => Ok(ProcedureFollowup::V241031001(None)),
            "274441001" => Ok(ProcedureFollowup::V274441001(None)),
            "30549001" => Ok(ProcedureFollowup::V30549001(None)),
            "35963001" => Ok(ProcedureFollowup::V35963001(None)),
            "359825008" => Ok(ProcedureFollowup::V359825008(None)),
            "394725008" => Ok(ProcedureFollowup::V394725008(None)),
            "447346005" => Ok(ProcedureFollowup::V447346005(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProcedureFollowup {
    fn into(self) -> Option<String> {
        match self {
            ProcedureFollowup::V18949003(_) => Some("18949003".to_string()),
            ProcedureFollowup::V225164002(_) => Some("225164002".to_string()),
            ProcedureFollowup::V229506003(_) => Some("229506003".to_string()),
            ProcedureFollowup::V241031001(_) => Some("241031001".to_string()),
            ProcedureFollowup::V274441001(_) => Some("274441001".to_string()),
            ProcedureFollowup::V30549001(_) => Some("30549001".to_string()),
            ProcedureFollowup::V35963001(_) => Some("35963001".to_string()),
            ProcedureFollowup::V359825008(_) => Some("359825008".to_string()),
            ProcedureFollowup::V394725008(_) => Some("394725008".to_string()),
            ProcedureFollowup::V447346005(_) => Some("447346005".to_string()),
            ProcedureFollowup::Null(_) => None,
        }
    }
}
impl MetaValue for ProcedureFollowup {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProcedureFollowup::V18949003(Some(e)) => e.get_field(field),
                ProcedureFollowup::V225164002(Some(e)) => e.get_field(field),
                ProcedureFollowup::V229506003(Some(e)) => e.get_field(field),
                ProcedureFollowup::V241031001(Some(e)) => e.get_field(field),
                ProcedureFollowup::V274441001(Some(e)) => e.get_field(field),
                ProcedureFollowup::V30549001(Some(e)) => e.get_field(field),
                ProcedureFollowup::V35963001(Some(e)) => e.get_field(field),
                ProcedureFollowup::V359825008(Some(e)) => e.get_field(field),
                ProcedureFollowup::V394725008(Some(e)) => e.get_field(field),
                ProcedureFollowup::V447346005(Some(e)) => e.get_field(field),
                ProcedureFollowup::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProcedureFollowup::V18949003(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V225164002(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V229506003(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V241031001(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V274441001(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V30549001(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V35963001(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V359825008(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V394725008(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::V447346005(Some(e)) => e.get_field_mut(field),
                ProcedureFollowup::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProcedureOutcome {
    #[code = "385669000"]
    V385669000(Option<Element>),
    #[code = "385670004"]
    V385670004(Option<Element>),
    #[code = "385671000"]
    V385671000(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProcedureOutcome {
    fn default() -> Self {
        ProcedureOutcome::Null(None)
    }
}
impl TryFrom<String> for ProcedureOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "385669000" => Ok(ProcedureOutcome::V385669000(None)),
            "385670004" => Ok(ProcedureOutcome::V385670004(None)),
            "385671000" => Ok(ProcedureOutcome::V385671000(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProcedureOutcome {
    fn into(self) -> Option<String> {
        match self {
            ProcedureOutcome::V385669000(_) => Some("385669000".to_string()),
            ProcedureOutcome::V385670004(_) => Some("385670004".to_string()),
            ProcedureOutcome::V385671000(_) => Some("385671000".to_string()),
            ProcedureOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for ProcedureOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProcedureOutcome::V385669000(Some(e)) => e.get_field(field),
                ProcedureOutcome::V385670004(Some(e)) => e.get_field(field),
                ProcedureOutcome::V385671000(Some(e)) => e.get_field(field),
                ProcedureOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProcedureOutcome::V385669000(Some(e)) => e.get_field_mut(field),
                ProcedureOutcome::V385670004(Some(e)) => e.get_field_mut(field),
                ProcedureOutcome::V385671000(Some(e)) => e.get_field_mut(field),
                ProcedureOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProcedureProgressStatusCodes {
    #[doc = "Anesthesia Induced"]
    #[code = "anesthesia-induced"]
    AnesthesiaInduced(Option<Element>),
    #[doc = "Closed Incision"]
    #[code = "closed-incision"]
    ClosedIncision(Option<Element>),
    #[doc = "In Operating Room"]
    #[code = "in-operating-room"]
    InOperatingRoom(Option<Element>),
    #[doc = "In Recovery Room"]
    #[code = "in-recovery-room"]
    InRecoveryRoom(Option<Element>),
    #[doc = "Open Incision"]
    #[code = "open-incision"]
    OpenIncision(Option<Element>),
    #[doc = "Prepared"]
    #[code = "prepared"]
    Prepared(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProcedureProgressStatusCodes {
    fn default() -> Self {
        ProcedureProgressStatusCodes::Null(None)
    }
}
impl TryFrom<String> for ProcedureProgressStatusCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "anesthesia-induced" => Ok(ProcedureProgressStatusCodes::AnesthesiaInduced(None)),
            "closed-incision" => Ok(ProcedureProgressStatusCodes::ClosedIncision(None)),
            "in-operating-room" => Ok(ProcedureProgressStatusCodes::InOperatingRoom(None)),
            "in-recovery-room" => Ok(ProcedureProgressStatusCodes::InRecoveryRoom(None)),
            "open-incision" => Ok(ProcedureProgressStatusCodes::OpenIncision(None)),
            "prepared" => Ok(ProcedureProgressStatusCodes::Prepared(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProcedureProgressStatusCodes {
    fn into(self) -> Option<String> {
        match self {
            ProcedureProgressStatusCodes::AnesthesiaInduced(_) => {
                Some("anesthesia-induced".to_string())
            }
            ProcedureProgressStatusCodes::ClosedIncision(_) => Some("closed-incision".to_string()),
            ProcedureProgressStatusCodes::InOperatingRoom(_) => {
                Some("in-operating-room".to_string())
            }
            ProcedureProgressStatusCodes::InRecoveryRoom(_) => Some("in-recovery-room".to_string()),
            ProcedureProgressStatusCodes::OpenIncision(_) => Some("open-incision".to_string()),
            ProcedureProgressStatusCodes::Prepared(_) => Some("prepared".to_string()),
            ProcedureProgressStatusCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ProcedureProgressStatusCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProcedureProgressStatusCodes::AnesthesiaInduced(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::ClosedIncision(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::InOperatingRoom(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::InRecoveryRoom(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::OpenIncision(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::Prepared(Some(e)) => e.get_field(field),
                ProcedureProgressStatusCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProcedureProgressStatusCodes::AnesthesiaInduced(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::ClosedIncision(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::InOperatingRoom(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::InRecoveryRoom(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::OpenIncision(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::Prepared(Some(e)) => e.get_field_mut(field),
                ProcedureProgressStatusCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProcessPriority {
    #[doc = "Deferred"]
    #[code = "deferred"]
    Deferred(Option<Element>),
    #[doc = "Normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "Immediate"]
    #[code = "stat"]
    Stat(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProcessPriority {
    fn default() -> Self {
        ProcessPriority::Null(None)
    }
}
impl TryFrom<String> for ProcessPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "deferred" => Ok(ProcessPriority::Deferred(None)),
            "normal" => Ok(ProcessPriority::Normal(None)),
            "stat" => Ok(ProcessPriority::Stat(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProcessPriority {
    fn into(self) -> Option<String> {
        match self {
            ProcessPriority::Deferred(_) => Some("deferred".to_string()),
            ProcessPriority::Normal(_) => Some("normal".to_string()),
            ProcessPriority::Stat(_) => Some("stat".to_string()),
            ProcessPriority::Null(_) => None,
        }
    }
}
impl MetaValue for ProcessPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProcessPriority::Deferred(Some(e)) => e.get_field(field),
                ProcessPriority::Normal(Some(e)) => e.get_field(field),
                ProcessPriority::Stat(Some(e)) => e.get_field(field),
                ProcessPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProcessPriority::Deferred(Some(e)) => e.get_field_mut(field),
                ProcessPriority::Normal(Some(e)) => e.get_field_mut(field),
                ProcessPriority::Stat(Some(e)) => e.get_field_mut(field),
                ProcessPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProductCategory {
    #[doc = "BiologicalAgent"]
    #[code = "biologicalAgent"]
    BiologicalAgent(Option<Element>),
    #[doc = "Cells"]
    #[code = "cells"]
    Cells(Option<Element>),
    #[doc = "Fluid"]
    #[code = "fluid"]
    Fluid(Option<Element>),
    #[doc = "Organ"]
    #[code = "organ"]
    Organ(Option<Element>),
    #[doc = "Tissue"]
    #[code = "tissue"]
    Tissue(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProductCategory {
    fn default() -> Self {
        ProductCategory::Null(None)
    }
}
impl TryFrom<String> for ProductCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "biologicalAgent" => Ok(ProductCategory::BiologicalAgent(None)),
            "cells" => Ok(ProductCategory::Cells(None)),
            "fluid" => Ok(ProductCategory::Fluid(None)),
            "organ" => Ok(ProductCategory::Organ(None)),
            "tissue" => Ok(ProductCategory::Tissue(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProductCategory {
    fn into(self) -> Option<String> {
        match self {
            ProductCategory::BiologicalAgent(_) => Some("biologicalAgent".to_string()),
            ProductCategory::Cells(_) => Some("cells".to_string()),
            ProductCategory::Fluid(_) => Some("fluid".to_string()),
            ProductCategory::Organ(_) => Some("organ".to_string()),
            ProductCategory::Tissue(_) => Some("tissue".to_string()),
            ProductCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ProductCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProductCategory::BiologicalAgent(Some(e)) => e.get_field(field),
                ProductCategory::Cells(Some(e)) => e.get_field(field),
                ProductCategory::Fluid(Some(e)) => e.get_field(field),
                ProductCategory::Organ(Some(e)) => e.get_field(field),
                ProductCategory::Tissue(Some(e)) => e.get_field(field),
                ProductCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProductCategory::BiologicalAgent(Some(e)) => e.get_field_mut(field),
                ProductCategory::Cells(Some(e)) => e.get_field_mut(field),
                ProductCategory::Fluid(Some(e)) => e.get_field_mut(field),
                ProductCategory::Organ(Some(e)) => e.get_field_mut(field),
                ProductCategory::Tissue(Some(e)) => e.get_field_mut(field),
                ProductCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProductStatus {
    #[doc = "Available"]
    #[code = "available"]
    Available(Option<Element>),
    #[doc = "Unavailable"]
    #[code = "unavailable"]
    Unavailable(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProductStatus {
    fn default() -> Self {
        ProductStatus::Null(None)
    }
}
impl TryFrom<String> for ProductStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "available" => Ok(ProductStatus::Available(None)),
            "unavailable" => Ok(ProductStatus::Unavailable(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProductStatus {
    fn into(self) -> Option<String> {
        match self {
            ProductStatus::Available(_) => Some("available".to_string()),
            ProductStatus::Unavailable(_) => Some("unavailable".to_string()),
            ProductStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ProductStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProductStatus::Available(Some(e)) => e.get_field(field),
                ProductStatus::Unavailable(Some(e)) => e.get_field(field),
                ProductStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProductStatus::Available(Some(e)) => e.get_field_mut(field),
                ProductStatus::Unavailable(Some(e)) => e.get_field_mut(field),
                ProductStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProductStorageScale {
    #[doc = "Celsius"]
    #[code = "celsius"]
    Celsius(Option<Element>),
    #[doc = "Fahrenheit"]
    #[code = "farenheit"]
    Farenheit(Option<Element>),
    #[doc = "Kelvin"]
    #[code = "kelvin"]
    Kelvin(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProductStorageScale {
    fn default() -> Self {
        ProductStorageScale::Null(None)
    }
}
impl TryFrom<String> for ProductStorageScale {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "celsius" => Ok(ProductStorageScale::Celsius(None)),
            "farenheit" => Ok(ProductStorageScale::Farenheit(None)),
            "kelvin" => Ok(ProductStorageScale::Kelvin(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProductStorageScale {
    fn into(self) -> Option<String> {
        match self {
            ProductStorageScale::Celsius(_) => Some("celsius".to_string()),
            ProductStorageScale::Farenheit(_) => Some("farenheit".to_string()),
            ProductStorageScale::Kelvin(_) => Some("kelvin".to_string()),
            ProductStorageScale::Null(_) => None,
        }
    }
}
impl MetaValue for ProductStorageScale {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProductStorageScale::Celsius(Some(e)) => e.get_field(field),
                ProductStorageScale::Farenheit(Some(e)) => e.get_field(field),
                ProductStorageScale::Kelvin(Some(e)) => e.get_field(field),
                ProductStorageScale::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProductStorageScale::Celsius(Some(e)) => e.get_field_mut(field),
                ProductStorageScale::Farenheit(Some(e)) => e.get_field_mut(field),
                ProductStorageScale::Kelvin(Some(e)) => e.get_field_mut(field),
                ProductStorageScale::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PropertyRepresentation {
    #[doc = "CDA Text Format"]
    #[code = "cdaText"]
    CdaText(Option<Element>),
    #[doc = "Type Attribute"]
    #[code = "typeAttr"]
    TypeAttr(Option<Element>),
    #[doc = "XHTML"]
    #[code = "xhtml"]
    Xhtml(Option<Element>),
    #[doc = "XML Attribute"]
    #[code = "xmlAttr"]
    XmlAttr(Option<Element>),
    #[doc = "XML Text"]
    #[code = "xmlText"]
    XmlText(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PropertyRepresentation {
    fn default() -> Self {
        PropertyRepresentation::Null(None)
    }
}
impl TryFrom<String> for PropertyRepresentation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cdaText" => Ok(PropertyRepresentation::CdaText(None)),
            "typeAttr" => Ok(PropertyRepresentation::TypeAttr(None)),
            "xhtml" => Ok(PropertyRepresentation::Xhtml(None)),
            "xmlAttr" => Ok(PropertyRepresentation::XmlAttr(None)),
            "xmlText" => Ok(PropertyRepresentation::XmlText(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PropertyRepresentation {
    fn into(self) -> Option<String> {
        match self {
            PropertyRepresentation::CdaText(_) => Some("cdaText".to_string()),
            PropertyRepresentation::TypeAttr(_) => Some("typeAttr".to_string()),
            PropertyRepresentation::Xhtml(_) => Some("xhtml".to_string()),
            PropertyRepresentation::XmlAttr(_) => Some("xmlAttr".to_string()),
            PropertyRepresentation::XmlText(_) => Some("xmlText".to_string()),
            PropertyRepresentation::Null(_) => None,
        }
    }
}
impl MetaValue for PropertyRepresentation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PropertyRepresentation::CdaText(Some(e)) => e.get_field(field),
                PropertyRepresentation::TypeAttr(Some(e)) => e.get_field(field),
                PropertyRepresentation::Xhtml(Some(e)) => e.get_field(field),
                PropertyRepresentation::XmlAttr(Some(e)) => e.get_field(field),
                PropertyRepresentation::XmlText(Some(e)) => e.get_field(field),
                PropertyRepresentation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PropertyRepresentation::CdaText(Some(e)) => e.get_field_mut(field),
                PropertyRepresentation::TypeAttr(Some(e)) => e.get_field_mut(field),
                PropertyRepresentation::Xhtml(Some(e)) => e.get_field_mut(field),
                PropertyRepresentation::XmlAttr(Some(e)) => e.get_field_mut(field),
                PropertyRepresentation::XmlText(Some(e)) => e.get_field_mut(field),
                PropertyRepresentation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceActivityType {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[code = "ANONY"]
    ANONY(Option<Element>),
    #[code = "APPEND"]
    APPEND(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[code = "CREATE"]
    CREATE(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[code = "DEID"]
    DEID(Option<Element>),
    #[code = "DELETE"]
    DELETE(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[code = "LABEL"]
    LABEL(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[code = "MASK"]
    MASK(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[code = "NULLIFY"]
    NULLIFY(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[code = "PSEUD"]
    PSEUD(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[code = "UPDATE"]
    UPDATE(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceActivityType {
    fn default() -> Self {
        ProvenanceActivityType::Null(None)
    }
}
impl TryFrom<String> for ProvenanceActivityType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(ProvenanceActivityType::ADM(None)),
            "ALY" => Ok(ProvenanceActivityType::ALY(None)),
            "ANONY" => Ok(ProvenanceActivityType::ANONY(None)),
            "APPEND" => Ok(ProvenanceActivityType::APPEND(None)),
            "ATND" => Ok(ProvenanceActivityType::ATND(None)),
            "AUT" => Ok(ProvenanceActivityType::AUT(None)),
            "AUTHEN" => Ok(ProvenanceActivityType::AUTHEN(None)),
            "BBY" => Ok(ProvenanceActivityType::BBY(None)),
            "BEN" => Ok(ProvenanceActivityType::BEN(None)),
            "CAGNT" => Ok(ProvenanceActivityType::CAGNT(None)),
            "CALLBCK" => Ok(ProvenanceActivityType::CALLBCK(None)),
            "CAT" => Ok(ProvenanceActivityType::CAT(None)),
            "CON" => Ok(ProvenanceActivityType::CON(None)),
            "COV" => Ok(ProvenanceActivityType::COV(None)),
            "CREATE" => Ok(ProvenanceActivityType::CREATE(None)),
            "CSM" => Ok(ProvenanceActivityType::CSM(None)),
            "CST" => Ok(ProvenanceActivityType::CST(None)),
            "DEID" => Ok(ProvenanceActivityType::DEID(None)),
            "DELETE" => Ok(ProvenanceActivityType::DELETE(None)),
            "DEV" => Ok(ProvenanceActivityType::DEV(None)),
            "DIR" => Ok(ProvenanceActivityType::DIR(None)),
            "DIS" => Ok(ProvenanceActivityType::DIS(None)),
            "DIST" => Ok(ProvenanceActivityType::DIST(None)),
            "DON" => Ok(ProvenanceActivityType::DON(None)),
            "DST" => Ok(ProvenanceActivityType::DST(None)),
            "ELOC" => Ok(ProvenanceActivityType::ELOC(None)),
            "ENT" => Ok(ProvenanceActivityType::ENT(None)),
            "ESC" => Ok(ProvenanceActivityType::ESC(None)),
            "EXPAGNT" => Ok(ProvenanceActivityType::EXPAGNT(None)),
            "EXPART" => Ok(ProvenanceActivityType::EXPART(None)),
            "EXPTRGT" => Ok(ProvenanceActivityType::EXPTRGT(None)),
            "EXSRC" => Ok(ProvenanceActivityType::EXSRC(None)),
            "GUAR" => Ok(ProvenanceActivityType::GUAR(None)),
            "HLD" => Ok(ProvenanceActivityType::HLD(None)),
            "IND" => Ok(ProvenanceActivityType::IND(None)),
            "INF" => Ok(ProvenanceActivityType::INF(None)),
            "IRCP" => Ok(ProvenanceActivityType::IRCP(None)),
            "LA" => Ok(ProvenanceActivityType::LA(None)),
            "LABEL" => Ok(ProvenanceActivityType::LABEL(None)),
            "LOC" => Ok(ProvenanceActivityType::LOC(None)),
            "MASK" => Ok(ProvenanceActivityType::MASK(None)),
            "NOT" => Ok(ProvenanceActivityType::NOT(None)),
            "NRD" => Ok(ProvenanceActivityType::NRD(None)),
            "NULLIFY" => Ok(ProvenanceActivityType::NULLIFY(None)),
            "ORG" => Ok(ProvenanceActivityType::ORG(None)),
            "PART" => Ok(ProvenanceActivityType::PART(None)),
            "PPRF" => Ok(ProvenanceActivityType::PPRF(None)),
            "PRCP" => Ok(ProvenanceActivityType::PRCP(None)),
            "PRD" => Ok(ProvenanceActivityType::PRD(None)),
            "PRF" => Ok(ProvenanceActivityType::PRF(None)),
            "PSEUD" => Ok(ProvenanceActivityType::PSEUD(None)),
            "RCT" => Ok(ProvenanceActivityType::RCT(None)),
            "RCV" => Ok(ProvenanceActivityType::RCV(None)),
            "RDV" => Ok(ProvenanceActivityType::RDV(None)),
            "REF" => Ok(ProvenanceActivityType::REF(None)),
            "REFB" => Ok(ProvenanceActivityType::REFB(None)),
            "REFT" => Ok(ProvenanceActivityType::REFT(None)),
            "RESP" => Ok(ProvenanceActivityType::RESP(None)),
            "RML" => Ok(ProvenanceActivityType::RML(None)),
            "SBJ" => Ok(ProvenanceActivityType::SBJ(None)),
            "SPC" => Ok(ProvenanceActivityType::SPC(None)),
            "SPRF" => Ok(ProvenanceActivityType::SPRF(None)),
            "TPA" => Ok(ProvenanceActivityType::TPA(None)),
            "TRANS" => Ok(ProvenanceActivityType::TRANS(None)),
            "TRC" => Ok(ProvenanceActivityType::TRC(None)),
            "UPDATE" => Ok(ProvenanceActivityType::UPDATE(None)),
            "VIA" => Ok(ProvenanceActivityType::VIA(None)),
            "VRF" => Ok(ProvenanceActivityType::VRF(None)),
            "WIT" => Ok(ProvenanceActivityType::WIT(None)),
            "_ParticipationAncillary" => Ok(ProvenanceActivityType::_ParticipationAncillary(None)),
            "_ParticipationInformationGenerator" => Ok(
                ProvenanceActivityType::_ParticipationInformationGenerator(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceActivityType {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceActivityType::ADM(_) => Some("ADM".to_string()),
            ProvenanceActivityType::ALY(_) => Some("ALY".to_string()),
            ProvenanceActivityType::ANONY(_) => Some("ANONY".to_string()),
            ProvenanceActivityType::APPEND(_) => Some("APPEND".to_string()),
            ProvenanceActivityType::ATND(_) => Some("ATND".to_string()),
            ProvenanceActivityType::AUT(_) => Some("AUT".to_string()),
            ProvenanceActivityType::AUTHEN(_) => Some("AUTHEN".to_string()),
            ProvenanceActivityType::BBY(_) => Some("BBY".to_string()),
            ProvenanceActivityType::BEN(_) => Some("BEN".to_string()),
            ProvenanceActivityType::CAGNT(_) => Some("CAGNT".to_string()),
            ProvenanceActivityType::CALLBCK(_) => Some("CALLBCK".to_string()),
            ProvenanceActivityType::CAT(_) => Some("CAT".to_string()),
            ProvenanceActivityType::CON(_) => Some("CON".to_string()),
            ProvenanceActivityType::COV(_) => Some("COV".to_string()),
            ProvenanceActivityType::CREATE(_) => Some("CREATE".to_string()),
            ProvenanceActivityType::CSM(_) => Some("CSM".to_string()),
            ProvenanceActivityType::CST(_) => Some("CST".to_string()),
            ProvenanceActivityType::DEID(_) => Some("DEID".to_string()),
            ProvenanceActivityType::DELETE(_) => Some("DELETE".to_string()),
            ProvenanceActivityType::DEV(_) => Some("DEV".to_string()),
            ProvenanceActivityType::DIR(_) => Some("DIR".to_string()),
            ProvenanceActivityType::DIS(_) => Some("DIS".to_string()),
            ProvenanceActivityType::DIST(_) => Some("DIST".to_string()),
            ProvenanceActivityType::DON(_) => Some("DON".to_string()),
            ProvenanceActivityType::DST(_) => Some("DST".to_string()),
            ProvenanceActivityType::ELOC(_) => Some("ELOC".to_string()),
            ProvenanceActivityType::ENT(_) => Some("ENT".to_string()),
            ProvenanceActivityType::ESC(_) => Some("ESC".to_string()),
            ProvenanceActivityType::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            ProvenanceActivityType::EXPART(_) => Some("EXPART".to_string()),
            ProvenanceActivityType::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            ProvenanceActivityType::EXSRC(_) => Some("EXSRC".to_string()),
            ProvenanceActivityType::GUAR(_) => Some("GUAR".to_string()),
            ProvenanceActivityType::HLD(_) => Some("HLD".to_string()),
            ProvenanceActivityType::IND(_) => Some("IND".to_string()),
            ProvenanceActivityType::INF(_) => Some("INF".to_string()),
            ProvenanceActivityType::IRCP(_) => Some("IRCP".to_string()),
            ProvenanceActivityType::LA(_) => Some("LA".to_string()),
            ProvenanceActivityType::LABEL(_) => Some("LABEL".to_string()),
            ProvenanceActivityType::LOC(_) => Some("LOC".to_string()),
            ProvenanceActivityType::MASK(_) => Some("MASK".to_string()),
            ProvenanceActivityType::NOT(_) => Some("NOT".to_string()),
            ProvenanceActivityType::NRD(_) => Some("NRD".to_string()),
            ProvenanceActivityType::NULLIFY(_) => Some("NULLIFY".to_string()),
            ProvenanceActivityType::ORG(_) => Some("ORG".to_string()),
            ProvenanceActivityType::PART(_) => Some("PART".to_string()),
            ProvenanceActivityType::PPRF(_) => Some("PPRF".to_string()),
            ProvenanceActivityType::PRCP(_) => Some("PRCP".to_string()),
            ProvenanceActivityType::PRD(_) => Some("PRD".to_string()),
            ProvenanceActivityType::PRF(_) => Some("PRF".to_string()),
            ProvenanceActivityType::PSEUD(_) => Some("PSEUD".to_string()),
            ProvenanceActivityType::RCT(_) => Some("RCT".to_string()),
            ProvenanceActivityType::RCV(_) => Some("RCV".to_string()),
            ProvenanceActivityType::RDV(_) => Some("RDV".to_string()),
            ProvenanceActivityType::REF(_) => Some("REF".to_string()),
            ProvenanceActivityType::REFB(_) => Some("REFB".to_string()),
            ProvenanceActivityType::REFT(_) => Some("REFT".to_string()),
            ProvenanceActivityType::RESP(_) => Some("RESP".to_string()),
            ProvenanceActivityType::RML(_) => Some("RML".to_string()),
            ProvenanceActivityType::SBJ(_) => Some("SBJ".to_string()),
            ProvenanceActivityType::SPC(_) => Some("SPC".to_string()),
            ProvenanceActivityType::SPRF(_) => Some("SPRF".to_string()),
            ProvenanceActivityType::TPA(_) => Some("TPA".to_string()),
            ProvenanceActivityType::TRANS(_) => Some("TRANS".to_string()),
            ProvenanceActivityType::TRC(_) => Some("TRC".to_string()),
            ProvenanceActivityType::UPDATE(_) => Some("UPDATE".to_string()),
            ProvenanceActivityType::VIA(_) => Some("VIA".to_string()),
            ProvenanceActivityType::VRF(_) => Some("VRF".to_string()),
            ProvenanceActivityType::WIT(_) => Some("WIT".to_string()),
            ProvenanceActivityType::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            ProvenanceActivityType::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            ProvenanceActivityType::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceActivityType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceActivityType::ADM(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ALY(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ANONY(Some(e)) => e.get_field(field),
                ProvenanceActivityType::APPEND(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ATND(Some(e)) => e.get_field(field),
                ProvenanceActivityType::AUT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::AUTHEN(Some(e)) => e.get_field(field),
                ProvenanceActivityType::BBY(Some(e)) => e.get_field(field),
                ProvenanceActivityType::BEN(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CAGNT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CALLBCK(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CAT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CON(Some(e)) => e.get_field(field),
                ProvenanceActivityType::COV(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CREATE(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CSM(Some(e)) => e.get_field(field),
                ProvenanceActivityType::CST(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DEID(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DELETE(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DEV(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DIR(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DIS(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DIST(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DON(Some(e)) => e.get_field(field),
                ProvenanceActivityType::DST(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ELOC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ENT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ESC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::EXPAGNT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::EXPART(Some(e)) => e.get_field(field),
                ProvenanceActivityType::EXPTRGT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::EXSRC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::GUAR(Some(e)) => e.get_field(field),
                ProvenanceActivityType::HLD(Some(e)) => e.get_field(field),
                ProvenanceActivityType::IND(Some(e)) => e.get_field(field),
                ProvenanceActivityType::INF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::IRCP(Some(e)) => e.get_field(field),
                ProvenanceActivityType::LA(Some(e)) => e.get_field(field),
                ProvenanceActivityType::LABEL(Some(e)) => e.get_field(field),
                ProvenanceActivityType::LOC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::MASK(Some(e)) => e.get_field(field),
                ProvenanceActivityType::NOT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::NRD(Some(e)) => e.get_field(field),
                ProvenanceActivityType::NULLIFY(Some(e)) => e.get_field(field),
                ProvenanceActivityType::ORG(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PART(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PPRF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PRCP(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PRD(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PRF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::PSEUD(Some(e)) => e.get_field(field),
                ProvenanceActivityType::RCT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::RCV(Some(e)) => e.get_field(field),
                ProvenanceActivityType::RDV(Some(e)) => e.get_field(field),
                ProvenanceActivityType::REF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::REFB(Some(e)) => e.get_field(field),
                ProvenanceActivityType::REFT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::RESP(Some(e)) => e.get_field(field),
                ProvenanceActivityType::RML(Some(e)) => e.get_field(field),
                ProvenanceActivityType::SBJ(Some(e)) => e.get_field(field),
                ProvenanceActivityType::SPC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::SPRF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::TPA(Some(e)) => e.get_field(field),
                ProvenanceActivityType::TRANS(Some(e)) => e.get_field(field),
                ProvenanceActivityType::TRC(Some(e)) => e.get_field(field),
                ProvenanceActivityType::UPDATE(Some(e)) => e.get_field(field),
                ProvenanceActivityType::VIA(Some(e)) => e.get_field(field),
                ProvenanceActivityType::VRF(Some(e)) => e.get_field(field),
                ProvenanceActivityType::WIT(Some(e)) => e.get_field(field),
                ProvenanceActivityType::_ParticipationAncillary(Some(e)) => e.get_field(field),
                ProvenanceActivityType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                ProvenanceActivityType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceActivityType::ADM(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ALY(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ANONY(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::APPEND(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ATND(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::AUT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::AUTHEN(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::BBY(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::BEN(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CAGNT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CALLBCK(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CAT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CON(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::COV(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CREATE(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CSM(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::CST(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DEID(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DELETE(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DEV(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DIR(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DIS(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DIST(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DON(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::DST(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ELOC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ENT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ESC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::EXPAGNT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::EXPART(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::EXPTRGT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::EXSRC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::GUAR(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::HLD(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::IND(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::INF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::IRCP(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::LA(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::LABEL(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::LOC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::MASK(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::NOT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::NRD(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::NULLIFY(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::ORG(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PART(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PPRF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PRCP(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PRD(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PRF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::PSEUD(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::RCT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::RCV(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::RDV(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::REF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::REFB(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::REFT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::RESP(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::RML(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::SBJ(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::SPC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::SPRF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::TPA(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::TRANS(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::TRC(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::UPDATE(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::VIA(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::VRF(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::WIT(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::_ParticipationAncillary(Some(e)) => e.get_field_mut(field),
                ProvenanceActivityType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                ProvenanceActivityType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceAgentRole {
    #[doc = "Assembler"]
    #[code = "assembler"]
    Assembler(Option<Element>),
    #[doc = "Attester"]
    #[code = "attester"]
    Attester(Option<Element>),
    #[doc = "Author"]
    #[code = "author"]
    Author(Option<Element>),
    #[doc = "Composer"]
    #[code = "composer"]
    Composer(Option<Element>),
    #[doc = "Custodian"]
    #[code = "custodian"]
    Custodian(Option<Element>),
    #[doc = "Enterer"]
    #[code = "enterer"]
    Enterer(Option<Element>),
    #[doc = "Informant"]
    #[code = "informant"]
    Informant(Option<Element>),
    #[doc = "Legal Authenticator"]
    #[code = "legal"]
    Legal(Option<Element>),
    #[doc = "Performer"]
    #[code = "performer"]
    Performer(Option<Element>),
    #[doc = "Verifier"]
    #[code = "verifier"]
    Verifier(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceAgentRole {
    fn default() -> Self {
        ProvenanceAgentRole::Null(None)
    }
}
impl TryFrom<String> for ProvenanceAgentRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "assembler" => Ok(ProvenanceAgentRole::Assembler(None)),
            "attester" => Ok(ProvenanceAgentRole::Attester(None)),
            "author" => Ok(ProvenanceAgentRole::Author(None)),
            "composer" => Ok(ProvenanceAgentRole::Composer(None)),
            "custodian" => Ok(ProvenanceAgentRole::Custodian(None)),
            "enterer" => Ok(ProvenanceAgentRole::Enterer(None)),
            "informant" => Ok(ProvenanceAgentRole::Informant(None)),
            "legal" => Ok(ProvenanceAgentRole::Legal(None)),
            "performer" => Ok(ProvenanceAgentRole::Performer(None)),
            "verifier" => Ok(ProvenanceAgentRole::Verifier(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceAgentRole {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceAgentRole::Assembler(_) => Some("assembler".to_string()),
            ProvenanceAgentRole::Attester(_) => Some("attester".to_string()),
            ProvenanceAgentRole::Author(_) => Some("author".to_string()),
            ProvenanceAgentRole::Composer(_) => Some("composer".to_string()),
            ProvenanceAgentRole::Custodian(_) => Some("custodian".to_string()),
            ProvenanceAgentRole::Enterer(_) => Some("enterer".to_string()),
            ProvenanceAgentRole::Informant(_) => Some("informant".to_string()),
            ProvenanceAgentRole::Legal(_) => Some("legal".to_string()),
            ProvenanceAgentRole::Performer(_) => Some("performer".to_string()),
            ProvenanceAgentRole::Verifier(_) => Some("verifier".to_string()),
            ProvenanceAgentRole::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceAgentRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceAgentRole::Assembler(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Attester(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Author(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Composer(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Custodian(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Enterer(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Informant(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Legal(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Performer(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Verifier(Some(e)) => e.get_field(field),
                ProvenanceAgentRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceAgentRole::Assembler(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Attester(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Author(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Composer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Custodian(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Enterer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Informant(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Legal(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Performer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Verifier(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceAgentType {
    #[doc = "Assembler"]
    #[code = "assembler"]
    Assembler(Option<Element>),
    #[doc = "Attester"]
    #[code = "attester"]
    Attester(Option<Element>),
    #[doc = "Author"]
    #[code = "author"]
    Author(Option<Element>),
    #[doc = "Composer"]
    #[code = "composer"]
    Composer(Option<Element>),
    #[doc = "Custodian"]
    #[code = "custodian"]
    Custodian(Option<Element>),
    #[doc = "Enterer"]
    #[code = "enterer"]
    Enterer(Option<Element>),
    #[doc = "Informant"]
    #[code = "informant"]
    Informant(Option<Element>),
    #[doc = "Legal Authenticator"]
    #[code = "legal"]
    Legal(Option<Element>),
    #[doc = "Performer"]
    #[code = "performer"]
    Performer(Option<Element>),
    #[doc = "Verifier"]
    #[code = "verifier"]
    Verifier(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceAgentType {
    fn default() -> Self {
        ProvenanceAgentType::Null(None)
    }
}
impl TryFrom<String> for ProvenanceAgentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "assembler" => Ok(ProvenanceAgentType::Assembler(None)),
            "attester" => Ok(ProvenanceAgentType::Attester(None)),
            "author" => Ok(ProvenanceAgentType::Author(None)),
            "composer" => Ok(ProvenanceAgentType::Composer(None)),
            "custodian" => Ok(ProvenanceAgentType::Custodian(None)),
            "enterer" => Ok(ProvenanceAgentType::Enterer(None)),
            "informant" => Ok(ProvenanceAgentType::Informant(None)),
            "legal" => Ok(ProvenanceAgentType::Legal(None)),
            "performer" => Ok(ProvenanceAgentType::Performer(None)),
            "verifier" => Ok(ProvenanceAgentType::Verifier(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceAgentType {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceAgentType::Assembler(_) => Some("assembler".to_string()),
            ProvenanceAgentType::Attester(_) => Some("attester".to_string()),
            ProvenanceAgentType::Author(_) => Some("author".to_string()),
            ProvenanceAgentType::Composer(_) => Some("composer".to_string()),
            ProvenanceAgentType::Custodian(_) => Some("custodian".to_string()),
            ProvenanceAgentType::Enterer(_) => Some("enterer".to_string()),
            ProvenanceAgentType::Informant(_) => Some("informant".to_string()),
            ProvenanceAgentType::Legal(_) => Some("legal".to_string()),
            ProvenanceAgentType::Performer(_) => Some("performer".to_string()),
            ProvenanceAgentType::Verifier(_) => Some("verifier".to_string()),
            ProvenanceAgentType::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceAgentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceAgentType::Assembler(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Attester(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Author(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Composer(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Custodian(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Enterer(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Informant(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Legal(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Performer(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Verifier(Some(e)) => e.get_field(field),
                ProvenanceAgentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceAgentType::Assembler(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Attester(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Author(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Composer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Custodian(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Enterer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Informant(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Legal(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Performer(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Verifier(Some(e)) => e.get_field_mut(field),
                ProvenanceAgentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceEntityRole {
    #[doc = "Derivation"]
    #[code = "derivation"]
    Derivation(Option<Element>),
    #[doc = "Quotation"]
    #[code = "quotation"]
    Quotation(Option<Element>),
    #[doc = "Removal"]
    #[code = "removal"]
    Removal(Option<Element>),
    #[doc = "Revision"]
    #[code = "revision"]
    Revision(Option<Element>),
    #[doc = "Source"]
    #[code = "source"]
    Source(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceEntityRole {
    fn default() -> Self {
        ProvenanceEntityRole::Null(None)
    }
}
impl TryFrom<String> for ProvenanceEntityRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "derivation" => Ok(ProvenanceEntityRole::Derivation(None)),
            "quotation" => Ok(ProvenanceEntityRole::Quotation(None)),
            "removal" => Ok(ProvenanceEntityRole::Removal(None)),
            "revision" => Ok(ProvenanceEntityRole::Revision(None)),
            "source" => Ok(ProvenanceEntityRole::Source(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceEntityRole {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceEntityRole::Derivation(_) => Some("derivation".to_string()),
            ProvenanceEntityRole::Quotation(_) => Some("quotation".to_string()),
            ProvenanceEntityRole::Removal(_) => Some("removal".to_string()),
            ProvenanceEntityRole::Revision(_) => Some("revision".to_string()),
            ProvenanceEntityRole::Source(_) => Some("source".to_string()),
            ProvenanceEntityRole::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceEntityRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceEntityRole::Derivation(Some(e)) => e.get_field(field),
                ProvenanceEntityRole::Quotation(Some(e)) => e.get_field(field),
                ProvenanceEntityRole::Removal(Some(e)) => e.get_field(field),
                ProvenanceEntityRole::Revision(Some(e)) => e.get_field(field),
                ProvenanceEntityRole::Source(Some(e)) => e.get_field(field),
                ProvenanceEntityRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceEntityRole::Derivation(Some(e)) => e.get_field_mut(field),
                ProvenanceEntityRole::Quotation(Some(e)) => e.get_field_mut(field),
                ProvenanceEntityRole::Removal(Some(e)) => e.get_field_mut(field),
                ProvenanceEntityRole::Revision(Some(e)) => e.get_field_mut(field),
                ProvenanceEntityRole::Source(Some(e)) => e.get_field_mut(field),
                ProvenanceEntityRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceHistoryAgentType {
    #[doc = "Author"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "Data Enterer"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "Informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "Verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceHistoryAgentType {
    fn default() -> Self {
        ProvenanceHistoryAgentType::Null(None)
    }
}
impl TryFrom<String> for ProvenanceHistoryAgentType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AUT" => Ok(ProvenanceHistoryAgentType::AUT(None)),
            "ENT" => Ok(ProvenanceHistoryAgentType::ENT(None)),
            "INF" => Ok(ProvenanceHistoryAgentType::INF(None)),
            "VRF" => Ok(ProvenanceHistoryAgentType::VRF(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceHistoryAgentType {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceHistoryAgentType::AUT(_) => Some("AUT".to_string()),
            ProvenanceHistoryAgentType::ENT(_) => Some("ENT".to_string()),
            ProvenanceHistoryAgentType::INF(_) => Some("INF".to_string()),
            ProvenanceHistoryAgentType::VRF(_) => Some("VRF".to_string()),
            ProvenanceHistoryAgentType::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceHistoryAgentType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceHistoryAgentType::AUT(Some(e)) => e.get_field(field),
                ProvenanceHistoryAgentType::ENT(Some(e)) => e.get_field(field),
                ProvenanceHistoryAgentType::INF(Some(e)) => e.get_field(field),
                ProvenanceHistoryAgentType::VRF(Some(e)) => e.get_field(field),
                ProvenanceHistoryAgentType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceHistoryAgentType::AUT(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryAgentType::ENT(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryAgentType::INF(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryAgentType::VRF(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryAgentType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProvenanceHistoryRecordActivity {
    #[doc = "Stopped/Ended/Aborted"]
    #[code = "ABORT"]
    ABORT(Option<Element>),
    #[doc = "Activated"]
    #[code = "ACTIVATE"]
    ACTIVATE(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "CANCEL"]
    CANCEL(Option<Element>),
    #[doc = "Completed"]
    #[code = "COMPLETE"]
    COMPLETE(Option<Element>),
    #[doc = "Created"]
    #[code = "CREATE"]
    CREATE(Option<Element>),
    #[doc = "Deleted"]
    #[code = "DELETE"]
    DELETE(Option<Element>),
    #[doc = "Held"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "Mark Entered-in-error"]
    #[code = "NULLIFY"]
    NULLIFY(Option<Element>),
    #[doc = "Replaced"]
    #[code = "OBSOLETE"]
    OBSOLETE(Option<Element>),
    #[doc = "Reactivated"]
    #[code = "REACTIVATE"]
    REACTIVATE(Option<Element>),
    #[doc = "Released"]
    #[code = "RELEASE"]
    RELEASE(Option<Element>),
    #[code = "RESUME"]
    RESUME(Option<Element>),
    #[doc = "Suspended"]
    #[code = "SUSPEND"]
    SUSPEND(Option<Element>),
    #[doc = "Updated"]
    #[code = "UPDATE"]
    UPDATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProvenanceHistoryRecordActivity {
    fn default() -> Self {
        ProvenanceHistoryRecordActivity::Null(None)
    }
}
impl TryFrom<String> for ProvenanceHistoryRecordActivity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ABORT" => Ok(ProvenanceHistoryRecordActivity::ABORT(None)),
            "ACTIVATE" => Ok(ProvenanceHistoryRecordActivity::ACTIVATE(None)),
            "CANCEL" => Ok(ProvenanceHistoryRecordActivity::CANCEL(None)),
            "COMPLETE" => Ok(ProvenanceHistoryRecordActivity::COMPLETE(None)),
            "CREATE" => Ok(ProvenanceHistoryRecordActivity::CREATE(None)),
            "DELETE" => Ok(ProvenanceHistoryRecordActivity::DELETE(None)),
            "HOLD" => Ok(ProvenanceHistoryRecordActivity::HOLD(None)),
            "NULLIFY" => Ok(ProvenanceHistoryRecordActivity::NULLIFY(None)),
            "OBSOLETE" => Ok(ProvenanceHistoryRecordActivity::OBSOLETE(None)),
            "REACTIVATE" => Ok(ProvenanceHistoryRecordActivity::REACTIVATE(None)),
            "RELEASE" => Ok(ProvenanceHistoryRecordActivity::RELEASE(None)),
            "RESUME" => Ok(ProvenanceHistoryRecordActivity::RESUME(None)),
            "SUSPEND" => Ok(ProvenanceHistoryRecordActivity::SUSPEND(None)),
            "UPDATE" => Ok(ProvenanceHistoryRecordActivity::UPDATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProvenanceHistoryRecordActivity {
    fn into(self) -> Option<String> {
        match self {
            ProvenanceHistoryRecordActivity::ABORT(_) => Some("ABORT".to_string()),
            ProvenanceHistoryRecordActivity::ACTIVATE(_) => Some("ACTIVATE".to_string()),
            ProvenanceHistoryRecordActivity::CANCEL(_) => Some("CANCEL".to_string()),
            ProvenanceHistoryRecordActivity::COMPLETE(_) => Some("COMPLETE".to_string()),
            ProvenanceHistoryRecordActivity::CREATE(_) => Some("CREATE".to_string()),
            ProvenanceHistoryRecordActivity::DELETE(_) => Some("DELETE".to_string()),
            ProvenanceHistoryRecordActivity::HOLD(_) => Some("HOLD".to_string()),
            ProvenanceHistoryRecordActivity::NULLIFY(_) => Some("NULLIFY".to_string()),
            ProvenanceHistoryRecordActivity::OBSOLETE(_) => Some("OBSOLETE".to_string()),
            ProvenanceHistoryRecordActivity::REACTIVATE(_) => Some("REACTIVATE".to_string()),
            ProvenanceHistoryRecordActivity::RELEASE(_) => Some("RELEASE".to_string()),
            ProvenanceHistoryRecordActivity::RESUME(_) => Some("RESUME".to_string()),
            ProvenanceHistoryRecordActivity::SUSPEND(_) => Some("SUSPEND".to_string()),
            ProvenanceHistoryRecordActivity::UPDATE(_) => Some("UPDATE".to_string()),
            ProvenanceHistoryRecordActivity::Null(_) => None,
        }
    }
}
impl MetaValue for ProvenanceHistoryRecordActivity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProvenanceHistoryRecordActivity::ABORT(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::ACTIVATE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::CANCEL(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::COMPLETE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::CREATE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::DELETE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::HOLD(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::NULLIFY(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::OBSOLETE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::REACTIVATE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::RELEASE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::RESUME(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::SUSPEND(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::UPDATE(Some(e)) => e.get_field(field),
                ProvenanceHistoryRecordActivity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProvenanceHistoryRecordActivity::ABORT(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::ACTIVATE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::CANCEL(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::COMPLETE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::CREATE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::DELETE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::HOLD(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::NULLIFY(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::OBSOLETE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::REACTIVATE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::RELEASE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::RESUME(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::SUSPEND(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::UPDATE(Some(e)) => e.get_field_mut(field),
                ProvenanceHistoryRecordActivity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ProviderQualification {
    #[doc = "Dentist"]
    #[code = "311405"]
    V311405(Option<Element>),
    #[doc = "Optometrist"]
    #[code = "604210"]
    V604210(Option<Element>),
    #[doc = "Ophthalmologist"]
    #[code = "604215"]
    V604215(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ProviderQualification {
    fn default() -> Self {
        ProviderQualification::Null(None)
    }
}
impl TryFrom<String> for ProviderQualification {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "311405" => Ok(ProviderQualification::V311405(None)),
            "604210" => Ok(ProviderQualification::V604210(None)),
            "604215" => Ok(ProviderQualification::V604215(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ProviderQualification {
    fn into(self) -> Option<String> {
        match self {
            ProviderQualification::V311405(_) => Some("311405".to_string()),
            ProviderQualification::V604210(_) => Some("604210".to_string()),
            ProviderQualification::V604215(_) => Some("604215".to_string()),
            ProviderQualification::Null(_) => None,
        }
    }
}
impl MetaValue for ProviderQualification {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ProviderQualification::V311405(Some(e)) => e.get_field(field),
                ProviderQualification::V604210(Some(e)) => e.get_field(field),
                ProviderQualification::V604215(Some(e)) => e.get_field(field),
                ProviderQualification::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ProviderQualification::V311405(Some(e)) => e.get_field_mut(field),
                ProviderQualification::V604210(Some(e)) => e.get_field_mut(field),
                ProviderQualification::V604215(Some(e)) => e.get_field_mut(field),
                ProviderQualification::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum PublicationStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Retired"]
    #[code = "retired"]
    Retired(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for PublicationStatus {
    fn default() -> Self {
        PublicationStatus::Null(None)
    }
}
impl TryFrom<String> for PublicationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(PublicationStatus::Active(None)),
            "draft" => Ok(PublicationStatus::Draft(None)),
            "retired" => Ok(PublicationStatus::Retired(None)),
            "unknown" => Ok(PublicationStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &PublicationStatus {
    fn into(self) -> Option<String> {
        match self {
            PublicationStatus::Active(_) => Some("active".to_string()),
            PublicationStatus::Draft(_) => Some("draft".to_string()),
            PublicationStatus::Retired(_) => Some("retired".to_string()),
            PublicationStatus::Unknown(_) => Some("unknown".to_string()),
            PublicationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for PublicationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                PublicationStatus::Active(Some(e)) => e.get_field(field),
                PublicationStatus::Draft(Some(e)) => e.get_field(field),
                PublicationStatus::Retired(Some(e)) => e.get_field(field),
                PublicationStatus::Unknown(Some(e)) => e.get_field(field),
                PublicationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                PublicationStatus::Active(Some(e)) => e.get_field_mut(field),
                PublicationStatus::Draft(Some(e)) => e.get_field_mut(field),
                PublicationStatus::Retired(Some(e)) => e.get_field_mut(field),
                PublicationStatus::Unknown(Some(e)) => e.get_field_mut(field),
                PublicationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QualityType {
    #[doc = "INDEL Comparison"]
    #[code = "indel"]
    Indel(Option<Element>),
    #[doc = "SNP Comparison"]
    #[code = "snp"]
    Snp(Option<Element>),
    #[doc = "UNKNOWN Comparison"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QualityType {
    fn default() -> Self {
        QualityType::Null(None)
    }
}
impl TryFrom<String> for QualityType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "indel" => Ok(QualityType::Indel(None)),
            "snp" => Ok(QualityType::Snp(None)),
            "unknown" => Ok(QualityType::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QualityType {
    fn into(self) -> Option<String> {
        match self {
            QualityType::Indel(_) => Some("indel".to_string()),
            QualityType::Snp(_) => Some("snp".to_string()),
            QualityType::Unknown(_) => Some("unknown".to_string()),
            QualityType::Null(_) => None,
        }
    }
}
impl MetaValue for QualityType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QualityType::Indel(Some(e)) => e.get_field(field),
                QualityType::Snp(Some(e)) => e.get_field(field),
                QualityType::Unknown(Some(e)) => e.get_field(field),
                QualityType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QualityType::Indel(Some(e)) => e.get_field_mut(field),
                QualityType::Snp(Some(e)) => e.get_field_mut(field),
                QualityType::Unknown(Some(e)) => e.get_field_mut(field),
                QualityType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuantityComparator {
    #[doc = "Less than"]
    #[code = "<"]
    Greater(Option<Element>),
    #[doc = "Less or Equal to"]
    #[code = "<="]
    GreaterEqual(Option<Element>),
    #[doc = "Greater than"]
    #[code = ">"]
    Less(Option<Element>),
    #[doc = "Greater or Equal to"]
    #[code = ">="]
    LessEqual(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuantityComparator {
    fn default() -> Self {
        QuantityComparator::Null(None)
    }
}
impl TryFrom<String> for QuantityComparator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "<" => Ok(QuantityComparator::Greater(None)),
            "<=" => Ok(QuantityComparator::GreaterEqual(None)),
            ">" => Ok(QuantityComparator::Less(None)),
            ">=" => Ok(QuantityComparator::LessEqual(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuantityComparator {
    fn into(self) -> Option<String> {
        match self {
            QuantityComparator::Greater(_) => Some("<".to_string()),
            QuantityComparator::GreaterEqual(_) => Some("<=".to_string()),
            QuantityComparator::Less(_) => Some(">".to_string()),
            QuantityComparator::LessEqual(_) => Some(">=".to_string()),
            QuantityComparator::Null(_) => None,
        }
    }
}
impl MetaValue for QuantityComparator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuantityComparator::Greater(Some(e)) => e.get_field(field),
                QuantityComparator::GreaterEqual(Some(e)) => e.get_field(field),
                QuantityComparator::Less(Some(e)) => e.get_field(field),
                QuantityComparator::LessEqual(Some(e)) => e.get_field(field),
                QuantityComparator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuantityComparator::Greater(Some(e)) => e.get_field_mut(field),
                QuantityComparator::GreaterEqual(Some(e)) => e.get_field_mut(field),
                QuantityComparator::Less(Some(e)) => e.get_field_mut(field),
                QuantityComparator::LessEqual(Some(e)) => e.get_field_mut(field),
                QuantityComparator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionMaxOccurs {
    #[doc = "Repeating"]
    #[code = "*"]
    Star(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionMaxOccurs {
    fn default() -> Self {
        QuestionMaxOccurs::Null(None)
    }
}
impl TryFrom<String> for QuestionMaxOccurs {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "*" => Ok(QuestionMaxOccurs::Star(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionMaxOccurs {
    fn into(self) -> Option<String> {
        match self {
            QuestionMaxOccurs::Star(_) => Some("*".to_string()),
            QuestionMaxOccurs::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionMaxOccurs {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionMaxOccurs::Star(Some(e)) => e.get_field(field),
                QuestionMaxOccurs::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionMaxOccurs::Star(Some(e)) => e.get_field_mut(field),
                QuestionMaxOccurs::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireAnswersStatus {
    #[doc = "Amended"]
    #[code = "amended"]
    Amended(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireAnswersStatus {
    fn default() -> Self {
        QuestionnaireAnswersStatus::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireAnswersStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "amended" => Ok(QuestionnaireAnswersStatus::Amended(None)),
            "completed" => Ok(QuestionnaireAnswersStatus::Completed(None)),
            "entered-in-error" => Ok(QuestionnaireAnswersStatus::EnteredInError(None)),
            "in-progress" => Ok(QuestionnaireAnswersStatus::InProgress(None)),
            "stopped" => Ok(QuestionnaireAnswersStatus::Stopped(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireAnswersStatus {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireAnswersStatus::Amended(_) => Some("amended".to_string()),
            QuestionnaireAnswersStatus::Completed(_) => Some("completed".to_string()),
            QuestionnaireAnswersStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            QuestionnaireAnswersStatus::InProgress(_) => Some("in-progress".to_string()),
            QuestionnaireAnswersStatus::Stopped(_) => Some("stopped".to_string()),
            QuestionnaireAnswersStatus::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireAnswersStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireAnswersStatus::Amended(Some(e)) => e.get_field(field),
                QuestionnaireAnswersStatus::Completed(Some(e)) => e.get_field(field),
                QuestionnaireAnswersStatus::EnteredInError(Some(e)) => e.get_field(field),
                QuestionnaireAnswersStatus::InProgress(Some(e)) => e.get_field(field),
                QuestionnaireAnswersStatus::Stopped(Some(e)) => e.get_field(field),
                QuestionnaireAnswersStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireAnswersStatus::Amended(Some(e)) => e.get_field_mut(field),
                QuestionnaireAnswersStatus::Completed(Some(e)) => e.get_field_mut(field),
                QuestionnaireAnswersStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                QuestionnaireAnswersStatus::InProgress(Some(e)) => e.get_field_mut(field),
                QuestionnaireAnswersStatus::Stopped(Some(e)) => e.get_field_mut(field),
                QuestionnaireAnswersStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireCategory {
    #[doc = "Consumer satisfaction questionnaire"]
    #[code = "273384008"]
    V273384008(Option<Element>),
    #[doc = "General health questionnaire"]
    #[code = "273479001"]
    V273479001(Option<Element>),
    #[doc = "Mental status questionnaire"]
    #[code = "273601006"]
    V273601006(Option<Element>),
    #[doc = "Social support questionnaire"]
    #[code = "273820006"]
    V273820006(Option<Element>),
    #[doc = "Administrative form"]
    #[code = "304784009"]
    V304784009(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireCategory {
    fn default() -> Self {
        QuestionnaireCategory::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "273384008" => Ok(QuestionnaireCategory::V273384008(None)),
            "273479001" => Ok(QuestionnaireCategory::V273479001(None)),
            "273601006" => Ok(QuestionnaireCategory::V273601006(None)),
            "273820006" => Ok(QuestionnaireCategory::V273820006(None)),
            "304784009" => Ok(QuestionnaireCategory::V304784009(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireCategory {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireCategory::V273384008(_) => Some("273384008".to_string()),
            QuestionnaireCategory::V273479001(_) => Some("273479001".to_string()),
            QuestionnaireCategory::V273601006(_) => Some("273601006".to_string()),
            QuestionnaireCategory::V273820006(_) => Some("273820006".to_string()),
            QuestionnaireCategory::V304784009(_) => Some("304784009".to_string()),
            QuestionnaireCategory::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireCategory::V273384008(Some(e)) => e.get_field(field),
                QuestionnaireCategory::V273479001(Some(e)) => e.get_field(field),
                QuestionnaireCategory::V273601006(Some(e)) => e.get_field(field),
                QuestionnaireCategory::V273820006(Some(e)) => e.get_field(field),
                QuestionnaireCategory::V304784009(Some(e)) => e.get_field(field),
                QuestionnaireCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireCategory::V273384008(Some(e)) => e.get_field_mut(field),
                QuestionnaireCategory::V273479001(Some(e)) => e.get_field_mut(field),
                QuestionnaireCategory::V273601006(Some(e)) => e.get_field_mut(field),
                QuestionnaireCategory::V273820006(Some(e)) => e.get_field_mut(field),
                QuestionnaireCategory::V304784009(Some(e)) => e.get_field_mut(field),
                QuestionnaireCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireDisplayCategory {
    #[doc = "Help"]
    #[code = "help"]
    Help(Option<Element>),
    #[doc = "Instructions"]
    #[code = "instructions"]
    Instructions(Option<Element>),
    #[doc = "Security"]
    #[code = "security"]
    Security(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireDisplayCategory {
    fn default() -> Self {
        QuestionnaireDisplayCategory::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireDisplayCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "help" => Ok(QuestionnaireDisplayCategory::Help(None)),
            "instructions" => Ok(QuestionnaireDisplayCategory::Instructions(None)),
            "security" => Ok(QuestionnaireDisplayCategory::Security(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireDisplayCategory {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireDisplayCategory::Help(_) => Some("help".to_string()),
            QuestionnaireDisplayCategory::Instructions(_) => Some("instructions".to_string()),
            QuestionnaireDisplayCategory::Security(_) => Some("security".to_string()),
            QuestionnaireDisplayCategory::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireDisplayCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireDisplayCategory::Help(Some(e)) => e.get_field(field),
                QuestionnaireDisplayCategory::Instructions(Some(e)) => e.get_field(field),
                QuestionnaireDisplayCategory::Security(Some(e)) => e.get_field(field),
                QuestionnaireDisplayCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireDisplayCategory::Help(Some(e)) => e.get_field_mut(field),
                QuestionnaireDisplayCategory::Instructions(Some(e)) => e.get_field_mut(field),
                QuestionnaireDisplayCategory::Security(Some(e)) => e.get_field_mut(field),
                QuestionnaireDisplayCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireEnableBehavior {
    #[doc = "All"]
    #[code = "all"]
    All(Option<Element>),
    #[doc = "Any"]
    #[code = "any"]
    Any(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireEnableBehavior {
    fn default() -> Self {
        QuestionnaireEnableBehavior::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireEnableBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all" => Ok(QuestionnaireEnableBehavior::All(None)),
            "any" => Ok(QuestionnaireEnableBehavior::Any(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireEnableBehavior {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireEnableBehavior::All(_) => Some("all".to_string()),
            QuestionnaireEnableBehavior::Any(_) => Some("any".to_string()),
            QuestionnaireEnableBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireEnableBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireEnableBehavior::All(Some(e)) => e.get_field(field),
                QuestionnaireEnableBehavior::Any(Some(e)) => e.get_field(field),
                QuestionnaireEnableBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireEnableBehavior::All(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableBehavior::Any(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireEnableOperator {
    #[doc = "Not Equals"]
    #[code = "!="]
    NotEqual(Option<Element>),
    #[doc = "Less Than"]
    #[code = "<"]
    Greater(Option<Element>),
    #[doc = "Less or Equals"]
    #[code = "<="]
    GreaterEqual(Option<Element>),
    #[doc = "Equals"]
    #[code = "="]
    Equal(Option<Element>),
    #[doc = "Greater Than"]
    #[code = ">"]
    Less(Option<Element>),
    #[doc = "Greater or Equals"]
    #[code = ">="]
    LessEqual(Option<Element>),
    #[doc = "Exists"]
    #[code = "exists"]
    Exists(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireEnableOperator {
    fn default() -> Self {
        QuestionnaireEnableOperator::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireEnableOperator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "!=" => Ok(QuestionnaireEnableOperator::NotEqual(None)),
            "<" => Ok(QuestionnaireEnableOperator::Greater(None)),
            "<=" => Ok(QuestionnaireEnableOperator::GreaterEqual(None)),
            "=" => Ok(QuestionnaireEnableOperator::Equal(None)),
            ">" => Ok(QuestionnaireEnableOperator::Less(None)),
            ">=" => Ok(QuestionnaireEnableOperator::LessEqual(None)),
            "exists" => Ok(QuestionnaireEnableOperator::Exists(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireEnableOperator {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireEnableOperator::NotEqual(_) => Some("!=".to_string()),
            QuestionnaireEnableOperator::Greater(_) => Some("<".to_string()),
            QuestionnaireEnableOperator::GreaterEqual(_) => Some("<=".to_string()),
            QuestionnaireEnableOperator::Equal(_) => Some("=".to_string()),
            QuestionnaireEnableOperator::Less(_) => Some(">".to_string()),
            QuestionnaireEnableOperator::LessEqual(_) => Some(">=".to_string()),
            QuestionnaireEnableOperator::Exists(_) => Some("exists".to_string()),
            QuestionnaireEnableOperator::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireEnableOperator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireEnableOperator::NotEqual(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::Greater(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::GreaterEqual(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::Equal(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::Less(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::LessEqual(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::Exists(Some(e)) => e.get_field(field),
                QuestionnaireEnableOperator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireEnableOperator::NotEqual(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::Greater(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::GreaterEqual(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::Equal(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::Less(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::LessEqual(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::Exists(Some(e)) => e.get_field_mut(field),
                QuestionnaireEnableOperator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireItemControl {
    #[doc = "Answer Table"]
    #[code = "atable"]
    Atable(Option<Element>),
    #[doc = "Auto-complete"]
    #[code = "autocomplete"]
    Autocomplete(Option<Element>),
    #[doc = "Check-box"]
    #[code = "check-box"]
    CheckBox(Option<Element>),
    #[doc = "Drop down"]
    #[code = "drop-down"]
    DropDown(Option<Element>),
    #[doc = "Fly-over"]
    #[code = "flyover"]
    Flyover(Option<Element>),
    #[doc = "Footer"]
    #[code = "footer"]
    Footer(Option<Element>),
    #[code = "group"]
    Group(Option<Element>),
    #[doc = "Group Table"]
    #[code = "gtable"]
    Gtable(Option<Element>),
    #[doc = "Header"]
    #[code = "header"]
    Header(Option<Element>),
    #[doc = "Help-Button"]
    #[code = "help"]
    Help(Option<Element>),
    #[doc = "Horizontal Answer Table"]
    #[code = "htable"]
    Htable(Option<Element>),
    #[doc = "In-line"]
    #[code = "inline"]
    Inline(Option<Element>),
    #[doc = "List"]
    #[code = "list"]
    List(Option<Element>),
    #[doc = "Lookup"]
    #[code = "lookup"]
    Lookup(Option<Element>),
    #[doc = "Lower-bound"]
    #[code = "lower"]
    Lower(Option<Element>),
    #[doc = "Prompt"]
    #[code = "prompt"]
    Prompt(Option<Element>),
    #[code = "question"]
    Question(Option<Element>),
    #[doc = "Radio Button"]
    #[code = "radio-button"]
    RadioButton(Option<Element>),
    #[doc = "Slider"]
    #[code = "slider"]
    Slider(Option<Element>),
    #[doc = "Spinner"]
    #[code = "spinner"]
    Spinner(Option<Element>),
    #[doc = "Vertical Answer Table"]
    #[code = "table"]
    Table(Option<Element>),
    #[code = "text"]
    Text(Option<Element>),
    #[doc = "Text Box"]
    #[code = "text-box"]
    TextBox(Option<Element>),
    #[doc = "Unit"]
    #[code = "unit"]
    Unit(Option<Element>),
    #[doc = "Upper-bound"]
    #[code = "upper"]
    Upper(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireItemControl {
    fn default() -> Self {
        QuestionnaireItemControl::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireItemControl {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "atable" => Ok(QuestionnaireItemControl::Atable(None)),
            "autocomplete" => Ok(QuestionnaireItemControl::Autocomplete(None)),
            "check-box" => Ok(QuestionnaireItemControl::CheckBox(None)),
            "drop-down" => Ok(QuestionnaireItemControl::DropDown(None)),
            "flyover" => Ok(QuestionnaireItemControl::Flyover(None)),
            "footer" => Ok(QuestionnaireItemControl::Footer(None)),
            "group" => Ok(QuestionnaireItemControl::Group(None)),
            "gtable" => Ok(QuestionnaireItemControl::Gtable(None)),
            "header" => Ok(QuestionnaireItemControl::Header(None)),
            "help" => Ok(QuestionnaireItemControl::Help(None)),
            "htable" => Ok(QuestionnaireItemControl::Htable(None)),
            "inline" => Ok(QuestionnaireItemControl::Inline(None)),
            "list" => Ok(QuestionnaireItemControl::List(None)),
            "lookup" => Ok(QuestionnaireItemControl::Lookup(None)),
            "lower" => Ok(QuestionnaireItemControl::Lower(None)),
            "prompt" => Ok(QuestionnaireItemControl::Prompt(None)),
            "question" => Ok(QuestionnaireItemControl::Question(None)),
            "radio-button" => Ok(QuestionnaireItemControl::RadioButton(None)),
            "slider" => Ok(QuestionnaireItemControl::Slider(None)),
            "spinner" => Ok(QuestionnaireItemControl::Spinner(None)),
            "table" => Ok(QuestionnaireItemControl::Table(None)),
            "text" => Ok(QuestionnaireItemControl::Text(None)),
            "text-box" => Ok(QuestionnaireItemControl::TextBox(None)),
            "unit" => Ok(QuestionnaireItemControl::Unit(None)),
            "upper" => Ok(QuestionnaireItemControl::Upper(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireItemControl {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireItemControl::Atable(_) => Some("atable".to_string()),
            QuestionnaireItemControl::Autocomplete(_) => Some("autocomplete".to_string()),
            QuestionnaireItemControl::CheckBox(_) => Some("check-box".to_string()),
            QuestionnaireItemControl::DropDown(_) => Some("drop-down".to_string()),
            QuestionnaireItemControl::Flyover(_) => Some("flyover".to_string()),
            QuestionnaireItemControl::Footer(_) => Some("footer".to_string()),
            QuestionnaireItemControl::Group(_) => Some("group".to_string()),
            QuestionnaireItemControl::Gtable(_) => Some("gtable".to_string()),
            QuestionnaireItemControl::Header(_) => Some("header".to_string()),
            QuestionnaireItemControl::Help(_) => Some("help".to_string()),
            QuestionnaireItemControl::Htable(_) => Some("htable".to_string()),
            QuestionnaireItemControl::Inline(_) => Some("inline".to_string()),
            QuestionnaireItemControl::List(_) => Some("list".to_string()),
            QuestionnaireItemControl::Lookup(_) => Some("lookup".to_string()),
            QuestionnaireItemControl::Lower(_) => Some("lower".to_string()),
            QuestionnaireItemControl::Prompt(_) => Some("prompt".to_string()),
            QuestionnaireItemControl::Question(_) => Some("question".to_string()),
            QuestionnaireItemControl::RadioButton(_) => Some("radio-button".to_string()),
            QuestionnaireItemControl::Slider(_) => Some("slider".to_string()),
            QuestionnaireItemControl::Spinner(_) => Some("spinner".to_string()),
            QuestionnaireItemControl::Table(_) => Some("table".to_string()),
            QuestionnaireItemControl::Text(_) => Some("text".to_string()),
            QuestionnaireItemControl::TextBox(_) => Some("text-box".to_string()),
            QuestionnaireItemControl::Unit(_) => Some("unit".to_string()),
            QuestionnaireItemControl::Upper(_) => Some("upper".to_string()),
            QuestionnaireItemControl::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireItemControl {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireItemControl::Atable(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Autocomplete(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::CheckBox(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::DropDown(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Flyover(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Footer(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Group(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Gtable(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Header(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Help(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Htable(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Inline(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::List(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Lookup(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Lower(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Prompt(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Question(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::RadioButton(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Slider(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Spinner(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Table(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Text(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::TextBox(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Unit(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Upper(Some(e)) => e.get_field(field),
                QuestionnaireItemControl::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireItemControl::Atable(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Autocomplete(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::CheckBox(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::DropDown(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Flyover(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Footer(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Group(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Gtable(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Header(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Help(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Htable(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Inline(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::List(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Lookup(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Lower(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Prompt(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Question(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::RadioButton(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Slider(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Spinner(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Table(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Text(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::TextBox(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Unit(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Upper(Some(e)) => e.get_field_mut(field),
                QuestionnaireItemControl::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireUsageMode {
    #[doc = "Capture Only"]
    #[code = "capture"]
    Capture(Option<Element>),
    #[doc = "Capture & Display"]
    #[code = "capture-display"]
    CaptureDisplay(Option<Element>),
    #[doc = "Capture or, if answered, Display"]
    #[code = "capture-display-non-empty"]
    CaptureDisplayNonEmpty(Option<Element>),
    #[doc = "Display Only"]
    #[code = "display"]
    Display(Option<Element>),
    #[doc = "Display when Answered"]
    #[code = "display-non-empty"]
    DisplayNonEmpty(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireUsageMode {
    fn default() -> Self {
        QuestionnaireUsageMode::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireUsageMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "capture" => Ok(QuestionnaireUsageMode::Capture(None)),
            "capture-display" => Ok(QuestionnaireUsageMode::CaptureDisplay(None)),
            "capture-display-non-empty" => Ok(QuestionnaireUsageMode::CaptureDisplayNonEmpty(None)),
            "display" => Ok(QuestionnaireUsageMode::Display(None)),
            "display-non-empty" => Ok(QuestionnaireUsageMode::DisplayNonEmpty(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireUsageMode {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireUsageMode::Capture(_) => Some("capture".to_string()),
            QuestionnaireUsageMode::CaptureDisplay(_) => Some("capture-display".to_string()),
            QuestionnaireUsageMode::CaptureDisplayNonEmpty(_) => {
                Some("capture-display-non-empty".to_string())
            }
            QuestionnaireUsageMode::Display(_) => Some("display".to_string()),
            QuestionnaireUsageMode::DisplayNonEmpty(_) => Some("display-non-empty".to_string()),
            QuestionnaireUsageMode::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireUsageMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireUsageMode::Capture(Some(e)) => e.get_field(field),
                QuestionnaireUsageMode::CaptureDisplay(Some(e)) => e.get_field(field),
                QuestionnaireUsageMode::CaptureDisplayNonEmpty(Some(e)) => e.get_field(field),
                QuestionnaireUsageMode::Display(Some(e)) => e.get_field(field),
                QuestionnaireUsageMode::DisplayNonEmpty(Some(e)) => e.get_field(field),
                QuestionnaireUsageMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireUsageMode::Capture(Some(e)) => e.get_field_mut(field),
                QuestionnaireUsageMode::CaptureDisplay(Some(e)) => e.get_field_mut(field),
                QuestionnaireUsageMode::CaptureDisplayNonEmpty(Some(e)) => e.get_field_mut(field),
                QuestionnaireUsageMode::Display(Some(e)) => e.get_field_mut(field),
                QuestionnaireUsageMode::DisplayNonEmpty(Some(e)) => e.get_field_mut(field),
                QuestionnaireUsageMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum QuestionnaireresponseMode {
    #[code = "ELECTRONIC"]
    ELECTRONIC(Option<Element>),
    #[code = "VERBAL"]
    VERBAL(Option<Element>),
    #[code = "WRITTEN"]
    WRITTEN(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for QuestionnaireresponseMode {
    fn default() -> Self {
        QuestionnaireresponseMode::Null(None)
    }
}
impl TryFrom<String> for QuestionnaireresponseMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ELECTRONIC" => Ok(QuestionnaireresponseMode::ELECTRONIC(None)),
            "VERBAL" => Ok(QuestionnaireresponseMode::VERBAL(None)),
            "WRITTEN" => Ok(QuestionnaireresponseMode::WRITTEN(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &QuestionnaireresponseMode {
    fn into(self) -> Option<String> {
        match self {
            QuestionnaireresponseMode::ELECTRONIC(_) => Some("ELECTRONIC".to_string()),
            QuestionnaireresponseMode::VERBAL(_) => Some("VERBAL".to_string()),
            QuestionnaireresponseMode::WRITTEN(_) => Some("WRITTEN".to_string()),
            QuestionnaireresponseMode::Null(_) => None,
        }
    }
}
impl MetaValue for QuestionnaireresponseMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                QuestionnaireresponseMode::ELECTRONIC(Some(e)) => e.get_field(field),
                QuestionnaireresponseMode::VERBAL(Some(e)) => e.get_field(field),
                QuestionnaireresponseMode::WRITTEN(Some(e)) => e.get_field(field),
                QuestionnaireresponseMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                QuestionnaireresponseMode::ELECTRONIC(Some(e)) => e.get_field_mut(field),
                QuestionnaireresponseMode::VERBAL(Some(e)) => e.get_field_mut(field),
                QuestionnaireresponseMode::WRITTEN(Some(e)) => e.get_field_mut(field),
                QuestionnaireresponseMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReactionEventCertainty {
    #[doc = "Confirmed"]
    #[code = "confirmed"]
    Confirmed(Option<Element>),
    #[doc = "Likely"]
    #[code = "likely"]
    Likely(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "Unlikely"]
    #[code = "unlikely"]
    Unlikely(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReactionEventCertainty {
    fn default() -> Self {
        ReactionEventCertainty::Null(None)
    }
}
impl TryFrom<String> for ReactionEventCertainty {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "confirmed" => Ok(ReactionEventCertainty::Confirmed(None)),
            "likely" => Ok(ReactionEventCertainty::Likely(None)),
            "unknown" => Ok(ReactionEventCertainty::Unknown(None)),
            "unlikely" => Ok(ReactionEventCertainty::Unlikely(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReactionEventCertainty {
    fn into(self) -> Option<String> {
        match self {
            ReactionEventCertainty::Confirmed(_) => Some("confirmed".to_string()),
            ReactionEventCertainty::Likely(_) => Some("likely".to_string()),
            ReactionEventCertainty::Unknown(_) => Some("unknown".to_string()),
            ReactionEventCertainty::Unlikely(_) => Some("unlikely".to_string()),
            ReactionEventCertainty::Null(_) => None,
        }
    }
}
impl MetaValue for ReactionEventCertainty {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReactionEventCertainty::Confirmed(Some(e)) => e.get_field(field),
                ReactionEventCertainty::Likely(Some(e)) => e.get_field(field),
                ReactionEventCertainty::Unknown(Some(e)) => e.get_field(field),
                ReactionEventCertainty::Unlikely(Some(e)) => e.get_field(field),
                ReactionEventCertainty::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReactionEventCertainty::Confirmed(Some(e)) => e.get_field_mut(field),
                ReactionEventCertainty::Likely(Some(e)) => e.get_field_mut(field),
                ReactionEventCertainty::Unknown(Some(e)) => e.get_field_mut(field),
                ReactionEventCertainty::Unlikely(Some(e)) => e.get_field_mut(field),
                ReactionEventCertainty::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReactionEventSeverity {
    #[doc = "Mild"]
    #[code = "mild"]
    Mild(Option<Element>),
    #[doc = "Moderate"]
    #[code = "moderate"]
    Moderate(Option<Element>),
    #[doc = "Severe"]
    #[code = "severe"]
    Severe(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReactionEventSeverity {
    fn default() -> Self {
        ReactionEventSeverity::Null(None)
    }
}
impl TryFrom<String> for ReactionEventSeverity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "mild" => Ok(ReactionEventSeverity::Mild(None)),
            "moderate" => Ok(ReactionEventSeverity::Moderate(None)),
            "severe" => Ok(ReactionEventSeverity::Severe(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReactionEventSeverity {
    fn into(self) -> Option<String> {
        match self {
            ReactionEventSeverity::Mild(_) => Some("mild".to_string()),
            ReactionEventSeverity::Moderate(_) => Some("moderate".to_string()),
            ReactionEventSeverity::Severe(_) => Some("severe".to_string()),
            ReactionEventSeverity::Null(_) => None,
        }
    }
}
impl MetaValue for ReactionEventSeverity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReactionEventSeverity::Mild(Some(e)) => e.get_field(field),
                ReactionEventSeverity::Moderate(Some(e)) => e.get_field(field),
                ReactionEventSeverity::Severe(Some(e)) => e.get_field(field),
                ReactionEventSeverity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReactionEventSeverity::Mild(Some(e)) => e.get_field_mut(field),
                ReactionEventSeverity::Moderate(Some(e)) => e.get_field_mut(field),
                ReactionEventSeverity::Severe(Some(e)) => e.get_field_mut(field),
                ReactionEventSeverity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReasonMedicationGivenCodes {
    #[doc = "None"]
    #[code = "a"]
    A(Option<Element>),
    #[doc = "Given as Ordered"]
    #[code = "b"]
    B(Option<Element>),
    #[doc = "Emergency"]
    #[code = "c"]
    C(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReasonMedicationGivenCodes {
    fn default() -> Self {
        ReasonMedicationGivenCodes::Null(None)
    }
}
impl TryFrom<String> for ReasonMedicationGivenCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a" => Ok(ReasonMedicationGivenCodes::A(None)),
            "b" => Ok(ReasonMedicationGivenCodes::B(None)),
            "c" => Ok(ReasonMedicationGivenCodes::C(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReasonMedicationGivenCodes {
    fn into(self) -> Option<String> {
        match self {
            ReasonMedicationGivenCodes::A(_) => Some("a".to_string()),
            ReasonMedicationGivenCodes::B(_) => Some("b".to_string()),
            ReasonMedicationGivenCodes::C(_) => Some("c".to_string()),
            ReasonMedicationGivenCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ReasonMedicationGivenCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReasonMedicationGivenCodes::A(Some(e)) => e.get_field(field),
                ReasonMedicationGivenCodes::B(Some(e)) => e.get_field(field),
                ReasonMedicationGivenCodes::C(Some(e)) => e.get_field(field),
                ReasonMedicationGivenCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReasonMedicationGivenCodes::A(Some(e)) => e.get_field_mut(field),
                ReasonMedicationGivenCodes::B(Some(e)) => e.get_field_mut(field),
                ReasonMedicationGivenCodes::C(Some(e)) => e.get_field_mut(field),
                ReasonMedicationGivenCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RecommendationStrength {
    #[doc = "Strong"]
    #[code = "strong"]
    Strong(Option<Element>),
    #[doc = "Weak"]
    #[code = "weak"]
    Weak(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RecommendationStrength {
    fn default() -> Self {
        RecommendationStrength::Null(None)
    }
}
impl TryFrom<String> for RecommendationStrength {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "strong" => Ok(RecommendationStrength::Strong(None)),
            "weak" => Ok(RecommendationStrength::Weak(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RecommendationStrength {
    fn into(self) -> Option<String> {
        match self {
            RecommendationStrength::Strong(_) => Some("strong".to_string()),
            RecommendationStrength::Weak(_) => Some("weak".to_string()),
            RecommendationStrength::Null(_) => None,
        }
    }
}
impl MetaValue for RecommendationStrength {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RecommendationStrength::Strong(Some(e)) => e.get_field(field),
                RecommendationStrength::Weak(Some(e)) => e.get_field(field),
                RecommendationStrength::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RecommendationStrength::Strong(Some(e)) => e.get_field_mut(field),
                RecommendationStrength::Weak(Some(e)) => e.get_field_mut(field),
                RecommendationStrength::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReferenceHandlingPolicy {
    #[doc = "Reference Integrity Enforced"]
    #[code = "enforced"]
    Enforced(Option<Element>),
    #[doc = "Literal References"]
    #[code = "literal"]
    Literal(Option<Element>),
    #[doc = "Local References Only"]
    #[code = "local"]
    Local(Option<Element>),
    #[doc = "Logical References"]
    #[code = "logical"]
    Logical(Option<Element>),
    #[doc = "Resolves References"]
    #[code = "resolves"]
    Resolves(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReferenceHandlingPolicy {
    fn default() -> Self {
        ReferenceHandlingPolicy::Null(None)
    }
}
impl TryFrom<String> for ReferenceHandlingPolicy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "enforced" => Ok(ReferenceHandlingPolicy::Enforced(None)),
            "literal" => Ok(ReferenceHandlingPolicy::Literal(None)),
            "local" => Ok(ReferenceHandlingPolicy::Local(None)),
            "logical" => Ok(ReferenceHandlingPolicy::Logical(None)),
            "resolves" => Ok(ReferenceHandlingPolicy::Resolves(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReferenceHandlingPolicy {
    fn into(self) -> Option<String> {
        match self {
            ReferenceHandlingPolicy::Enforced(_) => Some("enforced".to_string()),
            ReferenceHandlingPolicy::Literal(_) => Some("literal".to_string()),
            ReferenceHandlingPolicy::Local(_) => Some("local".to_string()),
            ReferenceHandlingPolicy::Logical(_) => Some("logical".to_string()),
            ReferenceHandlingPolicy::Resolves(_) => Some("resolves".to_string()),
            ReferenceHandlingPolicy::Null(_) => None,
        }
    }
}
impl MetaValue for ReferenceHandlingPolicy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReferenceHandlingPolicy::Enforced(Some(e)) => e.get_field(field),
                ReferenceHandlingPolicy::Literal(Some(e)) => e.get_field(field),
                ReferenceHandlingPolicy::Local(Some(e)) => e.get_field(field),
                ReferenceHandlingPolicy::Logical(Some(e)) => e.get_field(field),
                ReferenceHandlingPolicy::Resolves(Some(e)) => e.get_field(field),
                ReferenceHandlingPolicy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReferenceHandlingPolicy::Enforced(Some(e)) => e.get_field_mut(field),
                ReferenceHandlingPolicy::Literal(Some(e)) => e.get_field_mut(field),
                ReferenceHandlingPolicy::Local(Some(e)) => e.get_field_mut(field),
                ReferenceHandlingPolicy::Logical(Some(e)) => e.get_field_mut(field),
                ReferenceHandlingPolicy::Resolves(Some(e)) => e.get_field_mut(field),
                ReferenceHandlingPolicy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReferenceVersionRules {
    #[doc = "Either Specific or independent"]
    #[code = "either"]
    Either(Option<Element>),
    #[doc = "Version independent"]
    #[code = "independent"]
    Independent(Option<Element>),
    #[doc = "Version Specific"]
    #[code = "specific"]
    Specific(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReferenceVersionRules {
    fn default() -> Self {
        ReferenceVersionRules::Null(None)
    }
}
impl TryFrom<String> for ReferenceVersionRules {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "either" => Ok(ReferenceVersionRules::Either(None)),
            "independent" => Ok(ReferenceVersionRules::Independent(None)),
            "specific" => Ok(ReferenceVersionRules::Specific(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReferenceVersionRules {
    fn into(self) -> Option<String> {
        match self {
            ReferenceVersionRules::Either(_) => Some("either".to_string()),
            ReferenceVersionRules::Independent(_) => Some("independent".to_string()),
            ReferenceVersionRules::Specific(_) => Some("specific".to_string()),
            ReferenceVersionRules::Null(_) => None,
        }
    }
}
impl MetaValue for ReferenceVersionRules {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReferenceVersionRules::Either(Some(e)) => e.get_field(field),
                ReferenceVersionRules::Independent(Some(e)) => e.get_field(field),
                ReferenceVersionRules::Specific(Some(e)) => e.get_field(field),
                ReferenceVersionRules::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReferenceVersionRules::Either(Some(e)) => e.get_field_mut(field),
                ReferenceVersionRules::Independent(Some(e)) => e.get_field_mut(field),
                ReferenceVersionRules::Specific(Some(e)) => e.get_field_mut(field),
                ReferenceVersionRules::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReferencerangeMeaning {
    #[doc = "Endocrine"]
    #[code = "endocrine"]
    Endocrine(Option<Element>),
    #[doc = "Follicular Stage"]
    #[code = "follicular"]
    Follicular(Option<Element>),
    #[doc = "Luteal"]
    #[code = "luteal"]
    Luteal(Option<Element>),
    #[doc = "MidCycle"]
    #[code = "midcycle"]
    Midcycle(Option<Element>),
    #[doc = "Normal Range"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "Post Therapeutic Desired Level"]
    #[code = "post"]
    Post(Option<Element>),
    #[doc = "Post-Menopause"]
    #[code = "postmenopausal"]
    Postmenopausal(Option<Element>),
    #[doc = "Pre Therapeutic Desired Level"]
    #[code = "pre"]
    Pre(Option<Element>),
    #[doc = "Pre-Puberty"]
    #[code = "pre-puberty"]
    PrePuberty(Option<Element>),
    #[doc = "Recommended Range"]
    #[code = "recommended"]
    Recommended(Option<Element>),
    #[doc = "Therapeutic Desired Level"]
    #[code = "therapeutic"]
    Therapeutic(Option<Element>),
    #[doc = "Treatment Range"]
    #[code = "treatment"]
    Treatment(Option<Element>),
    #[doc = "Type"]
    #[code = "type"]
    Type(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReferencerangeMeaning {
    fn default() -> Self {
        ReferencerangeMeaning::Null(None)
    }
}
impl TryFrom<String> for ReferencerangeMeaning {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "endocrine" => Ok(ReferencerangeMeaning::Endocrine(None)),
            "follicular" => Ok(ReferencerangeMeaning::Follicular(None)),
            "luteal" => Ok(ReferencerangeMeaning::Luteal(None)),
            "midcycle" => Ok(ReferencerangeMeaning::Midcycle(None)),
            "normal" => Ok(ReferencerangeMeaning::Normal(None)),
            "post" => Ok(ReferencerangeMeaning::Post(None)),
            "postmenopausal" => Ok(ReferencerangeMeaning::Postmenopausal(None)),
            "pre" => Ok(ReferencerangeMeaning::Pre(None)),
            "pre-puberty" => Ok(ReferencerangeMeaning::PrePuberty(None)),
            "recommended" => Ok(ReferencerangeMeaning::Recommended(None)),
            "therapeutic" => Ok(ReferencerangeMeaning::Therapeutic(None)),
            "treatment" => Ok(ReferencerangeMeaning::Treatment(None)),
            "type" => Ok(ReferencerangeMeaning::Type(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReferencerangeMeaning {
    fn into(self) -> Option<String> {
        match self {
            ReferencerangeMeaning::Endocrine(_) => Some("endocrine".to_string()),
            ReferencerangeMeaning::Follicular(_) => Some("follicular".to_string()),
            ReferencerangeMeaning::Luteal(_) => Some("luteal".to_string()),
            ReferencerangeMeaning::Midcycle(_) => Some("midcycle".to_string()),
            ReferencerangeMeaning::Normal(_) => Some("normal".to_string()),
            ReferencerangeMeaning::Post(_) => Some("post".to_string()),
            ReferencerangeMeaning::Postmenopausal(_) => Some("postmenopausal".to_string()),
            ReferencerangeMeaning::Pre(_) => Some("pre".to_string()),
            ReferencerangeMeaning::PrePuberty(_) => Some("pre-puberty".to_string()),
            ReferencerangeMeaning::Recommended(_) => Some("recommended".to_string()),
            ReferencerangeMeaning::Therapeutic(_) => Some("therapeutic".to_string()),
            ReferencerangeMeaning::Treatment(_) => Some("treatment".to_string()),
            ReferencerangeMeaning::Type(_) => Some("type".to_string()),
            ReferencerangeMeaning::Null(_) => None,
        }
    }
}
impl MetaValue for ReferencerangeMeaning {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReferencerangeMeaning::Endocrine(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Follicular(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Luteal(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Midcycle(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Normal(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Post(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Postmenopausal(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Pre(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::PrePuberty(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Recommended(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Therapeutic(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Treatment(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Type(Some(e)) => e.get_field(field),
                ReferencerangeMeaning::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReferencerangeMeaning::Endocrine(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Follicular(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Luteal(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Midcycle(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Normal(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Post(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Postmenopausal(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Pre(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::PrePuberty(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Recommended(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Therapeutic(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Treatment(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Type(Some(e)) => e.get_field_mut(field),
                ReferencerangeMeaning::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RejectionCriteria {
    #[doc = "broken specimen container"]
    #[code = "broken"]
    Broken(Option<Element>),
    #[doc = "specimen clotted"]
    #[code = "clotted"]
    Clotted(Option<Element>),
    #[doc = "hemolized specimen"]
    #[code = "hemolized"]
    Hemolized(Option<Element>),
    #[doc = "insufficient specimen volume"]
    #[code = "insufficient"]
    Insufficient(Option<Element>),
    #[doc = "specimen temperature inappropriate"]
    #[code = "wrong-temperature"]
    WrongTemperature(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RejectionCriteria {
    fn default() -> Self {
        RejectionCriteria::Null(None)
    }
}
impl TryFrom<String> for RejectionCriteria {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "broken" => Ok(RejectionCriteria::Broken(None)),
            "clotted" => Ok(RejectionCriteria::Clotted(None)),
            "hemolized" => Ok(RejectionCriteria::Hemolized(None)),
            "insufficient" => Ok(RejectionCriteria::Insufficient(None)),
            "wrong-temperature" => Ok(RejectionCriteria::WrongTemperature(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RejectionCriteria {
    fn into(self) -> Option<String> {
        match self {
            RejectionCriteria::Broken(_) => Some("broken".to_string()),
            RejectionCriteria::Clotted(_) => Some("clotted".to_string()),
            RejectionCriteria::Hemolized(_) => Some("hemolized".to_string()),
            RejectionCriteria::Insufficient(_) => Some("insufficient".to_string()),
            RejectionCriteria::WrongTemperature(_) => Some("wrong-temperature".to_string()),
            RejectionCriteria::Null(_) => None,
        }
    }
}
impl MetaValue for RejectionCriteria {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RejectionCriteria::Broken(Some(e)) => e.get_field(field),
                RejectionCriteria::Clotted(Some(e)) => e.get_field(field),
                RejectionCriteria::Hemolized(Some(e)) => e.get_field(field),
                RejectionCriteria::Insufficient(Some(e)) => e.get_field(field),
                RejectionCriteria::WrongTemperature(Some(e)) => e.get_field(field),
                RejectionCriteria::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RejectionCriteria::Broken(Some(e)) => e.get_field_mut(field),
                RejectionCriteria::Clotted(Some(e)) => e.get_field_mut(field),
                RejectionCriteria::Hemolized(Some(e)) => e.get_field_mut(field),
                RejectionCriteria::Insufficient(Some(e)) => e.get_field_mut(field),
                RejectionCriteria::WrongTemperature(Some(e)) => e.get_field_mut(field),
                RejectionCriteria::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RelatedArtifactType {
    #[doc = "Citation"]
    #[code = "citation"]
    Citation(Option<Element>),
    #[doc = "Composed Of"]
    #[code = "composed-of"]
    ComposedOf(Option<Element>),
    #[doc = "Depends On"]
    #[code = "depends-on"]
    DependsOn(Option<Element>),
    #[doc = "Derived From"]
    #[code = "derived-from"]
    DerivedFrom(Option<Element>),
    #[doc = "Documentation"]
    #[code = "documentation"]
    Documentation(Option<Element>),
    #[doc = "Justification"]
    #[code = "justification"]
    Justification(Option<Element>),
    #[doc = "Predecessor"]
    #[code = "predecessor"]
    Predecessor(Option<Element>),
    #[doc = "Successor"]
    #[code = "successor"]
    Successor(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RelatedArtifactType {
    fn default() -> Self {
        RelatedArtifactType::Null(None)
    }
}
impl TryFrom<String> for RelatedArtifactType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "citation" => Ok(RelatedArtifactType::Citation(None)),
            "composed-of" => Ok(RelatedArtifactType::ComposedOf(None)),
            "depends-on" => Ok(RelatedArtifactType::DependsOn(None)),
            "derived-from" => Ok(RelatedArtifactType::DerivedFrom(None)),
            "documentation" => Ok(RelatedArtifactType::Documentation(None)),
            "justification" => Ok(RelatedArtifactType::Justification(None)),
            "predecessor" => Ok(RelatedArtifactType::Predecessor(None)),
            "successor" => Ok(RelatedArtifactType::Successor(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RelatedArtifactType {
    fn into(self) -> Option<String> {
        match self {
            RelatedArtifactType::Citation(_) => Some("citation".to_string()),
            RelatedArtifactType::ComposedOf(_) => Some("composed-of".to_string()),
            RelatedArtifactType::DependsOn(_) => Some("depends-on".to_string()),
            RelatedArtifactType::DerivedFrom(_) => Some("derived-from".to_string()),
            RelatedArtifactType::Documentation(_) => Some("documentation".to_string()),
            RelatedArtifactType::Justification(_) => Some("justification".to_string()),
            RelatedArtifactType::Predecessor(_) => Some("predecessor".to_string()),
            RelatedArtifactType::Successor(_) => Some("successor".to_string()),
            RelatedArtifactType::Null(_) => None,
        }
    }
}
impl MetaValue for RelatedArtifactType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RelatedArtifactType::Citation(Some(e)) => e.get_field(field),
                RelatedArtifactType::ComposedOf(Some(e)) => e.get_field(field),
                RelatedArtifactType::DependsOn(Some(e)) => e.get_field(field),
                RelatedArtifactType::DerivedFrom(Some(e)) => e.get_field(field),
                RelatedArtifactType::Documentation(Some(e)) => e.get_field(field),
                RelatedArtifactType::Justification(Some(e)) => e.get_field(field),
                RelatedArtifactType::Predecessor(Some(e)) => e.get_field(field),
                RelatedArtifactType::Successor(Some(e)) => e.get_field(field),
                RelatedArtifactType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RelatedArtifactType::Citation(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::ComposedOf(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::DependsOn(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::DerivedFrom(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::Documentation(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::Justification(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::Predecessor(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::Successor(Some(e)) => e.get_field_mut(field),
                RelatedArtifactType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RelatedClaimRelationship {
    #[doc = "Associated Claim"]
    #[code = "associated"]
    Associated(Option<Element>),
    #[doc = "Prior Claim"]
    #[code = "prior"]
    Prior(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RelatedClaimRelationship {
    fn default() -> Self {
        RelatedClaimRelationship::Null(None)
    }
}
impl TryFrom<String> for RelatedClaimRelationship {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "associated" => Ok(RelatedClaimRelationship::Associated(None)),
            "prior" => Ok(RelatedClaimRelationship::Prior(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RelatedClaimRelationship {
    fn into(self) -> Option<String> {
        match self {
            RelatedClaimRelationship::Associated(_) => Some("associated".to_string()),
            RelatedClaimRelationship::Prior(_) => Some("prior".to_string()),
            RelatedClaimRelationship::Null(_) => None,
        }
    }
}
impl MetaValue for RelatedClaimRelationship {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RelatedClaimRelationship::Associated(Some(e)) => e.get_field(field),
                RelatedClaimRelationship::Prior(Some(e)) => e.get_field(field),
                RelatedClaimRelationship::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RelatedClaimRelationship::Associated(Some(e)) => e.get_field_mut(field),
                RelatedClaimRelationship::Prior(Some(e)) => e.get_field_mut(field),
                RelatedClaimRelationship::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RelationType {
    #[doc = "Replaced By"]
    #[code = "is-replaced-by"]
    IsReplacedBy(Option<Element>),
    #[doc = "Triggers"]
    #[code = "triggers"]
    Triggers(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RelationType {
    fn default() -> Self {
        RelationType::Null(None)
    }
}
impl TryFrom<String> for RelationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "is-replaced-by" => Ok(RelationType::IsReplacedBy(None)),
            "triggers" => Ok(RelationType::Triggers(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RelationType {
    fn into(self) -> Option<String> {
        match self {
            RelationType::IsReplacedBy(_) => Some("is-replaced-by".to_string()),
            RelationType::Triggers(_) => Some("triggers".to_string()),
            RelationType::Null(_) => None,
        }
    }
}
impl MetaValue for RelationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RelationType::IsReplacedBy(Some(e)) => e.get_field(field),
                RelationType::Triggers(Some(e)) => e.get_field(field),
                RelationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RelationType::IsReplacedBy(Some(e)) => e.get_field_mut(field),
                RelationType::Triggers(Some(e)) => e.get_field_mut(field),
                RelationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Relationship {
    #[doc = "Self"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Spouse"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Child"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Common Law Spouse"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Other"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Relationship {
    fn default() -> Self {
        Relationship::Null(None)
    }
}
impl TryFrom<String> for Relationship {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(Relationship::V1(None)),
            "2" => Ok(Relationship::V2(None)),
            "3" => Ok(Relationship::V3(None)),
            "4" => Ok(Relationship::V4(None)),
            "5" => Ok(Relationship::V5(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Relationship {
    fn into(self) -> Option<String> {
        match self {
            Relationship::V1(_) => Some("1".to_string()),
            Relationship::V2(_) => Some("2".to_string()),
            Relationship::V3(_) => Some("3".to_string()),
            Relationship::V4(_) => Some("4".to_string()),
            Relationship::V5(_) => Some("5".to_string()),
            Relationship::Null(_) => None,
        }
    }
}
impl MetaValue for Relationship {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Relationship::V1(Some(e)) => e.get_field(field),
                Relationship::V2(Some(e)) => e.get_field(field),
                Relationship::V3(Some(e)) => e.get_field(field),
                Relationship::V4(Some(e)) => e.get_field(field),
                Relationship::V5(Some(e)) => e.get_field(field),
                Relationship::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Relationship::V1(Some(e)) => e.get_field_mut(field),
                Relationship::V2(Some(e)) => e.get_field_mut(field),
                Relationship::V3(Some(e)) => e.get_field_mut(field),
                Relationship::V4(Some(e)) => e.get_field_mut(field),
                Relationship::V5(Some(e)) => e.get_field_mut(field),
                Relationship::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RemittanceOutcome {
    #[doc = "Processing Complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Partial Processing"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "Queued"]
    #[code = "queued"]
    Queued(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RemittanceOutcome {
    fn default() -> Self {
        RemittanceOutcome::Null(None)
    }
}
impl TryFrom<String> for RemittanceOutcome {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complete" => Ok(RemittanceOutcome::Complete(None)),
            "error" => Ok(RemittanceOutcome::Error(None)),
            "partial" => Ok(RemittanceOutcome::Partial(None)),
            "queued" => Ok(RemittanceOutcome::Queued(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RemittanceOutcome {
    fn into(self) -> Option<String> {
        match self {
            RemittanceOutcome::Complete(_) => Some("complete".to_string()),
            RemittanceOutcome::Error(_) => Some("error".to_string()),
            RemittanceOutcome::Partial(_) => Some("partial".to_string()),
            RemittanceOutcome::Queued(_) => Some("queued".to_string()),
            RemittanceOutcome::Null(_) => None,
        }
    }
}
impl MetaValue for RemittanceOutcome {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RemittanceOutcome::Complete(Some(e)) => e.get_field(field),
                RemittanceOutcome::Error(Some(e)) => e.get_field(field),
                RemittanceOutcome::Partial(Some(e)) => e.get_field(field),
                RemittanceOutcome::Queued(Some(e)) => e.get_field(field),
                RemittanceOutcome::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RemittanceOutcome::Complete(Some(e)) => e.get_field_mut(field),
                RemittanceOutcome::Error(Some(e)) => e.get_field_mut(field),
                RemittanceOutcome::Partial(Some(e)) => e.get_field_mut(field),
                RemittanceOutcome::Queued(Some(e)) => e.get_field_mut(field),
                RemittanceOutcome::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReportActionResultCodes {
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Fail"]
    #[code = "fail"]
    Fail(Option<Element>),
    #[doc = "Pass"]
    #[code = "pass"]
    Pass(Option<Element>),
    #[doc = "Skip"]
    #[code = "skip"]
    Skip(Option<Element>),
    #[doc = "Warning"]
    #[code = "warning"]
    Warning(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReportActionResultCodes {
    fn default() -> Self {
        ReportActionResultCodes::Null(None)
    }
}
impl TryFrom<String> for ReportActionResultCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "error" => Ok(ReportActionResultCodes::Error(None)),
            "fail" => Ok(ReportActionResultCodes::Fail(None)),
            "pass" => Ok(ReportActionResultCodes::Pass(None)),
            "skip" => Ok(ReportActionResultCodes::Skip(None)),
            "warning" => Ok(ReportActionResultCodes::Warning(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReportActionResultCodes {
    fn into(self) -> Option<String> {
        match self {
            ReportActionResultCodes::Error(_) => Some("error".to_string()),
            ReportActionResultCodes::Fail(_) => Some("fail".to_string()),
            ReportActionResultCodes::Pass(_) => Some("pass".to_string()),
            ReportActionResultCodes::Skip(_) => Some("skip".to_string()),
            ReportActionResultCodes::Warning(_) => Some("warning".to_string()),
            ReportActionResultCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ReportActionResultCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReportActionResultCodes::Error(Some(e)) => e.get_field(field),
                ReportActionResultCodes::Fail(Some(e)) => e.get_field(field),
                ReportActionResultCodes::Pass(Some(e)) => e.get_field(field),
                ReportActionResultCodes::Skip(Some(e)) => e.get_field(field),
                ReportActionResultCodes::Warning(Some(e)) => e.get_field(field),
                ReportActionResultCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReportActionResultCodes::Error(Some(e)) => e.get_field_mut(field),
                ReportActionResultCodes::Fail(Some(e)) => e.get_field_mut(field),
                ReportActionResultCodes::Pass(Some(e)) => e.get_field_mut(field),
                ReportActionResultCodes::Skip(Some(e)) => e.get_field_mut(field),
                ReportActionResultCodes::Warning(Some(e)) => e.get_field_mut(field),
                ReportActionResultCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReportParticipantType {
    #[doc = "Client"]
    #[code = "client"]
    Client(Option<Element>),
    #[doc = "Server"]
    #[code = "server"]
    Server(Option<Element>),
    #[doc = "Test Engine"]
    #[code = "test-engine"]
    TestEngine(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReportParticipantType {
    fn default() -> Self {
        ReportParticipantType::Null(None)
    }
}
impl TryFrom<String> for ReportParticipantType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "client" => Ok(ReportParticipantType::Client(None)),
            "server" => Ok(ReportParticipantType::Server(None)),
            "test-engine" => Ok(ReportParticipantType::TestEngine(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReportParticipantType {
    fn into(self) -> Option<String> {
        match self {
            ReportParticipantType::Client(_) => Some("client".to_string()),
            ReportParticipantType::Server(_) => Some("server".to_string()),
            ReportParticipantType::TestEngine(_) => Some("test-engine".to_string()),
            ReportParticipantType::Null(_) => None,
        }
    }
}
impl MetaValue for ReportParticipantType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReportParticipantType::Client(Some(e)) => e.get_field(field),
                ReportParticipantType::Server(Some(e)) => e.get_field(field),
                ReportParticipantType::TestEngine(Some(e)) => e.get_field(field),
                ReportParticipantType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReportParticipantType::Client(Some(e)) => e.get_field_mut(field),
                ReportParticipantType::Server(Some(e)) => e.get_field_mut(field),
                ReportParticipantType::TestEngine(Some(e)) => e.get_field_mut(field),
                ReportParticipantType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReportResultCodes {
    #[doc = "Fail"]
    #[code = "fail"]
    Fail(Option<Element>),
    #[doc = "Pass"]
    #[code = "pass"]
    Pass(Option<Element>),
    #[doc = "Pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReportResultCodes {
    fn default() -> Self {
        ReportResultCodes::Null(None)
    }
}
impl TryFrom<String> for ReportResultCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fail" => Ok(ReportResultCodes::Fail(None)),
            "pass" => Ok(ReportResultCodes::Pass(None)),
            "pending" => Ok(ReportResultCodes::Pending(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReportResultCodes {
    fn into(self) -> Option<String> {
        match self {
            ReportResultCodes::Fail(_) => Some("fail".to_string()),
            ReportResultCodes::Pass(_) => Some("pass".to_string()),
            ReportResultCodes::Pending(_) => Some("pending".to_string()),
            ReportResultCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ReportResultCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReportResultCodes::Fail(Some(e)) => e.get_field(field),
                ReportResultCodes::Pass(Some(e)) => e.get_field(field),
                ReportResultCodes::Pending(Some(e)) => e.get_field(field),
                ReportResultCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReportResultCodes::Fail(Some(e)) => e.get_field_mut(field),
                ReportResultCodes::Pass(Some(e)) => e.get_field_mut(field),
                ReportResultCodes::Pending(Some(e)) => e.get_field_mut(field),
                ReportResultCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ReportStatusCodes {
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "Stopped"]
    #[code = "stopped"]
    Stopped(Option<Element>),
    #[doc = "Waiting"]
    #[code = "waiting"]
    Waiting(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ReportStatusCodes {
    fn default() -> Self {
        ReportStatusCodes::Null(None)
    }
}
impl TryFrom<String> for ReportStatusCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "completed" => Ok(ReportStatusCodes::Completed(None)),
            "entered-in-error" => Ok(ReportStatusCodes::EnteredInError(None)),
            "in-progress" => Ok(ReportStatusCodes::InProgress(None)),
            "stopped" => Ok(ReportStatusCodes::Stopped(None)),
            "waiting" => Ok(ReportStatusCodes::Waiting(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ReportStatusCodes {
    fn into(self) -> Option<String> {
        match self {
            ReportStatusCodes::Completed(_) => Some("completed".to_string()),
            ReportStatusCodes::EnteredInError(_) => Some("entered-in-error".to_string()),
            ReportStatusCodes::InProgress(_) => Some("in-progress".to_string()),
            ReportStatusCodes::Stopped(_) => Some("stopped".to_string()),
            ReportStatusCodes::Waiting(_) => Some("waiting".to_string()),
            ReportStatusCodes::Null(_) => None,
        }
    }
}
impl MetaValue for ReportStatusCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ReportStatusCodes::Completed(Some(e)) => e.get_field(field),
                ReportStatusCodes::EnteredInError(Some(e)) => e.get_field(field),
                ReportStatusCodes::InProgress(Some(e)) => e.get_field(field),
                ReportStatusCodes::Stopped(Some(e)) => e.get_field(field),
                ReportStatusCodes::Waiting(Some(e)) => e.get_field(field),
                ReportStatusCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ReportStatusCodes::Completed(Some(e)) => e.get_field_mut(field),
                ReportStatusCodes::EnteredInError(Some(e)) => e.get_field_mut(field),
                ReportStatusCodes::InProgress(Some(e)) => e.get_field_mut(field),
                ReportStatusCodes::Stopped(Some(e)) => e.get_field_mut(field),
                ReportStatusCodes::Waiting(Some(e)) => e.get_field_mut(field),
                ReportStatusCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RepositoryType {
    #[doc = "Click and see"]
    #[code = "directlink"]
    Directlink(Option<Element>),
    #[doc = "Result cannot be access unless an account is logged in"]
    #[code = "login"]
    Login(Option<Element>),
    #[doc = "Result need to be fetched with API and need LOGIN( or cookies are required when visiting the link of resource)"]
    #[code = "oauth"]
    Oauth(Option<Element>),
    #[doc = "The URL is the RESTful or other kind of API that can access to the result."]
    #[code = "openapi"]
    Openapi(Option<Element>),
    #[doc = "Some other complicated or particular way to get resource from URL."]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RepositoryType {
    fn default() -> Self {
        RepositoryType::Null(None)
    }
}
impl TryFrom<String> for RepositoryType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "directlink" => Ok(RepositoryType::Directlink(None)),
            "login" => Ok(RepositoryType::Login(None)),
            "oauth" => Ok(RepositoryType::Oauth(None)),
            "openapi" => Ok(RepositoryType::Openapi(None)),
            "other" => Ok(RepositoryType::Other(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RepositoryType {
    fn into(self) -> Option<String> {
        match self {
            RepositoryType::Directlink(_) => Some("directlink".to_string()),
            RepositoryType::Login(_) => Some("login".to_string()),
            RepositoryType::Oauth(_) => Some("oauth".to_string()),
            RepositoryType::Openapi(_) => Some("openapi".to_string()),
            RepositoryType::Other(_) => Some("other".to_string()),
            RepositoryType::Null(_) => None,
        }
    }
}
impl MetaValue for RepositoryType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RepositoryType::Directlink(Some(e)) => e.get_field(field),
                RepositoryType::Login(Some(e)) => e.get_field(field),
                RepositoryType::Oauth(Some(e)) => e.get_field(field),
                RepositoryType::Openapi(Some(e)) => e.get_field(field),
                RepositoryType::Other(Some(e)) => e.get_field(field),
                RepositoryType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RepositoryType::Directlink(Some(e)) => e.get_field_mut(field),
                RepositoryType::Login(Some(e)) => e.get_field_mut(field),
                RepositoryType::Oauth(Some(e)) => e.get_field_mut(field),
                RepositoryType::Openapi(Some(e)) => e.get_field_mut(field),
                RepositoryType::Other(Some(e)) => e.get_field_mut(field),
                RepositoryType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RequestIntent {
    #[doc = "Directive"]
    #[code = "directive"]
    Directive(Option<Element>),
    #[doc = "Filler Order"]
    #[code = "filler-order"]
    FillerOrder(Option<Element>),
    #[doc = "Instance Order"]
    #[code = "instance-order"]
    InstanceOrder(Option<Element>),
    #[doc = "Option"]
    #[code = "option"]
    Option(Option<Element>),
    #[doc = "Order"]
    #[code = "order"]
    Order(Option<Element>),
    #[doc = "Original Order"]
    #[code = "original-order"]
    OriginalOrder(Option<Element>),
    #[doc = "Plan"]
    #[code = "plan"]
    Plan(Option<Element>),
    #[doc = "Proposal"]
    #[code = "proposal"]
    Proposal(Option<Element>),
    #[doc = "Reflex Order"]
    #[code = "reflex-order"]
    ReflexOrder(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RequestIntent {
    fn default() -> Self {
        RequestIntent::Null(None)
    }
}
impl TryFrom<String> for RequestIntent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "directive" => Ok(RequestIntent::Directive(None)),
            "filler-order" => Ok(RequestIntent::FillerOrder(None)),
            "instance-order" => Ok(RequestIntent::InstanceOrder(None)),
            "option" => Ok(RequestIntent::Option(None)),
            "order" => Ok(RequestIntent::Order(None)),
            "original-order" => Ok(RequestIntent::OriginalOrder(None)),
            "plan" => Ok(RequestIntent::Plan(None)),
            "proposal" => Ok(RequestIntent::Proposal(None)),
            "reflex-order" => Ok(RequestIntent::ReflexOrder(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RequestIntent {
    fn into(self) -> Option<String> {
        match self {
            RequestIntent::Directive(_) => Some("directive".to_string()),
            RequestIntent::FillerOrder(_) => Some("filler-order".to_string()),
            RequestIntent::InstanceOrder(_) => Some("instance-order".to_string()),
            RequestIntent::Option(_) => Some("option".to_string()),
            RequestIntent::Order(_) => Some("order".to_string()),
            RequestIntent::OriginalOrder(_) => Some("original-order".to_string()),
            RequestIntent::Plan(_) => Some("plan".to_string()),
            RequestIntent::Proposal(_) => Some("proposal".to_string()),
            RequestIntent::ReflexOrder(_) => Some("reflex-order".to_string()),
            RequestIntent::Null(_) => None,
        }
    }
}
impl MetaValue for RequestIntent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RequestIntent::Directive(Some(e)) => e.get_field(field),
                RequestIntent::FillerOrder(Some(e)) => e.get_field(field),
                RequestIntent::InstanceOrder(Some(e)) => e.get_field(field),
                RequestIntent::Option(Some(e)) => e.get_field(field),
                RequestIntent::Order(Some(e)) => e.get_field(field),
                RequestIntent::OriginalOrder(Some(e)) => e.get_field(field),
                RequestIntent::Plan(Some(e)) => e.get_field(field),
                RequestIntent::Proposal(Some(e)) => e.get_field(field),
                RequestIntent::ReflexOrder(Some(e)) => e.get_field(field),
                RequestIntent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RequestIntent::Directive(Some(e)) => e.get_field_mut(field),
                RequestIntent::FillerOrder(Some(e)) => e.get_field_mut(field),
                RequestIntent::InstanceOrder(Some(e)) => e.get_field_mut(field),
                RequestIntent::Option(Some(e)) => e.get_field_mut(field),
                RequestIntent::Order(Some(e)) => e.get_field_mut(field),
                RequestIntent::OriginalOrder(Some(e)) => e.get_field_mut(field),
                RequestIntent::Plan(Some(e)) => e.get_field_mut(field),
                RequestIntent::Proposal(Some(e)) => e.get_field_mut(field),
                RequestIntent::ReflexOrder(Some(e)) => e.get_field_mut(field),
                RequestIntent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RequestPriority {
    #[doc = "ASAP"]
    #[code = "asap"]
    Asap(Option<Element>),
    #[doc = "Routine"]
    #[code = "routine"]
    Routine(Option<Element>),
    #[doc = "STAT"]
    #[code = "stat"]
    Stat(Option<Element>),
    #[doc = "Urgent"]
    #[code = "urgent"]
    Urgent(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RequestPriority {
    fn default() -> Self {
        RequestPriority::Null(None)
    }
}
impl TryFrom<String> for RequestPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "asap" => Ok(RequestPriority::Asap(None)),
            "routine" => Ok(RequestPriority::Routine(None)),
            "stat" => Ok(RequestPriority::Stat(None)),
            "urgent" => Ok(RequestPriority::Urgent(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RequestPriority {
    fn into(self) -> Option<String> {
        match self {
            RequestPriority::Asap(_) => Some("asap".to_string()),
            RequestPriority::Routine(_) => Some("routine".to_string()),
            RequestPriority::Stat(_) => Some("stat".to_string()),
            RequestPriority::Urgent(_) => Some("urgent".to_string()),
            RequestPriority::Null(_) => None,
        }
    }
}
impl MetaValue for RequestPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RequestPriority::Asap(Some(e)) => e.get_field(field),
                RequestPriority::Routine(Some(e)) => e.get_field(field),
                RequestPriority::Stat(Some(e)) => e.get_field(field),
                RequestPriority::Urgent(Some(e)) => e.get_field(field),
                RequestPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RequestPriority::Asap(Some(e)) => e.get_field_mut(field),
                RequestPriority::Routine(Some(e)) => e.get_field_mut(field),
                RequestPriority::Stat(Some(e)) => e.get_field_mut(field),
                RequestPriority::Urgent(Some(e)) => e.get_field_mut(field),
                RequestPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RequestResourceTypes {
    #[doc = "Appointment"]
    #[code = "Appointment"]
    Appointment(Option<Element>),
    #[doc = "AppointmentResponse"]
    #[code = "AppointmentResponse"]
    AppointmentResponse(Option<Element>),
    #[doc = "CarePlan"]
    #[code = "CarePlan"]
    CarePlan(Option<Element>),
    #[doc = "Claim"]
    #[code = "Claim"]
    Claim(Option<Element>),
    #[doc = "CommunicationRequest"]
    #[code = "CommunicationRequest"]
    CommunicationRequest(Option<Element>),
    #[doc = "Contract"]
    #[code = "Contract"]
    Contract(Option<Element>),
    #[doc = "DeviceRequest"]
    #[code = "DeviceRequest"]
    DeviceRequest(Option<Element>),
    #[doc = "EnrollmentRequest"]
    #[code = "EnrollmentRequest"]
    EnrollmentRequest(Option<Element>),
    #[doc = "ImmunizationRecommendation"]
    #[code = "ImmunizationRecommendation"]
    ImmunizationRecommendation(Option<Element>),
    #[doc = "MedicationRequest"]
    #[code = "MedicationRequest"]
    MedicationRequest(Option<Element>),
    #[doc = "NutritionOrder"]
    #[code = "NutritionOrder"]
    NutritionOrder(Option<Element>),
    #[doc = "ServiceRequest"]
    #[code = "ServiceRequest"]
    ServiceRequest(Option<Element>),
    #[doc = "SupplyRequest"]
    #[code = "SupplyRequest"]
    SupplyRequest(Option<Element>),
    #[doc = "Task"]
    #[code = "Task"]
    Task(Option<Element>),
    #[doc = "VisionPrescription"]
    #[code = "VisionPrescription"]
    VisionPrescription(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RequestResourceTypes {
    fn default() -> Self {
        RequestResourceTypes::Null(None)
    }
}
impl TryFrom<String> for RequestResourceTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Appointment" => Ok(RequestResourceTypes::Appointment(None)),
            "AppointmentResponse" => Ok(RequestResourceTypes::AppointmentResponse(None)),
            "CarePlan" => Ok(RequestResourceTypes::CarePlan(None)),
            "Claim" => Ok(RequestResourceTypes::Claim(None)),
            "CommunicationRequest" => Ok(RequestResourceTypes::CommunicationRequest(None)),
            "Contract" => Ok(RequestResourceTypes::Contract(None)),
            "DeviceRequest" => Ok(RequestResourceTypes::DeviceRequest(None)),
            "EnrollmentRequest" => Ok(RequestResourceTypes::EnrollmentRequest(None)),
            "ImmunizationRecommendation" => {
                Ok(RequestResourceTypes::ImmunizationRecommendation(None))
            }
            "MedicationRequest" => Ok(RequestResourceTypes::MedicationRequest(None)),
            "NutritionOrder" => Ok(RequestResourceTypes::NutritionOrder(None)),
            "ServiceRequest" => Ok(RequestResourceTypes::ServiceRequest(None)),
            "SupplyRequest" => Ok(RequestResourceTypes::SupplyRequest(None)),
            "Task" => Ok(RequestResourceTypes::Task(None)),
            "VisionPrescription" => Ok(RequestResourceTypes::VisionPrescription(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RequestResourceTypes {
    fn into(self) -> Option<String> {
        match self {
            RequestResourceTypes::Appointment(_) => Some("Appointment".to_string()),
            RequestResourceTypes::AppointmentResponse(_) => Some("AppointmentResponse".to_string()),
            RequestResourceTypes::CarePlan(_) => Some("CarePlan".to_string()),
            RequestResourceTypes::Claim(_) => Some("Claim".to_string()),
            RequestResourceTypes::CommunicationRequest(_) => {
                Some("CommunicationRequest".to_string())
            }
            RequestResourceTypes::Contract(_) => Some("Contract".to_string()),
            RequestResourceTypes::DeviceRequest(_) => Some("DeviceRequest".to_string()),
            RequestResourceTypes::EnrollmentRequest(_) => Some("EnrollmentRequest".to_string()),
            RequestResourceTypes::ImmunizationRecommendation(_) => {
                Some("ImmunizationRecommendation".to_string())
            }
            RequestResourceTypes::MedicationRequest(_) => Some("MedicationRequest".to_string()),
            RequestResourceTypes::NutritionOrder(_) => Some("NutritionOrder".to_string()),
            RequestResourceTypes::ServiceRequest(_) => Some("ServiceRequest".to_string()),
            RequestResourceTypes::SupplyRequest(_) => Some("SupplyRequest".to_string()),
            RequestResourceTypes::Task(_) => Some("Task".to_string()),
            RequestResourceTypes::VisionPrescription(_) => Some("VisionPrescription".to_string()),
            RequestResourceTypes::Null(_) => None,
        }
    }
}
impl MetaValue for RequestResourceTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RequestResourceTypes::Appointment(Some(e)) => e.get_field(field),
                RequestResourceTypes::AppointmentResponse(Some(e)) => e.get_field(field),
                RequestResourceTypes::CarePlan(Some(e)) => e.get_field(field),
                RequestResourceTypes::Claim(Some(e)) => e.get_field(field),
                RequestResourceTypes::CommunicationRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::Contract(Some(e)) => e.get_field(field),
                RequestResourceTypes::DeviceRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::EnrollmentRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::ImmunizationRecommendation(Some(e)) => e.get_field(field),
                RequestResourceTypes::MedicationRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::NutritionOrder(Some(e)) => e.get_field(field),
                RequestResourceTypes::ServiceRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::SupplyRequest(Some(e)) => e.get_field(field),
                RequestResourceTypes::Task(Some(e)) => e.get_field(field),
                RequestResourceTypes::VisionPrescription(Some(e)) => e.get_field(field),
                RequestResourceTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RequestResourceTypes::Appointment(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::AppointmentResponse(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::CarePlan(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::Claim(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::CommunicationRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::Contract(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::DeviceRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::EnrollmentRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::ImmunizationRecommendation(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::MedicationRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::NutritionOrder(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::ServiceRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::SupplyRequest(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::Task(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::VisionPrescription(Some(e)) => e.get_field_mut(field),
                RequestResourceTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RequestStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Revoked"]
    #[code = "revoked"]
    Revoked(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RequestStatus {
    fn default() -> Self {
        RequestStatus::Null(None)
    }
}
impl TryFrom<String> for RequestStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(RequestStatus::Active(None)),
            "completed" => Ok(RequestStatus::Completed(None)),
            "draft" => Ok(RequestStatus::Draft(None)),
            "entered-in-error" => Ok(RequestStatus::EnteredInError(None)),
            "on-hold" => Ok(RequestStatus::OnHold(None)),
            "revoked" => Ok(RequestStatus::Revoked(None)),
            "unknown" => Ok(RequestStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RequestStatus {
    fn into(self) -> Option<String> {
        match self {
            RequestStatus::Active(_) => Some("active".to_string()),
            RequestStatus::Completed(_) => Some("completed".to_string()),
            RequestStatus::Draft(_) => Some("draft".to_string()),
            RequestStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            RequestStatus::OnHold(_) => Some("on-hold".to_string()),
            RequestStatus::Revoked(_) => Some("revoked".to_string()),
            RequestStatus::Unknown(_) => Some("unknown".to_string()),
            RequestStatus::Null(_) => None,
        }
    }
}
impl MetaValue for RequestStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RequestStatus::Active(Some(e)) => e.get_field(field),
                RequestStatus::Completed(Some(e)) => e.get_field(field),
                RequestStatus::Draft(Some(e)) => e.get_field(field),
                RequestStatus::EnteredInError(Some(e)) => e.get_field(field),
                RequestStatus::OnHold(Some(e)) => e.get_field(field),
                RequestStatus::Revoked(Some(e)) => e.get_field(field),
                RequestStatus::Unknown(Some(e)) => e.get_field(field),
                RequestStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RequestStatus::Active(Some(e)) => e.get_field_mut(field),
                RequestStatus::Completed(Some(e)) => e.get_field_mut(field),
                RequestStatus::Draft(Some(e)) => e.get_field_mut(field),
                RequestStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                RequestStatus::OnHold(Some(e)) => e.get_field_mut(field),
                RequestStatus::Revoked(Some(e)) => e.get_field_mut(field),
                RequestStatus::Unknown(Some(e)) => e.get_field_mut(field),
                RequestStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchElementType {
    #[doc = "Exposure"]
    #[code = "exposure"]
    Exposure(Option<Element>),
    #[doc = "Outcome"]
    #[code = "outcome"]
    Outcome(Option<Element>),
    #[doc = "Population"]
    #[code = "population"]
    Population(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchElementType {
    fn default() -> Self {
        ResearchElementType::Null(None)
    }
}
impl TryFrom<String> for ResearchElementType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exposure" => Ok(ResearchElementType::Exposure(None)),
            "outcome" => Ok(ResearchElementType::Outcome(None)),
            "population" => Ok(ResearchElementType::Population(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchElementType {
    fn into(self) -> Option<String> {
        match self {
            ResearchElementType::Exposure(_) => Some("exposure".to_string()),
            ResearchElementType::Outcome(_) => Some("outcome".to_string()),
            ResearchElementType::Population(_) => Some("population".to_string()),
            ResearchElementType::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchElementType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchElementType::Exposure(Some(e)) => e.get_field(field),
                ResearchElementType::Outcome(Some(e)) => e.get_field(field),
                ResearchElementType::Population(Some(e)) => e.get_field(field),
                ResearchElementType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchElementType::Exposure(Some(e)) => e.get_field_mut(field),
                ResearchElementType::Outcome(Some(e)) => e.get_field_mut(field),
                ResearchElementType::Population(Some(e)) => e.get_field_mut(field),
                ResearchElementType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchStudyObjectiveType {
    #[doc = "Exploratory"]
    #[code = "exploratory"]
    Exploratory(Option<Element>),
    #[doc = "Primary"]
    #[code = "primary"]
    Primary(Option<Element>),
    #[doc = "Secondary"]
    #[code = "secondary"]
    Secondary(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchStudyObjectiveType {
    fn default() -> Self {
        ResearchStudyObjectiveType::Null(None)
    }
}
impl TryFrom<String> for ResearchStudyObjectiveType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exploratory" => Ok(ResearchStudyObjectiveType::Exploratory(None)),
            "primary" => Ok(ResearchStudyObjectiveType::Primary(None)),
            "secondary" => Ok(ResearchStudyObjectiveType::Secondary(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchStudyObjectiveType {
    fn into(self) -> Option<String> {
        match self {
            ResearchStudyObjectiveType::Exploratory(_) => Some("exploratory".to_string()),
            ResearchStudyObjectiveType::Primary(_) => Some("primary".to_string()),
            ResearchStudyObjectiveType::Secondary(_) => Some("secondary".to_string()),
            ResearchStudyObjectiveType::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchStudyObjectiveType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchStudyObjectiveType::Exploratory(Some(e)) => e.get_field(field),
                ResearchStudyObjectiveType::Primary(Some(e)) => e.get_field(field),
                ResearchStudyObjectiveType::Secondary(Some(e)) => e.get_field(field),
                ResearchStudyObjectiveType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchStudyObjectiveType::Exploratory(Some(e)) => e.get_field_mut(field),
                ResearchStudyObjectiveType::Primary(Some(e)) => e.get_field_mut(field),
                ResearchStudyObjectiveType::Secondary(Some(e)) => e.get_field_mut(field),
                ResearchStudyObjectiveType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchStudyPhase {
    #[doc = "Early Phase 1"]
    #[code = "early-phase-1"]
    EarlyPhase1(Option<Element>),
    #[doc = "N/A"]
    #[code = "n-a"]
    NA(Option<Element>),
    #[doc = "Phase 1"]
    #[code = "phase-1"]
    Phase1(Option<Element>),
    #[doc = "Phase 1/Phase 2"]
    #[code = "phase-1-phase-2"]
    Phase1Phase2(Option<Element>),
    #[doc = "Phase 2"]
    #[code = "phase-2"]
    Phase2(Option<Element>),
    #[doc = "Phase 2/Phase 3"]
    #[code = "phase-2-phase-3"]
    Phase2Phase3(Option<Element>),
    #[doc = "Phase 3"]
    #[code = "phase-3"]
    Phase3(Option<Element>),
    #[doc = "Phase 4"]
    #[code = "phase-4"]
    Phase4(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchStudyPhase {
    fn default() -> Self {
        ResearchStudyPhase::Null(None)
    }
}
impl TryFrom<String> for ResearchStudyPhase {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "early-phase-1" => Ok(ResearchStudyPhase::EarlyPhase1(None)),
            "n-a" => Ok(ResearchStudyPhase::NA(None)),
            "phase-1" => Ok(ResearchStudyPhase::Phase1(None)),
            "phase-1-phase-2" => Ok(ResearchStudyPhase::Phase1Phase2(None)),
            "phase-2" => Ok(ResearchStudyPhase::Phase2(None)),
            "phase-2-phase-3" => Ok(ResearchStudyPhase::Phase2Phase3(None)),
            "phase-3" => Ok(ResearchStudyPhase::Phase3(None)),
            "phase-4" => Ok(ResearchStudyPhase::Phase4(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchStudyPhase {
    fn into(self) -> Option<String> {
        match self {
            ResearchStudyPhase::EarlyPhase1(_) => Some("early-phase-1".to_string()),
            ResearchStudyPhase::NA(_) => Some("n-a".to_string()),
            ResearchStudyPhase::Phase1(_) => Some("phase-1".to_string()),
            ResearchStudyPhase::Phase1Phase2(_) => Some("phase-1-phase-2".to_string()),
            ResearchStudyPhase::Phase2(_) => Some("phase-2".to_string()),
            ResearchStudyPhase::Phase2Phase3(_) => Some("phase-2-phase-3".to_string()),
            ResearchStudyPhase::Phase3(_) => Some("phase-3".to_string()),
            ResearchStudyPhase::Phase4(_) => Some("phase-4".to_string()),
            ResearchStudyPhase::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchStudyPhase {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchStudyPhase::EarlyPhase1(Some(e)) => e.get_field(field),
                ResearchStudyPhase::NA(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase1(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase1Phase2(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase2(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase2Phase3(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase3(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Phase4(Some(e)) => e.get_field(field),
                ResearchStudyPhase::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchStudyPhase::EarlyPhase1(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::NA(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase1(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase1Phase2(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase2(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase2Phase3(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase3(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Phase4(Some(e)) => e.get_field_mut(field),
                ResearchStudyPhase::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchStudyPrimPurpType {
    #[doc = "Basic Science"]
    #[code = "basic-science"]
    BasicScience(Option<Element>),
    #[doc = "Device Feasibility"]
    #[code = "device-feasibility"]
    DeviceFeasibility(Option<Element>),
    #[doc = "Diagnostic"]
    #[code = "diagnostic"]
    Diagnostic(Option<Element>),
    #[doc = "Health Services Research"]
    #[code = "health-services-research"]
    HealthServicesResearch(Option<Element>),
    #[doc = "Prevention"]
    #[code = "prevention"]
    Prevention(Option<Element>),
    #[doc = "Screening"]
    #[code = "screening"]
    Screening(Option<Element>),
    #[doc = "Supportive Care"]
    #[code = "supportive-care"]
    SupportiveCare(Option<Element>),
    #[doc = "Treatment"]
    #[code = "treatment"]
    Treatment(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchStudyPrimPurpType {
    fn default() -> Self {
        ResearchStudyPrimPurpType::Null(None)
    }
}
impl TryFrom<String> for ResearchStudyPrimPurpType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "basic-science" => Ok(ResearchStudyPrimPurpType::BasicScience(None)),
            "device-feasibility" => Ok(ResearchStudyPrimPurpType::DeviceFeasibility(None)),
            "diagnostic" => Ok(ResearchStudyPrimPurpType::Diagnostic(None)),
            "health-services-research" => {
                Ok(ResearchStudyPrimPurpType::HealthServicesResearch(None))
            }
            "prevention" => Ok(ResearchStudyPrimPurpType::Prevention(None)),
            "screening" => Ok(ResearchStudyPrimPurpType::Screening(None)),
            "supportive-care" => Ok(ResearchStudyPrimPurpType::SupportiveCare(None)),
            "treatment" => Ok(ResearchStudyPrimPurpType::Treatment(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchStudyPrimPurpType {
    fn into(self) -> Option<String> {
        match self {
            ResearchStudyPrimPurpType::BasicScience(_) => Some("basic-science".to_string()),
            ResearchStudyPrimPurpType::DeviceFeasibility(_) => {
                Some("device-feasibility".to_string())
            }
            ResearchStudyPrimPurpType::Diagnostic(_) => Some("diagnostic".to_string()),
            ResearchStudyPrimPurpType::HealthServicesResearch(_) => {
                Some("health-services-research".to_string())
            }
            ResearchStudyPrimPurpType::Prevention(_) => Some("prevention".to_string()),
            ResearchStudyPrimPurpType::Screening(_) => Some("screening".to_string()),
            ResearchStudyPrimPurpType::SupportiveCare(_) => Some("supportive-care".to_string()),
            ResearchStudyPrimPurpType::Treatment(_) => Some("treatment".to_string()),
            ResearchStudyPrimPurpType::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchStudyPrimPurpType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchStudyPrimPurpType::BasicScience(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::DeviceFeasibility(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::Diagnostic(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::HealthServicesResearch(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::Prevention(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::Screening(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::SupportiveCare(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::Treatment(Some(e)) => e.get_field(field),
                ResearchStudyPrimPurpType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchStudyPrimPurpType::BasicScience(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::DeviceFeasibility(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::Diagnostic(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::HealthServicesResearch(Some(e)) => {
                    e.get_field_mut(field)
                }
                ResearchStudyPrimPurpType::Prevention(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::Screening(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::SupportiveCare(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::Treatment(Some(e)) => e.get_field_mut(field),
                ResearchStudyPrimPurpType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchStudyReasonStopped {
    #[doc = "Accrual Goal Met"]
    #[code = "accrual-goal-met"]
    AccrualGoalMet(Option<Element>),
    #[doc = "Closed due to lack of study progress"]
    #[code = "closed-due-to-lack-of-study-progress"]
    ClosedDueToLackOfStudyProgress(Option<Element>),
    #[doc = "Closed due to toxicity"]
    #[code = "closed-due-to-toxicity"]
    ClosedDueToToxicity(Option<Element>),
    #[doc = "Temporarily closed per study design"]
    #[code = "temporarily-closed-per-study-design"]
    TemporarilyClosedPerStudyDesign(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchStudyReasonStopped {
    fn default() -> Self {
        ResearchStudyReasonStopped::Null(None)
    }
}
impl TryFrom<String> for ResearchStudyReasonStopped {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "accrual-goal-met" => Ok(ResearchStudyReasonStopped::AccrualGoalMet(None)),
            "closed-due-to-lack-of-study-progress" => Ok(
                ResearchStudyReasonStopped::ClosedDueToLackOfStudyProgress(None),
            ),
            "closed-due-to-toxicity" => Ok(ResearchStudyReasonStopped::ClosedDueToToxicity(None)),
            "temporarily-closed-per-study-design" => Ok(
                ResearchStudyReasonStopped::TemporarilyClosedPerStudyDesign(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchStudyReasonStopped {
    fn into(self) -> Option<String> {
        match self {
            ResearchStudyReasonStopped::AccrualGoalMet(_) => Some("accrual-goal-met".to_string()),
            ResearchStudyReasonStopped::ClosedDueToLackOfStudyProgress(_) => {
                Some("closed-due-to-lack-of-study-progress".to_string())
            }
            ResearchStudyReasonStopped::ClosedDueToToxicity(_) => {
                Some("closed-due-to-toxicity".to_string())
            }
            ResearchStudyReasonStopped::TemporarilyClosedPerStudyDesign(_) => {
                Some("temporarily-closed-per-study-design".to_string())
            }
            ResearchStudyReasonStopped::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchStudyReasonStopped {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchStudyReasonStopped::AccrualGoalMet(Some(e)) => e.get_field(field),
                ResearchStudyReasonStopped::ClosedDueToLackOfStudyProgress(Some(e)) => {
                    e.get_field(field)
                }
                ResearchStudyReasonStopped::ClosedDueToToxicity(Some(e)) => e.get_field(field),
                ResearchStudyReasonStopped::TemporarilyClosedPerStudyDesign(Some(e)) => {
                    e.get_field(field)
                }
                ResearchStudyReasonStopped::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchStudyReasonStopped::AccrualGoalMet(Some(e)) => e.get_field_mut(field),
                ResearchStudyReasonStopped::ClosedDueToLackOfStudyProgress(Some(e)) => {
                    e.get_field_mut(field)
                }
                ResearchStudyReasonStopped::ClosedDueToToxicity(Some(e)) => e.get_field_mut(field),
                ResearchStudyReasonStopped::TemporarilyClosedPerStudyDesign(Some(e)) => {
                    e.get_field_mut(field)
                }
                ResearchStudyReasonStopped::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchStudyStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Administratively Completed"]
    #[code = "administratively-completed"]
    AdministrativelyCompleted(Option<Element>),
    #[doc = "Approved"]
    #[code = "approved"]
    Approved(Option<Element>),
    #[doc = "Closed to Accrual"]
    #[code = "closed-to-accrual"]
    ClosedToAccrual(Option<Element>),
    #[doc = "Closed to Accrual and Intervention"]
    #[code = "closed-to-accrual-and-intervention"]
    ClosedToAccrualAndIntervention(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Disapproved"]
    #[code = "disapproved"]
    Disapproved(Option<Element>),
    #[doc = "In Review"]
    #[code = "in-review"]
    InReview(Option<Element>),
    #[doc = "Temporarily Closed to Accrual"]
    #[code = "temporarily-closed-to-accrual"]
    TemporarilyClosedToAccrual(Option<Element>),
    #[doc = "Temporarily Closed to Accrual and Intervention"]
    #[code = "temporarily-closed-to-accrual-and-intervention"]
    TemporarilyClosedToAccrualAndIntervention(Option<Element>),
    #[doc = "Withdrawn"]
    #[code = "withdrawn"]
    Withdrawn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchStudyStatus {
    fn default() -> Self {
        ResearchStudyStatus::Null(None)
    }
}
impl TryFrom<String> for ResearchStudyStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(ResearchStudyStatus::Active(None)),
            "administratively-completed" => {
                Ok(ResearchStudyStatus::AdministrativelyCompleted(None))
            }
            "approved" => Ok(ResearchStudyStatus::Approved(None)),
            "closed-to-accrual" => Ok(ResearchStudyStatus::ClosedToAccrual(None)),
            "closed-to-accrual-and-intervention" => {
                Ok(ResearchStudyStatus::ClosedToAccrualAndIntervention(None))
            }
            "completed" => Ok(ResearchStudyStatus::Completed(None)),
            "disapproved" => Ok(ResearchStudyStatus::Disapproved(None)),
            "in-review" => Ok(ResearchStudyStatus::InReview(None)),
            "temporarily-closed-to-accrual" => {
                Ok(ResearchStudyStatus::TemporarilyClosedToAccrual(None))
            }
            "temporarily-closed-to-accrual-and-intervention" => {
                Ok(ResearchStudyStatus::TemporarilyClosedToAccrualAndIntervention(None))
            }
            "withdrawn" => Ok(ResearchStudyStatus::Withdrawn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchStudyStatus {
    fn into(self) -> Option<String> {
        match self {
            ResearchStudyStatus::Active(_) => Some("active".to_string()),
            ResearchStudyStatus::AdministrativelyCompleted(_) => {
                Some("administratively-completed".to_string())
            }
            ResearchStudyStatus::Approved(_) => Some("approved".to_string()),
            ResearchStudyStatus::ClosedToAccrual(_) => Some("closed-to-accrual".to_string()),
            ResearchStudyStatus::ClosedToAccrualAndIntervention(_) => {
                Some("closed-to-accrual-and-intervention".to_string())
            }
            ResearchStudyStatus::Completed(_) => Some("completed".to_string()),
            ResearchStudyStatus::Disapproved(_) => Some("disapproved".to_string()),
            ResearchStudyStatus::InReview(_) => Some("in-review".to_string()),
            ResearchStudyStatus::TemporarilyClosedToAccrual(_) => {
                Some("temporarily-closed-to-accrual".to_string())
            }
            ResearchStudyStatus::TemporarilyClosedToAccrualAndIntervention(_) => {
                Some("temporarily-closed-to-accrual-and-intervention".to_string())
            }
            ResearchStudyStatus::Withdrawn(_) => Some("withdrawn".to_string()),
            ResearchStudyStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchStudyStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchStudyStatus::Active(Some(e)) => e.get_field(field),
                ResearchStudyStatus::AdministrativelyCompleted(Some(e)) => e.get_field(field),
                ResearchStudyStatus::Approved(Some(e)) => e.get_field(field),
                ResearchStudyStatus::ClosedToAccrual(Some(e)) => e.get_field(field),
                ResearchStudyStatus::ClosedToAccrualAndIntervention(Some(e)) => e.get_field(field),
                ResearchStudyStatus::Completed(Some(e)) => e.get_field(field),
                ResearchStudyStatus::Disapproved(Some(e)) => e.get_field(field),
                ResearchStudyStatus::InReview(Some(e)) => e.get_field(field),
                ResearchStudyStatus::TemporarilyClosedToAccrual(Some(e)) => e.get_field(field),
                ResearchStudyStatus::TemporarilyClosedToAccrualAndIntervention(Some(e)) => {
                    e.get_field(field)
                }
                ResearchStudyStatus::Withdrawn(Some(e)) => e.get_field(field),
                ResearchStudyStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchStudyStatus::Active(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::AdministrativelyCompleted(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::Approved(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::ClosedToAccrual(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::ClosedToAccrualAndIntervention(Some(e)) => {
                    e.get_field_mut(field)
                }
                ResearchStudyStatus::Completed(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::Disapproved(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::InReview(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::TemporarilyClosedToAccrual(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::TemporarilyClosedToAccrualAndIntervention(Some(e)) => {
                    e.get_field_mut(field)
                }
                ResearchStudyStatus::Withdrawn(Some(e)) => e.get_field_mut(field),
                ResearchStudyStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResearchSubjectStatus {
    #[doc = "Candidate"]
    #[code = "candidate"]
    Candidate(Option<Element>),
    #[doc = "Eligible"]
    #[code = "eligible"]
    Eligible(Option<Element>),
    #[doc = "Follow-up"]
    #[code = "follow-up"]
    FollowUp(Option<Element>),
    #[doc = "Ineligible"]
    #[code = "ineligible"]
    Ineligible(Option<Element>),
    #[doc = "Not Registered"]
    #[code = "not-registered"]
    NotRegistered(Option<Element>),
    #[doc = "Off-study"]
    #[code = "off-study"]
    OffStudy(Option<Element>),
    #[doc = "On-study"]
    #[code = "on-study"]
    OnStudy(Option<Element>),
    #[doc = "On-study-intervention"]
    #[code = "on-study-intervention"]
    OnStudyIntervention(Option<Element>),
    #[doc = "On-study-observation"]
    #[code = "on-study-observation"]
    OnStudyObservation(Option<Element>),
    #[doc = "Pending on-study"]
    #[code = "pending-on-study"]
    PendingOnStudy(Option<Element>),
    #[doc = "Potential Candidate"]
    #[code = "potential-candidate"]
    PotentialCandidate(Option<Element>),
    #[doc = "Screening"]
    #[code = "screening"]
    Screening(Option<Element>),
    #[doc = "Withdrawn"]
    #[code = "withdrawn"]
    Withdrawn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResearchSubjectStatus {
    fn default() -> Self {
        ResearchSubjectStatus::Null(None)
    }
}
impl TryFrom<String> for ResearchSubjectStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "candidate" => Ok(ResearchSubjectStatus::Candidate(None)),
            "eligible" => Ok(ResearchSubjectStatus::Eligible(None)),
            "follow-up" => Ok(ResearchSubjectStatus::FollowUp(None)),
            "ineligible" => Ok(ResearchSubjectStatus::Ineligible(None)),
            "not-registered" => Ok(ResearchSubjectStatus::NotRegistered(None)),
            "off-study" => Ok(ResearchSubjectStatus::OffStudy(None)),
            "on-study" => Ok(ResearchSubjectStatus::OnStudy(None)),
            "on-study-intervention" => Ok(ResearchSubjectStatus::OnStudyIntervention(None)),
            "on-study-observation" => Ok(ResearchSubjectStatus::OnStudyObservation(None)),
            "pending-on-study" => Ok(ResearchSubjectStatus::PendingOnStudy(None)),
            "potential-candidate" => Ok(ResearchSubjectStatus::PotentialCandidate(None)),
            "screening" => Ok(ResearchSubjectStatus::Screening(None)),
            "withdrawn" => Ok(ResearchSubjectStatus::Withdrawn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResearchSubjectStatus {
    fn into(self) -> Option<String> {
        match self {
            ResearchSubjectStatus::Candidate(_) => Some("candidate".to_string()),
            ResearchSubjectStatus::Eligible(_) => Some("eligible".to_string()),
            ResearchSubjectStatus::FollowUp(_) => Some("follow-up".to_string()),
            ResearchSubjectStatus::Ineligible(_) => Some("ineligible".to_string()),
            ResearchSubjectStatus::NotRegistered(_) => Some("not-registered".to_string()),
            ResearchSubjectStatus::OffStudy(_) => Some("off-study".to_string()),
            ResearchSubjectStatus::OnStudy(_) => Some("on-study".to_string()),
            ResearchSubjectStatus::OnStudyIntervention(_) => {
                Some("on-study-intervention".to_string())
            }
            ResearchSubjectStatus::OnStudyObservation(_) => {
                Some("on-study-observation".to_string())
            }
            ResearchSubjectStatus::PendingOnStudy(_) => Some("pending-on-study".to_string()),
            ResearchSubjectStatus::PotentialCandidate(_) => Some("potential-candidate".to_string()),
            ResearchSubjectStatus::Screening(_) => Some("screening".to_string()),
            ResearchSubjectStatus::Withdrawn(_) => Some("withdrawn".to_string()),
            ResearchSubjectStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ResearchSubjectStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResearchSubjectStatus::Candidate(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::Eligible(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::FollowUp(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::Ineligible(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::NotRegistered(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::OffStudy(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::OnStudy(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::OnStudyIntervention(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::OnStudyObservation(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::PendingOnStudy(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::PotentialCandidate(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::Screening(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::Withdrawn(Some(e)) => e.get_field(field),
                ResearchSubjectStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResearchSubjectStatus::Candidate(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::Eligible(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::FollowUp(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::Ineligible(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::NotRegistered(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::OffStudy(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::OnStudy(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::OnStudyIntervention(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::OnStudyObservation(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::PendingOnStudy(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::PotentialCandidate(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::Screening(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::Withdrawn(Some(e)) => e.get_field_mut(field),
                ResearchSubjectStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceAggregationMode {
    #[doc = "Bundled"]
    #[code = "bundled"]
    Bundled(Option<Element>),
    #[doc = "Contained"]
    #[code = "contained"]
    Contained(Option<Element>),
    #[doc = "Referenced"]
    #[code = "referenced"]
    Referenced(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceAggregationMode {
    fn default() -> Self {
        ResourceAggregationMode::Null(None)
    }
}
impl TryFrom<String> for ResourceAggregationMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "bundled" => Ok(ResourceAggregationMode::Bundled(None)),
            "contained" => Ok(ResourceAggregationMode::Contained(None)),
            "referenced" => Ok(ResourceAggregationMode::Referenced(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceAggregationMode {
    fn into(self) -> Option<String> {
        match self {
            ResourceAggregationMode::Bundled(_) => Some("bundled".to_string()),
            ResourceAggregationMode::Contained(_) => Some("contained".to_string()),
            ResourceAggregationMode::Referenced(_) => Some("referenced".to_string()),
            ResourceAggregationMode::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceAggregationMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceAggregationMode::Bundled(Some(e)) => e.get_field(field),
                ResourceAggregationMode::Contained(Some(e)) => e.get_field(field),
                ResourceAggregationMode::Referenced(Some(e)) => e.get_field(field),
                ResourceAggregationMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceAggregationMode::Bundled(Some(e)) => e.get_field_mut(field),
                ResourceAggregationMode::Contained(Some(e)) => e.get_field_mut(field),
                ResourceAggregationMode::Referenced(Some(e)) => e.get_field_mut(field),
                ResourceAggregationMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceSecurityCategory {
    #[doc = "Anonymous READ Access Resource"]
    #[code = "anonymous"]
    Anonymous(Option<Element>),
    #[doc = "Business Sensitive Resource"]
    #[code = "business"]
    Business(Option<Element>),
    #[doc = "Individual Sensitive Resource"]
    #[code = "individual"]
    Individual(Option<Element>),
    #[doc = "Not classified"]
    #[code = "not-classified"]
    NotClassified(Option<Element>),
    #[doc = "Patient Sensitive"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceSecurityCategory {
    fn default() -> Self {
        ResourceSecurityCategory::Null(None)
    }
}
impl TryFrom<String> for ResourceSecurityCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "anonymous" => Ok(ResourceSecurityCategory::Anonymous(None)),
            "business" => Ok(ResourceSecurityCategory::Business(None)),
            "individual" => Ok(ResourceSecurityCategory::Individual(None)),
            "not-classified" => Ok(ResourceSecurityCategory::NotClassified(None)),
            "patient" => Ok(ResourceSecurityCategory::Patient(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceSecurityCategory {
    fn into(self) -> Option<String> {
        match self {
            ResourceSecurityCategory::Anonymous(_) => Some("anonymous".to_string()),
            ResourceSecurityCategory::Business(_) => Some("business".to_string()),
            ResourceSecurityCategory::Individual(_) => Some("individual".to_string()),
            ResourceSecurityCategory::NotClassified(_) => Some("not-classified".to_string()),
            ResourceSecurityCategory::Patient(_) => Some("patient".to_string()),
            ResourceSecurityCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceSecurityCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceSecurityCategory::Anonymous(Some(e)) => e.get_field(field),
                ResourceSecurityCategory::Business(Some(e)) => e.get_field(field),
                ResourceSecurityCategory::Individual(Some(e)) => e.get_field(field),
                ResourceSecurityCategory::NotClassified(Some(e)) => e.get_field(field),
                ResourceSecurityCategory::Patient(Some(e)) => e.get_field(field),
                ResourceSecurityCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceSecurityCategory::Anonymous(Some(e)) => e.get_field_mut(field),
                ResourceSecurityCategory::Business(Some(e)) => e.get_field_mut(field),
                ResourceSecurityCategory::Individual(Some(e)) => e.get_field_mut(field),
                ResourceSecurityCategory::NotClassified(Some(e)) => e.get_field_mut(field),
                ResourceSecurityCategory::Patient(Some(e)) => e.get_field_mut(field),
                ResourceSecurityCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceSlicingRules {
    #[doc = "Closed"]
    #[code = "closed"]
    Closed(Option<Element>),
    #[doc = "Open"]
    #[code = "open"]
    Open(Option<Element>),
    #[doc = "Open at End"]
    #[code = "openAtEnd"]
    OpenAtEnd(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceSlicingRules {
    fn default() -> Self {
        ResourceSlicingRules::Null(None)
    }
}
impl TryFrom<String> for ResourceSlicingRules {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "closed" => Ok(ResourceSlicingRules::Closed(None)),
            "open" => Ok(ResourceSlicingRules::Open(None)),
            "openAtEnd" => Ok(ResourceSlicingRules::OpenAtEnd(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceSlicingRules {
    fn into(self) -> Option<String> {
        match self {
            ResourceSlicingRules::Closed(_) => Some("closed".to_string()),
            ResourceSlicingRules::Open(_) => Some("open".to_string()),
            ResourceSlicingRules::OpenAtEnd(_) => Some("openAtEnd".to_string()),
            ResourceSlicingRules::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceSlicingRules {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceSlicingRules::Closed(Some(e)) => e.get_field(field),
                ResourceSlicingRules::Open(Some(e)) => e.get_field(field),
                ResourceSlicingRules::OpenAtEnd(Some(e)) => e.get_field(field),
                ResourceSlicingRules::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceSlicingRules::Closed(Some(e)) => e.get_field_mut(field),
                ResourceSlicingRules::Open(Some(e)) => e.get_field_mut(field),
                ResourceSlicingRules::OpenAtEnd(Some(e)) => e.get_field_mut(field),
                ResourceSlicingRules::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceStatus {
    #[doc = "abandoned"]
    #[code = "abandoned"]
    Abandoned(Option<Element>),
    #[doc = "accepted"]
    #[code = "accepted"]
    Accepted(Option<Element>),
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "ahead-of-target"]
    #[code = "ahead-of-target"]
    AheadOfTarget(Option<Element>),
    #[doc = "arrived"]
    #[code = "arrived"]
    Arrived(Option<Element>),
    #[doc = "behind-target"]
    #[code = "behind-target"]
    BehindTarget(Option<Element>),
    #[doc = "busy-unavailable"]
    #[code = "busy-unavailable"]
    BusyUnavailable(Option<Element>),
    #[doc = "complete"]
    #[code = "complete"]
    Complete(Option<Element>),
    #[doc = "confirmed"]
    #[code = "confirmed"]
    Confirmed(Option<Element>),
    #[doc = "declined"]
    #[code = "declined"]
    Declined(Option<Element>),
    #[doc = "differential"]
    #[code = "differential"]
    Differential(Option<Element>),
    #[doc = "draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "failed"]
    #[code = "failed"]
    Failed(Option<Element>),
    #[doc = "free"]
    #[code = "free"]
    Free(Option<Element>),
    #[doc = "hw-discon"]
    #[code = "hw-discon"]
    HwDiscon(Option<Element>),
    #[doc = "inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "not-ready"]
    #[code = "not-ready"]
    NotReady(Option<Element>),
    #[doc = "on-target"]
    #[code = "on-target"]
    OnTarget(Option<Element>),
    #[doc = "partial"]
    #[code = "partial"]
    Partial(Option<Element>),
    #[doc = "planned"]
    #[code = "planned"]
    Planned(Option<Element>),
    #[doc = "proposed"]
    #[code = "proposed"]
    Proposed(Option<Element>),
    #[doc = "received"]
    #[code = "received"]
    Received(Option<Element>),
    #[doc = "refuted"]
    #[code = "refuted"]
    Refuted(Option<Element>),
    #[doc = "replaced"]
    #[code = "replaced"]
    Replaced(Option<Element>),
    #[doc = "requested"]
    #[code = "requested"]
    Requested(Option<Element>),
    #[doc = "resolved"]
    #[code = "resolved"]
    Resolved(Option<Element>),
    #[doc = "suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "transduc-discon"]
    #[code = "transduc-discon"]
    TransducDiscon(Option<Element>),
    #[doc = "unconfirmed"]
    #[code = "unconfirmed"]
    Unconfirmed(Option<Element>),
    #[doc = "unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceStatus {
    fn default() -> Self {
        ResourceStatus::Null(None)
    }
}
impl TryFrom<String> for ResourceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "abandoned" => Ok(ResourceStatus::Abandoned(None)),
            "accepted" => Ok(ResourceStatus::Accepted(None)),
            "active" => Ok(ResourceStatus::Active(None)),
            "ahead-of-target" => Ok(ResourceStatus::AheadOfTarget(None)),
            "arrived" => Ok(ResourceStatus::Arrived(None)),
            "behind-target" => Ok(ResourceStatus::BehindTarget(None)),
            "busy-unavailable" => Ok(ResourceStatus::BusyUnavailable(None)),
            "complete" => Ok(ResourceStatus::Complete(None)),
            "confirmed" => Ok(ResourceStatus::Confirmed(None)),
            "declined" => Ok(ResourceStatus::Declined(None)),
            "differential" => Ok(ResourceStatus::Differential(None)),
            "draft" => Ok(ResourceStatus::Draft(None)),
            "error" => Ok(ResourceStatus::Error(None)),
            "failed" => Ok(ResourceStatus::Failed(None)),
            "free" => Ok(ResourceStatus::Free(None)),
            "hw-discon" => Ok(ResourceStatus::HwDiscon(None)),
            "inactive" => Ok(ResourceStatus::Inactive(None)),
            "not-ready" => Ok(ResourceStatus::NotReady(None)),
            "on-target" => Ok(ResourceStatus::OnTarget(None)),
            "partial" => Ok(ResourceStatus::Partial(None)),
            "planned" => Ok(ResourceStatus::Planned(None)),
            "proposed" => Ok(ResourceStatus::Proposed(None)),
            "received" => Ok(ResourceStatus::Received(None)),
            "refuted" => Ok(ResourceStatus::Refuted(None)),
            "replaced" => Ok(ResourceStatus::Replaced(None)),
            "requested" => Ok(ResourceStatus::Requested(None)),
            "resolved" => Ok(ResourceStatus::Resolved(None)),
            "suspended" => Ok(ResourceStatus::Suspended(None)),
            "transduc-discon" => Ok(ResourceStatus::TransducDiscon(None)),
            "unconfirmed" => Ok(ResourceStatus::Unconfirmed(None)),
            "unknown" => Ok(ResourceStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceStatus {
    fn into(self) -> Option<String> {
        match self {
            ResourceStatus::Abandoned(_) => Some("abandoned".to_string()),
            ResourceStatus::Accepted(_) => Some("accepted".to_string()),
            ResourceStatus::Active(_) => Some("active".to_string()),
            ResourceStatus::AheadOfTarget(_) => Some("ahead-of-target".to_string()),
            ResourceStatus::Arrived(_) => Some("arrived".to_string()),
            ResourceStatus::BehindTarget(_) => Some("behind-target".to_string()),
            ResourceStatus::BusyUnavailable(_) => Some("busy-unavailable".to_string()),
            ResourceStatus::Complete(_) => Some("complete".to_string()),
            ResourceStatus::Confirmed(_) => Some("confirmed".to_string()),
            ResourceStatus::Declined(_) => Some("declined".to_string()),
            ResourceStatus::Differential(_) => Some("differential".to_string()),
            ResourceStatus::Draft(_) => Some("draft".to_string()),
            ResourceStatus::Error(_) => Some("error".to_string()),
            ResourceStatus::Failed(_) => Some("failed".to_string()),
            ResourceStatus::Free(_) => Some("free".to_string()),
            ResourceStatus::HwDiscon(_) => Some("hw-discon".to_string()),
            ResourceStatus::Inactive(_) => Some("inactive".to_string()),
            ResourceStatus::NotReady(_) => Some("not-ready".to_string()),
            ResourceStatus::OnTarget(_) => Some("on-target".to_string()),
            ResourceStatus::Partial(_) => Some("partial".to_string()),
            ResourceStatus::Planned(_) => Some("planned".to_string()),
            ResourceStatus::Proposed(_) => Some("proposed".to_string()),
            ResourceStatus::Received(_) => Some("received".to_string()),
            ResourceStatus::Refuted(_) => Some("refuted".to_string()),
            ResourceStatus::Replaced(_) => Some("replaced".to_string()),
            ResourceStatus::Requested(_) => Some("requested".to_string()),
            ResourceStatus::Resolved(_) => Some("resolved".to_string()),
            ResourceStatus::Suspended(_) => Some("suspended".to_string()),
            ResourceStatus::TransducDiscon(_) => Some("transduc-discon".to_string()),
            ResourceStatus::Unconfirmed(_) => Some("unconfirmed".to_string()),
            ResourceStatus::Unknown(_) => Some("unknown".to_string()),
            ResourceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceStatus::Abandoned(Some(e)) => e.get_field(field),
                ResourceStatus::Accepted(Some(e)) => e.get_field(field),
                ResourceStatus::Active(Some(e)) => e.get_field(field),
                ResourceStatus::AheadOfTarget(Some(e)) => e.get_field(field),
                ResourceStatus::Arrived(Some(e)) => e.get_field(field),
                ResourceStatus::BehindTarget(Some(e)) => e.get_field(field),
                ResourceStatus::BusyUnavailable(Some(e)) => e.get_field(field),
                ResourceStatus::Complete(Some(e)) => e.get_field(field),
                ResourceStatus::Confirmed(Some(e)) => e.get_field(field),
                ResourceStatus::Declined(Some(e)) => e.get_field(field),
                ResourceStatus::Differential(Some(e)) => e.get_field(field),
                ResourceStatus::Draft(Some(e)) => e.get_field(field),
                ResourceStatus::Error(Some(e)) => e.get_field(field),
                ResourceStatus::Failed(Some(e)) => e.get_field(field),
                ResourceStatus::Free(Some(e)) => e.get_field(field),
                ResourceStatus::HwDiscon(Some(e)) => e.get_field(field),
                ResourceStatus::Inactive(Some(e)) => e.get_field(field),
                ResourceStatus::NotReady(Some(e)) => e.get_field(field),
                ResourceStatus::OnTarget(Some(e)) => e.get_field(field),
                ResourceStatus::Partial(Some(e)) => e.get_field(field),
                ResourceStatus::Planned(Some(e)) => e.get_field(field),
                ResourceStatus::Proposed(Some(e)) => e.get_field(field),
                ResourceStatus::Received(Some(e)) => e.get_field(field),
                ResourceStatus::Refuted(Some(e)) => e.get_field(field),
                ResourceStatus::Replaced(Some(e)) => e.get_field(field),
                ResourceStatus::Requested(Some(e)) => e.get_field(field),
                ResourceStatus::Resolved(Some(e)) => e.get_field(field),
                ResourceStatus::Suspended(Some(e)) => e.get_field(field),
                ResourceStatus::TransducDiscon(Some(e)) => e.get_field(field),
                ResourceStatus::Unconfirmed(Some(e)) => e.get_field(field),
                ResourceStatus::Unknown(Some(e)) => e.get_field(field),
                ResourceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceStatus::Abandoned(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Accepted(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Active(Some(e)) => e.get_field_mut(field),
                ResourceStatus::AheadOfTarget(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Arrived(Some(e)) => e.get_field_mut(field),
                ResourceStatus::BehindTarget(Some(e)) => e.get_field_mut(field),
                ResourceStatus::BusyUnavailable(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Complete(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Confirmed(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Declined(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Differential(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Draft(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Error(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Failed(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Free(Some(e)) => e.get_field_mut(field),
                ResourceStatus::HwDiscon(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Inactive(Some(e)) => e.get_field_mut(field),
                ResourceStatus::NotReady(Some(e)) => e.get_field_mut(field),
                ResourceStatus::OnTarget(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Partial(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Planned(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Proposed(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Received(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Refuted(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Replaced(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Requested(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Resolved(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Suspended(Some(e)) => e.get_field_mut(field),
                ResourceStatus::TransducDiscon(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Unconfirmed(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Unknown(Some(e)) => e.get_field_mut(field),
                ResourceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceTypeLink {
    #[doc = "Organization"]
    #[code = "organization"]
    Organization(Option<Element>),
    #[doc = "Patient"]
    #[code = "patient"]
    Patient(Option<Element>),
    #[doc = "Practitioner"]
    #[code = "practitioner"]
    Practitioner(Option<Element>),
    #[doc = "RelatedPerson"]
    #[code = "relatedperson"]
    Relatedperson(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceTypeLink {
    fn default() -> Self {
        ResourceTypeLink::Null(None)
    }
}
impl TryFrom<String> for ResourceTypeLink {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "organization" => Ok(ResourceTypeLink::Organization(None)),
            "patient" => Ok(ResourceTypeLink::Patient(None)),
            "practitioner" => Ok(ResourceTypeLink::Practitioner(None)),
            "relatedperson" => Ok(ResourceTypeLink::Relatedperson(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceTypeLink {
    fn into(self) -> Option<String> {
        match self {
            ResourceTypeLink::Organization(_) => Some("organization".to_string()),
            ResourceTypeLink::Patient(_) => Some("patient".to_string()),
            ResourceTypeLink::Practitioner(_) => Some("practitioner".to_string()),
            ResourceTypeLink::Relatedperson(_) => Some("relatedperson".to_string()),
            ResourceTypeLink::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceTypeLink {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceTypeLink::Organization(Some(e)) => e.get_field(field),
                ResourceTypeLink::Patient(Some(e)) => e.get_field(field),
                ResourceTypeLink::Practitioner(Some(e)) => e.get_field(field),
                ResourceTypeLink::Relatedperson(Some(e)) => e.get_field(field),
                ResourceTypeLink::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceTypeLink::Organization(Some(e)) => e.get_field_mut(field),
                ResourceTypeLink::Patient(Some(e)) => e.get_field_mut(field),
                ResourceTypeLink::Practitioner(Some(e)) => e.get_field_mut(field),
                ResourceTypeLink::Relatedperson(Some(e)) => e.get_field_mut(field),
                ResourceTypeLink::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResourceValidationMode {
    #[doc = "Validate for Create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "Validate for Delete"]
    #[code = "delete"]
    Delete(Option<Element>),
    #[doc = "Validate Against a Profile"]
    #[code = "profile"]
    Profile(Option<Element>),
    #[doc = "Validate for Update"]
    #[code = "update"]
    Update(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResourceValidationMode {
    fn default() -> Self {
        ResourceValidationMode::Null(None)
    }
}
impl TryFrom<String> for ResourceValidationMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "create" => Ok(ResourceValidationMode::Create(None)),
            "delete" => Ok(ResourceValidationMode::Delete(None)),
            "profile" => Ok(ResourceValidationMode::Profile(None)),
            "update" => Ok(ResourceValidationMode::Update(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResourceValidationMode {
    fn into(self) -> Option<String> {
        match self {
            ResourceValidationMode::Create(_) => Some("create".to_string()),
            ResourceValidationMode::Delete(_) => Some("delete".to_string()),
            ResourceValidationMode::Profile(_) => Some("profile".to_string()),
            ResourceValidationMode::Update(_) => Some("update".to_string()),
            ResourceValidationMode::Null(_) => None,
        }
    }
}
impl MetaValue for ResourceValidationMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResourceValidationMode::Create(Some(e)) => e.get_field(field),
                ResourceValidationMode::Delete(Some(e)) => e.get_field(field),
                ResourceValidationMode::Profile(Some(e)) => e.get_field(field),
                ResourceValidationMode::Update(Some(e)) => e.get_field(field),
                ResourceValidationMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResourceValidationMode::Create(Some(e)) => e.get_field_mut(field),
                ResourceValidationMode::Delete(Some(e)) => e.get_field_mut(field),
                ResourceValidationMode::Profile(Some(e)) => e.get_field_mut(field),
                ResourceValidationMode::Update(Some(e)) => e.get_field_mut(field),
                ResourceValidationMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ResponseCode {
    #[doc = "Fatal Error"]
    #[code = "fatal-error"]
    FatalError(Option<Element>),
    #[doc = "OK"]
    #[code = "ok"]
    Ok(Option<Element>),
    #[doc = "Transient Error"]
    #[code = "transient-error"]
    TransientError(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ResponseCode {
    fn default() -> Self {
        ResponseCode::Null(None)
    }
}
impl TryFrom<String> for ResponseCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fatal-error" => Ok(ResponseCode::FatalError(None)),
            "ok" => Ok(ResponseCode::Ok(None)),
            "transient-error" => Ok(ResponseCode::TransientError(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ResponseCode {
    fn into(self) -> Option<String> {
        match self {
            ResponseCode::FatalError(_) => Some("fatal-error".to_string()),
            ResponseCode::Ok(_) => Some("ok".to_string()),
            ResponseCode::TransientError(_) => Some("transient-error".to_string()),
            ResponseCode::Null(_) => None,
        }
    }
}
impl MetaValue for ResponseCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ResponseCode::FatalError(Some(e)) => e.get_field(field),
                ResponseCode::Ok(Some(e)) => e.get_field(field),
                ResponseCode::TransientError(Some(e)) => e.get_field(field),
                ResponseCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ResponseCode::FatalError(Some(e)) => e.get_field_mut(field),
                ResponseCode::Ok(Some(e)) => e.get_field_mut(field),
                ResponseCode::TransientError(Some(e)) => e.get_field_mut(field),
                ResponseCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RestfulCapabilityMode {
    #[doc = "Client"]
    #[code = "client"]
    Client(Option<Element>),
    #[doc = "Server"]
    #[code = "server"]
    Server(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RestfulCapabilityMode {
    fn default() -> Self {
        RestfulCapabilityMode::Null(None)
    }
}
impl TryFrom<String> for RestfulCapabilityMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "client" => Ok(RestfulCapabilityMode::Client(None)),
            "server" => Ok(RestfulCapabilityMode::Server(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RestfulCapabilityMode {
    fn into(self) -> Option<String> {
        match self {
            RestfulCapabilityMode::Client(_) => Some("client".to_string()),
            RestfulCapabilityMode::Server(_) => Some("server".to_string()),
            RestfulCapabilityMode::Null(_) => None,
        }
    }
}
impl MetaValue for RestfulCapabilityMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RestfulCapabilityMode::Client(Some(e)) => e.get_field(field),
                RestfulCapabilityMode::Server(Some(e)) => e.get_field(field),
                RestfulCapabilityMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RestfulCapabilityMode::Client(Some(e)) => e.get_field_mut(field),
                RestfulCapabilityMode::Server(Some(e)) => e.get_field_mut(field),
                RestfulCapabilityMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RestfulSecurityService {
    #[doc = "Basic"]
    #[code = "Basic"]
    Basic(Option<Element>),
    #[doc = "Certificates"]
    #[code = "Certificates"]
    Certificates(Option<Element>),
    #[doc = "Kerberos"]
    #[code = "Kerberos"]
    Kerberos(Option<Element>),
    #[doc = "NTLM"]
    #[code = "NTLM"]
    NTLM(Option<Element>),
    #[doc = "OAuth"]
    #[code = "OAuth"]
    OAuth(Option<Element>),
    #[doc = "SMART-on-FHIR"]
    #[code = "SMART-on-FHIR"]
    SMARTOnFHIR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RestfulSecurityService {
    fn default() -> Self {
        RestfulSecurityService::Null(None)
    }
}
impl TryFrom<String> for RestfulSecurityService {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Basic" => Ok(RestfulSecurityService::Basic(None)),
            "Certificates" => Ok(RestfulSecurityService::Certificates(None)),
            "Kerberos" => Ok(RestfulSecurityService::Kerberos(None)),
            "NTLM" => Ok(RestfulSecurityService::NTLM(None)),
            "OAuth" => Ok(RestfulSecurityService::OAuth(None)),
            "SMART-on-FHIR" => Ok(RestfulSecurityService::SMARTOnFHIR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RestfulSecurityService {
    fn into(self) -> Option<String> {
        match self {
            RestfulSecurityService::Basic(_) => Some("Basic".to_string()),
            RestfulSecurityService::Certificates(_) => Some("Certificates".to_string()),
            RestfulSecurityService::Kerberos(_) => Some("Kerberos".to_string()),
            RestfulSecurityService::NTLM(_) => Some("NTLM".to_string()),
            RestfulSecurityService::OAuth(_) => Some("OAuth".to_string()),
            RestfulSecurityService::SMARTOnFHIR(_) => Some("SMART-on-FHIR".to_string()),
            RestfulSecurityService::Null(_) => None,
        }
    }
}
impl MetaValue for RestfulSecurityService {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RestfulSecurityService::Basic(Some(e)) => e.get_field(field),
                RestfulSecurityService::Certificates(Some(e)) => e.get_field(field),
                RestfulSecurityService::Kerberos(Some(e)) => e.get_field(field),
                RestfulSecurityService::NTLM(Some(e)) => e.get_field(field),
                RestfulSecurityService::OAuth(Some(e)) => e.get_field(field),
                RestfulSecurityService::SMARTOnFHIR(Some(e)) => e.get_field(field),
                RestfulSecurityService::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RestfulSecurityService::Basic(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::Certificates(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::Kerberos(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::NTLM(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::OAuth(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::SMARTOnFHIR(Some(e)) => e.get_field_mut(field),
                RestfulSecurityService::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RiskEstimateType {
    #[doc = "count"]
    #[code = "count"]
    Count(Option<Element>),
    #[doc = "derivedProportion"]
    #[code = "derivedProportion"]
    DerivedProportion(Option<Element>),
    #[doc = "descriptive"]
    #[code = "descriptive"]
    Descriptive(Option<Element>),
    #[doc = "mean"]
    #[code = "mean"]
    Mean(Option<Element>),
    #[doc = "median"]
    #[code = "median"]
    Median(Option<Element>),
    #[doc = "proportion"]
    #[code = "proportion"]
    Proportion(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RiskEstimateType {
    fn default() -> Self {
        RiskEstimateType::Null(None)
    }
}
impl TryFrom<String> for RiskEstimateType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "count" => Ok(RiskEstimateType::Count(None)),
            "derivedProportion" => Ok(RiskEstimateType::DerivedProportion(None)),
            "descriptive" => Ok(RiskEstimateType::Descriptive(None)),
            "mean" => Ok(RiskEstimateType::Mean(None)),
            "median" => Ok(RiskEstimateType::Median(None)),
            "proportion" => Ok(RiskEstimateType::Proportion(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RiskEstimateType {
    fn into(self) -> Option<String> {
        match self {
            RiskEstimateType::Count(_) => Some("count".to_string()),
            RiskEstimateType::DerivedProportion(_) => Some("derivedProportion".to_string()),
            RiskEstimateType::Descriptive(_) => Some("descriptive".to_string()),
            RiskEstimateType::Mean(_) => Some("mean".to_string()),
            RiskEstimateType::Median(_) => Some("median".to_string()),
            RiskEstimateType::Proportion(_) => Some("proportion".to_string()),
            RiskEstimateType::Null(_) => None,
        }
    }
}
impl MetaValue for RiskEstimateType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RiskEstimateType::Count(Some(e)) => e.get_field(field),
                RiskEstimateType::DerivedProportion(Some(e)) => e.get_field(field),
                RiskEstimateType::Descriptive(Some(e)) => e.get_field(field),
                RiskEstimateType::Mean(Some(e)) => e.get_field(field),
                RiskEstimateType::Median(Some(e)) => e.get_field(field),
                RiskEstimateType::Proportion(Some(e)) => e.get_field(field),
                RiskEstimateType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RiskEstimateType::Count(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::DerivedProportion(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::Descriptive(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::Mean(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::Median(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::Proportion(Some(e)) => e.get_field_mut(field),
                RiskEstimateType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum RiskProbability {
    #[doc = "Certain"]
    #[code = "certain"]
    Certain(Option<Element>),
    #[doc = "High likelihood"]
    #[code = "high"]
    High(Option<Element>),
    #[doc = "Low likelihood"]
    #[code = "low"]
    Low(Option<Element>),
    #[doc = "Moderate likelihood"]
    #[code = "moderate"]
    Moderate(Option<Element>),
    #[doc = "Negligible likelihood"]
    #[code = "negligible"]
    Negligible(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for RiskProbability {
    fn default() -> Self {
        RiskProbability::Null(None)
    }
}
impl TryFrom<String> for RiskProbability {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "certain" => Ok(RiskProbability::Certain(None)),
            "high" => Ok(RiskProbability::High(None)),
            "low" => Ok(RiskProbability::Low(None)),
            "moderate" => Ok(RiskProbability::Moderate(None)),
            "negligible" => Ok(RiskProbability::Negligible(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &RiskProbability {
    fn into(self) -> Option<String> {
        match self {
            RiskProbability::Certain(_) => Some("certain".to_string()),
            RiskProbability::High(_) => Some("high".to_string()),
            RiskProbability::Low(_) => Some("low".to_string()),
            RiskProbability::Moderate(_) => Some("moderate".to_string()),
            RiskProbability::Negligible(_) => Some("negligible".to_string()),
            RiskProbability::Null(_) => None,
        }
    }
}
impl MetaValue for RiskProbability {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                RiskProbability::Certain(Some(e)) => e.get_field(field),
                RiskProbability::High(Some(e)) => e.get_field(field),
                RiskProbability::Low(Some(e)) => e.get_field(field),
                RiskProbability::Moderate(Some(e)) => e.get_field(field),
                RiskProbability::Negligible(Some(e)) => e.get_field(field),
                RiskProbability::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                RiskProbability::Certain(Some(e)) => e.get_field_mut(field),
                RiskProbability::High(Some(e)) => e.get_field_mut(field),
                RiskProbability::Low(Some(e)) => e.get_field_mut(field),
                RiskProbability::Moderate(Some(e)) => e.get_field_mut(field),
                RiskProbability::Negligible(Some(e)) => e.get_field_mut(field),
                RiskProbability::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SearchComparator {
    #[doc = "Approximately"]
    #[code = "ap"]
    Ap(Option<Element>),
    #[doc = "Ends Before"]
    #[code = "eb"]
    Eb(Option<Element>),
    #[doc = "Equals"]
    #[code = "eq"]
    Eq(Option<Element>),
    #[doc = "Greater or Equals"]
    #[code = "ge"]
    Ge(Option<Element>),
    #[doc = "Greater Than"]
    #[code = "gt"]
    Gt(Option<Element>),
    #[doc = "Less of Equal"]
    #[code = "le"]
    Le(Option<Element>),
    #[doc = "Less Than"]
    #[code = "lt"]
    Lt(Option<Element>),
    #[doc = "Not Equals"]
    #[code = "ne"]
    Ne(Option<Element>),
    #[doc = "Starts After"]
    #[code = "sa"]
    Sa(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SearchComparator {
    fn default() -> Self {
        SearchComparator::Null(None)
    }
}
impl TryFrom<String> for SearchComparator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ap" => Ok(SearchComparator::Ap(None)),
            "eb" => Ok(SearchComparator::Eb(None)),
            "eq" => Ok(SearchComparator::Eq(None)),
            "ge" => Ok(SearchComparator::Ge(None)),
            "gt" => Ok(SearchComparator::Gt(None)),
            "le" => Ok(SearchComparator::Le(None)),
            "lt" => Ok(SearchComparator::Lt(None)),
            "ne" => Ok(SearchComparator::Ne(None)),
            "sa" => Ok(SearchComparator::Sa(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SearchComparator {
    fn into(self) -> Option<String> {
        match self {
            SearchComparator::Ap(_) => Some("ap".to_string()),
            SearchComparator::Eb(_) => Some("eb".to_string()),
            SearchComparator::Eq(_) => Some("eq".to_string()),
            SearchComparator::Ge(_) => Some("ge".to_string()),
            SearchComparator::Gt(_) => Some("gt".to_string()),
            SearchComparator::Le(_) => Some("le".to_string()),
            SearchComparator::Lt(_) => Some("lt".to_string()),
            SearchComparator::Ne(_) => Some("ne".to_string()),
            SearchComparator::Sa(_) => Some("sa".to_string()),
            SearchComparator::Null(_) => None,
        }
    }
}
impl MetaValue for SearchComparator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SearchComparator::Ap(Some(e)) => e.get_field(field),
                SearchComparator::Eb(Some(e)) => e.get_field(field),
                SearchComparator::Eq(Some(e)) => e.get_field(field),
                SearchComparator::Ge(Some(e)) => e.get_field(field),
                SearchComparator::Gt(Some(e)) => e.get_field(field),
                SearchComparator::Le(Some(e)) => e.get_field(field),
                SearchComparator::Lt(Some(e)) => e.get_field(field),
                SearchComparator::Ne(Some(e)) => e.get_field(field),
                SearchComparator::Sa(Some(e)) => e.get_field(field),
                SearchComparator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SearchComparator::Ap(Some(e)) => e.get_field_mut(field),
                SearchComparator::Eb(Some(e)) => e.get_field_mut(field),
                SearchComparator::Eq(Some(e)) => e.get_field_mut(field),
                SearchComparator::Ge(Some(e)) => e.get_field_mut(field),
                SearchComparator::Gt(Some(e)) => e.get_field_mut(field),
                SearchComparator::Le(Some(e)) => e.get_field_mut(field),
                SearchComparator::Lt(Some(e)) => e.get_field_mut(field),
                SearchComparator::Ne(Some(e)) => e.get_field_mut(field),
                SearchComparator::Sa(Some(e)) => e.get_field_mut(field),
                SearchComparator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SearchEntryMode {
    #[doc = "Include"]
    #[code = "include"]
    Include(Option<Element>),
    #[doc = "Match"]
    #[code = "match"]
    Match(Option<Element>),
    #[doc = "Outcome"]
    #[code = "outcome"]
    Outcome(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SearchEntryMode {
    fn default() -> Self {
        SearchEntryMode::Null(None)
    }
}
impl TryFrom<String> for SearchEntryMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "include" => Ok(SearchEntryMode::Include(None)),
            "match" => Ok(SearchEntryMode::Match(None)),
            "outcome" => Ok(SearchEntryMode::Outcome(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SearchEntryMode {
    fn into(self) -> Option<String> {
        match self {
            SearchEntryMode::Include(_) => Some("include".to_string()),
            SearchEntryMode::Match(_) => Some("match".to_string()),
            SearchEntryMode::Outcome(_) => Some("outcome".to_string()),
            SearchEntryMode::Null(_) => None,
        }
    }
}
impl MetaValue for SearchEntryMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SearchEntryMode::Include(Some(e)) => e.get_field(field),
                SearchEntryMode::Match(Some(e)) => e.get_field(field),
                SearchEntryMode::Outcome(Some(e)) => e.get_field(field),
                SearchEntryMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SearchEntryMode::Include(Some(e)) => e.get_field_mut(field),
                SearchEntryMode::Match(Some(e)) => e.get_field_mut(field),
                SearchEntryMode::Outcome(Some(e)) => e.get_field_mut(field),
                SearchEntryMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SearchModifierCode {
    #[doc = "Above"]
    #[code = "above"]
    Above(Option<Element>),
    #[doc = "Below"]
    #[code = "below"]
    Below(Option<Element>),
    #[doc = "Contains"]
    #[code = "contains"]
    Contains(Option<Element>),
    #[doc = "Exact"]
    #[code = "exact"]
    Exact(Option<Element>),
    #[doc = "Identifier"]
    #[code = "identifier"]
    Identifier(Option<Element>),
    #[doc = "In"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "Missing"]
    #[code = "missing"]
    Missing(Option<Element>),
    #[doc = "Not"]
    #[code = "not"]
    Not(Option<Element>),
    #[doc = "Not In"]
    #[code = "not-in"]
    NotIn(Option<Element>),
    #[doc = "Of Type"]
    #[code = "ofType"]
    OfType(Option<Element>),
    #[doc = "Text"]
    #[code = "text"]
    Text(Option<Element>),
    #[doc = "Type"]
    #[code = "type"]
    Type(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SearchModifierCode {
    fn default() -> Self {
        SearchModifierCode::Null(None)
    }
}
impl TryFrom<String> for SearchModifierCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "above" => Ok(SearchModifierCode::Above(None)),
            "below" => Ok(SearchModifierCode::Below(None)),
            "contains" => Ok(SearchModifierCode::Contains(None)),
            "exact" => Ok(SearchModifierCode::Exact(None)),
            "identifier" => Ok(SearchModifierCode::Identifier(None)),
            "in" => Ok(SearchModifierCode::In(None)),
            "missing" => Ok(SearchModifierCode::Missing(None)),
            "not" => Ok(SearchModifierCode::Not(None)),
            "not-in" => Ok(SearchModifierCode::NotIn(None)),
            "ofType" => Ok(SearchModifierCode::OfType(None)),
            "text" => Ok(SearchModifierCode::Text(None)),
            "type" => Ok(SearchModifierCode::Type(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SearchModifierCode {
    fn into(self) -> Option<String> {
        match self {
            SearchModifierCode::Above(_) => Some("above".to_string()),
            SearchModifierCode::Below(_) => Some("below".to_string()),
            SearchModifierCode::Contains(_) => Some("contains".to_string()),
            SearchModifierCode::Exact(_) => Some("exact".to_string()),
            SearchModifierCode::Identifier(_) => Some("identifier".to_string()),
            SearchModifierCode::In(_) => Some("in".to_string()),
            SearchModifierCode::Missing(_) => Some("missing".to_string()),
            SearchModifierCode::Not(_) => Some("not".to_string()),
            SearchModifierCode::NotIn(_) => Some("not-in".to_string()),
            SearchModifierCode::OfType(_) => Some("ofType".to_string()),
            SearchModifierCode::Text(_) => Some("text".to_string()),
            SearchModifierCode::Type(_) => Some("type".to_string()),
            SearchModifierCode::Null(_) => None,
        }
    }
}
impl MetaValue for SearchModifierCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SearchModifierCode::Above(Some(e)) => e.get_field(field),
                SearchModifierCode::Below(Some(e)) => e.get_field(field),
                SearchModifierCode::Contains(Some(e)) => e.get_field(field),
                SearchModifierCode::Exact(Some(e)) => e.get_field(field),
                SearchModifierCode::Identifier(Some(e)) => e.get_field(field),
                SearchModifierCode::In(Some(e)) => e.get_field(field),
                SearchModifierCode::Missing(Some(e)) => e.get_field(field),
                SearchModifierCode::Not(Some(e)) => e.get_field(field),
                SearchModifierCode::NotIn(Some(e)) => e.get_field(field),
                SearchModifierCode::OfType(Some(e)) => e.get_field(field),
                SearchModifierCode::Text(Some(e)) => e.get_field(field),
                SearchModifierCode::Type(Some(e)) => e.get_field(field),
                SearchModifierCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SearchModifierCode::Above(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Below(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Contains(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Exact(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Identifier(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::In(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Missing(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Not(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::NotIn(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::OfType(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Text(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Type(Some(e)) => e.get_field_mut(field),
                SearchModifierCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SearchParamType {
    #[doc = "Composite"]
    #[code = "composite"]
    Composite(Option<Element>),
    #[doc = "Date/DateTime"]
    #[code = "date"]
    Date(Option<Element>),
    #[doc = "Number"]
    #[code = "number"]
    Number(Option<Element>),
    #[doc = "Quantity"]
    #[code = "quantity"]
    Quantity(Option<Element>),
    #[doc = "Reference"]
    #[code = "reference"]
    Reference(Option<Element>),
    #[doc = "Special"]
    #[code = "special"]
    Special(Option<Element>),
    #[doc = "String"]
    #[code = "string"]
    String(Option<Element>),
    #[doc = "Token"]
    #[code = "token"]
    Token(Option<Element>),
    #[doc = "URI"]
    #[code = "uri"]
    Uri(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SearchParamType {
    fn default() -> Self {
        SearchParamType::Null(None)
    }
}
impl TryFrom<String> for SearchParamType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "composite" => Ok(SearchParamType::Composite(None)),
            "date" => Ok(SearchParamType::Date(None)),
            "number" => Ok(SearchParamType::Number(None)),
            "quantity" => Ok(SearchParamType::Quantity(None)),
            "reference" => Ok(SearchParamType::Reference(None)),
            "special" => Ok(SearchParamType::Special(None)),
            "string" => Ok(SearchParamType::String(None)),
            "token" => Ok(SearchParamType::Token(None)),
            "uri" => Ok(SearchParamType::Uri(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SearchParamType {
    fn into(self) -> Option<String> {
        match self {
            SearchParamType::Composite(_) => Some("composite".to_string()),
            SearchParamType::Date(_) => Some("date".to_string()),
            SearchParamType::Number(_) => Some("number".to_string()),
            SearchParamType::Quantity(_) => Some("quantity".to_string()),
            SearchParamType::Reference(_) => Some("reference".to_string()),
            SearchParamType::Special(_) => Some("special".to_string()),
            SearchParamType::String(_) => Some("string".to_string()),
            SearchParamType::Token(_) => Some("token".to_string()),
            SearchParamType::Uri(_) => Some("uri".to_string()),
            SearchParamType::Null(_) => None,
        }
    }
}
impl MetaValue for SearchParamType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SearchParamType::Composite(Some(e)) => e.get_field(field),
                SearchParamType::Date(Some(e)) => e.get_field(field),
                SearchParamType::Number(Some(e)) => e.get_field(field),
                SearchParamType::Quantity(Some(e)) => e.get_field(field),
                SearchParamType::Reference(Some(e)) => e.get_field(field),
                SearchParamType::Special(Some(e)) => e.get_field(field),
                SearchParamType::String(Some(e)) => e.get_field(field),
                SearchParamType::Token(Some(e)) => e.get_field(field),
                SearchParamType::Uri(Some(e)) => e.get_field(field),
                SearchParamType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SearchParamType::Composite(Some(e)) => e.get_field_mut(field),
                SearchParamType::Date(Some(e)) => e.get_field_mut(field),
                SearchParamType::Number(Some(e)) => e.get_field_mut(field),
                SearchParamType::Quantity(Some(e)) => e.get_field_mut(field),
                SearchParamType::Reference(Some(e)) => e.get_field_mut(field),
                SearchParamType::Special(Some(e)) => e.get_field_mut(field),
                SearchParamType::String(Some(e)) => e.get_field_mut(field),
                SearchParamType::Token(Some(e)) => e.get_field_mut(field),
                SearchParamType::Uri(Some(e)) => e.get_field_mut(field),
                SearchParamType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SearchXpathUsage {
    #[doc = "Distance"]
    #[code = "distance"]
    Distance(Option<Element>),
    #[doc = "Nearby"]
    #[code = "nearby"]
    Nearby(Option<Element>),
    #[doc = "Normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Phonetic"]
    #[code = "phonetic"]
    Phonetic(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SearchXpathUsage {
    fn default() -> Self {
        SearchXpathUsage::Null(None)
    }
}
impl TryFrom<String> for SearchXpathUsage {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "distance" => Ok(SearchXpathUsage::Distance(None)),
            "nearby" => Ok(SearchXpathUsage::Nearby(None)),
            "normal" => Ok(SearchXpathUsage::Normal(None)),
            "other" => Ok(SearchXpathUsage::Other(None)),
            "phonetic" => Ok(SearchXpathUsage::Phonetic(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SearchXpathUsage {
    fn into(self) -> Option<String> {
        match self {
            SearchXpathUsage::Distance(_) => Some("distance".to_string()),
            SearchXpathUsage::Nearby(_) => Some("nearby".to_string()),
            SearchXpathUsage::Normal(_) => Some("normal".to_string()),
            SearchXpathUsage::Other(_) => Some("other".to_string()),
            SearchXpathUsage::Phonetic(_) => Some("phonetic".to_string()),
            SearchXpathUsage::Null(_) => None,
        }
    }
}
impl MetaValue for SearchXpathUsage {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SearchXpathUsage::Distance(Some(e)) => e.get_field(field),
                SearchXpathUsage::Nearby(Some(e)) => e.get_field(field),
                SearchXpathUsage::Normal(Some(e)) => e.get_field(field),
                SearchXpathUsage::Other(Some(e)) => e.get_field(field),
                SearchXpathUsage::Phonetic(Some(e)) => e.get_field(field),
                SearchXpathUsage::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SearchXpathUsage::Distance(Some(e)) => e.get_field_mut(field),
                SearchXpathUsage::Nearby(Some(e)) => e.get_field_mut(field),
                SearchXpathUsage::Normal(Some(e)) => e.get_field_mut(field),
                SearchXpathUsage::Other(Some(e)) => e.get_field_mut(field),
                SearchXpathUsage::Phonetic(Some(e)) => e.get_field_mut(field),
                SearchXpathUsage::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SecondaryFinding {
    #[doc = "ACMG Version 1"]
    #[code = "acmg-version1"]
    AcmgVersion1(Option<Element>),
    #[doc = "ACMG Version 2"]
    #[code = "acmg-version2"]
    AcmgVersion2(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SecondaryFinding {
    fn default() -> Self {
        SecondaryFinding::Null(None)
    }
}
impl TryFrom<String> for SecondaryFinding {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "acmg-version1" => Ok(SecondaryFinding::AcmgVersion1(None)),
            "acmg-version2" => Ok(SecondaryFinding::AcmgVersion2(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SecondaryFinding {
    fn into(self) -> Option<String> {
        match self {
            SecondaryFinding::AcmgVersion1(_) => Some("acmg-version1".to_string()),
            SecondaryFinding::AcmgVersion2(_) => Some("acmg-version2".to_string()),
            SecondaryFinding::Null(_) => None,
        }
    }
}
impl MetaValue for SecondaryFinding {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SecondaryFinding::AcmgVersion1(Some(e)) => e.get_field(field),
                SecondaryFinding::AcmgVersion2(Some(e)) => e.get_field(field),
                SecondaryFinding::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SecondaryFinding::AcmgVersion1(Some(e)) => e.get_field_mut(field),
                SecondaryFinding::AcmgVersion2(Some(e)) => e.get_field_mut(field),
                SecondaryFinding::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SequenceType {
    #[doc = "AA Sequence"]
    #[code = "aa"]
    Aa(Option<Element>),
    #[doc = "DNA Sequence"]
    #[code = "dna"]
    Dna(Option<Element>),
    #[doc = "RNA Sequence"]
    #[code = "rna"]
    Rna(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SequenceType {
    fn default() -> Self {
        SequenceType::Null(None)
    }
}
impl TryFrom<String> for SequenceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aa" => Ok(SequenceType::Aa(None)),
            "dna" => Ok(SequenceType::Dna(None)),
            "rna" => Ok(SequenceType::Rna(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SequenceType {
    fn into(self) -> Option<String> {
        match self {
            SequenceType::Aa(_) => Some("aa".to_string()),
            SequenceType::Dna(_) => Some("dna".to_string()),
            SequenceType::Rna(_) => Some("rna".to_string()),
            SequenceType::Null(_) => None,
        }
    }
}
impl MetaValue for SequenceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SequenceType::Aa(Some(e)) => e.get_field(field),
                SequenceType::Dna(Some(e)) => e.get_field(field),
                SequenceType::Rna(Some(e)) => e.get_field(field),
                SequenceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SequenceType::Aa(Some(e)) => e.get_field_mut(field),
                SequenceType::Dna(Some(e)) => e.get_field_mut(field),
                SequenceType::Rna(Some(e)) => e.get_field_mut(field),
                SequenceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SeriesPerformerFunction {
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SeriesPerformerFunction {
    fn default() -> Self {
        SeriesPerformerFunction::Null(None)
    }
}
impl TryFrom<String> for SeriesPerformerFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CON" => Ok(SeriesPerformerFunction::CON(None)),
            "PRF" => Ok(SeriesPerformerFunction::PRF(None)),
            "REF" => Ok(SeriesPerformerFunction::REF(None)),
            "SPRF" => Ok(SeriesPerformerFunction::SPRF(None)),
            "VRF" => Ok(SeriesPerformerFunction::VRF(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SeriesPerformerFunction {
    fn into(self) -> Option<String> {
        match self {
            SeriesPerformerFunction::CON(_) => Some("CON".to_string()),
            SeriesPerformerFunction::PRF(_) => Some("PRF".to_string()),
            SeriesPerformerFunction::REF(_) => Some("REF".to_string()),
            SeriesPerformerFunction::SPRF(_) => Some("SPRF".to_string()),
            SeriesPerformerFunction::VRF(_) => Some("VRF".to_string()),
            SeriesPerformerFunction::Null(_) => None,
        }
    }
}
impl MetaValue for SeriesPerformerFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SeriesPerformerFunction::CON(Some(e)) => e.get_field(field),
                SeriesPerformerFunction::PRF(Some(e)) => e.get_field(field),
                SeriesPerformerFunction::REF(Some(e)) => e.get_field(field),
                SeriesPerformerFunction::SPRF(Some(e)) => e.get_field(field),
                SeriesPerformerFunction::VRF(Some(e)) => e.get_field(field),
                SeriesPerformerFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SeriesPerformerFunction::CON(Some(e)) => e.get_field_mut(field),
                SeriesPerformerFunction::PRF(Some(e)) => e.get_field_mut(field),
                SeriesPerformerFunction::REF(Some(e)) => e.get_field_mut(field),
                SeriesPerformerFunction::SPRF(Some(e)) => e.get_field_mut(field),
                SeriesPerformerFunction::VRF(Some(e)) => e.get_field_mut(field),
                SeriesPerformerFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServiceModifiers {
    #[doc = "After hours"]
    #[code = "ah"]
    Ah(Option<Element>),
    #[doc = "Side of the Road"]
    #[code = "sr"]
    Sr(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServiceModifiers {
    fn default() -> Self {
        ServiceModifiers::Null(None)
    }
}
impl TryFrom<String> for ServiceModifiers {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ah" => Ok(ServiceModifiers::Ah(None)),
            "sr" => Ok(ServiceModifiers::Sr(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServiceModifiers {
    fn into(self) -> Option<String> {
        match self {
            ServiceModifiers::Ah(_) => Some("ah".to_string()),
            ServiceModifiers::Sr(_) => Some("sr".to_string()),
            ServiceModifiers::Null(_) => None,
        }
    }
}
impl MetaValue for ServiceModifiers {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServiceModifiers::Ah(Some(e)) => e.get_field(field),
                ServiceModifiers::Sr(Some(e)) => e.get_field(field),
                ServiceModifiers::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServiceModifiers::Ah(Some(e)) => e.get_field_mut(field),
                ServiceModifiers::Sr(Some(e)) => e.get_field_mut(field),
                ServiceModifiers::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServicePharmacy {
    #[doc = "Compounding Fee"]
    #[code = "compoundfee"]
    Compoundfee(Option<Element>),
    #[doc = "Dispense Fee"]
    #[code = "dispensefee"]
    Dispensefee(Option<Element>),
    #[doc = "Drug Cost"]
    #[code = "drugcost"]
    Drugcost(Option<Element>),
    #[doc = "Flu Shot"]
    #[code = "flushot"]
    Flushot(Option<Element>),
    #[doc = "Markup"]
    #[code = "markup"]
    Markup(Option<Element>),
    #[doc = "Smoking cessation"]
    #[code = "smokecess"]
    Smokecess(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServicePharmacy {
    fn default() -> Self {
        ServicePharmacy::Null(None)
    }
}
impl TryFrom<String> for ServicePharmacy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "compoundfee" => Ok(ServicePharmacy::Compoundfee(None)),
            "dispensefee" => Ok(ServicePharmacy::Dispensefee(None)),
            "drugcost" => Ok(ServicePharmacy::Drugcost(None)),
            "flushot" => Ok(ServicePharmacy::Flushot(None)),
            "markup" => Ok(ServicePharmacy::Markup(None)),
            "smokecess" => Ok(ServicePharmacy::Smokecess(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServicePharmacy {
    fn into(self) -> Option<String> {
        match self {
            ServicePharmacy::Compoundfee(_) => Some("compoundfee".to_string()),
            ServicePharmacy::Dispensefee(_) => Some("dispensefee".to_string()),
            ServicePharmacy::Drugcost(_) => Some("drugcost".to_string()),
            ServicePharmacy::Flushot(_) => Some("flushot".to_string()),
            ServicePharmacy::Markup(_) => Some("markup".to_string()),
            ServicePharmacy::Smokecess(_) => Some("smokecess".to_string()),
            ServicePharmacy::Null(_) => None,
        }
    }
}
impl MetaValue for ServicePharmacy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServicePharmacy::Compoundfee(Some(e)) => e.get_field(field),
                ServicePharmacy::Dispensefee(Some(e)) => e.get_field(field),
                ServicePharmacy::Drugcost(Some(e)) => e.get_field(field),
                ServicePharmacy::Flushot(Some(e)) => e.get_field(field),
                ServicePharmacy::Markup(Some(e)) => e.get_field(field),
                ServicePharmacy::Smokecess(Some(e)) => e.get_field(field),
                ServicePharmacy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServicePharmacy::Compoundfee(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Dispensefee(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Drugcost(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Flushot(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Markup(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Smokecess(Some(e)) => e.get_field_mut(field),
                ServicePharmacy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServicePlace {
    #[doc = "Pharmacy"]
    #[code = "01"]
    V01(Option<Element>),
    #[doc = "School"]
    #[code = "03"]
    V03(Option<Element>),
    #[doc = "Homeless Shelter"]
    #[code = "04"]
    V04(Option<Element>),
    #[doc = "Indian Health Service Free-standing Facility"]
    #[code = "05"]
    V05(Option<Element>),
    #[doc = "Indian Health Service Provider-based Facility"]
    #[code = "06"]
    V06(Option<Element>),
    #[doc = "Tribal 638 Free-Standing Facility"]
    #[code = "07"]
    V07(Option<Element>),
    #[doc = "Tribal 638 Provider-Based Facility"]
    #[code = "08"]
    V08(Option<Element>),
    #[doc = "Prison/Correctional Facility"]
    #[code = "09"]
    V09(Option<Element>),
    #[doc = "Office"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "Home"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "Assisted Living Fa"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "Group Home"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "Mobile Unit"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "Off Campus-Outpatient Hospital"]
    #[code = "19"]
    V19(Option<Element>),
    #[doc = "Urgent Care Facility"]
    #[code = "20"]
    V20(Option<Element>),
    #[doc = "Inpatient Hospital"]
    #[code = "21"]
    V21(Option<Element>),
    #[doc = "AmbulanceLand"]
    #[code = "41"]
    V41(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServicePlace {
    fn default() -> Self {
        ServicePlace::Null(None)
    }
}
impl TryFrom<String> for ServicePlace {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "01" => Ok(ServicePlace::V01(None)),
            "03" => Ok(ServicePlace::V03(None)),
            "04" => Ok(ServicePlace::V04(None)),
            "05" => Ok(ServicePlace::V05(None)),
            "06" => Ok(ServicePlace::V06(None)),
            "07" => Ok(ServicePlace::V07(None)),
            "08" => Ok(ServicePlace::V08(None)),
            "09" => Ok(ServicePlace::V09(None)),
            "11" => Ok(ServicePlace::V11(None)),
            "12" => Ok(ServicePlace::V12(None)),
            "13" => Ok(ServicePlace::V13(None)),
            "14" => Ok(ServicePlace::V14(None)),
            "15" => Ok(ServicePlace::V15(None)),
            "19" => Ok(ServicePlace::V19(None)),
            "20" => Ok(ServicePlace::V20(None)),
            "21" => Ok(ServicePlace::V21(None)),
            "41" => Ok(ServicePlace::V41(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServicePlace {
    fn into(self) -> Option<String> {
        match self {
            ServicePlace::V01(_) => Some("01".to_string()),
            ServicePlace::V03(_) => Some("03".to_string()),
            ServicePlace::V04(_) => Some("04".to_string()),
            ServicePlace::V05(_) => Some("05".to_string()),
            ServicePlace::V06(_) => Some("06".to_string()),
            ServicePlace::V07(_) => Some("07".to_string()),
            ServicePlace::V08(_) => Some("08".to_string()),
            ServicePlace::V09(_) => Some("09".to_string()),
            ServicePlace::V11(_) => Some("11".to_string()),
            ServicePlace::V12(_) => Some("12".to_string()),
            ServicePlace::V13(_) => Some("13".to_string()),
            ServicePlace::V14(_) => Some("14".to_string()),
            ServicePlace::V15(_) => Some("15".to_string()),
            ServicePlace::V19(_) => Some("19".to_string()),
            ServicePlace::V20(_) => Some("20".to_string()),
            ServicePlace::V21(_) => Some("21".to_string()),
            ServicePlace::V41(_) => Some("41".to_string()),
            ServicePlace::Null(_) => None,
        }
    }
}
impl MetaValue for ServicePlace {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServicePlace::V01(Some(e)) => e.get_field(field),
                ServicePlace::V03(Some(e)) => e.get_field(field),
                ServicePlace::V04(Some(e)) => e.get_field(field),
                ServicePlace::V05(Some(e)) => e.get_field(field),
                ServicePlace::V06(Some(e)) => e.get_field(field),
                ServicePlace::V07(Some(e)) => e.get_field(field),
                ServicePlace::V08(Some(e)) => e.get_field(field),
                ServicePlace::V09(Some(e)) => e.get_field(field),
                ServicePlace::V11(Some(e)) => e.get_field(field),
                ServicePlace::V12(Some(e)) => e.get_field(field),
                ServicePlace::V13(Some(e)) => e.get_field(field),
                ServicePlace::V14(Some(e)) => e.get_field(field),
                ServicePlace::V15(Some(e)) => e.get_field(field),
                ServicePlace::V19(Some(e)) => e.get_field(field),
                ServicePlace::V20(Some(e)) => e.get_field(field),
                ServicePlace::V21(Some(e)) => e.get_field(field),
                ServicePlace::V41(Some(e)) => e.get_field(field),
                ServicePlace::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServicePlace::V01(Some(e)) => e.get_field_mut(field),
                ServicePlace::V03(Some(e)) => e.get_field_mut(field),
                ServicePlace::V04(Some(e)) => e.get_field_mut(field),
                ServicePlace::V05(Some(e)) => e.get_field_mut(field),
                ServicePlace::V06(Some(e)) => e.get_field_mut(field),
                ServicePlace::V07(Some(e)) => e.get_field_mut(field),
                ServicePlace::V08(Some(e)) => e.get_field_mut(field),
                ServicePlace::V09(Some(e)) => e.get_field_mut(field),
                ServicePlace::V11(Some(e)) => e.get_field_mut(field),
                ServicePlace::V12(Some(e)) => e.get_field_mut(field),
                ServicePlace::V13(Some(e)) => e.get_field_mut(field),
                ServicePlace::V14(Some(e)) => e.get_field_mut(field),
                ServicePlace::V15(Some(e)) => e.get_field_mut(field),
                ServicePlace::V19(Some(e)) => e.get_field_mut(field),
                ServicePlace::V20(Some(e)) => e.get_field_mut(field),
                ServicePlace::V21(Some(e)) => e.get_field_mut(field),
                ServicePlace::V41(Some(e)) => e.get_field_mut(field),
                ServicePlace::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServiceProduct {
    #[doc = "Exam"]
    #[code = "exam"]
    Exam(Option<Element>),
    #[doc = "Flu shot"]
    #[code = "flushot"]
    Flushot(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServiceProduct {
    fn default() -> Self {
        ServiceProduct::Null(None)
    }
}
impl TryFrom<String> for ServiceProduct {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exam" => Ok(ServiceProduct::Exam(None)),
            "flushot" => Ok(ServiceProduct::Flushot(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServiceProduct {
    fn into(self) -> Option<String> {
        match self {
            ServiceProduct::Exam(_) => Some("exam".to_string()),
            ServiceProduct::Flushot(_) => Some("flushot".to_string()),
            ServiceProduct::Null(_) => None,
        }
    }
}
impl MetaValue for ServiceProduct {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServiceProduct::Exam(Some(e)) => e.get_field(field),
                ServiceProduct::Flushot(Some(e)) => e.get_field(field),
                ServiceProduct::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServiceProduct::Exam(Some(e)) => e.get_field_mut(field),
                ServiceProduct::Flushot(Some(e)) => e.get_field_mut(field),
                ServiceProduct::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServiceProvisionConditions {
    #[doc = "Fees apply"]
    #[code = "cost"]
    Cost(Option<Element>),
    #[doc = "Discounts Available"]
    #[code = "disc"]
    Disc(Option<Element>),
    #[doc = "Free"]
    #[code = "free"]
    Free(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServiceProvisionConditions {
    fn default() -> Self {
        ServiceProvisionConditions::Null(None)
    }
}
impl TryFrom<String> for ServiceProvisionConditions {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "cost" => Ok(ServiceProvisionConditions::Cost(None)),
            "disc" => Ok(ServiceProvisionConditions::Disc(None)),
            "free" => Ok(ServiceProvisionConditions::Free(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServiceProvisionConditions {
    fn into(self) -> Option<String> {
        match self {
            ServiceProvisionConditions::Cost(_) => Some("cost".to_string()),
            ServiceProvisionConditions::Disc(_) => Some("disc".to_string()),
            ServiceProvisionConditions::Free(_) => Some("free".to_string()),
            ServiceProvisionConditions::Null(_) => None,
        }
    }
}
impl MetaValue for ServiceProvisionConditions {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServiceProvisionConditions::Cost(Some(e)) => e.get_field(field),
                ServiceProvisionConditions::Disc(Some(e)) => e.get_field(field),
                ServiceProvisionConditions::Free(Some(e)) => e.get_field(field),
                ServiceProvisionConditions::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServiceProvisionConditions::Cost(Some(e)) => e.get_field_mut(field),
                ServiceProvisionConditions::Disc(Some(e)) => e.get_field_mut(field),
                ServiceProvisionConditions::Free(Some(e)) => e.get_field_mut(field),
                ServiceProvisionConditions::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServiceReferralMethod {
    #[doc = "Secure Messaging"]
    #[code = "elec"]
    Elec(Option<Element>),
    #[doc = "Fax"]
    #[code = "fax"]
    Fax(Option<Element>),
    #[doc = "Mail"]
    #[code = "mail"]
    Mail(Option<Element>),
    #[doc = "Phone"]
    #[code = "phone"]
    Phone(Option<Element>),
    #[doc = "Secure Email"]
    #[code = "semail"]
    Semail(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServiceReferralMethod {
    fn default() -> Self {
        ServiceReferralMethod::Null(None)
    }
}
impl TryFrom<String> for ServiceReferralMethod {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "elec" => Ok(ServiceReferralMethod::Elec(None)),
            "fax" => Ok(ServiceReferralMethod::Fax(None)),
            "mail" => Ok(ServiceReferralMethod::Mail(None)),
            "phone" => Ok(ServiceReferralMethod::Phone(None)),
            "semail" => Ok(ServiceReferralMethod::Semail(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServiceReferralMethod {
    fn into(self) -> Option<String> {
        match self {
            ServiceReferralMethod::Elec(_) => Some("elec".to_string()),
            ServiceReferralMethod::Fax(_) => Some("fax".to_string()),
            ServiceReferralMethod::Mail(_) => Some("mail".to_string()),
            ServiceReferralMethod::Phone(_) => Some("phone".to_string()),
            ServiceReferralMethod::Semail(_) => Some("semail".to_string()),
            ServiceReferralMethod::Null(_) => None,
        }
    }
}
impl MetaValue for ServiceReferralMethod {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServiceReferralMethod::Elec(Some(e)) => e.get_field(field),
                ServiceReferralMethod::Fax(Some(e)) => e.get_field(field),
                ServiceReferralMethod::Mail(Some(e)) => e.get_field(field),
                ServiceReferralMethod::Phone(Some(e)) => e.get_field(field),
                ServiceReferralMethod::Semail(Some(e)) => e.get_field(field),
                ServiceReferralMethod::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServiceReferralMethod::Elec(Some(e)) => e.get_field_mut(field),
                ServiceReferralMethod::Fax(Some(e)) => e.get_field_mut(field),
                ServiceReferralMethod::Mail(Some(e)) => e.get_field_mut(field),
                ServiceReferralMethod::Phone(Some(e)) => e.get_field_mut(field),
                ServiceReferralMethod::Semail(Some(e)) => e.get_field_mut(field),
                ServiceReferralMethod::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServiceUscls {
    #[doc = "Exam, comp, primary"]
    #[code = "1101"]
    V1101(Option<Element>),
    #[doc = "Exam, comp, mixed"]
    #[code = "1102"]
    V1102(Option<Element>),
    #[doc = "Exam, comp, permanent"]
    #[code = "1103"]
    V1103(Option<Element>),
    #[doc = "Polishing, 1 unit"]
    #[code = "11101"]
    V11101(Option<Element>),
    #[doc = "Polishing, 2 unit"]
    #[code = "11102"]
    V11102(Option<Element>),
    #[doc = "Polishing, 3 unit"]
    #[code = "11103"]
    V11103(Option<Element>),
    #[doc = "Polishing, 4 unit"]
    #[code = "11104"]
    V11104(Option<Element>),
    #[doc = "Exam, recall"]
    #[code = "1201"]
    V1201(Option<Element>),
    #[doc = "Exam, emergency"]
    #[code = "1205"]
    V1205(Option<Element>),
    #[doc = "Radiograph, series (12)"]
    #[code = "2101"]
    V2101(Option<Element>),
    #[doc = "Radiograph, series (16)"]
    #[code = "2102"]
    V2102(Option<Element>),
    #[doc = "Amalgam, 1 surface"]
    #[code = "21211"]
    V21211(Option<Element>),
    #[doc = "Amalgam, 2 surface"]
    #[code = "21212"]
    V21212(Option<Element>),
    #[doc = "Radiograph, bitewing"]
    #[code = "2141"]
    V2141(Option<Element>),
    #[doc = "Radiograph, panoramic"]
    #[code = "2601"]
    V2601(Option<Element>),
    #[doc = "Crown, PFM"]
    #[code = "27211"]
    V27211(Option<Element>),
    #[doc = "Maryland Bridge"]
    #[code = "67211"]
    V67211(Option<Element>),
    #[doc = "Lab, commercial"]
    #[code = "99111"]
    V99111(Option<Element>),
    #[doc = "Lab, in office"]
    #[code = "99333"]
    V99333(Option<Element>),
    #[doc = "Expense"]
    #[code = "99555"]
    V99555(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServiceUscls {
    fn default() -> Self {
        ServiceUscls::Null(None)
    }
}
impl TryFrom<String> for ServiceUscls {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1101" => Ok(ServiceUscls::V1101(None)),
            "1102" => Ok(ServiceUscls::V1102(None)),
            "1103" => Ok(ServiceUscls::V1103(None)),
            "11101" => Ok(ServiceUscls::V11101(None)),
            "11102" => Ok(ServiceUscls::V11102(None)),
            "11103" => Ok(ServiceUscls::V11103(None)),
            "11104" => Ok(ServiceUscls::V11104(None)),
            "1201" => Ok(ServiceUscls::V1201(None)),
            "1205" => Ok(ServiceUscls::V1205(None)),
            "2101" => Ok(ServiceUscls::V2101(None)),
            "2102" => Ok(ServiceUscls::V2102(None)),
            "21211" => Ok(ServiceUscls::V21211(None)),
            "21212" => Ok(ServiceUscls::V21212(None)),
            "2141" => Ok(ServiceUscls::V2141(None)),
            "2601" => Ok(ServiceUscls::V2601(None)),
            "27211" => Ok(ServiceUscls::V27211(None)),
            "67211" => Ok(ServiceUscls::V67211(None)),
            "99111" => Ok(ServiceUscls::V99111(None)),
            "99333" => Ok(ServiceUscls::V99333(None)),
            "99555" => Ok(ServiceUscls::V99555(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServiceUscls {
    fn into(self) -> Option<String> {
        match self {
            ServiceUscls::V1101(_) => Some("1101".to_string()),
            ServiceUscls::V1102(_) => Some("1102".to_string()),
            ServiceUscls::V1103(_) => Some("1103".to_string()),
            ServiceUscls::V11101(_) => Some("11101".to_string()),
            ServiceUscls::V11102(_) => Some("11102".to_string()),
            ServiceUscls::V11103(_) => Some("11103".to_string()),
            ServiceUscls::V11104(_) => Some("11104".to_string()),
            ServiceUscls::V1201(_) => Some("1201".to_string()),
            ServiceUscls::V1205(_) => Some("1205".to_string()),
            ServiceUscls::V2101(_) => Some("2101".to_string()),
            ServiceUscls::V2102(_) => Some("2102".to_string()),
            ServiceUscls::V21211(_) => Some("21211".to_string()),
            ServiceUscls::V21212(_) => Some("21212".to_string()),
            ServiceUscls::V2141(_) => Some("2141".to_string()),
            ServiceUscls::V2601(_) => Some("2601".to_string()),
            ServiceUscls::V27211(_) => Some("27211".to_string()),
            ServiceUscls::V67211(_) => Some("67211".to_string()),
            ServiceUscls::V99111(_) => Some("99111".to_string()),
            ServiceUscls::V99333(_) => Some("99333".to_string()),
            ServiceUscls::V99555(_) => Some("99555".to_string()),
            ServiceUscls::Null(_) => None,
        }
    }
}
impl MetaValue for ServiceUscls {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServiceUscls::V1101(Some(e)) => e.get_field(field),
                ServiceUscls::V1102(Some(e)) => e.get_field(field),
                ServiceUscls::V1103(Some(e)) => e.get_field(field),
                ServiceUscls::V11101(Some(e)) => e.get_field(field),
                ServiceUscls::V11102(Some(e)) => e.get_field(field),
                ServiceUscls::V11103(Some(e)) => e.get_field(field),
                ServiceUscls::V11104(Some(e)) => e.get_field(field),
                ServiceUscls::V1201(Some(e)) => e.get_field(field),
                ServiceUscls::V1205(Some(e)) => e.get_field(field),
                ServiceUscls::V2101(Some(e)) => e.get_field(field),
                ServiceUscls::V2102(Some(e)) => e.get_field(field),
                ServiceUscls::V21211(Some(e)) => e.get_field(field),
                ServiceUscls::V21212(Some(e)) => e.get_field(field),
                ServiceUscls::V2141(Some(e)) => e.get_field(field),
                ServiceUscls::V2601(Some(e)) => e.get_field(field),
                ServiceUscls::V27211(Some(e)) => e.get_field(field),
                ServiceUscls::V67211(Some(e)) => e.get_field(field),
                ServiceUscls::V99111(Some(e)) => e.get_field(field),
                ServiceUscls::V99333(Some(e)) => e.get_field(field),
                ServiceUscls::V99555(Some(e)) => e.get_field(field),
                ServiceUscls::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServiceUscls::V1101(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V1102(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V1103(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V11101(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V11102(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V11103(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V11104(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V1201(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V1205(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V2101(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V2102(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V21211(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V21212(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V2141(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V2601(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V27211(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V67211(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V99111(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V99333(Some(e)) => e.get_field_mut(field),
                ServiceUscls::V99555(Some(e)) => e.get_field_mut(field),
                ServiceUscls::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServicerequestCategory {
    #[doc = "Laboratory procedure"]
    #[code = "108252007"]
    V108252007(Option<Element>),
    #[doc = "Imaging"]
    #[code = "363679005"]
    V363679005(Option<Element>),
    #[doc = "Surgical procedure"]
    #[code = "387713003"]
    V387713003(Option<Element>),
    #[doc = "Counselling"]
    #[code = "409063005"]
    V409063005(Option<Element>),
    #[doc = "Education"]
    #[code = "409073007"]
    V409073007(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServicerequestCategory {
    fn default() -> Self {
        ServicerequestCategory::Null(None)
    }
}
impl TryFrom<String> for ServicerequestCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "108252007" => Ok(ServicerequestCategory::V108252007(None)),
            "363679005" => Ok(ServicerequestCategory::V363679005(None)),
            "387713003" => Ok(ServicerequestCategory::V387713003(None)),
            "409063005" => Ok(ServicerequestCategory::V409063005(None)),
            "409073007" => Ok(ServicerequestCategory::V409073007(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServicerequestCategory {
    fn into(self) -> Option<String> {
        match self {
            ServicerequestCategory::V108252007(_) => Some("108252007".to_string()),
            ServicerequestCategory::V363679005(_) => Some("363679005".to_string()),
            ServicerequestCategory::V387713003(_) => Some("387713003".to_string()),
            ServicerequestCategory::V409063005(_) => Some("409063005".to_string()),
            ServicerequestCategory::V409073007(_) => Some("409073007".to_string()),
            ServicerequestCategory::Null(_) => None,
        }
    }
}
impl MetaValue for ServicerequestCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServicerequestCategory::V108252007(Some(e)) => e.get_field(field),
                ServicerequestCategory::V363679005(Some(e)) => e.get_field(field),
                ServicerequestCategory::V387713003(Some(e)) => e.get_field(field),
                ServicerequestCategory::V409063005(Some(e)) => e.get_field(field),
                ServicerequestCategory::V409073007(Some(e)) => e.get_field(field),
                ServicerequestCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServicerequestCategory::V108252007(Some(e)) => e.get_field_mut(field),
                ServicerequestCategory::V363679005(Some(e)) => e.get_field_mut(field),
                ServicerequestCategory::V387713003(Some(e)) => e.get_field_mut(field),
                ServicerequestCategory::V409063005(Some(e)) => e.get_field_mut(field),
                ServicerequestCategory::V409073007(Some(e)) => e.get_field_mut(field),
                ServicerequestCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ServicerequestOrderdetail {
    #[doc = "Patient triggered inspiratory assistance (procedure)"]
    #[code = "243144002"]
    V243144002(Option<Element>),
    #[doc = "Assisted controlled mandatory ventilation (procedure)"]
    #[code = "243150007"]
    V243150007(Option<Element>),
    #[doc = "Pressure controlled ventilation (procedure)"]
    #[code = "286812008"]
    V286812008(Option<Element>),
    #[doc = "Continuous positive airway pressure ventilation treatment (regime/therapy)"]
    #[code = "47545007"]
    V47545007(Option<Element>),
    #[doc = "Synchronized intermittent mandatory ventilation (procedure)"]
    #[code = "59427005"]
    V59427005(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ServicerequestOrderdetail {
    fn default() -> Self {
        ServicerequestOrderdetail::Null(None)
    }
}
impl TryFrom<String> for ServicerequestOrderdetail {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "243144002" => Ok(ServicerequestOrderdetail::V243144002(None)),
            "243150007" => Ok(ServicerequestOrderdetail::V243150007(None)),
            "286812008" => Ok(ServicerequestOrderdetail::V286812008(None)),
            "47545007" => Ok(ServicerequestOrderdetail::V47545007(None)),
            "59427005" => Ok(ServicerequestOrderdetail::V59427005(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ServicerequestOrderdetail {
    fn into(self) -> Option<String> {
        match self {
            ServicerequestOrderdetail::V243144002(_) => Some("243144002".to_string()),
            ServicerequestOrderdetail::V243150007(_) => Some("243150007".to_string()),
            ServicerequestOrderdetail::V286812008(_) => Some("286812008".to_string()),
            ServicerequestOrderdetail::V47545007(_) => Some("47545007".to_string()),
            ServicerequestOrderdetail::V59427005(_) => Some("59427005".to_string()),
            ServicerequestOrderdetail::Null(_) => None,
        }
    }
}
impl MetaValue for ServicerequestOrderdetail {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ServicerequestOrderdetail::V243144002(Some(e)) => e.get_field(field),
                ServicerequestOrderdetail::V243150007(Some(e)) => e.get_field(field),
                ServicerequestOrderdetail::V286812008(Some(e)) => e.get_field(field),
                ServicerequestOrderdetail::V47545007(Some(e)) => e.get_field(field),
                ServicerequestOrderdetail::V59427005(Some(e)) => e.get_field(field),
                ServicerequestOrderdetail::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ServicerequestOrderdetail::V243144002(Some(e)) => e.get_field_mut(field),
                ServicerequestOrderdetail::V243150007(Some(e)) => e.get_field_mut(field),
                ServicerequestOrderdetail::V286812008(Some(e)) => e.get_field_mut(field),
                ServicerequestOrderdetail::V47545007(Some(e)) => e.get_field_mut(field),
                ServicerequestOrderdetail::V59427005(Some(e)) => e.get_field_mut(field),
                ServicerequestOrderdetail::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SignatureType {
    #[doc = "Author's Signature"]
    #[code = "1.2.840.10065.1.12.1.1"]
    V128401006511211(Option<Element>),
    #[doc = "Identity Witness Signature"]
    #[code = "1.2.840.10065.1.12.1.10"]
    V1284010065112110(Option<Element>),
    #[doc = "Consent Witness Signature"]
    #[code = "1.2.840.10065.1.12.1.11"]
    V1284010065112111(Option<Element>),
    #[doc = "Interpreter Signature"]
    #[code = "1.2.840.10065.1.12.1.12"]
    V1284010065112112(Option<Element>),
    #[doc = "Review Signature"]
    #[code = "1.2.840.10065.1.12.1.13"]
    V1284010065112113(Option<Element>),
    #[doc = "Source Signature"]
    #[code = "1.2.840.10065.1.12.1.14"]
    V1284010065112114(Option<Element>),
    #[doc = "Addendum Signature"]
    #[code = "1.2.840.10065.1.12.1.15"]
    V1284010065112115(Option<Element>),
    #[doc = "Modification Signature"]
    #[code = "1.2.840.10065.1.12.1.16"]
    V1284010065112116(Option<Element>),
    #[doc = "Administrative (Error/Edit) Signature"]
    #[code = "1.2.840.10065.1.12.1.17"]
    V1284010065112117(Option<Element>),
    #[doc = "Timestamp Signature"]
    #[code = "1.2.840.10065.1.12.1.18"]
    V1284010065112118(Option<Element>),
    #[doc = "Coauthor's Signature"]
    #[code = "1.2.840.10065.1.12.1.2"]
    V128401006511212(Option<Element>),
    #[doc = "Co-participant's Signature"]
    #[code = "1.2.840.10065.1.12.1.3"]
    V128401006511213(Option<Element>),
    #[doc = "Transcriptionist/Recorder Signature"]
    #[code = "1.2.840.10065.1.12.1.4"]
    V128401006511214(Option<Element>),
    #[doc = "Verification Signature"]
    #[code = "1.2.840.10065.1.12.1.5"]
    V128401006511215(Option<Element>),
    #[doc = "Validation Signature"]
    #[code = "1.2.840.10065.1.12.1.6"]
    V128401006511216(Option<Element>),
    #[doc = "Consent Signature"]
    #[code = "1.2.840.10065.1.12.1.7"]
    V128401006511217(Option<Element>),
    #[doc = "Signature Witness Signature"]
    #[code = "1.2.840.10065.1.12.1.8"]
    V128401006511218(Option<Element>),
    #[doc = "Event Witness Signature"]
    #[code = "1.2.840.10065.1.12.1.9"]
    V128401006511219(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SignatureType {
    fn default() -> Self {
        SignatureType::Null(None)
    }
}
impl TryFrom<String> for SignatureType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1.2.840.10065.1.12.1.1" => Ok(SignatureType::V128401006511211(None)),
            "1.2.840.10065.1.12.1.10" => Ok(SignatureType::V1284010065112110(None)),
            "1.2.840.10065.1.12.1.11" => Ok(SignatureType::V1284010065112111(None)),
            "1.2.840.10065.1.12.1.12" => Ok(SignatureType::V1284010065112112(None)),
            "1.2.840.10065.1.12.1.13" => Ok(SignatureType::V1284010065112113(None)),
            "1.2.840.10065.1.12.1.14" => Ok(SignatureType::V1284010065112114(None)),
            "1.2.840.10065.1.12.1.15" => Ok(SignatureType::V1284010065112115(None)),
            "1.2.840.10065.1.12.1.16" => Ok(SignatureType::V1284010065112116(None)),
            "1.2.840.10065.1.12.1.17" => Ok(SignatureType::V1284010065112117(None)),
            "1.2.840.10065.1.12.1.18" => Ok(SignatureType::V1284010065112118(None)),
            "1.2.840.10065.1.12.1.2" => Ok(SignatureType::V128401006511212(None)),
            "1.2.840.10065.1.12.1.3" => Ok(SignatureType::V128401006511213(None)),
            "1.2.840.10065.1.12.1.4" => Ok(SignatureType::V128401006511214(None)),
            "1.2.840.10065.1.12.1.5" => Ok(SignatureType::V128401006511215(None)),
            "1.2.840.10065.1.12.1.6" => Ok(SignatureType::V128401006511216(None)),
            "1.2.840.10065.1.12.1.7" => Ok(SignatureType::V128401006511217(None)),
            "1.2.840.10065.1.12.1.8" => Ok(SignatureType::V128401006511218(None)),
            "1.2.840.10065.1.12.1.9" => Ok(SignatureType::V128401006511219(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SignatureType {
    fn into(self) -> Option<String> {
        match self {
            SignatureType::V128401006511211(_) => Some("1.2.840.10065.1.12.1.1".to_string()),
            SignatureType::V1284010065112110(_) => Some("1.2.840.10065.1.12.1.10".to_string()),
            SignatureType::V1284010065112111(_) => Some("1.2.840.10065.1.12.1.11".to_string()),
            SignatureType::V1284010065112112(_) => Some("1.2.840.10065.1.12.1.12".to_string()),
            SignatureType::V1284010065112113(_) => Some("1.2.840.10065.1.12.1.13".to_string()),
            SignatureType::V1284010065112114(_) => Some("1.2.840.10065.1.12.1.14".to_string()),
            SignatureType::V1284010065112115(_) => Some("1.2.840.10065.1.12.1.15".to_string()),
            SignatureType::V1284010065112116(_) => Some("1.2.840.10065.1.12.1.16".to_string()),
            SignatureType::V1284010065112117(_) => Some("1.2.840.10065.1.12.1.17".to_string()),
            SignatureType::V1284010065112118(_) => Some("1.2.840.10065.1.12.1.18".to_string()),
            SignatureType::V128401006511212(_) => Some("1.2.840.10065.1.12.1.2".to_string()),
            SignatureType::V128401006511213(_) => Some("1.2.840.10065.1.12.1.3".to_string()),
            SignatureType::V128401006511214(_) => Some("1.2.840.10065.1.12.1.4".to_string()),
            SignatureType::V128401006511215(_) => Some("1.2.840.10065.1.12.1.5".to_string()),
            SignatureType::V128401006511216(_) => Some("1.2.840.10065.1.12.1.6".to_string()),
            SignatureType::V128401006511217(_) => Some("1.2.840.10065.1.12.1.7".to_string()),
            SignatureType::V128401006511218(_) => Some("1.2.840.10065.1.12.1.8".to_string()),
            SignatureType::V128401006511219(_) => Some("1.2.840.10065.1.12.1.9".to_string()),
            SignatureType::Null(_) => None,
        }
    }
}
impl MetaValue for SignatureType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SignatureType::V128401006511211(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112110(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112111(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112112(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112113(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112114(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112115(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112116(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112117(Some(e)) => e.get_field(field),
                SignatureType::V1284010065112118(Some(e)) => e.get_field(field),
                SignatureType::V128401006511212(Some(e)) => e.get_field(field),
                SignatureType::V128401006511213(Some(e)) => e.get_field(field),
                SignatureType::V128401006511214(Some(e)) => e.get_field(field),
                SignatureType::V128401006511215(Some(e)) => e.get_field(field),
                SignatureType::V128401006511216(Some(e)) => e.get_field(field),
                SignatureType::V128401006511217(Some(e)) => e.get_field(field),
                SignatureType::V128401006511218(Some(e)) => e.get_field(field),
                SignatureType::V128401006511219(Some(e)) => e.get_field(field),
                SignatureType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SignatureType::V128401006511211(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112110(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112111(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112112(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112113(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112114(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112115(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112116(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112117(Some(e)) => e.get_field_mut(field),
                SignatureType::V1284010065112118(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511212(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511213(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511214(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511215(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511216(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511217(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511218(Some(e)) => e.get_field_mut(field),
                SignatureType::V128401006511219(Some(e)) => e.get_field_mut(field),
                SignatureType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Slotstatus {
    #[doc = "Busy"]
    #[code = "busy"]
    Busy(Option<Element>),
    #[doc = "Busy (Tentative)"]
    #[code = "busy-tentative"]
    BusyTentative(Option<Element>),
    #[doc = "Busy (Unavailable)"]
    #[code = "busy-unavailable"]
    BusyUnavailable(Option<Element>),
    #[doc = "Entered in error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Free"]
    #[code = "free"]
    Free(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Slotstatus {
    fn default() -> Self {
        Slotstatus::Null(None)
    }
}
impl TryFrom<String> for Slotstatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "busy" => Ok(Slotstatus::Busy(None)),
            "busy-tentative" => Ok(Slotstatus::BusyTentative(None)),
            "busy-unavailable" => Ok(Slotstatus::BusyUnavailable(None)),
            "entered-in-error" => Ok(Slotstatus::EnteredInError(None)),
            "free" => Ok(Slotstatus::Free(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Slotstatus {
    fn into(self) -> Option<String> {
        match self {
            Slotstatus::Busy(_) => Some("busy".to_string()),
            Slotstatus::BusyTentative(_) => Some("busy-tentative".to_string()),
            Slotstatus::BusyUnavailable(_) => Some("busy-unavailable".to_string()),
            Slotstatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            Slotstatus::Free(_) => Some("free".to_string()),
            Slotstatus::Null(_) => None,
        }
    }
}
impl MetaValue for Slotstatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Slotstatus::Busy(Some(e)) => e.get_field(field),
                Slotstatus::BusyTentative(Some(e)) => e.get_field(field),
                Slotstatus::BusyUnavailable(Some(e)) => e.get_field(field),
                Slotstatus::EnteredInError(Some(e)) => e.get_field(field),
                Slotstatus::Free(Some(e)) => e.get_field(field),
                Slotstatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Slotstatus::Busy(Some(e)) => e.get_field_mut(field),
                Slotstatus::BusyTentative(Some(e)) => e.get_field_mut(field),
                Slotstatus::BusyUnavailable(Some(e)) => e.get_field_mut(field),
                Slotstatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                Slotstatus::Free(Some(e)) => e.get_field_mut(field),
                Slotstatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SmartCapabilities {
    #[doc = "Confidential Client Profile"]
    #[code = "client-confidential-symmetric"]
    ClientConfidentialSymmetric(Option<Element>),
    #[doc = "Public Client Profile"]
    #[code = "client-public"]
    ClientPublic(Option<Element>),
    #[doc = "Allows \"Encounter Level Launch Context (EHR)\""]
    #[code = "context-ehr-encounter"]
    ContextEhrEncounter(Option<Element>),
    #[doc = "Allows \"Patient Level Launch Context (EHR)\""]
    #[code = "context-ehr-patient"]
    ContextEhrPatient(Option<Element>),
    #[doc = "Allows \"Need Patient Banner\""]
    #[code = "context-passthrough-banner"]
    ContextPassthroughBanner(Option<Element>),
    #[doc = "Allows \"Smart Style Style\""]
    #[code = "context-passthrough-style"]
    ContextPassthroughStyle(Option<Element>),
    #[doc = "Allows \"Encounter Level Launch Context (STANDALONE)\""]
    #[code = "context-standalone-encounter"]
    ContextStandaloneEncounter(Option<Element>),
    #[doc = "Allows \"Patient Level Launch Context (STANDALONE)\""]
    #[code = "context-standalone-patient"]
    ContextStandalonePatient(Option<Element>),
    #[doc = "EHR Launch Mode"]
    #[code = "launch-ehr"]
    LaunchEhr(Option<Element>),
    #[doc = "Standalone Launch Mode"]
    #[code = "launch-standalone"]
    LaunchStandalone(Option<Element>),
    #[doc = "Supports Refresh Token"]
    #[code = "permission-offline"]
    PermissionOffline(Option<Element>),
    #[doc = "Supports Patient Level Scopes"]
    #[code = "permission-patient"]
    PermissionPatient(Option<Element>),
    #[doc = "Supports User Level Scopes"]
    #[code = "permission-user"]
    PermissionUser(Option<Element>),
    #[doc = "Supports OpenID Connect"]
    #[code = "sso-openid-connect"]
    SsoOpenidConnect(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SmartCapabilities {
    fn default() -> Self {
        SmartCapabilities::Null(None)
    }
}
impl TryFrom<String> for SmartCapabilities {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "client-confidential-symmetric" => {
                Ok(SmartCapabilities::ClientConfidentialSymmetric(None))
            }
            "client-public" => Ok(SmartCapabilities::ClientPublic(None)),
            "context-ehr-encounter" => Ok(SmartCapabilities::ContextEhrEncounter(None)),
            "context-ehr-patient" => Ok(SmartCapabilities::ContextEhrPatient(None)),
            "context-passthrough-banner" => Ok(SmartCapabilities::ContextPassthroughBanner(None)),
            "context-passthrough-style" => Ok(SmartCapabilities::ContextPassthroughStyle(None)),
            "context-standalone-encounter" => {
                Ok(SmartCapabilities::ContextStandaloneEncounter(None))
            }
            "context-standalone-patient" => Ok(SmartCapabilities::ContextStandalonePatient(None)),
            "launch-ehr" => Ok(SmartCapabilities::LaunchEhr(None)),
            "launch-standalone" => Ok(SmartCapabilities::LaunchStandalone(None)),
            "permission-offline" => Ok(SmartCapabilities::PermissionOffline(None)),
            "permission-patient" => Ok(SmartCapabilities::PermissionPatient(None)),
            "permission-user" => Ok(SmartCapabilities::PermissionUser(None)),
            "sso-openid-connect" => Ok(SmartCapabilities::SsoOpenidConnect(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SmartCapabilities {
    fn into(self) -> Option<String> {
        match self {
            SmartCapabilities::ClientConfidentialSymmetric(_) => {
                Some("client-confidential-symmetric".to_string())
            }
            SmartCapabilities::ClientPublic(_) => Some("client-public".to_string()),
            SmartCapabilities::ContextEhrEncounter(_) => Some("context-ehr-encounter".to_string()),
            SmartCapabilities::ContextEhrPatient(_) => Some("context-ehr-patient".to_string()),
            SmartCapabilities::ContextPassthroughBanner(_) => {
                Some("context-passthrough-banner".to_string())
            }
            SmartCapabilities::ContextPassthroughStyle(_) => {
                Some("context-passthrough-style".to_string())
            }
            SmartCapabilities::ContextStandaloneEncounter(_) => {
                Some("context-standalone-encounter".to_string())
            }
            SmartCapabilities::ContextStandalonePatient(_) => {
                Some("context-standalone-patient".to_string())
            }
            SmartCapabilities::LaunchEhr(_) => Some("launch-ehr".to_string()),
            SmartCapabilities::LaunchStandalone(_) => Some("launch-standalone".to_string()),
            SmartCapabilities::PermissionOffline(_) => Some("permission-offline".to_string()),
            SmartCapabilities::PermissionPatient(_) => Some("permission-patient".to_string()),
            SmartCapabilities::PermissionUser(_) => Some("permission-user".to_string()),
            SmartCapabilities::SsoOpenidConnect(_) => Some("sso-openid-connect".to_string()),
            SmartCapabilities::Null(_) => None,
        }
    }
}
impl MetaValue for SmartCapabilities {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SmartCapabilities::ClientConfidentialSymmetric(Some(e)) => e.get_field(field),
                SmartCapabilities::ClientPublic(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextEhrEncounter(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextEhrPatient(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextPassthroughBanner(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextPassthroughStyle(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextStandaloneEncounter(Some(e)) => e.get_field(field),
                SmartCapabilities::ContextStandalonePatient(Some(e)) => e.get_field(field),
                SmartCapabilities::LaunchEhr(Some(e)) => e.get_field(field),
                SmartCapabilities::LaunchStandalone(Some(e)) => e.get_field(field),
                SmartCapabilities::PermissionOffline(Some(e)) => e.get_field(field),
                SmartCapabilities::PermissionPatient(Some(e)) => e.get_field(field),
                SmartCapabilities::PermissionUser(Some(e)) => e.get_field(field),
                SmartCapabilities::SsoOpenidConnect(Some(e)) => e.get_field(field),
                SmartCapabilities::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SmartCapabilities::ClientConfidentialSymmetric(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ClientPublic(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextEhrEncounter(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextEhrPatient(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextPassthroughBanner(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextPassthroughStyle(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextStandaloneEncounter(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::ContextStandalonePatient(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::LaunchEhr(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::LaunchStandalone(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::PermissionOffline(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::PermissionPatient(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::PermissionUser(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::SsoOpenidConnect(Some(e)) => e.get_field_mut(field),
                SmartCapabilities::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SortDirection {
    #[doc = "Ascending"]
    #[code = "ascending"]
    Ascending(Option<Element>),
    #[doc = "Descending"]
    #[code = "descending"]
    Descending(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SortDirection {
    fn default() -> Self {
        SortDirection::Null(None)
    }
}
impl TryFrom<String> for SortDirection {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ascending" => Ok(SortDirection::Ascending(None)),
            "descending" => Ok(SortDirection::Descending(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SortDirection {
    fn into(self) -> Option<String> {
        match self {
            SortDirection::Ascending(_) => Some("ascending".to_string()),
            SortDirection::Descending(_) => Some("descending".to_string()),
            SortDirection::Null(_) => None,
        }
    }
}
impl MetaValue for SortDirection {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SortDirection::Ascending(Some(e)) => e.get_field(field),
                SortDirection::Descending(Some(e)) => e.get_field(field),
                SortDirection::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SortDirection::Ascending(Some(e)) => e.get_field_mut(field),
                SortDirection::Descending(Some(e)) => e.get_field_mut(field),
                SortDirection::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecialValues {
    #[doc = "false"]
    #[code = "false"]
    False(Option<Element>),
    #[doc = "Nil Known"]
    #[code = "nil-known"]
    NilKnown(Option<Element>),
    #[doc = "Sufficient Quantity"]
    #[code = "sufficient"]
    Sufficient(Option<Element>),
    #[doc = "Trace Amount Detected"]
    #[code = "trace"]
    Trace(Option<Element>),
    #[doc = "true"]
    #[code = "true"]
    True(Option<Element>),
    #[doc = "Value Withdrawn"]
    #[code = "withdrawn"]
    Withdrawn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecialValues {
    fn default() -> Self {
        SpecialValues::Null(None)
    }
}
impl TryFrom<String> for SpecialValues {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "false" => Ok(SpecialValues::False(None)),
            "nil-known" => Ok(SpecialValues::NilKnown(None)),
            "sufficient" => Ok(SpecialValues::Sufficient(None)),
            "trace" => Ok(SpecialValues::Trace(None)),
            "true" => Ok(SpecialValues::True(None)),
            "withdrawn" => Ok(SpecialValues::Withdrawn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecialValues {
    fn into(self) -> Option<String> {
        match self {
            SpecialValues::False(_) => Some("false".to_string()),
            SpecialValues::NilKnown(_) => Some("nil-known".to_string()),
            SpecialValues::Sufficient(_) => Some("sufficient".to_string()),
            SpecialValues::Trace(_) => Some("trace".to_string()),
            SpecialValues::True(_) => Some("true".to_string()),
            SpecialValues::Withdrawn(_) => Some("withdrawn".to_string()),
            SpecialValues::Null(_) => None,
        }
    }
}
impl MetaValue for SpecialValues {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecialValues::False(Some(e)) => e.get_field(field),
                SpecialValues::NilKnown(Some(e)) => e.get_field(field),
                SpecialValues::Sufficient(Some(e)) => e.get_field(field),
                SpecialValues::Trace(Some(e)) => e.get_field(field),
                SpecialValues::True(Some(e)) => e.get_field(field),
                SpecialValues::Withdrawn(Some(e)) => e.get_field(field),
                SpecialValues::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecialValues::False(Some(e)) => e.get_field_mut(field),
                SpecialValues::NilKnown(Some(e)) => e.get_field_mut(field),
                SpecialValues::Sufficient(Some(e)) => e.get_field_mut(field),
                SpecialValues::Trace(Some(e)) => e.get_field_mut(field),
                SpecialValues::True(Some(e)) => e.get_field_mut(field),
                SpecialValues::Withdrawn(Some(e)) => e.get_field_mut(field),
                SpecialValues::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecimenCollection {
    #[doc = "Puncture - action"]
    #[code = "129300006"]
    V129300006(Option<Element>),
    #[doc = "Excision - action"]
    #[code = "129304002"]
    V129304002(Option<Element>),
    #[doc = "Biopsy - action"]
    #[code = "129314006"]
    V129314006(Option<Element>),
    #[doc = "Aspiration - action"]
    #[code = "129316008"]
    V129316008(Option<Element>),
    #[doc = "Scraping - action"]
    #[code = "129323009"]
    V129323009(Option<Element>),
    #[doc = "Timed urine collection"]
    #[code = "225113003"]
    V225113003(Option<Element>),
    #[doc = "Finger-prick sampling"]
    #[code = "278450005"]
    V278450005(Option<Element>),
    #[doc = "Collection of coughed sputum"]
    #[code = "386089008"]
    V386089008(Option<Element>),
    #[doc = "Urine specimen collection, catheterized"]
    #[code = "70777001"]
    V70777001(Option<Element>),
    #[doc = "Urine specimen collection, clean catch"]
    #[code = "73416001"]
    V73416001(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecimenCollection {
    fn default() -> Self {
        SpecimenCollection::Null(None)
    }
}
impl TryFrom<String> for SpecimenCollection {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "129300006" => Ok(SpecimenCollection::V129300006(None)),
            "129304002" => Ok(SpecimenCollection::V129304002(None)),
            "129314006" => Ok(SpecimenCollection::V129314006(None)),
            "129316008" => Ok(SpecimenCollection::V129316008(None)),
            "129323009" => Ok(SpecimenCollection::V129323009(None)),
            "225113003" => Ok(SpecimenCollection::V225113003(None)),
            "278450005" => Ok(SpecimenCollection::V278450005(None)),
            "386089008" => Ok(SpecimenCollection::V386089008(None)),
            "70777001" => Ok(SpecimenCollection::V70777001(None)),
            "73416001" => Ok(SpecimenCollection::V73416001(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecimenCollection {
    fn into(self) -> Option<String> {
        match self {
            SpecimenCollection::V129300006(_) => Some("129300006".to_string()),
            SpecimenCollection::V129304002(_) => Some("129304002".to_string()),
            SpecimenCollection::V129314006(_) => Some("129314006".to_string()),
            SpecimenCollection::V129316008(_) => Some("129316008".to_string()),
            SpecimenCollection::V129323009(_) => Some("129323009".to_string()),
            SpecimenCollection::V225113003(_) => Some("225113003".to_string()),
            SpecimenCollection::V278450005(_) => Some("278450005".to_string()),
            SpecimenCollection::V386089008(_) => Some("386089008".to_string()),
            SpecimenCollection::V70777001(_) => Some("70777001".to_string()),
            SpecimenCollection::V73416001(_) => Some("73416001".to_string()),
            SpecimenCollection::Null(_) => None,
        }
    }
}
impl MetaValue for SpecimenCollection {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecimenCollection::V129300006(Some(e)) => e.get_field(field),
                SpecimenCollection::V129304002(Some(e)) => e.get_field(field),
                SpecimenCollection::V129314006(Some(e)) => e.get_field(field),
                SpecimenCollection::V129316008(Some(e)) => e.get_field(field),
                SpecimenCollection::V129323009(Some(e)) => e.get_field(field),
                SpecimenCollection::V225113003(Some(e)) => e.get_field(field),
                SpecimenCollection::V278450005(Some(e)) => e.get_field(field),
                SpecimenCollection::V386089008(Some(e)) => e.get_field(field),
                SpecimenCollection::V70777001(Some(e)) => e.get_field(field),
                SpecimenCollection::V73416001(Some(e)) => e.get_field(field),
                SpecimenCollection::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecimenCollection::V129300006(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V129304002(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V129314006(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V129316008(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V129323009(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V225113003(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V278450005(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V386089008(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V70777001(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::V73416001(Some(e)) => e.get_field_mut(field),
                SpecimenCollection::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecimenCollectionMethod {
    #[doc = "Puncture - action"]
    #[code = "129300006"]
    V129300006(Option<Element>),
    #[doc = "Excision - action"]
    #[code = "129304002"]
    V129304002(Option<Element>),
    #[doc = "Biopsy - action"]
    #[code = "129314006"]
    V129314006(Option<Element>),
    #[doc = "Aspiration - action"]
    #[code = "129316008"]
    V129316008(Option<Element>),
    #[doc = "Scraping - action"]
    #[code = "129323009"]
    V129323009(Option<Element>),
    #[doc = "Timed urine collection"]
    #[code = "225113003"]
    V225113003(Option<Element>),
    #[doc = "Finger-prick sampling"]
    #[code = "278450005"]
    V278450005(Option<Element>),
    #[doc = "Collection of coughed sputum"]
    #[code = "386089008"]
    V386089008(Option<Element>),
    #[doc = "Urine specimen collection, catheterized"]
    #[code = "70777001"]
    V70777001(Option<Element>),
    #[doc = "Urine specimen collection, clean catch"]
    #[code = "73416001"]
    V73416001(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecimenCollectionMethod {
    fn default() -> Self {
        SpecimenCollectionMethod::Null(None)
    }
}
impl TryFrom<String> for SpecimenCollectionMethod {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "129300006" => Ok(SpecimenCollectionMethod::V129300006(None)),
            "129304002" => Ok(SpecimenCollectionMethod::V129304002(None)),
            "129314006" => Ok(SpecimenCollectionMethod::V129314006(None)),
            "129316008" => Ok(SpecimenCollectionMethod::V129316008(None)),
            "129323009" => Ok(SpecimenCollectionMethod::V129323009(None)),
            "225113003" => Ok(SpecimenCollectionMethod::V225113003(None)),
            "278450005" => Ok(SpecimenCollectionMethod::V278450005(None)),
            "386089008" => Ok(SpecimenCollectionMethod::V386089008(None)),
            "70777001" => Ok(SpecimenCollectionMethod::V70777001(None)),
            "73416001" => Ok(SpecimenCollectionMethod::V73416001(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecimenCollectionMethod {
    fn into(self) -> Option<String> {
        match self {
            SpecimenCollectionMethod::V129300006(_) => Some("129300006".to_string()),
            SpecimenCollectionMethod::V129304002(_) => Some("129304002".to_string()),
            SpecimenCollectionMethod::V129314006(_) => Some("129314006".to_string()),
            SpecimenCollectionMethod::V129316008(_) => Some("129316008".to_string()),
            SpecimenCollectionMethod::V129323009(_) => Some("129323009".to_string()),
            SpecimenCollectionMethod::V225113003(_) => Some("225113003".to_string()),
            SpecimenCollectionMethod::V278450005(_) => Some("278450005".to_string()),
            SpecimenCollectionMethod::V386089008(_) => Some("386089008".to_string()),
            SpecimenCollectionMethod::V70777001(_) => Some("70777001".to_string()),
            SpecimenCollectionMethod::V73416001(_) => Some("73416001".to_string()),
            SpecimenCollectionMethod::Null(_) => None,
        }
    }
}
impl MetaValue for SpecimenCollectionMethod {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecimenCollectionMethod::V129300006(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V129304002(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V129314006(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V129316008(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V129323009(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V225113003(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V278450005(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V386089008(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V70777001(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::V73416001(Some(e)) => e.get_field(field),
                SpecimenCollectionMethod::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecimenCollectionMethod::V129300006(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V129304002(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V129314006(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V129316008(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V129323009(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V225113003(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V278450005(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V386089008(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V70777001(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::V73416001(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionMethod::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecimenCollectionPriority {
    #[doc = "STAT"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "ASAP"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "ASAP-ED"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "AM"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "ROUTINE"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "NURSE COLLECT"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "CALL OR FAX"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecimenCollectionPriority {
    fn default() -> Self {
        SpecimenCollectionPriority::Null(None)
    }
}
impl TryFrom<String> for SpecimenCollectionPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(SpecimenCollectionPriority::V1(None)),
            "2" => Ok(SpecimenCollectionPriority::V2(None)),
            "3" => Ok(SpecimenCollectionPriority::V3(None)),
            "4" => Ok(SpecimenCollectionPriority::V4(None)),
            "5" => Ok(SpecimenCollectionPriority::V5(None)),
            "6" => Ok(SpecimenCollectionPriority::V6(None)),
            "7" => Ok(SpecimenCollectionPriority::V7(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecimenCollectionPriority {
    fn into(self) -> Option<String> {
        match self {
            SpecimenCollectionPriority::V1(_) => Some("1".to_string()),
            SpecimenCollectionPriority::V2(_) => Some("2".to_string()),
            SpecimenCollectionPriority::V3(_) => Some("3".to_string()),
            SpecimenCollectionPriority::V4(_) => Some("4".to_string()),
            SpecimenCollectionPriority::V5(_) => Some("5".to_string()),
            SpecimenCollectionPriority::V6(_) => Some("6".to_string()),
            SpecimenCollectionPriority::V7(_) => Some("7".to_string()),
            SpecimenCollectionPriority::Null(_) => None,
        }
    }
}
impl MetaValue for SpecimenCollectionPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecimenCollectionPriority::V1(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V2(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V3(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V4(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V5(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V6(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::V7(Some(e)) => e.get_field(field),
                SpecimenCollectionPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecimenCollectionPriority::V1(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V2(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V3(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V4(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V5(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V6(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::V7(Some(e)) => e.get_field_mut(field),
                SpecimenCollectionPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecimenContainedPreference {
    #[doc = "Alternate"]
    #[code = "alternate"]
    Alternate(Option<Element>),
    #[doc = "Preferred"]
    #[code = "preferred"]
    Preferred(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecimenContainedPreference {
    fn default() -> Self {
        SpecimenContainedPreference::Null(None)
    }
}
impl TryFrom<String> for SpecimenContainedPreference {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alternate" => Ok(SpecimenContainedPreference::Alternate(None)),
            "preferred" => Ok(SpecimenContainedPreference::Preferred(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecimenContainedPreference {
    fn into(self) -> Option<String> {
        match self {
            SpecimenContainedPreference::Alternate(_) => Some("alternate".to_string()),
            SpecimenContainedPreference::Preferred(_) => Some("preferred".to_string()),
            SpecimenContainedPreference::Null(_) => None,
        }
    }
}
impl MetaValue for SpecimenContainedPreference {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecimenContainedPreference::Alternate(Some(e)) => e.get_field(field),
                SpecimenContainedPreference::Preferred(Some(e)) => e.get_field(field),
                SpecimenContainedPreference::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecimenContainedPreference::Alternate(Some(e)) => e.get_field_mut(field),
                SpecimenContainedPreference::Preferred(Some(e)) => e.get_field_mut(field),
                SpecimenContainedPreference::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SpecimenStatus {
    #[doc = "Available"]
    #[code = "available"]
    Available(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Unavailable"]
    #[code = "unavailable"]
    Unavailable(Option<Element>),
    #[doc = "Unsatisfactory"]
    #[code = "unsatisfactory"]
    Unsatisfactory(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SpecimenStatus {
    fn default() -> Self {
        SpecimenStatus::Null(None)
    }
}
impl TryFrom<String> for SpecimenStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "available" => Ok(SpecimenStatus::Available(None)),
            "entered-in-error" => Ok(SpecimenStatus::EnteredInError(None)),
            "unavailable" => Ok(SpecimenStatus::Unavailable(None)),
            "unsatisfactory" => Ok(SpecimenStatus::Unsatisfactory(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SpecimenStatus {
    fn into(self) -> Option<String> {
        match self {
            SpecimenStatus::Available(_) => Some("available".to_string()),
            SpecimenStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            SpecimenStatus::Unavailable(_) => Some("unavailable".to_string()),
            SpecimenStatus::Unsatisfactory(_) => Some("unsatisfactory".to_string()),
            SpecimenStatus::Null(_) => None,
        }
    }
}
impl MetaValue for SpecimenStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SpecimenStatus::Available(Some(e)) => e.get_field(field),
                SpecimenStatus::EnteredInError(Some(e)) => e.get_field(field),
                SpecimenStatus::Unavailable(Some(e)) => e.get_field(field),
                SpecimenStatus::Unsatisfactory(Some(e)) => e.get_field(field),
                SpecimenStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SpecimenStatus::Available(Some(e)) => e.get_field_mut(field),
                SpecimenStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                SpecimenStatus::Unavailable(Some(e)) => e.get_field_mut(field),
                SpecimenStatus::Unsatisfactory(Some(e)) => e.get_field_mut(field),
                SpecimenStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum StandardsStatus {
    #[doc = "Deprecated"]
    #[code = "deprecated"]
    Deprecated(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "External"]
    #[code = "external"]
    External(Option<Element>),
    #[doc = "Informative"]
    #[code = "informative"]
    Informative(Option<Element>),
    #[doc = "Normative"]
    #[code = "normative"]
    Normative(Option<Element>),
    #[doc = "Trial-Use"]
    #[code = "trial-use"]
    TrialUse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for StandardsStatus {
    fn default() -> Self {
        StandardsStatus::Null(None)
    }
}
impl TryFrom<String> for StandardsStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "deprecated" => Ok(StandardsStatus::Deprecated(None)),
            "draft" => Ok(StandardsStatus::Draft(None)),
            "external" => Ok(StandardsStatus::External(None)),
            "informative" => Ok(StandardsStatus::Informative(None)),
            "normative" => Ok(StandardsStatus::Normative(None)),
            "trial-use" => Ok(StandardsStatus::TrialUse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &StandardsStatus {
    fn into(self) -> Option<String> {
        match self {
            StandardsStatus::Deprecated(_) => Some("deprecated".to_string()),
            StandardsStatus::Draft(_) => Some("draft".to_string()),
            StandardsStatus::External(_) => Some("external".to_string()),
            StandardsStatus::Informative(_) => Some("informative".to_string()),
            StandardsStatus::Normative(_) => Some("normative".to_string()),
            StandardsStatus::TrialUse(_) => Some("trial-use".to_string()),
            StandardsStatus::Null(_) => None,
        }
    }
}
impl MetaValue for StandardsStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                StandardsStatus::Deprecated(Some(e)) => e.get_field(field),
                StandardsStatus::Draft(Some(e)) => e.get_field(field),
                StandardsStatus::External(Some(e)) => e.get_field(field),
                StandardsStatus::Informative(Some(e)) => e.get_field(field),
                StandardsStatus::Normative(Some(e)) => e.get_field(field),
                StandardsStatus::TrialUse(Some(e)) => e.get_field(field),
                StandardsStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                StandardsStatus::Deprecated(Some(e)) => e.get_field_mut(field),
                StandardsStatus::Draft(Some(e)) => e.get_field_mut(field),
                StandardsStatus::External(Some(e)) => e.get_field_mut(field),
                StandardsStatus::Informative(Some(e)) => e.get_field_mut(field),
                StandardsStatus::Normative(Some(e)) => e.get_field_mut(field),
                StandardsStatus::TrialUse(Some(e)) => e.get_field_mut(field),
                StandardsStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum StrandType {
    #[doc = "Crick strand of referenceSeq"]
    #[code = "crick"]
    Crick(Option<Element>),
    #[doc = "Watson strand of referenceSeq"]
    #[code = "watson"]
    Watson(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for StrandType {
    fn default() -> Self {
        StrandType::Null(None)
    }
}
impl TryFrom<String> for StrandType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "crick" => Ok(StrandType::Crick(None)),
            "watson" => Ok(StrandType::Watson(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &StrandType {
    fn into(self) -> Option<String> {
        match self {
            StrandType::Crick(_) => Some("crick".to_string()),
            StrandType::Watson(_) => Some("watson".to_string()),
            StrandType::Null(_) => None,
        }
    }
}
impl MetaValue for StrandType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                StrandType::Crick(Some(e)) => e.get_field(field),
                StrandType::Watson(Some(e)) => e.get_field(field),
                StrandType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                StrandType::Crick(Some(e)) => e.get_field_mut(field),
                StrandType::Watson(Some(e)) => e.get_field_mut(field),
                StrandType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum StructureDefinitionKind {
    #[doc = "Complex Data Type"]
    #[code = "complex-type"]
    ComplexType(Option<Element>),
    #[doc = "Logical"]
    #[code = "logical"]
    Logical(Option<Element>),
    #[doc = "Primitive Data Type"]
    #[code = "primitive-type"]
    PrimitiveType(Option<Element>),
    #[doc = "Resource"]
    #[code = "resource"]
    Resource(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for StructureDefinitionKind {
    fn default() -> Self {
        StructureDefinitionKind::Null(None)
    }
}
impl TryFrom<String> for StructureDefinitionKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "complex-type" => Ok(StructureDefinitionKind::ComplexType(None)),
            "logical" => Ok(StructureDefinitionKind::Logical(None)),
            "primitive-type" => Ok(StructureDefinitionKind::PrimitiveType(None)),
            "resource" => Ok(StructureDefinitionKind::Resource(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &StructureDefinitionKind {
    fn into(self) -> Option<String> {
        match self {
            StructureDefinitionKind::ComplexType(_) => Some("complex-type".to_string()),
            StructureDefinitionKind::Logical(_) => Some("logical".to_string()),
            StructureDefinitionKind::PrimitiveType(_) => Some("primitive-type".to_string()),
            StructureDefinitionKind::Resource(_) => Some("resource".to_string()),
            StructureDefinitionKind::Null(_) => None,
        }
    }
}
impl MetaValue for StructureDefinitionKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                StructureDefinitionKind::ComplexType(Some(e)) => e.get_field(field),
                StructureDefinitionKind::Logical(Some(e)) => e.get_field(field),
                StructureDefinitionKind::PrimitiveType(Some(e)) => e.get_field(field),
                StructureDefinitionKind::Resource(Some(e)) => e.get_field(field),
                StructureDefinitionKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                StructureDefinitionKind::ComplexType(Some(e)) => e.get_field_mut(field),
                StructureDefinitionKind::Logical(Some(e)) => e.get_field_mut(field),
                StructureDefinitionKind::PrimitiveType(Some(e)) => e.get_field_mut(field),
                StructureDefinitionKind::Resource(Some(e)) => e.get_field_mut(field),
                StructureDefinitionKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum StudyType {
    #[doc = "controlled trial (non-randomized)"]
    #[code = "CCT"]
    CCT(Option<Element>),
    #[doc = "randomized trial"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "case-control study"]
    #[code = "case-control"]
    CaseControl(Option<Element>),
    #[doc = "case report"]
    #[code = "case-report"]
    CaseReport(Option<Element>),
    #[doc = "comparative cohort study"]
    #[code = "cohort"]
    Cohort(Option<Element>),
    #[doc = "mixed methods"]
    #[code = "mixed"]
    Mixed(Option<Element>),
    #[doc = "uncontrolled cohort or case series"]
    #[code = "series"]
    Series(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for StudyType {
    fn default() -> Self {
        StudyType::Null(None)
    }
}
impl TryFrom<String> for StudyType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CCT" => Ok(StudyType::CCT(None)),
            "RCT" => Ok(StudyType::RCT(None)),
            "case-control" => Ok(StudyType::CaseControl(None)),
            "case-report" => Ok(StudyType::CaseReport(None)),
            "cohort" => Ok(StudyType::Cohort(None)),
            "mixed" => Ok(StudyType::Mixed(None)),
            "series" => Ok(StudyType::Series(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &StudyType {
    fn into(self) -> Option<String> {
        match self {
            StudyType::CCT(_) => Some("CCT".to_string()),
            StudyType::RCT(_) => Some("RCT".to_string()),
            StudyType::CaseControl(_) => Some("case-control".to_string()),
            StudyType::CaseReport(_) => Some("case-report".to_string()),
            StudyType::Cohort(_) => Some("cohort".to_string()),
            StudyType::Mixed(_) => Some("mixed".to_string()),
            StudyType::Series(_) => Some("series".to_string()),
            StudyType::Null(_) => None,
        }
    }
}
impl MetaValue for StudyType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                StudyType::CCT(Some(e)) => e.get_field(field),
                StudyType::RCT(Some(e)) => e.get_field(field),
                StudyType::CaseControl(Some(e)) => e.get_field(field),
                StudyType::CaseReport(Some(e)) => e.get_field(field),
                StudyType::Cohort(Some(e)) => e.get_field(field),
                StudyType::Mixed(Some(e)) => e.get_field(field),
                StudyType::Series(Some(e)) => e.get_field(field),
                StudyType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                StudyType::CCT(Some(e)) => e.get_field_mut(field),
                StudyType::RCT(Some(e)) => e.get_field_mut(field),
                StudyType::CaseControl(Some(e)) => e.get_field_mut(field),
                StudyType::CaseReport(Some(e)) => e.get_field_mut(field),
                StudyType::Cohort(Some(e)) => e.get_field_mut(field),
                StudyType::Mixed(Some(e)) => e.get_field_mut(field),
                StudyType::Series(Some(e)) => e.get_field_mut(field),
                StudyType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubjectType {
    #[code = "Device"]
    Device(Option<Element>),
    #[code = "Location"]
    Location(Option<Element>),
    #[code = "Organization"]
    Organization(Option<Element>),
    #[code = "Patient"]
    Patient(Option<Element>),
    #[code = "Practitioner"]
    Practitioner(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubjectType {
    fn default() -> Self {
        SubjectType::Null(None)
    }
}
impl TryFrom<String> for SubjectType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Device" => Ok(SubjectType::Device(None)),
            "Location" => Ok(SubjectType::Location(None)),
            "Organization" => Ok(SubjectType::Organization(None)),
            "Patient" => Ok(SubjectType::Patient(None)),
            "Practitioner" => Ok(SubjectType::Practitioner(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubjectType {
    fn into(self) -> Option<String> {
        match self {
            SubjectType::Device(_) => Some("Device".to_string()),
            SubjectType::Location(_) => Some("Location".to_string()),
            SubjectType::Organization(_) => Some("Organization".to_string()),
            SubjectType::Patient(_) => Some("Patient".to_string()),
            SubjectType::Practitioner(_) => Some("Practitioner".to_string()),
            SubjectType::Null(_) => None,
        }
    }
}
impl MetaValue for SubjectType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubjectType::Device(Some(e)) => e.get_field(field),
                SubjectType::Location(Some(e)) => e.get_field(field),
                SubjectType::Organization(Some(e)) => e.get_field(field),
                SubjectType::Patient(Some(e)) => e.get_field(field),
                SubjectType::Practitioner(Some(e)) => e.get_field(field),
                SubjectType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubjectType::Device(Some(e)) => e.get_field_mut(field),
                SubjectType::Location(Some(e)) => e.get_field_mut(field),
                SubjectType::Organization(Some(e)) => e.get_field_mut(field),
                SubjectType::Patient(Some(e)) => e.get_field_mut(field),
                SubjectType::Practitioner(Some(e)) => e.get_field_mut(field),
                SubjectType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubscriberRelationship {
    #[doc = "Child"]
    #[code = "child"]
    Child(Option<Element>),
    #[doc = "Common Law Spouse"]
    #[code = "common"]
    Common(Option<Element>),
    #[doc = "Injured Party"]
    #[code = "injured"]
    Injured(Option<Element>),
    #[doc = "Other"]
    #[code = "other"]
    Other(Option<Element>),
    #[doc = "Parent"]
    #[code = "parent"]
    Parent(Option<Element>),
    #[doc = "Self"]
    #[code = "self"]
    _Self(Option<Element>),
    #[doc = "Spouse"]
    #[code = "spouse"]
    Spouse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubscriberRelationship {
    fn default() -> Self {
        SubscriberRelationship::Null(None)
    }
}
impl TryFrom<String> for SubscriberRelationship {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "child" => Ok(SubscriberRelationship::Child(None)),
            "common" => Ok(SubscriberRelationship::Common(None)),
            "injured" => Ok(SubscriberRelationship::Injured(None)),
            "other" => Ok(SubscriberRelationship::Other(None)),
            "parent" => Ok(SubscriberRelationship::Parent(None)),
            "self" => Ok(SubscriberRelationship::_Self(None)),
            "spouse" => Ok(SubscriberRelationship::Spouse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubscriberRelationship {
    fn into(self) -> Option<String> {
        match self {
            SubscriberRelationship::Child(_) => Some("child".to_string()),
            SubscriberRelationship::Common(_) => Some("common".to_string()),
            SubscriberRelationship::Injured(_) => Some("injured".to_string()),
            SubscriberRelationship::Other(_) => Some("other".to_string()),
            SubscriberRelationship::Parent(_) => Some("parent".to_string()),
            SubscriberRelationship::_Self(_) => Some("self".to_string()),
            SubscriberRelationship::Spouse(_) => Some("spouse".to_string()),
            SubscriberRelationship::Null(_) => None,
        }
    }
}
impl MetaValue for SubscriberRelationship {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubscriberRelationship::Child(Some(e)) => e.get_field(field),
                SubscriberRelationship::Common(Some(e)) => e.get_field(field),
                SubscriberRelationship::Injured(Some(e)) => e.get_field(field),
                SubscriberRelationship::Other(Some(e)) => e.get_field(field),
                SubscriberRelationship::Parent(Some(e)) => e.get_field(field),
                SubscriberRelationship::_Self(Some(e)) => e.get_field(field),
                SubscriberRelationship::Spouse(Some(e)) => e.get_field(field),
                SubscriberRelationship::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubscriberRelationship::Child(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Common(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Injured(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Other(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Parent(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::_Self(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Spouse(Some(e)) => e.get_field_mut(field),
                SubscriberRelationship::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubscriptionChannelType {
    #[doc = "Email"]
    #[code = "email"]
    Email(Option<Element>),
    #[doc = "Message"]
    #[code = "message"]
    Message(Option<Element>),
    #[doc = "Rest Hook"]
    #[code = "rest-hook"]
    RestHook(Option<Element>),
    #[doc = "SMS"]
    #[code = "sms"]
    Sms(Option<Element>),
    #[doc = "Websocket"]
    #[code = "websocket"]
    Websocket(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubscriptionChannelType {
    fn default() -> Self {
        SubscriptionChannelType::Null(None)
    }
}
impl TryFrom<String> for SubscriptionChannelType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "email" => Ok(SubscriptionChannelType::Email(None)),
            "message" => Ok(SubscriptionChannelType::Message(None)),
            "rest-hook" => Ok(SubscriptionChannelType::RestHook(None)),
            "sms" => Ok(SubscriptionChannelType::Sms(None)),
            "websocket" => Ok(SubscriptionChannelType::Websocket(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubscriptionChannelType {
    fn into(self) -> Option<String> {
        match self {
            SubscriptionChannelType::Email(_) => Some("email".to_string()),
            SubscriptionChannelType::Message(_) => Some("message".to_string()),
            SubscriptionChannelType::RestHook(_) => Some("rest-hook".to_string()),
            SubscriptionChannelType::Sms(_) => Some("sms".to_string()),
            SubscriptionChannelType::Websocket(_) => Some("websocket".to_string()),
            SubscriptionChannelType::Null(_) => None,
        }
    }
}
impl MetaValue for SubscriptionChannelType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubscriptionChannelType::Email(Some(e)) => e.get_field(field),
                SubscriptionChannelType::Message(Some(e)) => e.get_field(field),
                SubscriptionChannelType::RestHook(Some(e)) => e.get_field(field),
                SubscriptionChannelType::Sms(Some(e)) => e.get_field(field),
                SubscriptionChannelType::Websocket(Some(e)) => e.get_field(field),
                SubscriptionChannelType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubscriptionChannelType::Email(Some(e)) => e.get_field_mut(field),
                SubscriptionChannelType::Message(Some(e)) => e.get_field_mut(field),
                SubscriptionChannelType::RestHook(Some(e)) => e.get_field_mut(field),
                SubscriptionChannelType::Sms(Some(e)) => e.get_field_mut(field),
                SubscriptionChannelType::Websocket(Some(e)) => e.get_field_mut(field),
                SubscriptionChannelType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubscriptionStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Error"]
    #[code = "error"]
    Error(Option<Element>),
    #[doc = "Off"]
    #[code = "off"]
    Off(Option<Element>),
    #[doc = "Requested"]
    #[code = "requested"]
    Requested(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubscriptionStatus {
    fn default() -> Self {
        SubscriptionStatus::Null(None)
    }
}
impl TryFrom<String> for SubscriptionStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(SubscriptionStatus::Active(None)),
            "error" => Ok(SubscriptionStatus::Error(None)),
            "off" => Ok(SubscriptionStatus::Off(None)),
            "requested" => Ok(SubscriptionStatus::Requested(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubscriptionStatus {
    fn into(self) -> Option<String> {
        match self {
            SubscriptionStatus::Active(_) => Some("active".to_string()),
            SubscriptionStatus::Error(_) => Some("error".to_string()),
            SubscriptionStatus::Off(_) => Some("off".to_string()),
            SubscriptionStatus::Requested(_) => Some("requested".to_string()),
            SubscriptionStatus::Null(_) => None,
        }
    }
}
impl MetaValue for SubscriptionStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubscriptionStatus::Active(Some(e)) => e.get_field(field),
                SubscriptionStatus::Error(Some(e)) => e.get_field(field),
                SubscriptionStatus::Off(Some(e)) => e.get_field(field),
                SubscriptionStatus::Requested(Some(e)) => e.get_field(field),
                SubscriptionStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubscriptionStatus::Active(Some(e)) => e.get_field_mut(field),
                SubscriptionStatus::Error(Some(e)) => e.get_field_mut(field),
                SubscriptionStatus::Off(Some(e)) => e.get_field_mut(field),
                SubscriptionStatus::Requested(Some(e)) => e.get_field_mut(field),
                SubscriptionStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubscriptionTag {
    #[doc = "Delivered"]
    #[code = "delivered"]
    Delivered(Option<Element>),
    #[doc = "Queued"]
    #[code = "queued"]
    Queued(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubscriptionTag {
    fn default() -> Self {
        SubscriptionTag::Null(None)
    }
}
impl TryFrom<String> for SubscriptionTag {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "delivered" => Ok(SubscriptionTag::Delivered(None)),
            "queued" => Ok(SubscriptionTag::Queued(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubscriptionTag {
    fn into(self) -> Option<String> {
        match self {
            SubscriptionTag::Delivered(_) => Some("delivered".to_string()),
            SubscriptionTag::Queued(_) => Some("queued".to_string()),
            SubscriptionTag::Null(_) => None,
        }
    }
}
impl MetaValue for SubscriptionTag {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubscriptionTag::Delivered(Some(e)) => e.get_field(field),
                SubscriptionTag::Queued(Some(e)) => e.get_field(field),
                SubscriptionTag::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubscriptionTag::Delivered(Some(e)) => e.get_field_mut(field),
                SubscriptionTag::Queued(Some(e)) => e.get_field_mut(field),
                SubscriptionTag::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubstanceCategory {
    #[doc = "Allergen"]
    #[code = "allergen"]
    Allergen(Option<Element>),
    #[doc = "Biological Substance"]
    #[code = "biological"]
    Biological(Option<Element>),
    #[doc = "Body Substance"]
    #[code = "body"]
    Body(Option<Element>),
    #[doc = "Chemical"]
    #[code = "chemical"]
    Chemical(Option<Element>),
    #[doc = "Drug or Medicament"]
    #[code = "drug"]
    Drug(Option<Element>),
    #[doc = "Dietary Substance"]
    #[code = "food"]
    Food(Option<Element>),
    #[doc = "Material"]
    #[code = "material"]
    Material(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubstanceCategory {
    fn default() -> Self {
        SubstanceCategory::Null(None)
    }
}
impl TryFrom<String> for SubstanceCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "allergen" => Ok(SubstanceCategory::Allergen(None)),
            "biological" => Ok(SubstanceCategory::Biological(None)),
            "body" => Ok(SubstanceCategory::Body(None)),
            "chemical" => Ok(SubstanceCategory::Chemical(None)),
            "drug" => Ok(SubstanceCategory::Drug(None)),
            "food" => Ok(SubstanceCategory::Food(None)),
            "material" => Ok(SubstanceCategory::Material(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubstanceCategory {
    fn into(self) -> Option<String> {
        match self {
            SubstanceCategory::Allergen(_) => Some("allergen".to_string()),
            SubstanceCategory::Biological(_) => Some("biological".to_string()),
            SubstanceCategory::Body(_) => Some("body".to_string()),
            SubstanceCategory::Chemical(_) => Some("chemical".to_string()),
            SubstanceCategory::Drug(_) => Some("drug".to_string()),
            SubstanceCategory::Food(_) => Some("food".to_string()),
            SubstanceCategory::Material(_) => Some("material".to_string()),
            SubstanceCategory::Null(_) => None,
        }
    }
}
impl MetaValue for SubstanceCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubstanceCategory::Allergen(Some(e)) => e.get_field(field),
                SubstanceCategory::Biological(Some(e)) => e.get_field(field),
                SubstanceCategory::Body(Some(e)) => e.get_field(field),
                SubstanceCategory::Chemical(Some(e)) => e.get_field(field),
                SubstanceCategory::Drug(Some(e)) => e.get_field(field),
                SubstanceCategory::Food(Some(e)) => e.get_field(field),
                SubstanceCategory::Material(Some(e)) => e.get_field(field),
                SubstanceCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubstanceCategory::Allergen(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Biological(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Body(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Chemical(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Drug(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Food(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Material(Some(e)) => e.get_field_mut(field),
                SubstanceCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SubstanceStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SubstanceStatus {
    fn default() -> Self {
        SubstanceStatus::Null(None)
    }
}
impl TryFrom<String> for SubstanceStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(SubstanceStatus::Active(None)),
            "entered-in-error" => Ok(SubstanceStatus::EnteredInError(None)),
            "inactive" => Ok(SubstanceStatus::Inactive(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SubstanceStatus {
    fn into(self) -> Option<String> {
        match self {
            SubstanceStatus::Active(_) => Some("active".to_string()),
            SubstanceStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            SubstanceStatus::Inactive(_) => Some("inactive".to_string()),
            SubstanceStatus::Null(_) => None,
        }
    }
}
impl MetaValue for SubstanceStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SubstanceStatus::Active(Some(e)) => e.get_field(field),
                SubstanceStatus::EnteredInError(Some(e)) => e.get_field(field),
                SubstanceStatus::Inactive(Some(e)) => e.get_field(field),
                SubstanceStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SubstanceStatus::Active(Some(e)) => e.get_field_mut(field),
                SubstanceStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                SubstanceStatus::Inactive(Some(e)) => e.get_field_mut(field),
                SubstanceStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplementType {
    #[doc = "Standard Enteral Formula"]
    #[code = "441531000124102"]
    V441531000124102(Option<Element>),
    #[doc = "Standard enteral formula with fiber"]
    #[code = "441561000124106"]
    V441561000124106(Option<Element>),
    #[doc = "High energy enteral formula with fiber"]
    #[code = "441571000124104"]
    V441571000124104(Option<Element>),
    #[doc = "Diabetic enteral formula with fiber"]
    #[code = "441591000124103"]
    V441591000124103(Option<Element>),
    #[doc = "Diabetic high calorie high protein enteral formula with fiber"]
    #[code = "441601000124106"]
    V441601000124106(Option<Element>),
    #[doc = "Hydrolyzed peptide-based high protein enteral formula"]
    #[code = "441671000124100"]
    V441671000124100(Option<Element>),
    #[doc = "Adult formula"]
    #[code = "442651000124102"]
    V442651000124102(Option<Element>),
    #[doc = "Adult clear liquid supplement"]
    #[code = "442901000124106"]
    V442901000124106(Option<Element>),
    #[doc = "Adult elemental formula"]
    #[code = "442911000124109"]
    V442911000124109(Option<Element>),
    #[doc = "Adult standard formula"]
    #[code = "442921000124101"]
    V442921000124101(Option<Element>),
    #[doc = "Adult soy protein isolate formula"]
    #[code = "442931000124103"]
    V442931000124103(Option<Element>),
    #[doc = "Adult renal specialty formula"]
    #[code = "442941000124108"]
    V442941000124108(Option<Element>),
    #[doc = "Adult pulmonary specialty formula"]
    #[code = "442951000124105"]
    V442951000124105(Option<Element>),
    #[doc = "Adult low carbohydrate formula"]
    #[code = "442961000124107"]
    V442961000124107(Option<Element>),
    #[doc = "Adult high energy formula"]
    #[code = "442971000124100"]
    V442971000124100(Option<Element>),
    #[doc = "Adult hydrolyzed protein formula"]
    #[code = "442981000124102"]
    V442981000124102(Option<Element>),
    #[doc = "Adult high protein formula"]
    #[code = "442991000124104"]
    V442991000124104(Option<Element>),
    #[doc = "Adult high protein high fiber formula"]
    #[code = "443011000124100"]
    V443011000124100(Option<Element>),
    #[doc = "Adult hepatic specialty formula"]
    #[code = "443021000124108"]
    V443021000124108(Option<Element>),
    #[doc = "Adult critical care formula"]
    #[code = "443031000124106"]
    V443031000124106(Option<Element>),
    #[doc = "Adult diabetes specialty formula"]
    #[code = "443051000124104"]
    V443051000124104(Option<Element>),
    #[doc = "High protein formula"]
    #[code = "443111000124101"]
    V443111000124101(Option<Element>),
    #[doc = "Increased fiber formula"]
    #[code = "443351000124102"]
    V443351000124102(Option<Element>),
    #[doc = "Pediatric Formula"]
    #[code = "443361000124100"]
    V443361000124100(Option<Element>),
    #[doc = "Pediatric clear liquid supplement"]
    #[code = "443391000124108"]
    V443391000124108(Option<Element>),
    #[doc = "Pediatric elemental formula"]
    #[code = "443401000124105"]
    V443401000124105(Option<Element>),
    #[doc = "Elemental Formula"]
    #[code = "443411000124108"]
    V443411000124108(Option<Element>),
    #[doc = "Pediatric hydrolyzed protein formula"]
    #[code = "443421000124100"]
    V443421000124100(Option<Element>),
    #[doc = "High Energy Formula"]
    #[code = "443431000124102"]
    V443431000124102(Option<Element>),
    #[doc = "Clear liquid supplement"]
    #[code = "443441000124107"]
    V443441000124107(Option<Element>),
    #[doc = "Pediatric standard formula"]
    #[code = "443451000124109"]
    V443451000124109(Option<Element>),
    #[doc = "Standard Formula"]
    #[code = "443461000124106"]
    V443461000124106(Option<Element>),
    #[doc = "Pediatric increased fiber formula"]
    #[code = "443471000124104"]
    V443471000124104(Option<Element>),
    #[doc = "Renal Formula"]
    #[code = "443481000124101"]
    V443481000124101(Option<Element>),
    #[doc = "Pediatric high energy formula"]
    #[code = "443491000124103"]
    V443491000124103(Option<Element>),
    #[doc = "Pediatric high energy formula with increased fiber"]
    #[code = "443501000124106"]
    V443501000124106(Option<Element>),
    #[doc = "Soy based formula"]
    #[code = "443561000124107"]
    V443561000124107(Option<Element>),
    #[doc = "Hydrolyzed protein formula"]
    #[code = "443771000124106"]
    V443771000124106(Option<Element>),
    #[doc = "Standard pudding oral supplement"]
    #[code = "444321000124108"]
    V444321000124108(Option<Element>),
    #[doc = "Diabetic meal replacement bar"]
    #[code = "444331000124106"]
    V444331000124106(Option<Element>),
    #[doc = "Electrolyte replacement supplement"]
    #[code = "444361000124102"]
    V444361000124102(Option<Element>),
    #[doc = "Powdered electrolyte replacement supplement"]
    #[code = "444371000124109"]
    V444371000124109(Option<Element>),
    #[doc = "Liquid electrolyte replacement supplement"]
    #[code = "444381000124107"]
    V444381000124107(Option<Element>),
    #[doc = "Frozen electrolyte replacement supplement"]
    #[code = "444401000124107"]
    V444401000124107(Option<Element>),
    #[doc = "Pediatric reduced energy formula"]
    #[code = "444431000124104"]
    V444431000124104(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplementType {
    fn default() -> Self {
        SupplementType::Null(None)
    }
}
impl TryFrom<String> for SupplementType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "441531000124102" => Ok(SupplementType::V441531000124102(None)),
            "441561000124106" => Ok(SupplementType::V441561000124106(None)),
            "441571000124104" => Ok(SupplementType::V441571000124104(None)),
            "441591000124103" => Ok(SupplementType::V441591000124103(None)),
            "441601000124106" => Ok(SupplementType::V441601000124106(None)),
            "441671000124100" => Ok(SupplementType::V441671000124100(None)),
            "442651000124102" => Ok(SupplementType::V442651000124102(None)),
            "442901000124106" => Ok(SupplementType::V442901000124106(None)),
            "442911000124109" => Ok(SupplementType::V442911000124109(None)),
            "442921000124101" => Ok(SupplementType::V442921000124101(None)),
            "442931000124103" => Ok(SupplementType::V442931000124103(None)),
            "442941000124108" => Ok(SupplementType::V442941000124108(None)),
            "442951000124105" => Ok(SupplementType::V442951000124105(None)),
            "442961000124107" => Ok(SupplementType::V442961000124107(None)),
            "442971000124100" => Ok(SupplementType::V442971000124100(None)),
            "442981000124102" => Ok(SupplementType::V442981000124102(None)),
            "442991000124104" => Ok(SupplementType::V442991000124104(None)),
            "443011000124100" => Ok(SupplementType::V443011000124100(None)),
            "443021000124108" => Ok(SupplementType::V443021000124108(None)),
            "443031000124106" => Ok(SupplementType::V443031000124106(None)),
            "443051000124104" => Ok(SupplementType::V443051000124104(None)),
            "443111000124101" => Ok(SupplementType::V443111000124101(None)),
            "443351000124102" => Ok(SupplementType::V443351000124102(None)),
            "443361000124100" => Ok(SupplementType::V443361000124100(None)),
            "443391000124108" => Ok(SupplementType::V443391000124108(None)),
            "443401000124105" => Ok(SupplementType::V443401000124105(None)),
            "443411000124108" => Ok(SupplementType::V443411000124108(None)),
            "443421000124100" => Ok(SupplementType::V443421000124100(None)),
            "443431000124102" => Ok(SupplementType::V443431000124102(None)),
            "443441000124107" => Ok(SupplementType::V443441000124107(None)),
            "443451000124109" => Ok(SupplementType::V443451000124109(None)),
            "443461000124106" => Ok(SupplementType::V443461000124106(None)),
            "443471000124104" => Ok(SupplementType::V443471000124104(None)),
            "443481000124101" => Ok(SupplementType::V443481000124101(None)),
            "443491000124103" => Ok(SupplementType::V443491000124103(None)),
            "443501000124106" => Ok(SupplementType::V443501000124106(None)),
            "443561000124107" => Ok(SupplementType::V443561000124107(None)),
            "443771000124106" => Ok(SupplementType::V443771000124106(None)),
            "444321000124108" => Ok(SupplementType::V444321000124108(None)),
            "444331000124106" => Ok(SupplementType::V444331000124106(None)),
            "444361000124102" => Ok(SupplementType::V444361000124102(None)),
            "444371000124109" => Ok(SupplementType::V444371000124109(None)),
            "444381000124107" => Ok(SupplementType::V444381000124107(None)),
            "444401000124107" => Ok(SupplementType::V444401000124107(None)),
            "444431000124104" => Ok(SupplementType::V444431000124104(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplementType {
    fn into(self) -> Option<String> {
        match self {
            SupplementType::V441531000124102(_) => Some("441531000124102".to_string()),
            SupplementType::V441561000124106(_) => Some("441561000124106".to_string()),
            SupplementType::V441571000124104(_) => Some("441571000124104".to_string()),
            SupplementType::V441591000124103(_) => Some("441591000124103".to_string()),
            SupplementType::V441601000124106(_) => Some("441601000124106".to_string()),
            SupplementType::V441671000124100(_) => Some("441671000124100".to_string()),
            SupplementType::V442651000124102(_) => Some("442651000124102".to_string()),
            SupplementType::V442901000124106(_) => Some("442901000124106".to_string()),
            SupplementType::V442911000124109(_) => Some("442911000124109".to_string()),
            SupplementType::V442921000124101(_) => Some("442921000124101".to_string()),
            SupplementType::V442931000124103(_) => Some("442931000124103".to_string()),
            SupplementType::V442941000124108(_) => Some("442941000124108".to_string()),
            SupplementType::V442951000124105(_) => Some("442951000124105".to_string()),
            SupplementType::V442961000124107(_) => Some("442961000124107".to_string()),
            SupplementType::V442971000124100(_) => Some("442971000124100".to_string()),
            SupplementType::V442981000124102(_) => Some("442981000124102".to_string()),
            SupplementType::V442991000124104(_) => Some("442991000124104".to_string()),
            SupplementType::V443011000124100(_) => Some("443011000124100".to_string()),
            SupplementType::V443021000124108(_) => Some("443021000124108".to_string()),
            SupplementType::V443031000124106(_) => Some("443031000124106".to_string()),
            SupplementType::V443051000124104(_) => Some("443051000124104".to_string()),
            SupplementType::V443111000124101(_) => Some("443111000124101".to_string()),
            SupplementType::V443351000124102(_) => Some("443351000124102".to_string()),
            SupplementType::V443361000124100(_) => Some("443361000124100".to_string()),
            SupplementType::V443391000124108(_) => Some("443391000124108".to_string()),
            SupplementType::V443401000124105(_) => Some("443401000124105".to_string()),
            SupplementType::V443411000124108(_) => Some("443411000124108".to_string()),
            SupplementType::V443421000124100(_) => Some("443421000124100".to_string()),
            SupplementType::V443431000124102(_) => Some("443431000124102".to_string()),
            SupplementType::V443441000124107(_) => Some("443441000124107".to_string()),
            SupplementType::V443451000124109(_) => Some("443451000124109".to_string()),
            SupplementType::V443461000124106(_) => Some("443461000124106".to_string()),
            SupplementType::V443471000124104(_) => Some("443471000124104".to_string()),
            SupplementType::V443481000124101(_) => Some("443481000124101".to_string()),
            SupplementType::V443491000124103(_) => Some("443491000124103".to_string()),
            SupplementType::V443501000124106(_) => Some("443501000124106".to_string()),
            SupplementType::V443561000124107(_) => Some("443561000124107".to_string()),
            SupplementType::V443771000124106(_) => Some("443771000124106".to_string()),
            SupplementType::V444321000124108(_) => Some("444321000124108".to_string()),
            SupplementType::V444331000124106(_) => Some("444331000124106".to_string()),
            SupplementType::V444361000124102(_) => Some("444361000124102".to_string()),
            SupplementType::V444371000124109(_) => Some("444371000124109".to_string()),
            SupplementType::V444381000124107(_) => Some("444381000124107".to_string()),
            SupplementType::V444401000124107(_) => Some("444401000124107".to_string()),
            SupplementType::V444431000124104(_) => Some("444431000124104".to_string()),
            SupplementType::Null(_) => None,
        }
    }
}
impl MetaValue for SupplementType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplementType::V441531000124102(Some(e)) => e.get_field(field),
                SupplementType::V441561000124106(Some(e)) => e.get_field(field),
                SupplementType::V441571000124104(Some(e)) => e.get_field(field),
                SupplementType::V441591000124103(Some(e)) => e.get_field(field),
                SupplementType::V441601000124106(Some(e)) => e.get_field(field),
                SupplementType::V441671000124100(Some(e)) => e.get_field(field),
                SupplementType::V442651000124102(Some(e)) => e.get_field(field),
                SupplementType::V442901000124106(Some(e)) => e.get_field(field),
                SupplementType::V442911000124109(Some(e)) => e.get_field(field),
                SupplementType::V442921000124101(Some(e)) => e.get_field(field),
                SupplementType::V442931000124103(Some(e)) => e.get_field(field),
                SupplementType::V442941000124108(Some(e)) => e.get_field(field),
                SupplementType::V442951000124105(Some(e)) => e.get_field(field),
                SupplementType::V442961000124107(Some(e)) => e.get_field(field),
                SupplementType::V442971000124100(Some(e)) => e.get_field(field),
                SupplementType::V442981000124102(Some(e)) => e.get_field(field),
                SupplementType::V442991000124104(Some(e)) => e.get_field(field),
                SupplementType::V443011000124100(Some(e)) => e.get_field(field),
                SupplementType::V443021000124108(Some(e)) => e.get_field(field),
                SupplementType::V443031000124106(Some(e)) => e.get_field(field),
                SupplementType::V443051000124104(Some(e)) => e.get_field(field),
                SupplementType::V443111000124101(Some(e)) => e.get_field(field),
                SupplementType::V443351000124102(Some(e)) => e.get_field(field),
                SupplementType::V443361000124100(Some(e)) => e.get_field(field),
                SupplementType::V443391000124108(Some(e)) => e.get_field(field),
                SupplementType::V443401000124105(Some(e)) => e.get_field(field),
                SupplementType::V443411000124108(Some(e)) => e.get_field(field),
                SupplementType::V443421000124100(Some(e)) => e.get_field(field),
                SupplementType::V443431000124102(Some(e)) => e.get_field(field),
                SupplementType::V443441000124107(Some(e)) => e.get_field(field),
                SupplementType::V443451000124109(Some(e)) => e.get_field(field),
                SupplementType::V443461000124106(Some(e)) => e.get_field(field),
                SupplementType::V443471000124104(Some(e)) => e.get_field(field),
                SupplementType::V443481000124101(Some(e)) => e.get_field(field),
                SupplementType::V443491000124103(Some(e)) => e.get_field(field),
                SupplementType::V443501000124106(Some(e)) => e.get_field(field),
                SupplementType::V443561000124107(Some(e)) => e.get_field(field),
                SupplementType::V443771000124106(Some(e)) => e.get_field(field),
                SupplementType::V444321000124108(Some(e)) => e.get_field(field),
                SupplementType::V444331000124106(Some(e)) => e.get_field(field),
                SupplementType::V444361000124102(Some(e)) => e.get_field(field),
                SupplementType::V444371000124109(Some(e)) => e.get_field(field),
                SupplementType::V444381000124107(Some(e)) => e.get_field(field),
                SupplementType::V444401000124107(Some(e)) => e.get_field(field),
                SupplementType::V444431000124104(Some(e)) => e.get_field(field),
                SupplementType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplementType::V441531000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V441561000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V441571000124104(Some(e)) => e.get_field_mut(field),
                SupplementType::V441591000124103(Some(e)) => e.get_field_mut(field),
                SupplementType::V441601000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V441671000124100(Some(e)) => e.get_field_mut(field),
                SupplementType::V442651000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V442901000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V442911000124109(Some(e)) => e.get_field_mut(field),
                SupplementType::V442921000124101(Some(e)) => e.get_field_mut(field),
                SupplementType::V442931000124103(Some(e)) => e.get_field_mut(field),
                SupplementType::V442941000124108(Some(e)) => e.get_field_mut(field),
                SupplementType::V442951000124105(Some(e)) => e.get_field_mut(field),
                SupplementType::V442961000124107(Some(e)) => e.get_field_mut(field),
                SupplementType::V442971000124100(Some(e)) => e.get_field_mut(field),
                SupplementType::V442981000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V442991000124104(Some(e)) => e.get_field_mut(field),
                SupplementType::V443011000124100(Some(e)) => e.get_field_mut(field),
                SupplementType::V443021000124108(Some(e)) => e.get_field_mut(field),
                SupplementType::V443031000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V443051000124104(Some(e)) => e.get_field_mut(field),
                SupplementType::V443111000124101(Some(e)) => e.get_field_mut(field),
                SupplementType::V443351000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V443361000124100(Some(e)) => e.get_field_mut(field),
                SupplementType::V443391000124108(Some(e)) => e.get_field_mut(field),
                SupplementType::V443401000124105(Some(e)) => e.get_field_mut(field),
                SupplementType::V443411000124108(Some(e)) => e.get_field_mut(field),
                SupplementType::V443421000124100(Some(e)) => e.get_field_mut(field),
                SupplementType::V443431000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V443441000124107(Some(e)) => e.get_field_mut(field),
                SupplementType::V443451000124109(Some(e)) => e.get_field_mut(field),
                SupplementType::V443461000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V443471000124104(Some(e)) => e.get_field_mut(field),
                SupplementType::V443481000124101(Some(e)) => e.get_field_mut(field),
                SupplementType::V443491000124103(Some(e)) => e.get_field_mut(field),
                SupplementType::V443501000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V443561000124107(Some(e)) => e.get_field_mut(field),
                SupplementType::V443771000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V444321000124108(Some(e)) => e.get_field_mut(field),
                SupplementType::V444331000124106(Some(e)) => e.get_field_mut(field),
                SupplementType::V444361000124102(Some(e)) => e.get_field_mut(field),
                SupplementType::V444371000124109(Some(e)) => e.get_field_mut(field),
                SupplementType::V444381000124107(Some(e)) => e.get_field_mut(field),
                SupplementType::V444401000124107(Some(e)) => e.get_field_mut(field),
                SupplementType::V444431000124104(Some(e)) => e.get_field_mut(field),
                SupplementType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplydeliveryStatus {
    #[doc = "Abandoned"]
    #[code = "abandoned"]
    Abandoned(Option<Element>),
    #[doc = "Delivered"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Entered In Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplydeliveryStatus {
    fn default() -> Self {
        SupplydeliveryStatus::Null(None)
    }
}
impl TryFrom<String> for SupplydeliveryStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "abandoned" => Ok(SupplydeliveryStatus::Abandoned(None)),
            "completed" => Ok(SupplydeliveryStatus::Completed(None)),
            "entered-in-error" => Ok(SupplydeliveryStatus::EnteredInError(None)),
            "in-progress" => Ok(SupplydeliveryStatus::InProgress(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplydeliveryStatus {
    fn into(self) -> Option<String> {
        match self {
            SupplydeliveryStatus::Abandoned(_) => Some("abandoned".to_string()),
            SupplydeliveryStatus::Completed(_) => Some("completed".to_string()),
            SupplydeliveryStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            SupplydeliveryStatus::InProgress(_) => Some("in-progress".to_string()),
            SupplydeliveryStatus::Null(_) => None,
        }
    }
}
impl MetaValue for SupplydeliveryStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplydeliveryStatus::Abandoned(Some(e)) => e.get_field(field),
                SupplydeliveryStatus::Completed(Some(e)) => e.get_field(field),
                SupplydeliveryStatus::EnteredInError(Some(e)) => e.get_field(field),
                SupplydeliveryStatus::InProgress(Some(e)) => e.get_field(field),
                SupplydeliveryStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplydeliveryStatus::Abandoned(Some(e)) => e.get_field_mut(field),
                SupplydeliveryStatus::Completed(Some(e)) => e.get_field_mut(field),
                SupplydeliveryStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                SupplydeliveryStatus::InProgress(Some(e)) => e.get_field_mut(field),
                SupplydeliveryStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplydeliveryType {
    #[doc = "Device"]
    #[code = "device"]
    Device(Option<Element>),
    #[doc = "Medication"]
    #[code = "medication"]
    Medication(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplydeliveryType {
    fn default() -> Self {
        SupplydeliveryType::Null(None)
    }
}
impl TryFrom<String> for SupplydeliveryType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "device" => Ok(SupplydeliveryType::Device(None)),
            "medication" => Ok(SupplydeliveryType::Medication(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplydeliveryType {
    fn into(self) -> Option<String> {
        match self {
            SupplydeliveryType::Device(_) => Some("device".to_string()),
            SupplydeliveryType::Medication(_) => Some("medication".to_string()),
            SupplydeliveryType::Null(_) => None,
        }
    }
}
impl MetaValue for SupplydeliveryType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplydeliveryType::Device(Some(e)) => e.get_field(field),
                SupplydeliveryType::Medication(Some(e)) => e.get_field(field),
                SupplydeliveryType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplydeliveryType::Device(Some(e)) => e.get_field_mut(field),
                SupplydeliveryType::Medication(Some(e)) => e.get_field_mut(field),
                SupplydeliveryType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplyrequestKind {
    #[doc = "Central Supply"]
    #[code = "central"]
    Central(Option<Element>),
    #[doc = "Non-Stock"]
    #[code = "nonstock"]
    Nonstock(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplyrequestKind {
    fn default() -> Self {
        SupplyrequestKind::Null(None)
    }
}
impl TryFrom<String> for SupplyrequestKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "central" => Ok(SupplyrequestKind::Central(None)),
            "nonstock" => Ok(SupplyrequestKind::Nonstock(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplyrequestKind {
    fn into(self) -> Option<String> {
        match self {
            SupplyrequestKind::Central(_) => Some("central".to_string()),
            SupplyrequestKind::Nonstock(_) => Some("nonstock".to_string()),
            SupplyrequestKind::Null(_) => None,
        }
    }
}
impl MetaValue for SupplyrequestKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplyrequestKind::Central(Some(e)) => e.get_field(field),
                SupplyrequestKind::Nonstock(Some(e)) => e.get_field(field),
                SupplyrequestKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplyrequestKind::Central(Some(e)) => e.get_field_mut(field),
                SupplyrequestKind::Nonstock(Some(e)) => e.get_field_mut(field),
                SupplyrequestKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplyrequestReason {
    #[doc = "Patient Care"]
    #[code = "patient-care"]
    PatientCare(Option<Element>),
    #[doc = "Ward Stock"]
    #[code = "ward-stock"]
    WardStock(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplyrequestReason {
    fn default() -> Self {
        SupplyrequestReason::Null(None)
    }
}
impl TryFrom<String> for SupplyrequestReason {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "patient-care" => Ok(SupplyrequestReason::PatientCare(None)),
            "ward-stock" => Ok(SupplyrequestReason::WardStock(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplyrequestReason {
    fn into(self) -> Option<String> {
        match self {
            SupplyrequestReason::PatientCare(_) => Some("patient-care".to_string()),
            SupplyrequestReason::WardStock(_) => Some("ward-stock".to_string()),
            SupplyrequestReason::Null(_) => None,
        }
    }
}
impl MetaValue for SupplyrequestReason {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplyrequestReason::PatientCare(Some(e)) => e.get_field(field),
                SupplyrequestReason::WardStock(Some(e)) => e.get_field(field),
                SupplyrequestReason::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplyrequestReason::PatientCare(Some(e)) => e.get_field_mut(field),
                SupplyrequestReason::WardStock(Some(e)) => e.get_field_mut(field),
                SupplyrequestReason::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupplyrequestStatus {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupplyrequestStatus {
    fn default() -> Self {
        SupplyrequestStatus::Null(None)
    }
}
impl TryFrom<String> for SupplyrequestStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(SupplyrequestStatus::Active(None)),
            "cancelled" => Ok(SupplyrequestStatus::Cancelled(None)),
            "completed" => Ok(SupplyrequestStatus::Completed(None)),
            "draft" => Ok(SupplyrequestStatus::Draft(None)),
            "entered-in-error" => Ok(SupplyrequestStatus::EnteredInError(None)),
            "suspended" => Ok(SupplyrequestStatus::Suspended(None)),
            "unknown" => Ok(SupplyrequestStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupplyrequestStatus {
    fn into(self) -> Option<String> {
        match self {
            SupplyrequestStatus::Active(_) => Some("active".to_string()),
            SupplyrequestStatus::Cancelled(_) => Some("cancelled".to_string()),
            SupplyrequestStatus::Completed(_) => Some("completed".to_string()),
            SupplyrequestStatus::Draft(_) => Some("draft".to_string()),
            SupplyrequestStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            SupplyrequestStatus::Suspended(_) => Some("suspended".to_string()),
            SupplyrequestStatus::Unknown(_) => Some("unknown".to_string()),
            SupplyrequestStatus::Null(_) => None,
        }
    }
}
impl MetaValue for SupplyrequestStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupplyrequestStatus::Active(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Cancelled(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Completed(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Draft(Some(e)) => e.get_field(field),
                SupplyrequestStatus::EnteredInError(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Suspended(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Unknown(Some(e)) => e.get_field(field),
                SupplyrequestStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupplyrequestStatus::Active(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Completed(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Draft(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Suspended(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Unknown(Some(e)) => e.get_field_mut(field),
                SupplyrequestStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Surface {
    #[doc = "Buccal"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "Distal"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Distoincisal"]
    #[code = "DI"]
    DI(Option<Element>),
    #[doc = "Distoclusal"]
    #[code = "DO"]
    DO(Option<Element>),
    #[doc = "Incisal"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Lingual"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Mesial"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "Mesioclusal"]
    #[code = "MO"]
    MO(Option<Element>),
    #[doc = "Mesioclusodistal"]
    #[code = "MOD"]
    MOD(Option<Element>),
    #[doc = "Occlusal"]
    #[code = "O"]
    O(Option<Element>),
    #[doc = "Ventral"]
    #[code = "V"]
    V(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Surface {
    fn default() -> Self {
        Surface::Null(None)
    }
}
impl TryFrom<String> for Surface {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(Surface::B(None)),
            "D" => Ok(Surface::D(None)),
            "DI" => Ok(Surface::DI(None)),
            "DO" => Ok(Surface::DO(None)),
            "I" => Ok(Surface::I(None)),
            "L" => Ok(Surface::L(None)),
            "M" => Ok(Surface::M(None)),
            "MO" => Ok(Surface::MO(None)),
            "MOD" => Ok(Surface::MOD(None)),
            "O" => Ok(Surface::O(None)),
            "V" => Ok(Surface::V(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Surface {
    fn into(self) -> Option<String> {
        match self {
            Surface::B(_) => Some("B".to_string()),
            Surface::D(_) => Some("D".to_string()),
            Surface::DI(_) => Some("DI".to_string()),
            Surface::DO(_) => Some("DO".to_string()),
            Surface::I(_) => Some("I".to_string()),
            Surface::L(_) => Some("L".to_string()),
            Surface::M(_) => Some("M".to_string()),
            Surface::MO(_) => Some("MO".to_string()),
            Surface::MOD(_) => Some("MOD".to_string()),
            Surface::O(_) => Some("O".to_string()),
            Surface::V(_) => Some("V".to_string()),
            Surface::Null(_) => None,
        }
    }
}
impl MetaValue for Surface {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Surface::B(Some(e)) => e.get_field(field),
                Surface::D(Some(e)) => e.get_field(field),
                Surface::DI(Some(e)) => e.get_field(field),
                Surface::DO(Some(e)) => e.get_field(field),
                Surface::I(Some(e)) => e.get_field(field),
                Surface::L(Some(e)) => e.get_field(field),
                Surface::M(Some(e)) => e.get_field(field),
                Surface::MO(Some(e)) => e.get_field(field),
                Surface::MOD(Some(e)) => e.get_field(field),
                Surface::O(Some(e)) => e.get_field(field),
                Surface::V(Some(e)) => e.get_field(field),
                Surface::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Surface::B(Some(e)) => e.get_field_mut(field),
                Surface::D(Some(e)) => e.get_field_mut(field),
                Surface::DI(Some(e)) => e.get_field_mut(field),
                Surface::DO(Some(e)) => e.get_field_mut(field),
                Surface::I(Some(e)) => e.get_field_mut(field),
                Surface::L(Some(e)) => e.get_field_mut(field),
                Surface::M(Some(e)) => e.get_field_mut(field),
                Surface::MO(Some(e)) => e.get_field_mut(field),
                Surface::MOD(Some(e)) => e.get_field_mut(field),
                Surface::O(Some(e)) => e.get_field_mut(field),
                Surface::V(Some(e)) => e.get_field_mut(field),
                Surface::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SynthesisType {
    #[doc = "individual patient data meta-analysis"]
    #[code = "IPD-MA"]
    IPDMA(Option<Element>),
    #[doc = "classifcation of results"]
    #[code = "classification"]
    Classification(Option<Element>),
    #[doc = "combined direct plus indirect network meta-analysis"]
    #[code = "combined-NMA"]
    CombinedNMA(Option<Element>),
    #[doc = "indirect network meta-analysis"]
    #[code = "indirect-NMA"]
    IndirectNMA(Option<Element>),
    #[doc = "range of results"]
    #[code = "range"]
    Range(Option<Element>),
    #[doc = "summary data meta-analysis"]
    #[code = "std-MA"]
    StdMA(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SynthesisType {
    fn default() -> Self {
        SynthesisType::Null(None)
    }
}
impl TryFrom<String> for SynthesisType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "IPD-MA" => Ok(SynthesisType::IPDMA(None)),
            "classification" => Ok(SynthesisType::Classification(None)),
            "combined-NMA" => Ok(SynthesisType::CombinedNMA(None)),
            "indirect-NMA" => Ok(SynthesisType::IndirectNMA(None)),
            "range" => Ok(SynthesisType::Range(None)),
            "std-MA" => Ok(SynthesisType::StdMA(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SynthesisType {
    fn into(self) -> Option<String> {
        match self {
            SynthesisType::IPDMA(_) => Some("IPD-MA".to_string()),
            SynthesisType::Classification(_) => Some("classification".to_string()),
            SynthesisType::CombinedNMA(_) => Some("combined-NMA".to_string()),
            SynthesisType::IndirectNMA(_) => Some("indirect-NMA".to_string()),
            SynthesisType::Range(_) => Some("range".to_string()),
            SynthesisType::StdMA(_) => Some("std-MA".to_string()),
            SynthesisType::Null(_) => None,
        }
    }
}
impl MetaValue for SynthesisType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SynthesisType::IPDMA(Some(e)) => e.get_field(field),
                SynthesisType::Classification(Some(e)) => e.get_field(field),
                SynthesisType::CombinedNMA(Some(e)) => e.get_field(field),
                SynthesisType::IndirectNMA(Some(e)) => e.get_field(field),
                SynthesisType::Range(Some(e)) => e.get_field(field),
                SynthesisType::StdMA(Some(e)) => e.get_field(field),
                SynthesisType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SynthesisType::IPDMA(Some(e)) => e.get_field_mut(field),
                SynthesisType::Classification(Some(e)) => e.get_field_mut(field),
                SynthesisType::CombinedNMA(Some(e)) => e.get_field_mut(field),
                SynthesisType::IndirectNMA(Some(e)) => e.get_field_mut(field),
                SynthesisType::Range(Some(e)) => e.get_field_mut(field),
                SynthesisType::StdMA(Some(e)) => e.get_field_mut(field),
                SynthesisType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SystemRestfulInteraction {
    #[code = "batch"]
    Batch(Option<Element>),
    #[code = "history-system"]
    HistorySystem(Option<Element>),
    #[code = "search-system"]
    SearchSystem(Option<Element>),
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SystemRestfulInteraction {
    fn default() -> Self {
        SystemRestfulInteraction::Null(None)
    }
}
impl TryFrom<String> for SystemRestfulInteraction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "batch" => Ok(SystemRestfulInteraction::Batch(None)),
            "history-system" => Ok(SystemRestfulInteraction::HistorySystem(None)),
            "search-system" => Ok(SystemRestfulInteraction::SearchSystem(None)),
            "transaction" => Ok(SystemRestfulInteraction::Transaction(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SystemRestfulInteraction {
    fn into(self) -> Option<String> {
        match self {
            SystemRestfulInteraction::Batch(_) => Some("batch".to_string()),
            SystemRestfulInteraction::HistorySystem(_) => Some("history-system".to_string()),
            SystemRestfulInteraction::SearchSystem(_) => Some("search-system".to_string()),
            SystemRestfulInteraction::Transaction(_) => Some("transaction".to_string()),
            SystemRestfulInteraction::Null(_) => None,
        }
    }
}
impl MetaValue for SystemRestfulInteraction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SystemRestfulInteraction::Batch(Some(e)) => e.get_field(field),
                SystemRestfulInteraction::HistorySystem(Some(e)) => e.get_field(field),
                SystemRestfulInteraction::SearchSystem(Some(e)) => e.get_field(field),
                SystemRestfulInteraction::Transaction(Some(e)) => e.get_field(field),
                SystemRestfulInteraction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SystemRestfulInteraction::Batch(Some(e)) => e.get_field_mut(field),
                SystemRestfulInteraction::HistorySystem(Some(e)) => e.get_field_mut(field),
                SystemRestfulInteraction::SearchSystem(Some(e)) => e.get_field_mut(field),
                SystemRestfulInteraction::Transaction(Some(e)) => e.get_field_mut(field),
                SystemRestfulInteraction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TaskCode {
    #[doc = "Mark the focal resource as no longer active"]
    #[code = "abort"]
    Abort(Option<Element>),
    #[doc = "Activate/approve the focal resource"]
    #[code = "approve"]
    Approve(Option<Element>),
    #[doc = "Change the focal resource"]
    #[code = "change"]
    Change(Option<Element>),
    #[doc = "Fulfill the focal request"]
    #[code = "fulfill"]
    Fulfill(Option<Element>),
    #[doc = "Replace the focal resource with the input resource"]
    #[code = "replace"]
    Replace(Option<Element>),
    #[doc = "Re-activate the focal resource"]
    #[code = "resume"]
    Resume(Option<Element>),
    #[doc = "Suspend the focal resource"]
    #[code = "suspend"]
    Suspend(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TaskCode {
    fn default() -> Self {
        TaskCode::Null(None)
    }
}
impl TryFrom<String> for TaskCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "abort" => Ok(TaskCode::Abort(None)),
            "approve" => Ok(TaskCode::Approve(None)),
            "change" => Ok(TaskCode::Change(None)),
            "fulfill" => Ok(TaskCode::Fulfill(None)),
            "replace" => Ok(TaskCode::Replace(None)),
            "resume" => Ok(TaskCode::Resume(None)),
            "suspend" => Ok(TaskCode::Suspend(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TaskCode {
    fn into(self) -> Option<String> {
        match self {
            TaskCode::Abort(_) => Some("abort".to_string()),
            TaskCode::Approve(_) => Some("approve".to_string()),
            TaskCode::Change(_) => Some("change".to_string()),
            TaskCode::Fulfill(_) => Some("fulfill".to_string()),
            TaskCode::Replace(_) => Some("replace".to_string()),
            TaskCode::Resume(_) => Some("resume".to_string()),
            TaskCode::Suspend(_) => Some("suspend".to_string()),
            TaskCode::Null(_) => None,
        }
    }
}
impl MetaValue for TaskCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TaskCode::Abort(Some(e)) => e.get_field(field),
                TaskCode::Approve(Some(e)) => e.get_field(field),
                TaskCode::Change(Some(e)) => e.get_field(field),
                TaskCode::Fulfill(Some(e)) => e.get_field(field),
                TaskCode::Replace(Some(e)) => e.get_field(field),
                TaskCode::Resume(Some(e)) => e.get_field(field),
                TaskCode::Suspend(Some(e)) => e.get_field(field),
                TaskCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TaskCode::Abort(Some(e)) => e.get_field_mut(field),
                TaskCode::Approve(Some(e)) => e.get_field_mut(field),
                TaskCode::Change(Some(e)) => e.get_field_mut(field),
                TaskCode::Fulfill(Some(e)) => e.get_field_mut(field),
                TaskCode::Replace(Some(e)) => e.get_field_mut(field),
                TaskCode::Resume(Some(e)) => e.get_field_mut(field),
                TaskCode::Suspend(Some(e)) => e.get_field_mut(field),
                TaskCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TaskIntent {
    #[code = "filler-order"]
    FillerOrder(Option<Element>),
    #[code = "instance-order"]
    InstanceOrder(Option<Element>),
    #[code = "option"]
    Option(Option<Element>),
    #[code = "order"]
    Order(Option<Element>),
    #[code = "original-order"]
    OriginalOrder(Option<Element>),
    #[code = "plan"]
    Plan(Option<Element>),
    #[code = "proposal"]
    Proposal(Option<Element>),
    #[code = "reflex-order"]
    ReflexOrder(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TaskIntent {
    fn default() -> Self {
        TaskIntent::Null(None)
    }
}
impl TryFrom<String> for TaskIntent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "filler-order" => Ok(TaskIntent::FillerOrder(None)),
            "instance-order" => Ok(TaskIntent::InstanceOrder(None)),
            "option" => Ok(TaskIntent::Option(None)),
            "order" => Ok(TaskIntent::Order(None)),
            "original-order" => Ok(TaskIntent::OriginalOrder(None)),
            "plan" => Ok(TaskIntent::Plan(None)),
            "proposal" => Ok(TaskIntent::Proposal(None)),
            "reflex-order" => Ok(TaskIntent::ReflexOrder(None)),
            "unknown" => Ok(TaskIntent::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TaskIntent {
    fn into(self) -> Option<String> {
        match self {
            TaskIntent::FillerOrder(_) => Some("filler-order".to_string()),
            TaskIntent::InstanceOrder(_) => Some("instance-order".to_string()),
            TaskIntent::Option(_) => Some("option".to_string()),
            TaskIntent::Order(_) => Some("order".to_string()),
            TaskIntent::OriginalOrder(_) => Some("original-order".to_string()),
            TaskIntent::Plan(_) => Some("plan".to_string()),
            TaskIntent::Proposal(_) => Some("proposal".to_string()),
            TaskIntent::ReflexOrder(_) => Some("reflex-order".to_string()),
            TaskIntent::Unknown(_) => Some("unknown".to_string()),
            TaskIntent::Null(_) => None,
        }
    }
}
impl MetaValue for TaskIntent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TaskIntent::FillerOrder(Some(e)) => e.get_field(field),
                TaskIntent::InstanceOrder(Some(e)) => e.get_field(field),
                TaskIntent::Option(Some(e)) => e.get_field(field),
                TaskIntent::Order(Some(e)) => e.get_field(field),
                TaskIntent::OriginalOrder(Some(e)) => e.get_field(field),
                TaskIntent::Plan(Some(e)) => e.get_field(field),
                TaskIntent::Proposal(Some(e)) => e.get_field(field),
                TaskIntent::ReflexOrder(Some(e)) => e.get_field(field),
                TaskIntent::Unknown(Some(e)) => e.get_field(field),
                TaskIntent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TaskIntent::FillerOrder(Some(e)) => e.get_field_mut(field),
                TaskIntent::InstanceOrder(Some(e)) => e.get_field_mut(field),
                TaskIntent::Option(Some(e)) => e.get_field_mut(field),
                TaskIntent::Order(Some(e)) => e.get_field_mut(field),
                TaskIntent::OriginalOrder(Some(e)) => e.get_field_mut(field),
                TaskIntent::Plan(Some(e)) => e.get_field_mut(field),
                TaskIntent::Proposal(Some(e)) => e.get_field_mut(field),
                TaskIntent::ReflexOrder(Some(e)) => e.get_field_mut(field),
                TaskIntent::Unknown(Some(e)) => e.get_field_mut(field),
                TaskIntent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TaskStatus {
    #[doc = "Accepted"]
    #[code = "accepted"]
    Accepted(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Entered in Error"]
    #[code = "entered-in-error"]
    EnteredInError(Option<Element>),
    #[doc = "Failed"]
    #[code = "failed"]
    Failed(Option<Element>),
    #[doc = "In Progress"]
    #[code = "in-progress"]
    InProgress(Option<Element>),
    #[doc = "On Hold"]
    #[code = "on-hold"]
    OnHold(Option<Element>),
    #[doc = "Ready"]
    #[code = "ready"]
    Ready(Option<Element>),
    #[doc = "Received"]
    #[code = "received"]
    Received(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "Requested"]
    #[code = "requested"]
    Requested(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TaskStatus {
    fn default() -> Self {
        TaskStatus::Null(None)
    }
}
impl TryFrom<String> for TaskStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "accepted" => Ok(TaskStatus::Accepted(None)),
            "cancelled" => Ok(TaskStatus::Cancelled(None)),
            "completed" => Ok(TaskStatus::Completed(None)),
            "draft" => Ok(TaskStatus::Draft(None)),
            "entered-in-error" => Ok(TaskStatus::EnteredInError(None)),
            "failed" => Ok(TaskStatus::Failed(None)),
            "in-progress" => Ok(TaskStatus::InProgress(None)),
            "on-hold" => Ok(TaskStatus::OnHold(None)),
            "ready" => Ok(TaskStatus::Ready(None)),
            "received" => Ok(TaskStatus::Received(None)),
            "rejected" => Ok(TaskStatus::Rejected(None)),
            "requested" => Ok(TaskStatus::Requested(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TaskStatus {
    fn into(self) -> Option<String> {
        match self {
            TaskStatus::Accepted(_) => Some("accepted".to_string()),
            TaskStatus::Cancelled(_) => Some("cancelled".to_string()),
            TaskStatus::Completed(_) => Some("completed".to_string()),
            TaskStatus::Draft(_) => Some("draft".to_string()),
            TaskStatus::EnteredInError(_) => Some("entered-in-error".to_string()),
            TaskStatus::Failed(_) => Some("failed".to_string()),
            TaskStatus::InProgress(_) => Some("in-progress".to_string()),
            TaskStatus::OnHold(_) => Some("on-hold".to_string()),
            TaskStatus::Ready(_) => Some("ready".to_string()),
            TaskStatus::Received(_) => Some("received".to_string()),
            TaskStatus::Rejected(_) => Some("rejected".to_string()),
            TaskStatus::Requested(_) => Some("requested".to_string()),
            TaskStatus::Null(_) => None,
        }
    }
}
impl MetaValue for TaskStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TaskStatus::Accepted(Some(e)) => e.get_field(field),
                TaskStatus::Cancelled(Some(e)) => e.get_field(field),
                TaskStatus::Completed(Some(e)) => e.get_field(field),
                TaskStatus::Draft(Some(e)) => e.get_field(field),
                TaskStatus::EnteredInError(Some(e)) => e.get_field(field),
                TaskStatus::Failed(Some(e)) => e.get_field(field),
                TaskStatus::InProgress(Some(e)) => e.get_field(field),
                TaskStatus::OnHold(Some(e)) => e.get_field(field),
                TaskStatus::Ready(Some(e)) => e.get_field(field),
                TaskStatus::Received(Some(e)) => e.get_field(field),
                TaskStatus::Rejected(Some(e)) => e.get_field(field),
                TaskStatus::Requested(Some(e)) => e.get_field(field),
                TaskStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TaskStatus::Accepted(Some(e)) => e.get_field_mut(field),
                TaskStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                TaskStatus::Completed(Some(e)) => e.get_field_mut(field),
                TaskStatus::Draft(Some(e)) => e.get_field_mut(field),
                TaskStatus::EnteredInError(Some(e)) => e.get_field_mut(field),
                TaskStatus::Failed(Some(e)) => e.get_field_mut(field),
                TaskStatus::InProgress(Some(e)) => e.get_field_mut(field),
                TaskStatus::OnHold(Some(e)) => e.get_field_mut(field),
                TaskStatus::Ready(Some(e)) => e.get_field_mut(field),
                TaskStatus::Received(Some(e)) => e.get_field_mut(field),
                TaskStatus::Rejected(Some(e)) => e.get_field_mut(field),
                TaskStatus::Requested(Some(e)) => e.get_field_mut(field),
                TaskStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Teeth {
    #[doc = "11"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "12"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "13"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "14"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "15"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "16"]
    #[code = "16"]
    V16(Option<Element>),
    #[doc = "17"]
    #[code = "17"]
    V17(Option<Element>),
    #[doc = "18"]
    #[code = "18"]
    V18(Option<Element>),
    #[doc = "21"]
    #[code = "21"]
    V21(Option<Element>),
    #[doc = "22"]
    #[code = "22"]
    V22(Option<Element>),
    #[doc = "23"]
    #[code = "23"]
    V23(Option<Element>),
    #[doc = "24"]
    #[code = "24"]
    V24(Option<Element>),
    #[doc = "25"]
    #[code = "25"]
    V25(Option<Element>),
    #[doc = "26"]
    #[code = "26"]
    V26(Option<Element>),
    #[doc = "27"]
    #[code = "27"]
    V27(Option<Element>),
    #[doc = "28"]
    #[code = "28"]
    V28(Option<Element>),
    #[doc = "31"]
    #[code = "31"]
    V31(Option<Element>),
    #[doc = "32"]
    #[code = "32"]
    V32(Option<Element>),
    #[doc = "33"]
    #[code = "33"]
    V33(Option<Element>),
    #[doc = "34"]
    #[code = "34"]
    V34(Option<Element>),
    #[doc = "35"]
    #[code = "35"]
    V35(Option<Element>),
    #[doc = "36"]
    #[code = "36"]
    V36(Option<Element>),
    #[doc = "37"]
    #[code = "37"]
    V37(Option<Element>),
    #[doc = "38"]
    #[code = "38"]
    V38(Option<Element>),
    #[doc = "41"]
    #[code = "41"]
    V41(Option<Element>),
    #[doc = "42"]
    #[code = "42"]
    V42(Option<Element>),
    #[doc = "43"]
    #[code = "43"]
    V43(Option<Element>),
    #[doc = "44"]
    #[code = "44"]
    V44(Option<Element>),
    #[doc = "45"]
    #[code = "45"]
    V45(Option<Element>),
    #[doc = "46"]
    #[code = "46"]
    V46(Option<Element>),
    #[doc = "47"]
    #[code = "47"]
    V47(Option<Element>),
    #[doc = "48"]
    #[code = "48"]
    V48(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Teeth {
    fn default() -> Self {
        Teeth::Null(None)
    }
}
impl TryFrom<String> for Teeth {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "11" => Ok(Teeth::V11(None)),
            "12" => Ok(Teeth::V12(None)),
            "13" => Ok(Teeth::V13(None)),
            "14" => Ok(Teeth::V14(None)),
            "15" => Ok(Teeth::V15(None)),
            "16" => Ok(Teeth::V16(None)),
            "17" => Ok(Teeth::V17(None)),
            "18" => Ok(Teeth::V18(None)),
            "21" => Ok(Teeth::V21(None)),
            "22" => Ok(Teeth::V22(None)),
            "23" => Ok(Teeth::V23(None)),
            "24" => Ok(Teeth::V24(None)),
            "25" => Ok(Teeth::V25(None)),
            "26" => Ok(Teeth::V26(None)),
            "27" => Ok(Teeth::V27(None)),
            "28" => Ok(Teeth::V28(None)),
            "31" => Ok(Teeth::V31(None)),
            "32" => Ok(Teeth::V32(None)),
            "33" => Ok(Teeth::V33(None)),
            "34" => Ok(Teeth::V34(None)),
            "35" => Ok(Teeth::V35(None)),
            "36" => Ok(Teeth::V36(None)),
            "37" => Ok(Teeth::V37(None)),
            "38" => Ok(Teeth::V38(None)),
            "41" => Ok(Teeth::V41(None)),
            "42" => Ok(Teeth::V42(None)),
            "43" => Ok(Teeth::V43(None)),
            "44" => Ok(Teeth::V44(None)),
            "45" => Ok(Teeth::V45(None)),
            "46" => Ok(Teeth::V46(None)),
            "47" => Ok(Teeth::V47(None)),
            "48" => Ok(Teeth::V48(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Teeth {
    fn into(self) -> Option<String> {
        match self {
            Teeth::V11(_) => Some("11".to_string()),
            Teeth::V12(_) => Some("12".to_string()),
            Teeth::V13(_) => Some("13".to_string()),
            Teeth::V14(_) => Some("14".to_string()),
            Teeth::V15(_) => Some("15".to_string()),
            Teeth::V16(_) => Some("16".to_string()),
            Teeth::V17(_) => Some("17".to_string()),
            Teeth::V18(_) => Some("18".to_string()),
            Teeth::V21(_) => Some("21".to_string()),
            Teeth::V22(_) => Some("22".to_string()),
            Teeth::V23(_) => Some("23".to_string()),
            Teeth::V24(_) => Some("24".to_string()),
            Teeth::V25(_) => Some("25".to_string()),
            Teeth::V26(_) => Some("26".to_string()),
            Teeth::V27(_) => Some("27".to_string()),
            Teeth::V28(_) => Some("28".to_string()),
            Teeth::V31(_) => Some("31".to_string()),
            Teeth::V32(_) => Some("32".to_string()),
            Teeth::V33(_) => Some("33".to_string()),
            Teeth::V34(_) => Some("34".to_string()),
            Teeth::V35(_) => Some("35".to_string()),
            Teeth::V36(_) => Some("36".to_string()),
            Teeth::V37(_) => Some("37".to_string()),
            Teeth::V38(_) => Some("38".to_string()),
            Teeth::V41(_) => Some("41".to_string()),
            Teeth::V42(_) => Some("42".to_string()),
            Teeth::V43(_) => Some("43".to_string()),
            Teeth::V44(_) => Some("44".to_string()),
            Teeth::V45(_) => Some("45".to_string()),
            Teeth::V46(_) => Some("46".to_string()),
            Teeth::V47(_) => Some("47".to_string()),
            Teeth::V48(_) => Some("48".to_string()),
            Teeth::Null(_) => None,
        }
    }
}
impl MetaValue for Teeth {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Teeth::V11(Some(e)) => e.get_field(field),
                Teeth::V12(Some(e)) => e.get_field(field),
                Teeth::V13(Some(e)) => e.get_field(field),
                Teeth::V14(Some(e)) => e.get_field(field),
                Teeth::V15(Some(e)) => e.get_field(field),
                Teeth::V16(Some(e)) => e.get_field(field),
                Teeth::V17(Some(e)) => e.get_field(field),
                Teeth::V18(Some(e)) => e.get_field(field),
                Teeth::V21(Some(e)) => e.get_field(field),
                Teeth::V22(Some(e)) => e.get_field(field),
                Teeth::V23(Some(e)) => e.get_field(field),
                Teeth::V24(Some(e)) => e.get_field(field),
                Teeth::V25(Some(e)) => e.get_field(field),
                Teeth::V26(Some(e)) => e.get_field(field),
                Teeth::V27(Some(e)) => e.get_field(field),
                Teeth::V28(Some(e)) => e.get_field(field),
                Teeth::V31(Some(e)) => e.get_field(field),
                Teeth::V32(Some(e)) => e.get_field(field),
                Teeth::V33(Some(e)) => e.get_field(field),
                Teeth::V34(Some(e)) => e.get_field(field),
                Teeth::V35(Some(e)) => e.get_field(field),
                Teeth::V36(Some(e)) => e.get_field(field),
                Teeth::V37(Some(e)) => e.get_field(field),
                Teeth::V38(Some(e)) => e.get_field(field),
                Teeth::V41(Some(e)) => e.get_field(field),
                Teeth::V42(Some(e)) => e.get_field(field),
                Teeth::V43(Some(e)) => e.get_field(field),
                Teeth::V44(Some(e)) => e.get_field(field),
                Teeth::V45(Some(e)) => e.get_field(field),
                Teeth::V46(Some(e)) => e.get_field(field),
                Teeth::V47(Some(e)) => e.get_field(field),
                Teeth::V48(Some(e)) => e.get_field(field),
                Teeth::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Teeth::V11(Some(e)) => e.get_field_mut(field),
                Teeth::V12(Some(e)) => e.get_field_mut(field),
                Teeth::V13(Some(e)) => e.get_field_mut(field),
                Teeth::V14(Some(e)) => e.get_field_mut(field),
                Teeth::V15(Some(e)) => e.get_field_mut(field),
                Teeth::V16(Some(e)) => e.get_field_mut(field),
                Teeth::V17(Some(e)) => e.get_field_mut(field),
                Teeth::V18(Some(e)) => e.get_field_mut(field),
                Teeth::V21(Some(e)) => e.get_field_mut(field),
                Teeth::V22(Some(e)) => e.get_field_mut(field),
                Teeth::V23(Some(e)) => e.get_field_mut(field),
                Teeth::V24(Some(e)) => e.get_field_mut(field),
                Teeth::V25(Some(e)) => e.get_field_mut(field),
                Teeth::V26(Some(e)) => e.get_field_mut(field),
                Teeth::V27(Some(e)) => e.get_field_mut(field),
                Teeth::V28(Some(e)) => e.get_field_mut(field),
                Teeth::V31(Some(e)) => e.get_field_mut(field),
                Teeth::V32(Some(e)) => e.get_field_mut(field),
                Teeth::V33(Some(e)) => e.get_field_mut(field),
                Teeth::V34(Some(e)) => e.get_field_mut(field),
                Teeth::V35(Some(e)) => e.get_field_mut(field),
                Teeth::V36(Some(e)) => e.get_field_mut(field),
                Teeth::V37(Some(e)) => e.get_field_mut(field),
                Teeth::V38(Some(e)) => e.get_field_mut(field),
                Teeth::V41(Some(e)) => e.get_field_mut(field),
                Teeth::V42(Some(e)) => e.get_field_mut(field),
                Teeth::V43(Some(e)) => e.get_field_mut(field),
                Teeth::V44(Some(e)) => e.get_field_mut(field),
                Teeth::V45(Some(e)) => e.get_field_mut(field),
                Teeth::V46(Some(e)) => e.get_field_mut(field),
                Teeth::V47(Some(e)) => e.get_field_mut(field),
                Teeth::V48(Some(e)) => e.get_field_mut(field),
                Teeth::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TemplateStatusCode {
    #[doc = "Active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "Cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "Draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "Under pre-publication review"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "Rejected"]
    #[code = "rejected"]
    Rejected(Option<Element>),
    #[doc = "Retired"]
    #[code = "retired"]
    Retired(Option<Element>),
    #[doc = "In Review"]
    #[code = "review"]
    Review(Option<Element>),
    #[doc = "Terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TemplateStatusCode {
    fn default() -> Self {
        TemplateStatusCode::Null(None)
    }
}
impl TryFrom<String> for TemplateStatusCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(TemplateStatusCode::Active(None)),
            "cancelled" => Ok(TemplateStatusCode::Cancelled(None)),
            "draft" => Ok(TemplateStatusCode::Draft(None)),
            "pending" => Ok(TemplateStatusCode::Pending(None)),
            "rejected" => Ok(TemplateStatusCode::Rejected(None)),
            "retired" => Ok(TemplateStatusCode::Retired(None)),
            "review" => Ok(TemplateStatusCode::Review(None)),
            "terminated" => Ok(TemplateStatusCode::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TemplateStatusCode {
    fn into(self) -> Option<String> {
        match self {
            TemplateStatusCode::Active(_) => Some("active".to_string()),
            TemplateStatusCode::Cancelled(_) => Some("cancelled".to_string()),
            TemplateStatusCode::Draft(_) => Some("draft".to_string()),
            TemplateStatusCode::Pending(_) => Some("pending".to_string()),
            TemplateStatusCode::Rejected(_) => Some("rejected".to_string()),
            TemplateStatusCode::Retired(_) => Some("retired".to_string()),
            TemplateStatusCode::Review(_) => Some("review".to_string()),
            TemplateStatusCode::Terminated(_) => Some("terminated".to_string()),
            TemplateStatusCode::Null(_) => None,
        }
    }
}
impl MetaValue for TemplateStatusCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TemplateStatusCode::Active(Some(e)) => e.get_field(field),
                TemplateStatusCode::Cancelled(Some(e)) => e.get_field(field),
                TemplateStatusCode::Draft(Some(e)) => e.get_field(field),
                TemplateStatusCode::Pending(Some(e)) => e.get_field(field),
                TemplateStatusCode::Rejected(Some(e)) => e.get_field(field),
                TemplateStatusCode::Retired(Some(e)) => e.get_field(field),
                TemplateStatusCode::Review(Some(e)) => e.get_field(field),
                TemplateStatusCode::Terminated(Some(e)) => e.get_field(field),
                TemplateStatusCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TemplateStatusCode::Active(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Cancelled(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Draft(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Pending(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Rejected(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Retired(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Review(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Terminated(Some(e)) => e.get_field_mut(field),
                TemplateStatusCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TestscriptOperationCodes {
    #[doc = "$apply"]
    #[code = "apply"]
    Apply(Option<Element>),
    #[doc = "Batch"]
    #[code = "batch"]
    Batch(Option<Element>),
    #[doc = "Capabilities"]
    #[code = "capabilities"]
    Capabilities(Option<Element>),
    #[doc = "$closure"]
    #[code = "closure"]
    Closure(Option<Element>),
    #[doc = "$conforms"]
    #[code = "conforms"]
    Conforms(Option<Element>),
    #[doc = "Create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "$data-requirements"]
    #[code = "data-requirements"]
    DataRequirements(Option<Element>),
    #[doc = "Delete"]
    #[code = "delete"]
    Delete(Option<Element>),
    #[doc = "Conditional Delete Multiple"]
    #[code = "deleteCondMultiple"]
    DeleteCondMultiple(Option<Element>),
    #[doc = "Conditional Delete Single"]
    #[code = "deleteCondSingle"]
    DeleteCondSingle(Option<Element>),
    #[doc = "$document"]
    #[code = "document"]
    Document(Option<Element>),
    #[doc = "$evaluate"]
    #[code = "evaluate"]
    Evaluate(Option<Element>),
    #[doc = "$evaluate-measure"]
    #[code = "evaluate-measure"]
    EvaluateMeasure(Option<Element>),
    #[doc = "$everything"]
    #[code = "everything"]
    Everything(Option<Element>),
    #[doc = "$expand"]
    #[code = "expand"]
    Expand(Option<Element>),
    #[doc = "$find"]
    #[code = "find"]
    Find(Option<Element>),
    #[doc = "$find-matches"]
    #[code = "find-matches"]
    FindMatches(Option<Element>),
    #[doc = "$graphql"]
    #[code = "graphql"]
    Graphql(Option<Element>),
    #[doc = "History"]
    #[code = "history"]
    History(Option<Element>),
    #[doc = "$implements"]
    #[code = "implements"]
    Implements(Option<Element>),
    #[doc = "$lastn"]
    #[code = "lastn"]
    Lastn(Option<Element>),
    #[doc = "$lookup"]
    #[code = "lookup"]
    Lookup(Option<Element>),
    #[doc = "$match"]
    #[code = "match"]
    Match(Option<Element>),
    #[doc = "$meta"]
    #[code = "meta"]
    Meta(Option<Element>),
    #[doc = "$meta-add"]
    #[code = "meta-add"]
    MetaAdd(Option<Element>),
    #[doc = "$meta-delete"]
    #[code = "meta-delete"]
    MetaDelete(Option<Element>),
    #[doc = "Patch"]
    #[code = "patch"]
    Patch(Option<Element>),
    #[doc = "$populate"]
    #[code = "populate"]
    Populate(Option<Element>),
    #[doc = "$populatehtml"]
    #[code = "populatehtml"]
    Populatehtml(Option<Element>),
    #[doc = "$populatelink"]
    #[code = "populatelink"]
    Populatelink(Option<Element>),
    #[doc = "$process-message"]
    #[code = "process-message"]
    ProcessMessage(Option<Element>),
    #[doc = "$questionnaire"]
    #[code = "questionnaire"]
    Questionnaire(Option<Element>),
    #[doc = "Read"]
    #[code = "read"]
    Read(Option<Element>),
    #[doc = "Search"]
    #[code = "search"]
    Search(Option<Element>),
    #[doc = "$stats"]
    #[code = "stats"]
    Stats(Option<Element>),
    #[doc = "$subset"]
    #[code = "subset"]
    Subset(Option<Element>),
    #[doc = "$subsumes"]
    #[code = "subsumes"]
    Subsumes(Option<Element>),
    #[doc = "Transaction"]
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "$transform"]
    #[code = "transform"]
    Transform(Option<Element>),
    #[doc = "$translate"]
    #[code = "translate"]
    Translate(Option<Element>),
    #[doc = "Update"]
    #[code = "update"]
    Update(Option<Element>),
    #[doc = "Create using Update"]
    #[code = "updateCreate"]
    UpdateCreate(Option<Element>),
    #[doc = "$validate"]
    #[code = "validate"]
    Validate(Option<Element>),
    #[doc = "$validate-code"]
    #[code = "validate-code"]
    ValidateCode(Option<Element>),
    #[doc = "Version Read"]
    #[code = "vread"]
    Vread(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TestscriptOperationCodes {
    fn default() -> Self {
        TestscriptOperationCodes::Null(None)
    }
}
impl TryFrom<String> for TestscriptOperationCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "apply" => Ok(TestscriptOperationCodes::Apply(None)),
            "batch" => Ok(TestscriptOperationCodes::Batch(None)),
            "capabilities" => Ok(TestscriptOperationCodes::Capabilities(None)),
            "closure" => Ok(TestscriptOperationCodes::Closure(None)),
            "conforms" => Ok(TestscriptOperationCodes::Conforms(None)),
            "create" => Ok(TestscriptOperationCodes::Create(None)),
            "data-requirements" => Ok(TestscriptOperationCodes::DataRequirements(None)),
            "delete" => Ok(TestscriptOperationCodes::Delete(None)),
            "deleteCondMultiple" => Ok(TestscriptOperationCodes::DeleteCondMultiple(None)),
            "deleteCondSingle" => Ok(TestscriptOperationCodes::DeleteCondSingle(None)),
            "document" => Ok(TestscriptOperationCodes::Document(None)),
            "evaluate" => Ok(TestscriptOperationCodes::Evaluate(None)),
            "evaluate-measure" => Ok(TestscriptOperationCodes::EvaluateMeasure(None)),
            "everything" => Ok(TestscriptOperationCodes::Everything(None)),
            "expand" => Ok(TestscriptOperationCodes::Expand(None)),
            "find" => Ok(TestscriptOperationCodes::Find(None)),
            "find-matches" => Ok(TestscriptOperationCodes::FindMatches(None)),
            "graphql" => Ok(TestscriptOperationCodes::Graphql(None)),
            "history" => Ok(TestscriptOperationCodes::History(None)),
            "implements" => Ok(TestscriptOperationCodes::Implements(None)),
            "lastn" => Ok(TestscriptOperationCodes::Lastn(None)),
            "lookup" => Ok(TestscriptOperationCodes::Lookup(None)),
            "match" => Ok(TestscriptOperationCodes::Match(None)),
            "meta" => Ok(TestscriptOperationCodes::Meta(None)),
            "meta-add" => Ok(TestscriptOperationCodes::MetaAdd(None)),
            "meta-delete" => Ok(TestscriptOperationCodes::MetaDelete(None)),
            "patch" => Ok(TestscriptOperationCodes::Patch(None)),
            "populate" => Ok(TestscriptOperationCodes::Populate(None)),
            "populatehtml" => Ok(TestscriptOperationCodes::Populatehtml(None)),
            "populatelink" => Ok(TestscriptOperationCodes::Populatelink(None)),
            "process-message" => Ok(TestscriptOperationCodes::ProcessMessage(None)),
            "questionnaire" => Ok(TestscriptOperationCodes::Questionnaire(None)),
            "read" => Ok(TestscriptOperationCodes::Read(None)),
            "search" => Ok(TestscriptOperationCodes::Search(None)),
            "stats" => Ok(TestscriptOperationCodes::Stats(None)),
            "subset" => Ok(TestscriptOperationCodes::Subset(None)),
            "subsumes" => Ok(TestscriptOperationCodes::Subsumes(None)),
            "transaction" => Ok(TestscriptOperationCodes::Transaction(None)),
            "transform" => Ok(TestscriptOperationCodes::Transform(None)),
            "translate" => Ok(TestscriptOperationCodes::Translate(None)),
            "update" => Ok(TestscriptOperationCodes::Update(None)),
            "updateCreate" => Ok(TestscriptOperationCodes::UpdateCreate(None)),
            "validate" => Ok(TestscriptOperationCodes::Validate(None)),
            "validate-code" => Ok(TestscriptOperationCodes::ValidateCode(None)),
            "vread" => Ok(TestscriptOperationCodes::Vread(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TestscriptOperationCodes {
    fn into(self) -> Option<String> {
        match self {
            TestscriptOperationCodes::Apply(_) => Some("apply".to_string()),
            TestscriptOperationCodes::Batch(_) => Some("batch".to_string()),
            TestscriptOperationCodes::Capabilities(_) => Some("capabilities".to_string()),
            TestscriptOperationCodes::Closure(_) => Some("closure".to_string()),
            TestscriptOperationCodes::Conforms(_) => Some("conforms".to_string()),
            TestscriptOperationCodes::Create(_) => Some("create".to_string()),
            TestscriptOperationCodes::DataRequirements(_) => Some("data-requirements".to_string()),
            TestscriptOperationCodes::Delete(_) => Some("delete".to_string()),
            TestscriptOperationCodes::DeleteCondMultiple(_) => {
                Some("deleteCondMultiple".to_string())
            }
            TestscriptOperationCodes::DeleteCondSingle(_) => Some("deleteCondSingle".to_string()),
            TestscriptOperationCodes::Document(_) => Some("document".to_string()),
            TestscriptOperationCodes::Evaluate(_) => Some("evaluate".to_string()),
            TestscriptOperationCodes::EvaluateMeasure(_) => Some("evaluate-measure".to_string()),
            TestscriptOperationCodes::Everything(_) => Some("everything".to_string()),
            TestscriptOperationCodes::Expand(_) => Some("expand".to_string()),
            TestscriptOperationCodes::Find(_) => Some("find".to_string()),
            TestscriptOperationCodes::FindMatches(_) => Some("find-matches".to_string()),
            TestscriptOperationCodes::Graphql(_) => Some("graphql".to_string()),
            TestscriptOperationCodes::History(_) => Some("history".to_string()),
            TestscriptOperationCodes::Implements(_) => Some("implements".to_string()),
            TestscriptOperationCodes::Lastn(_) => Some("lastn".to_string()),
            TestscriptOperationCodes::Lookup(_) => Some("lookup".to_string()),
            TestscriptOperationCodes::Match(_) => Some("match".to_string()),
            TestscriptOperationCodes::Meta(_) => Some("meta".to_string()),
            TestscriptOperationCodes::MetaAdd(_) => Some("meta-add".to_string()),
            TestscriptOperationCodes::MetaDelete(_) => Some("meta-delete".to_string()),
            TestscriptOperationCodes::Patch(_) => Some("patch".to_string()),
            TestscriptOperationCodes::Populate(_) => Some("populate".to_string()),
            TestscriptOperationCodes::Populatehtml(_) => Some("populatehtml".to_string()),
            TestscriptOperationCodes::Populatelink(_) => Some("populatelink".to_string()),
            TestscriptOperationCodes::ProcessMessage(_) => Some("process-message".to_string()),
            TestscriptOperationCodes::Questionnaire(_) => Some("questionnaire".to_string()),
            TestscriptOperationCodes::Read(_) => Some("read".to_string()),
            TestscriptOperationCodes::Search(_) => Some("search".to_string()),
            TestscriptOperationCodes::Stats(_) => Some("stats".to_string()),
            TestscriptOperationCodes::Subset(_) => Some("subset".to_string()),
            TestscriptOperationCodes::Subsumes(_) => Some("subsumes".to_string()),
            TestscriptOperationCodes::Transaction(_) => Some("transaction".to_string()),
            TestscriptOperationCodes::Transform(_) => Some("transform".to_string()),
            TestscriptOperationCodes::Translate(_) => Some("translate".to_string()),
            TestscriptOperationCodes::Update(_) => Some("update".to_string()),
            TestscriptOperationCodes::UpdateCreate(_) => Some("updateCreate".to_string()),
            TestscriptOperationCodes::Validate(_) => Some("validate".to_string()),
            TestscriptOperationCodes::ValidateCode(_) => Some("validate-code".to_string()),
            TestscriptOperationCodes::Vread(_) => Some("vread".to_string()),
            TestscriptOperationCodes::Null(_) => None,
        }
    }
}
impl MetaValue for TestscriptOperationCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TestscriptOperationCodes::Apply(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Batch(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Capabilities(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Closure(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Conforms(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Create(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::DataRequirements(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Delete(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::DeleteCondMultiple(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::DeleteCondSingle(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Document(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Evaluate(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::EvaluateMeasure(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Everything(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Expand(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Find(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::FindMatches(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Graphql(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::History(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Implements(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Lastn(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Lookup(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Match(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Meta(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::MetaAdd(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::MetaDelete(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Patch(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Populate(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Populatehtml(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Populatelink(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::ProcessMessage(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Questionnaire(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Read(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Search(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Stats(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Subset(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Subsumes(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Transaction(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Transform(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Translate(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Update(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::UpdateCreate(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Validate(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::ValidateCode(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Vread(Some(e)) => e.get_field(field),
                TestscriptOperationCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TestscriptOperationCodes::Apply(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Batch(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Capabilities(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Closure(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Conforms(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Create(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::DataRequirements(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Delete(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::DeleteCondMultiple(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::DeleteCondSingle(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Document(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Evaluate(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::EvaluateMeasure(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Everything(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Expand(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Find(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::FindMatches(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Graphql(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::History(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Implements(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Lastn(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Lookup(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Match(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Meta(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::MetaAdd(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::MetaDelete(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Patch(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Populate(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Populatehtml(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Populatelink(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::ProcessMessage(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Questionnaire(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Read(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Search(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Stats(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Subset(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Subsumes(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Transaction(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Transform(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Translate(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Update(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::UpdateCreate(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Validate(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::ValidateCode(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Vread(Some(e)) => e.get_field_mut(field),
                TestscriptOperationCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TestscriptProfileDestinationTypes {
    #[doc = "FHIR SDC FormManager"]
    #[code = "FHIR-SDC-FormManager"]
    FHIRSDCFormManager(Option<Element>),
    #[doc = "FHIR SDC FormProcessor"]
    #[code = "FHIR-SDC-FormProcessor"]
    FHIRSDCFormProcessor(Option<Element>),
    #[doc = "FHIR SDC FormReceiver"]
    #[code = "FHIR-SDC-FormReceiver"]
    FHIRSDCFormReceiver(Option<Element>),
    #[doc = "FHIR Server"]
    #[code = "FHIR-Server"]
    FHIRServer(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TestscriptProfileDestinationTypes {
    fn default() -> Self {
        TestscriptProfileDestinationTypes::Null(None)
    }
}
impl TryFrom<String> for TestscriptProfileDestinationTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "FHIR-SDC-FormManager" => {
                Ok(TestscriptProfileDestinationTypes::FHIRSDCFormManager(None))
            }
            "FHIR-SDC-FormProcessor" => Ok(
                TestscriptProfileDestinationTypes::FHIRSDCFormProcessor(None),
            ),
            "FHIR-SDC-FormReceiver" => {
                Ok(TestscriptProfileDestinationTypes::FHIRSDCFormReceiver(None))
            }
            "FHIR-Server" => Ok(TestscriptProfileDestinationTypes::FHIRServer(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TestscriptProfileDestinationTypes {
    fn into(self) -> Option<String> {
        match self {
            TestscriptProfileDestinationTypes::FHIRSDCFormManager(_) => {
                Some("FHIR-SDC-FormManager".to_string())
            }
            TestscriptProfileDestinationTypes::FHIRSDCFormProcessor(_) => {
                Some("FHIR-SDC-FormProcessor".to_string())
            }
            TestscriptProfileDestinationTypes::FHIRSDCFormReceiver(_) => {
                Some("FHIR-SDC-FormReceiver".to_string())
            }
            TestscriptProfileDestinationTypes::FHIRServer(_) => Some("FHIR-Server".to_string()),
            TestscriptProfileDestinationTypes::Null(_) => None,
        }
    }
}
impl MetaValue for TestscriptProfileDestinationTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TestscriptProfileDestinationTypes::FHIRSDCFormManager(Some(e)) => {
                    e.get_field(field)
                }
                TestscriptProfileDestinationTypes::FHIRSDCFormProcessor(Some(e)) => {
                    e.get_field(field)
                }
                TestscriptProfileDestinationTypes::FHIRSDCFormReceiver(Some(e)) => {
                    e.get_field(field)
                }
                TestscriptProfileDestinationTypes::FHIRServer(Some(e)) => e.get_field(field),
                TestscriptProfileDestinationTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TestscriptProfileDestinationTypes::FHIRSDCFormManager(Some(e)) => {
                    e.get_field_mut(field)
                }
                TestscriptProfileDestinationTypes::FHIRSDCFormProcessor(Some(e)) => {
                    e.get_field_mut(field)
                }
                TestscriptProfileDestinationTypes::FHIRSDCFormReceiver(Some(e)) => {
                    e.get_field_mut(field)
                }
                TestscriptProfileDestinationTypes::FHIRServer(Some(e)) => e.get_field_mut(field),
                TestscriptProfileDestinationTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TestscriptProfileOriginTypes {
    #[doc = "FHIR Client"]
    #[code = "FHIR-Client"]
    FHIRClient(Option<Element>),
    #[doc = "FHIR SDC FormFiller"]
    #[code = "FHIR-SDC-FormFiller"]
    FHIRSDCFormFiller(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TestscriptProfileOriginTypes {
    fn default() -> Self {
        TestscriptProfileOriginTypes::Null(None)
    }
}
impl TryFrom<String> for TestscriptProfileOriginTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "FHIR-Client" => Ok(TestscriptProfileOriginTypes::FHIRClient(None)),
            "FHIR-SDC-FormFiller" => Ok(TestscriptProfileOriginTypes::FHIRSDCFormFiller(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TestscriptProfileOriginTypes {
    fn into(self) -> Option<String> {
        match self {
            TestscriptProfileOriginTypes::FHIRClient(_) => Some("FHIR-Client".to_string()),
            TestscriptProfileOriginTypes::FHIRSDCFormFiller(_) => {
                Some("FHIR-SDC-FormFiller".to_string())
            }
            TestscriptProfileOriginTypes::Null(_) => None,
        }
    }
}
impl MetaValue for TestscriptProfileOriginTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TestscriptProfileOriginTypes::FHIRClient(Some(e)) => e.get_field(field),
                TestscriptProfileOriginTypes::FHIRSDCFormFiller(Some(e)) => e.get_field(field),
                TestscriptProfileOriginTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TestscriptProfileOriginTypes::FHIRClient(Some(e)) => e.get_field_mut(field),
                TestscriptProfileOriginTypes::FHIRSDCFormFiller(Some(e)) => e.get_field_mut(field),
                TestscriptProfileOriginTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TextureCode {
    #[doc = "Chopped food"]
    #[code = "228049004"]
    V228049004(Option<Element>),
    #[doc = "Cut-up food"]
    #[code = "228053002"]
    V228053002(Option<Element>),
    #[doc = "Liquidized food"]
    #[code = "228055009"]
    V228055009(Option<Element>),
    #[doc = "Lumpy food"]
    #[code = "228056005"]
    V228056005(Option<Element>),
    #[doc = "Semi-solid food"]
    #[code = "228057001"]
    V228057001(Option<Element>),
    #[doc = "Single texture food"]
    #[code = "228058006"]
    V228058006(Option<Element>),
    #[doc = "Soft food"]
    #[code = "228059003"]
    V228059003(Option<Element>),
    #[doc = "Solid food"]
    #[code = "228060008"]
    V228060008(Option<Element>),
    #[doc = "Easy to chew food"]
    #[code = "439091000124107"]
    V439091000124107(Option<Element>),
    #[doc = "Mashed food"]
    #[code = "441751000124100"]
    V441751000124100(Option<Element>),
    #[doc = "Minced food"]
    #[code = "441761000124103"]
    V441761000124103(Option<Element>),
    #[doc = "Moist food"]
    #[code = "441771000124105"]
    V441771000124105(Option<Element>),
    #[doc = "Strained food"]
    #[code = "441791000124106"]
    V441791000124106(Option<Element>),
    #[doc = "Ground food"]
    #[code = "441881000124103"]
    V441881000124103(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TextureCode {
    fn default() -> Self {
        TextureCode::Null(None)
    }
}
impl TryFrom<String> for TextureCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "228049004" => Ok(TextureCode::V228049004(None)),
            "228053002" => Ok(TextureCode::V228053002(None)),
            "228055009" => Ok(TextureCode::V228055009(None)),
            "228056005" => Ok(TextureCode::V228056005(None)),
            "228057001" => Ok(TextureCode::V228057001(None)),
            "228058006" => Ok(TextureCode::V228058006(None)),
            "228059003" => Ok(TextureCode::V228059003(None)),
            "228060008" => Ok(TextureCode::V228060008(None)),
            "439091000124107" => Ok(TextureCode::V439091000124107(None)),
            "441751000124100" => Ok(TextureCode::V441751000124100(None)),
            "441761000124103" => Ok(TextureCode::V441761000124103(None)),
            "441771000124105" => Ok(TextureCode::V441771000124105(None)),
            "441791000124106" => Ok(TextureCode::V441791000124106(None)),
            "441881000124103" => Ok(TextureCode::V441881000124103(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TextureCode {
    fn into(self) -> Option<String> {
        match self {
            TextureCode::V228049004(_) => Some("228049004".to_string()),
            TextureCode::V228053002(_) => Some("228053002".to_string()),
            TextureCode::V228055009(_) => Some("228055009".to_string()),
            TextureCode::V228056005(_) => Some("228056005".to_string()),
            TextureCode::V228057001(_) => Some("228057001".to_string()),
            TextureCode::V228058006(_) => Some("228058006".to_string()),
            TextureCode::V228059003(_) => Some("228059003".to_string()),
            TextureCode::V228060008(_) => Some("228060008".to_string()),
            TextureCode::V439091000124107(_) => Some("439091000124107".to_string()),
            TextureCode::V441751000124100(_) => Some("441751000124100".to_string()),
            TextureCode::V441761000124103(_) => Some("441761000124103".to_string()),
            TextureCode::V441771000124105(_) => Some("441771000124105".to_string()),
            TextureCode::V441791000124106(_) => Some("441791000124106".to_string()),
            TextureCode::V441881000124103(_) => Some("441881000124103".to_string()),
            TextureCode::Null(_) => None,
        }
    }
}
impl MetaValue for TextureCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TextureCode::V228049004(Some(e)) => e.get_field(field),
                TextureCode::V228053002(Some(e)) => e.get_field(field),
                TextureCode::V228055009(Some(e)) => e.get_field(field),
                TextureCode::V228056005(Some(e)) => e.get_field(field),
                TextureCode::V228057001(Some(e)) => e.get_field(field),
                TextureCode::V228058006(Some(e)) => e.get_field(field),
                TextureCode::V228059003(Some(e)) => e.get_field(field),
                TextureCode::V228060008(Some(e)) => e.get_field(field),
                TextureCode::V439091000124107(Some(e)) => e.get_field(field),
                TextureCode::V441751000124100(Some(e)) => e.get_field(field),
                TextureCode::V441761000124103(Some(e)) => e.get_field(field),
                TextureCode::V441771000124105(Some(e)) => e.get_field(field),
                TextureCode::V441791000124106(Some(e)) => e.get_field(field),
                TextureCode::V441881000124103(Some(e)) => e.get_field(field),
                TextureCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TextureCode::V228049004(Some(e)) => e.get_field_mut(field),
                TextureCode::V228053002(Some(e)) => e.get_field_mut(field),
                TextureCode::V228055009(Some(e)) => e.get_field_mut(field),
                TextureCode::V228056005(Some(e)) => e.get_field_mut(field),
                TextureCode::V228057001(Some(e)) => e.get_field_mut(field),
                TextureCode::V228058006(Some(e)) => e.get_field_mut(field),
                TextureCode::V228059003(Some(e)) => e.get_field_mut(field),
                TextureCode::V228060008(Some(e)) => e.get_field_mut(field),
                TextureCode::V439091000124107(Some(e)) => e.get_field_mut(field),
                TextureCode::V441751000124100(Some(e)) => e.get_field_mut(field),
                TextureCode::V441761000124103(Some(e)) => e.get_field_mut(field),
                TextureCode::V441771000124105(Some(e)) => e.get_field_mut(field),
                TextureCode::V441791000124106(Some(e)) => e.get_field_mut(field),
                TextureCode::V441881000124103(Some(e)) => e.get_field_mut(field),
                TextureCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TimingAbbreviation {
    #[doc = "AM"]
    #[code = "AM"]
    AM(Option<Element>),
    #[doc = "at bedtime"]
    #[code = "BED"]
    BED(Option<Element>),
    #[doc = "BID"]
    #[code = "BID"]
    BID(Option<Element>),
    #[doc = "monthly"]
    #[code = "MO"]
    MO(Option<Element>),
    #[doc = "PM"]
    #[code = "PM"]
    PM(Option<Element>),
    #[doc = "every hour"]
    #[code = "Q1H"]
    Q1H(Option<Element>),
    #[doc = "every 2 hours"]
    #[code = "Q2H"]
    Q2H(Option<Element>),
    #[doc = "every 3 hours"]
    #[code = "Q3H"]
    Q3H(Option<Element>),
    #[doc = "Q4H"]
    #[code = "Q4H"]
    Q4H(Option<Element>),
    #[doc = "Q6H"]
    #[code = "Q6H"]
    Q6H(Option<Element>),
    #[doc = "every 8 hours"]
    #[code = "Q8H"]
    Q8H(Option<Element>),
    #[doc = "QD"]
    #[code = "QD"]
    QD(Option<Element>),
    #[doc = "QID"]
    #[code = "QID"]
    QID(Option<Element>),
    #[doc = "QOD"]
    #[code = "QOD"]
    QOD(Option<Element>),
    #[doc = "TID"]
    #[code = "TID"]
    TID(Option<Element>),
    #[doc = "weekly"]
    #[code = "WK"]
    WK(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TimingAbbreviation {
    fn default() -> Self {
        TimingAbbreviation::Null(None)
    }
}
impl TryFrom<String> for TimingAbbreviation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AM" => Ok(TimingAbbreviation::AM(None)),
            "BED" => Ok(TimingAbbreviation::BED(None)),
            "BID" => Ok(TimingAbbreviation::BID(None)),
            "MO" => Ok(TimingAbbreviation::MO(None)),
            "PM" => Ok(TimingAbbreviation::PM(None)),
            "Q1H" => Ok(TimingAbbreviation::Q1H(None)),
            "Q2H" => Ok(TimingAbbreviation::Q2H(None)),
            "Q3H" => Ok(TimingAbbreviation::Q3H(None)),
            "Q4H" => Ok(TimingAbbreviation::Q4H(None)),
            "Q6H" => Ok(TimingAbbreviation::Q6H(None)),
            "Q8H" => Ok(TimingAbbreviation::Q8H(None)),
            "QD" => Ok(TimingAbbreviation::QD(None)),
            "QID" => Ok(TimingAbbreviation::QID(None)),
            "QOD" => Ok(TimingAbbreviation::QOD(None)),
            "TID" => Ok(TimingAbbreviation::TID(None)),
            "WK" => Ok(TimingAbbreviation::WK(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TimingAbbreviation {
    fn into(self) -> Option<String> {
        match self {
            TimingAbbreviation::AM(_) => Some("AM".to_string()),
            TimingAbbreviation::BED(_) => Some("BED".to_string()),
            TimingAbbreviation::BID(_) => Some("BID".to_string()),
            TimingAbbreviation::MO(_) => Some("MO".to_string()),
            TimingAbbreviation::PM(_) => Some("PM".to_string()),
            TimingAbbreviation::Q1H(_) => Some("Q1H".to_string()),
            TimingAbbreviation::Q2H(_) => Some("Q2H".to_string()),
            TimingAbbreviation::Q3H(_) => Some("Q3H".to_string()),
            TimingAbbreviation::Q4H(_) => Some("Q4H".to_string()),
            TimingAbbreviation::Q6H(_) => Some("Q6H".to_string()),
            TimingAbbreviation::Q8H(_) => Some("Q8H".to_string()),
            TimingAbbreviation::QD(_) => Some("QD".to_string()),
            TimingAbbreviation::QID(_) => Some("QID".to_string()),
            TimingAbbreviation::QOD(_) => Some("QOD".to_string()),
            TimingAbbreviation::TID(_) => Some("TID".to_string()),
            TimingAbbreviation::WK(_) => Some("WK".to_string()),
            TimingAbbreviation::Null(_) => None,
        }
    }
}
impl MetaValue for TimingAbbreviation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TimingAbbreviation::AM(Some(e)) => e.get_field(field),
                TimingAbbreviation::BED(Some(e)) => e.get_field(field),
                TimingAbbreviation::BID(Some(e)) => e.get_field(field),
                TimingAbbreviation::MO(Some(e)) => e.get_field(field),
                TimingAbbreviation::PM(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q1H(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q2H(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q3H(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q4H(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q6H(Some(e)) => e.get_field(field),
                TimingAbbreviation::Q8H(Some(e)) => e.get_field(field),
                TimingAbbreviation::QD(Some(e)) => e.get_field(field),
                TimingAbbreviation::QID(Some(e)) => e.get_field(field),
                TimingAbbreviation::QOD(Some(e)) => e.get_field(field),
                TimingAbbreviation::TID(Some(e)) => e.get_field(field),
                TimingAbbreviation::WK(Some(e)) => e.get_field(field),
                TimingAbbreviation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TimingAbbreviation::AM(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::BED(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::BID(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::MO(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::PM(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q1H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q2H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q3H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q4H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q6H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Q8H(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::QD(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::QID(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::QOD(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::TID(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::WK(Some(e)) => e.get_field_mut(field),
                TimingAbbreviation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Tooth {
    #[doc = "Oral cavity"]
    #[code = "0"]
    V0(Option<Element>),
    #[doc = "1"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "11"]
    #[code = "11"]
    V11(Option<Element>),
    #[doc = "12"]
    #[code = "12"]
    V12(Option<Element>),
    #[doc = "13"]
    #[code = "13"]
    V13(Option<Element>),
    #[doc = "14"]
    #[code = "14"]
    V14(Option<Element>),
    #[doc = "15"]
    #[code = "15"]
    V15(Option<Element>),
    #[doc = "16"]
    #[code = "16"]
    V16(Option<Element>),
    #[doc = "17"]
    #[code = "17"]
    V17(Option<Element>),
    #[doc = "18"]
    #[code = "18"]
    V18(Option<Element>),
    #[doc = "2"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "21"]
    #[code = "21"]
    V21(Option<Element>),
    #[doc = "22"]
    #[code = "22"]
    V22(Option<Element>),
    #[doc = "23"]
    #[code = "23"]
    V23(Option<Element>),
    #[doc = "24"]
    #[code = "24"]
    V24(Option<Element>),
    #[doc = "25"]
    #[code = "25"]
    V25(Option<Element>),
    #[doc = "26"]
    #[code = "26"]
    V26(Option<Element>),
    #[doc = "27"]
    #[code = "27"]
    V27(Option<Element>),
    #[doc = "28"]
    #[code = "28"]
    V28(Option<Element>),
    #[doc = "3"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "31"]
    #[code = "31"]
    V31(Option<Element>),
    #[doc = "32"]
    #[code = "32"]
    V32(Option<Element>),
    #[doc = "33"]
    #[code = "33"]
    V33(Option<Element>),
    #[doc = "34"]
    #[code = "34"]
    V34(Option<Element>),
    #[doc = "35"]
    #[code = "35"]
    V35(Option<Element>),
    #[doc = "36"]
    #[code = "36"]
    V36(Option<Element>),
    #[doc = "37"]
    #[code = "37"]
    V37(Option<Element>),
    #[doc = "38"]
    #[code = "38"]
    V38(Option<Element>),
    #[doc = "4"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "41"]
    #[code = "41"]
    V41(Option<Element>),
    #[doc = "42"]
    #[code = "42"]
    V42(Option<Element>),
    #[doc = "43"]
    #[code = "43"]
    V43(Option<Element>),
    #[doc = "44"]
    #[code = "44"]
    V44(Option<Element>),
    #[doc = "45"]
    #[code = "45"]
    V45(Option<Element>),
    #[doc = "46"]
    #[code = "46"]
    V46(Option<Element>),
    #[doc = "47"]
    #[code = "47"]
    V47(Option<Element>),
    #[doc = "48"]
    #[code = "48"]
    V48(Option<Element>),
    #[doc = "5"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "6"]
    #[code = "6"]
    V6(Option<Element>),
    #[doc = "7"]
    #[code = "7"]
    V7(Option<Element>),
    #[doc = "8"]
    #[code = "8"]
    V8(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Tooth {
    fn default() -> Self {
        Tooth::Null(None)
    }
}
impl TryFrom<String> for Tooth {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "0" => Ok(Tooth::V0(None)),
            "1" => Ok(Tooth::V1(None)),
            "11" => Ok(Tooth::V11(None)),
            "12" => Ok(Tooth::V12(None)),
            "13" => Ok(Tooth::V13(None)),
            "14" => Ok(Tooth::V14(None)),
            "15" => Ok(Tooth::V15(None)),
            "16" => Ok(Tooth::V16(None)),
            "17" => Ok(Tooth::V17(None)),
            "18" => Ok(Tooth::V18(None)),
            "2" => Ok(Tooth::V2(None)),
            "21" => Ok(Tooth::V21(None)),
            "22" => Ok(Tooth::V22(None)),
            "23" => Ok(Tooth::V23(None)),
            "24" => Ok(Tooth::V24(None)),
            "25" => Ok(Tooth::V25(None)),
            "26" => Ok(Tooth::V26(None)),
            "27" => Ok(Tooth::V27(None)),
            "28" => Ok(Tooth::V28(None)),
            "3" => Ok(Tooth::V3(None)),
            "31" => Ok(Tooth::V31(None)),
            "32" => Ok(Tooth::V32(None)),
            "33" => Ok(Tooth::V33(None)),
            "34" => Ok(Tooth::V34(None)),
            "35" => Ok(Tooth::V35(None)),
            "36" => Ok(Tooth::V36(None)),
            "37" => Ok(Tooth::V37(None)),
            "38" => Ok(Tooth::V38(None)),
            "4" => Ok(Tooth::V4(None)),
            "41" => Ok(Tooth::V41(None)),
            "42" => Ok(Tooth::V42(None)),
            "43" => Ok(Tooth::V43(None)),
            "44" => Ok(Tooth::V44(None)),
            "45" => Ok(Tooth::V45(None)),
            "46" => Ok(Tooth::V46(None)),
            "47" => Ok(Tooth::V47(None)),
            "48" => Ok(Tooth::V48(None)),
            "5" => Ok(Tooth::V5(None)),
            "6" => Ok(Tooth::V6(None)),
            "7" => Ok(Tooth::V7(None)),
            "8" => Ok(Tooth::V8(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Tooth {
    fn into(self) -> Option<String> {
        match self {
            Tooth::V0(_) => Some("0".to_string()),
            Tooth::V1(_) => Some("1".to_string()),
            Tooth::V11(_) => Some("11".to_string()),
            Tooth::V12(_) => Some("12".to_string()),
            Tooth::V13(_) => Some("13".to_string()),
            Tooth::V14(_) => Some("14".to_string()),
            Tooth::V15(_) => Some("15".to_string()),
            Tooth::V16(_) => Some("16".to_string()),
            Tooth::V17(_) => Some("17".to_string()),
            Tooth::V18(_) => Some("18".to_string()),
            Tooth::V2(_) => Some("2".to_string()),
            Tooth::V21(_) => Some("21".to_string()),
            Tooth::V22(_) => Some("22".to_string()),
            Tooth::V23(_) => Some("23".to_string()),
            Tooth::V24(_) => Some("24".to_string()),
            Tooth::V25(_) => Some("25".to_string()),
            Tooth::V26(_) => Some("26".to_string()),
            Tooth::V27(_) => Some("27".to_string()),
            Tooth::V28(_) => Some("28".to_string()),
            Tooth::V3(_) => Some("3".to_string()),
            Tooth::V31(_) => Some("31".to_string()),
            Tooth::V32(_) => Some("32".to_string()),
            Tooth::V33(_) => Some("33".to_string()),
            Tooth::V34(_) => Some("34".to_string()),
            Tooth::V35(_) => Some("35".to_string()),
            Tooth::V36(_) => Some("36".to_string()),
            Tooth::V37(_) => Some("37".to_string()),
            Tooth::V38(_) => Some("38".to_string()),
            Tooth::V4(_) => Some("4".to_string()),
            Tooth::V41(_) => Some("41".to_string()),
            Tooth::V42(_) => Some("42".to_string()),
            Tooth::V43(_) => Some("43".to_string()),
            Tooth::V44(_) => Some("44".to_string()),
            Tooth::V45(_) => Some("45".to_string()),
            Tooth::V46(_) => Some("46".to_string()),
            Tooth::V47(_) => Some("47".to_string()),
            Tooth::V48(_) => Some("48".to_string()),
            Tooth::V5(_) => Some("5".to_string()),
            Tooth::V6(_) => Some("6".to_string()),
            Tooth::V7(_) => Some("7".to_string()),
            Tooth::V8(_) => Some("8".to_string()),
            Tooth::Null(_) => None,
        }
    }
}
impl MetaValue for Tooth {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Tooth::V0(Some(e)) => e.get_field(field),
                Tooth::V1(Some(e)) => e.get_field(field),
                Tooth::V11(Some(e)) => e.get_field(field),
                Tooth::V12(Some(e)) => e.get_field(field),
                Tooth::V13(Some(e)) => e.get_field(field),
                Tooth::V14(Some(e)) => e.get_field(field),
                Tooth::V15(Some(e)) => e.get_field(field),
                Tooth::V16(Some(e)) => e.get_field(field),
                Tooth::V17(Some(e)) => e.get_field(field),
                Tooth::V18(Some(e)) => e.get_field(field),
                Tooth::V2(Some(e)) => e.get_field(field),
                Tooth::V21(Some(e)) => e.get_field(field),
                Tooth::V22(Some(e)) => e.get_field(field),
                Tooth::V23(Some(e)) => e.get_field(field),
                Tooth::V24(Some(e)) => e.get_field(field),
                Tooth::V25(Some(e)) => e.get_field(field),
                Tooth::V26(Some(e)) => e.get_field(field),
                Tooth::V27(Some(e)) => e.get_field(field),
                Tooth::V28(Some(e)) => e.get_field(field),
                Tooth::V3(Some(e)) => e.get_field(field),
                Tooth::V31(Some(e)) => e.get_field(field),
                Tooth::V32(Some(e)) => e.get_field(field),
                Tooth::V33(Some(e)) => e.get_field(field),
                Tooth::V34(Some(e)) => e.get_field(field),
                Tooth::V35(Some(e)) => e.get_field(field),
                Tooth::V36(Some(e)) => e.get_field(field),
                Tooth::V37(Some(e)) => e.get_field(field),
                Tooth::V38(Some(e)) => e.get_field(field),
                Tooth::V4(Some(e)) => e.get_field(field),
                Tooth::V41(Some(e)) => e.get_field(field),
                Tooth::V42(Some(e)) => e.get_field(field),
                Tooth::V43(Some(e)) => e.get_field(field),
                Tooth::V44(Some(e)) => e.get_field(field),
                Tooth::V45(Some(e)) => e.get_field(field),
                Tooth::V46(Some(e)) => e.get_field(field),
                Tooth::V47(Some(e)) => e.get_field(field),
                Tooth::V48(Some(e)) => e.get_field(field),
                Tooth::V5(Some(e)) => e.get_field(field),
                Tooth::V6(Some(e)) => e.get_field(field),
                Tooth::V7(Some(e)) => e.get_field(field),
                Tooth::V8(Some(e)) => e.get_field(field),
                Tooth::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Tooth::V0(Some(e)) => e.get_field_mut(field),
                Tooth::V1(Some(e)) => e.get_field_mut(field),
                Tooth::V11(Some(e)) => e.get_field_mut(field),
                Tooth::V12(Some(e)) => e.get_field_mut(field),
                Tooth::V13(Some(e)) => e.get_field_mut(field),
                Tooth::V14(Some(e)) => e.get_field_mut(field),
                Tooth::V15(Some(e)) => e.get_field_mut(field),
                Tooth::V16(Some(e)) => e.get_field_mut(field),
                Tooth::V17(Some(e)) => e.get_field_mut(field),
                Tooth::V18(Some(e)) => e.get_field_mut(field),
                Tooth::V2(Some(e)) => e.get_field_mut(field),
                Tooth::V21(Some(e)) => e.get_field_mut(field),
                Tooth::V22(Some(e)) => e.get_field_mut(field),
                Tooth::V23(Some(e)) => e.get_field_mut(field),
                Tooth::V24(Some(e)) => e.get_field_mut(field),
                Tooth::V25(Some(e)) => e.get_field_mut(field),
                Tooth::V26(Some(e)) => e.get_field_mut(field),
                Tooth::V27(Some(e)) => e.get_field_mut(field),
                Tooth::V28(Some(e)) => e.get_field_mut(field),
                Tooth::V3(Some(e)) => e.get_field_mut(field),
                Tooth::V31(Some(e)) => e.get_field_mut(field),
                Tooth::V32(Some(e)) => e.get_field_mut(field),
                Tooth::V33(Some(e)) => e.get_field_mut(field),
                Tooth::V34(Some(e)) => e.get_field_mut(field),
                Tooth::V35(Some(e)) => e.get_field_mut(field),
                Tooth::V36(Some(e)) => e.get_field_mut(field),
                Tooth::V37(Some(e)) => e.get_field_mut(field),
                Tooth::V38(Some(e)) => e.get_field_mut(field),
                Tooth::V4(Some(e)) => e.get_field_mut(field),
                Tooth::V41(Some(e)) => e.get_field_mut(field),
                Tooth::V42(Some(e)) => e.get_field_mut(field),
                Tooth::V43(Some(e)) => e.get_field_mut(field),
                Tooth::V44(Some(e)) => e.get_field_mut(field),
                Tooth::V45(Some(e)) => e.get_field_mut(field),
                Tooth::V46(Some(e)) => e.get_field_mut(field),
                Tooth::V47(Some(e)) => e.get_field_mut(field),
                Tooth::V48(Some(e)) => e.get_field_mut(field),
                Tooth::V5(Some(e)) => e.get_field_mut(field),
                Tooth::V6(Some(e)) => e.get_field_mut(field),
                Tooth::V7(Some(e)) => e.get_field_mut(field),
                Tooth::V8(Some(e)) => e.get_field_mut(field),
                Tooth::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TransactionMode {
    #[doc = "Batches supported"]
    #[code = "batch"]
    Batch(Option<Element>),
    #[doc = "Batches & Transactions"]
    #[code = "both"]
    Both(Option<Element>),
    #[doc = "None"]
    #[code = "not-supported"]
    NotSupported(Option<Element>),
    #[doc = "Transactions Supported"]
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TransactionMode {
    fn default() -> Self {
        TransactionMode::Null(None)
    }
}
impl TryFrom<String> for TransactionMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "batch" => Ok(TransactionMode::Batch(None)),
            "both" => Ok(TransactionMode::Both(None)),
            "not-supported" => Ok(TransactionMode::NotSupported(None)),
            "transaction" => Ok(TransactionMode::Transaction(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TransactionMode {
    fn into(self) -> Option<String> {
        match self {
            TransactionMode::Batch(_) => Some("batch".to_string()),
            TransactionMode::Both(_) => Some("both".to_string()),
            TransactionMode::NotSupported(_) => Some("not-supported".to_string()),
            TransactionMode::Transaction(_) => Some("transaction".to_string()),
            TransactionMode::Null(_) => None,
        }
    }
}
impl MetaValue for TransactionMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TransactionMode::Batch(Some(e)) => e.get_field(field),
                TransactionMode::Both(Some(e)) => e.get_field(field),
                TransactionMode::NotSupported(Some(e)) => e.get_field(field),
                TransactionMode::Transaction(Some(e)) => e.get_field(field),
                TransactionMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TransactionMode::Batch(Some(e)) => e.get_field_mut(field),
                TransactionMode::Both(Some(e)) => e.get_field_mut(field),
                TransactionMode::NotSupported(Some(e)) => e.get_field_mut(field),
                TransactionMode::Transaction(Some(e)) => e.get_field_mut(field),
                TransactionMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TriggerType {
    #[doc = "Data Access Ended"]
    #[code = "data-access-ended"]
    DataAccessEnded(Option<Element>),
    #[doc = "Data Accessed"]
    #[code = "data-accessed"]
    DataAccessed(Option<Element>),
    #[doc = "Data Added"]
    #[code = "data-added"]
    DataAdded(Option<Element>),
    #[doc = "Data Changed"]
    #[code = "data-changed"]
    DataChanged(Option<Element>),
    #[doc = "Data Updated"]
    #[code = "data-modified"]
    DataModified(Option<Element>),
    #[doc = "Data Removed"]
    #[code = "data-removed"]
    DataRemoved(Option<Element>),
    #[doc = "Named Event"]
    #[code = "named-event"]
    NamedEvent(Option<Element>),
    #[doc = "Periodic"]
    #[code = "periodic"]
    Periodic(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TriggerType {
    fn default() -> Self {
        TriggerType::Null(None)
    }
}
impl TryFrom<String> for TriggerType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "data-access-ended" => Ok(TriggerType::DataAccessEnded(None)),
            "data-accessed" => Ok(TriggerType::DataAccessed(None)),
            "data-added" => Ok(TriggerType::DataAdded(None)),
            "data-changed" => Ok(TriggerType::DataChanged(None)),
            "data-modified" => Ok(TriggerType::DataModified(None)),
            "data-removed" => Ok(TriggerType::DataRemoved(None)),
            "named-event" => Ok(TriggerType::NamedEvent(None)),
            "periodic" => Ok(TriggerType::Periodic(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TriggerType {
    fn into(self) -> Option<String> {
        match self {
            TriggerType::DataAccessEnded(_) => Some("data-access-ended".to_string()),
            TriggerType::DataAccessed(_) => Some("data-accessed".to_string()),
            TriggerType::DataAdded(_) => Some("data-added".to_string()),
            TriggerType::DataChanged(_) => Some("data-changed".to_string()),
            TriggerType::DataModified(_) => Some("data-modified".to_string()),
            TriggerType::DataRemoved(_) => Some("data-removed".to_string()),
            TriggerType::NamedEvent(_) => Some("named-event".to_string()),
            TriggerType::Periodic(_) => Some("periodic".to_string()),
            TriggerType::Null(_) => None,
        }
    }
}
impl MetaValue for TriggerType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TriggerType::DataAccessEnded(Some(e)) => e.get_field(field),
                TriggerType::DataAccessed(Some(e)) => e.get_field(field),
                TriggerType::DataAdded(Some(e)) => e.get_field(field),
                TriggerType::DataChanged(Some(e)) => e.get_field(field),
                TriggerType::DataModified(Some(e)) => e.get_field(field),
                TriggerType::DataRemoved(Some(e)) => e.get_field(field),
                TriggerType::NamedEvent(Some(e)) => e.get_field(field),
                TriggerType::Periodic(Some(e)) => e.get_field(field),
                TriggerType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TriggerType::DataAccessEnded(Some(e)) => e.get_field_mut(field),
                TriggerType::DataAccessed(Some(e)) => e.get_field_mut(field),
                TriggerType::DataAdded(Some(e)) => e.get_field_mut(field),
                TriggerType::DataChanged(Some(e)) => e.get_field_mut(field),
                TriggerType::DataModified(Some(e)) => e.get_field_mut(field),
                TriggerType::DataRemoved(Some(e)) => e.get_field_mut(field),
                TriggerType::NamedEvent(Some(e)) => e.get_field_mut(field),
                TriggerType::Periodic(Some(e)) => e.get_field_mut(field),
                TriggerType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TypeDerivationRule {
    #[doc = "Constraint"]
    #[code = "constraint"]
    Constraint(Option<Element>),
    #[doc = "Specialization"]
    #[code = "specialization"]
    Specialization(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TypeDerivationRule {
    fn default() -> Self {
        TypeDerivationRule::Null(None)
    }
}
impl TryFrom<String> for TypeDerivationRule {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "constraint" => Ok(TypeDerivationRule::Constraint(None)),
            "specialization" => Ok(TypeDerivationRule::Specialization(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TypeDerivationRule {
    fn into(self) -> Option<String> {
        match self {
            TypeDerivationRule::Constraint(_) => Some("constraint".to_string()),
            TypeDerivationRule::Specialization(_) => Some("specialization".to_string()),
            TypeDerivationRule::Null(_) => None,
        }
    }
}
impl MetaValue for TypeDerivationRule {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TypeDerivationRule::Constraint(Some(e)) => e.get_field(field),
                TypeDerivationRule::Specialization(Some(e)) => e.get_field(field),
                TypeDerivationRule::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TypeDerivationRule::Constraint(Some(e)) => e.get_field_mut(field),
                TypeDerivationRule::Specialization(Some(e)) => e.get_field_mut(field),
                TypeDerivationRule::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum TypeRestfulInteraction {
    #[code = "create"]
    Create(Option<Element>),
    #[code = "delete"]
    Delete(Option<Element>),
    #[code = "history-instance"]
    HistoryInstance(Option<Element>),
    #[code = "history-type"]
    HistoryType(Option<Element>),
    #[code = "patch"]
    Patch(Option<Element>),
    #[code = "read"]
    Read(Option<Element>),
    #[code = "search-type"]
    SearchType(Option<Element>),
    #[code = "update"]
    Update(Option<Element>),
    #[code = "vread"]
    Vread(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for TypeRestfulInteraction {
    fn default() -> Self {
        TypeRestfulInteraction::Null(None)
    }
}
impl TryFrom<String> for TypeRestfulInteraction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "create" => Ok(TypeRestfulInteraction::Create(None)),
            "delete" => Ok(TypeRestfulInteraction::Delete(None)),
            "history-instance" => Ok(TypeRestfulInteraction::HistoryInstance(None)),
            "history-type" => Ok(TypeRestfulInteraction::HistoryType(None)),
            "patch" => Ok(TypeRestfulInteraction::Patch(None)),
            "read" => Ok(TypeRestfulInteraction::Read(None)),
            "search-type" => Ok(TypeRestfulInteraction::SearchType(None)),
            "update" => Ok(TypeRestfulInteraction::Update(None)),
            "vread" => Ok(TypeRestfulInteraction::Vread(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &TypeRestfulInteraction {
    fn into(self) -> Option<String> {
        match self {
            TypeRestfulInteraction::Create(_) => Some("create".to_string()),
            TypeRestfulInteraction::Delete(_) => Some("delete".to_string()),
            TypeRestfulInteraction::HistoryInstance(_) => Some("history-instance".to_string()),
            TypeRestfulInteraction::HistoryType(_) => Some("history-type".to_string()),
            TypeRestfulInteraction::Patch(_) => Some("patch".to_string()),
            TypeRestfulInteraction::Read(_) => Some("read".to_string()),
            TypeRestfulInteraction::SearchType(_) => Some("search-type".to_string()),
            TypeRestfulInteraction::Update(_) => Some("update".to_string()),
            TypeRestfulInteraction::Vread(_) => Some("vread".to_string()),
            TypeRestfulInteraction::Null(_) => None,
        }
    }
}
impl MetaValue for TypeRestfulInteraction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                TypeRestfulInteraction::Create(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Delete(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::HistoryInstance(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::HistoryType(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Patch(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Read(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::SearchType(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Update(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Vread(Some(e)) => e.get_field(field),
                TypeRestfulInteraction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                TypeRestfulInteraction::Create(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Delete(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::HistoryInstance(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::HistoryType(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Patch(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Read(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::SearchType(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Update(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Vread(Some(e)) => e.get_field_mut(field),
                TypeRestfulInteraction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UcumBodylength {
    #[code = "[in_i]"]
    LeftSquareBracketin_iRightSquareBracket(Option<Element>),
    #[code = "cm"]
    Cm(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UcumBodylength {
    fn default() -> Self {
        UcumBodylength::Null(None)
    }
}
impl TryFrom<String> for UcumBodylength {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "[in_i]" => Ok(UcumBodylength::LeftSquareBracketin_iRightSquareBracket(
                None,
            )),
            "cm" => Ok(UcumBodylength::Cm(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UcumBodylength {
    fn into(self) -> Option<String> {
        match self {
            UcumBodylength::LeftSquareBracketin_iRightSquareBracket(_) => {
                Some("[in_i]".to_string())
            }
            UcumBodylength::Cm(_) => Some("cm".to_string()),
            UcumBodylength::Null(_) => None,
        }
    }
}
impl MetaValue for UcumBodylength {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UcumBodylength::LeftSquareBracketin_iRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumBodylength::Cm(Some(e)) => e.get_field(field),
                UcumBodylength::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UcumBodylength::LeftSquareBracketin_iRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumBodylength::Cm(Some(e)) => e.get_field_mut(field),
                UcumBodylength::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UcumBodytemp {
    #[code = "Cel"]
    Cel(Option<Element>),
    #[code = "[degF]"]
    LeftSquareBracketdegFRightSquareBracket(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UcumBodytemp {
    fn default() -> Self {
        UcumBodytemp::Null(None)
    }
}
impl TryFrom<String> for UcumBodytemp {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Cel" => Ok(UcumBodytemp::Cel(None)),
            "[degF]" => Ok(UcumBodytemp::LeftSquareBracketdegFRightSquareBracket(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UcumBodytemp {
    fn into(self) -> Option<String> {
        match self {
            UcumBodytemp::Cel(_) => Some("Cel".to_string()),
            UcumBodytemp::LeftSquareBracketdegFRightSquareBracket(_) => Some("[degF]".to_string()),
            UcumBodytemp::Null(_) => None,
        }
    }
}
impl MetaValue for UcumBodytemp {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UcumBodytemp::Cel(Some(e)) => e.get_field(field),
                UcumBodytemp::LeftSquareBracketdegFRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumBodytemp::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UcumBodytemp::Cel(Some(e)) => e.get_field_mut(field),
                UcumBodytemp::LeftSquareBracketdegFRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumBodytemp::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UcumBodyweight {
    #[code = "[lb_av]"]
    LeftSquareBracketlb_avRightSquareBracket(Option<Element>),
    #[code = "g"]
    G(Option<Element>),
    #[code = "kg"]
    Kg(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UcumBodyweight {
    fn default() -> Self {
        UcumBodyweight::Null(None)
    }
}
impl TryFrom<String> for UcumBodyweight {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "[lb_av]" => Ok(UcumBodyweight::LeftSquareBracketlb_avRightSquareBracket(
                None,
            )),
            "g" => Ok(UcumBodyweight::G(None)),
            "kg" => Ok(UcumBodyweight::Kg(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UcumBodyweight {
    fn into(self) -> Option<String> {
        match self {
            UcumBodyweight::LeftSquareBracketlb_avRightSquareBracket(_) => {
                Some("[lb_av]".to_string())
            }
            UcumBodyweight::G(_) => Some("g".to_string()),
            UcumBodyweight::Kg(_) => Some("kg".to_string()),
            UcumBodyweight::Null(_) => None,
        }
    }
}
impl MetaValue for UcumBodyweight {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UcumBodyweight::LeftSquareBracketlb_avRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumBodyweight::G(Some(e)) => e.get_field(field),
                UcumBodyweight::Kg(Some(e)) => e.get_field(field),
                UcumBodyweight::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UcumBodyweight::LeftSquareBracketlb_avRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumBodyweight::G(Some(e)) => e.get_field_mut(field),
                UcumBodyweight::Kg(Some(e)) => e.get_field_mut(field),
                UcumBodyweight::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UcumVitalsCommon {
    #[doc = "percent"]
    #[code = "%"]
    Percent(Option<Element>),
    #[doc = "per minute"]
    #[code = "/min"]
    _Min(Option<Element>),
    #[doc = "degree Celsius"]
    #[code = "Cel"]
    Cel(Option<Element>),
    #[doc = "degree Fahrenheit"]
    #[code = "[degF]"]
    LeftSquareBracketdegFRightSquareBracket(Option<Element>),
    #[doc = "inch (international)"]
    #[code = "[in_i]"]
    LeftSquareBracketin_iRightSquareBracket(Option<Element>),
    #[doc = "pound (US and British)"]
    #[code = "[lb_av]"]
    LeftSquareBracketlb_avRightSquareBracket(Option<Element>),
    #[doc = "centimeter"]
    #[code = "cm"]
    Cm(Option<Element>),
    #[doc = "gram"]
    #[code = "g"]
    G(Option<Element>),
    #[doc = "kilogram"]
    #[code = "kg"]
    Kg(Option<Element>),
    #[doc = "kilogram / (meter ^ 2)"]
    #[code = "kg/m2"]
    Kg_M2(Option<Element>),
    #[doc = "square meter"]
    #[code = "m2"]
    M2(Option<Element>),
    #[doc = "millimeter of mercury"]
    #[code = "mm[Hg]"]
    MmLeftSquareBracketHgRightSquareBracket(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UcumVitalsCommon {
    fn default() -> Self {
        UcumVitalsCommon::Null(None)
    }
}
impl TryFrom<String> for UcumVitalsCommon {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "%" => Ok(UcumVitalsCommon::Percent(None)),
            "/min" => Ok(UcumVitalsCommon::_Min(None)),
            "Cel" => Ok(UcumVitalsCommon::Cel(None)),
            "[degF]" => Ok(UcumVitalsCommon::LeftSquareBracketdegFRightSquareBracket(
                None,
            )),
            "[in_i]" => Ok(UcumVitalsCommon::LeftSquareBracketin_iRightSquareBracket(
                None,
            )),
            "[lb_av]" => Ok(UcumVitalsCommon::LeftSquareBracketlb_avRightSquareBracket(
                None,
            )),
            "cm" => Ok(UcumVitalsCommon::Cm(None)),
            "g" => Ok(UcumVitalsCommon::G(None)),
            "kg" => Ok(UcumVitalsCommon::Kg(None)),
            "kg/m2" => Ok(UcumVitalsCommon::Kg_M2(None)),
            "m2" => Ok(UcumVitalsCommon::M2(None)),
            "mm[Hg]" => Ok(UcumVitalsCommon::MmLeftSquareBracketHgRightSquareBracket(
                None,
            )),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UcumVitalsCommon {
    fn into(self) -> Option<String> {
        match self {
            UcumVitalsCommon::Percent(_) => Some("%".to_string()),
            UcumVitalsCommon::_Min(_) => Some("/min".to_string()),
            UcumVitalsCommon::Cel(_) => Some("Cel".to_string()),
            UcumVitalsCommon::LeftSquareBracketdegFRightSquareBracket(_) => {
                Some("[degF]".to_string())
            }
            UcumVitalsCommon::LeftSquareBracketin_iRightSquareBracket(_) => {
                Some("[in_i]".to_string())
            }
            UcumVitalsCommon::LeftSquareBracketlb_avRightSquareBracket(_) => {
                Some("[lb_av]".to_string())
            }
            UcumVitalsCommon::Cm(_) => Some("cm".to_string()),
            UcumVitalsCommon::G(_) => Some("g".to_string()),
            UcumVitalsCommon::Kg(_) => Some("kg".to_string()),
            UcumVitalsCommon::Kg_M2(_) => Some("kg/m2".to_string()),
            UcumVitalsCommon::M2(_) => Some("m2".to_string()),
            UcumVitalsCommon::MmLeftSquareBracketHgRightSquareBracket(_) => {
                Some("mm[Hg]".to_string())
            }
            UcumVitalsCommon::Null(_) => None,
        }
    }
}
impl MetaValue for UcumVitalsCommon {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UcumVitalsCommon::Percent(Some(e)) => e.get_field(field),
                UcumVitalsCommon::_Min(Some(e)) => e.get_field(field),
                UcumVitalsCommon::Cel(Some(e)) => e.get_field(field),
                UcumVitalsCommon::LeftSquareBracketdegFRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumVitalsCommon::LeftSquareBracketin_iRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumVitalsCommon::LeftSquareBracketlb_avRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumVitalsCommon::Cm(Some(e)) => e.get_field(field),
                UcumVitalsCommon::G(Some(e)) => e.get_field(field),
                UcumVitalsCommon::Kg(Some(e)) => e.get_field(field),
                UcumVitalsCommon::Kg_M2(Some(e)) => e.get_field(field),
                UcumVitalsCommon::M2(Some(e)) => e.get_field(field),
                UcumVitalsCommon::MmLeftSquareBracketHgRightSquareBracket(Some(e)) => {
                    e.get_field(field)
                }
                UcumVitalsCommon::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UcumVitalsCommon::Percent(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::_Min(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::Cel(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::LeftSquareBracketdegFRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumVitalsCommon::LeftSquareBracketin_iRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumVitalsCommon::LeftSquareBracketlb_avRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumVitalsCommon::Cm(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::G(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::Kg(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::Kg_M2(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::M2(Some(e)) => e.get_field_mut(field),
                UcumVitalsCommon::MmLeftSquareBracketHgRightSquareBracket(Some(e)) => {
                    e.get_field_mut(field)
                }
                UcumVitalsCommon::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum Udi {
    #[doc = "GUDID (FDA)"]
    #[code = "gudid"]
    Gudid(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for Udi {
    fn default() -> Self {
        Udi::Null(None)
    }
}
impl TryFrom<String> for Udi {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "gudid" => Ok(Udi::Gudid(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &Udi {
    fn into(self) -> Option<String> {
        match self {
            Udi::Gudid(_) => Some("gudid".to_string()),
            Udi::Null(_) => None,
        }
    }
}
impl MetaValue for Udi {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                Udi::Gudid(Some(e)) => e.get_field(field),
                Udi::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                Udi::Gudid(Some(e)) => e.get_field_mut(field),
                Udi::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UdiEntryType {
    #[doc = "Barcode"]
    #[code = "barcode"]
    Barcode(Option<Element>),
    #[doc = "Card"]
    #[code = "card"]
    Card(Option<Element>),
    #[doc = "Manual"]
    #[code = "manual"]
    Manual(Option<Element>),
    #[doc = "RFID"]
    #[code = "rfid"]
    Rfid(Option<Element>),
    #[doc = "Self Reported"]
    #[code = "self-reported"]
    SelfReported(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UdiEntryType {
    fn default() -> Self {
        UdiEntryType::Null(None)
    }
}
impl TryFrom<String> for UdiEntryType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "barcode" => Ok(UdiEntryType::Barcode(None)),
            "card" => Ok(UdiEntryType::Card(None)),
            "manual" => Ok(UdiEntryType::Manual(None)),
            "rfid" => Ok(UdiEntryType::Rfid(None)),
            "self-reported" => Ok(UdiEntryType::SelfReported(None)),
            "unknown" => Ok(UdiEntryType::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UdiEntryType {
    fn into(self) -> Option<String> {
        match self {
            UdiEntryType::Barcode(_) => Some("barcode".to_string()),
            UdiEntryType::Card(_) => Some("card".to_string()),
            UdiEntryType::Manual(_) => Some("manual".to_string()),
            UdiEntryType::Rfid(_) => Some("rfid".to_string()),
            UdiEntryType::SelfReported(_) => Some("self-reported".to_string()),
            UdiEntryType::Unknown(_) => Some("unknown".to_string()),
            UdiEntryType::Null(_) => None,
        }
    }
}
impl MetaValue for UdiEntryType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UdiEntryType::Barcode(Some(e)) => e.get_field(field),
                UdiEntryType::Card(Some(e)) => e.get_field(field),
                UdiEntryType::Manual(Some(e)) => e.get_field(field),
                UdiEntryType::Rfid(Some(e)) => e.get_field(field),
                UdiEntryType::SelfReported(Some(e)) => e.get_field(field),
                UdiEntryType::Unknown(Some(e)) => e.get_field(field),
                UdiEntryType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UdiEntryType::Barcode(Some(e)) => e.get_field_mut(field),
                UdiEntryType::Card(Some(e)) => e.get_field_mut(field),
                UdiEntryType::Manual(Some(e)) => e.get_field_mut(field),
                UdiEntryType::Rfid(Some(e)) => e.get_field_mut(field),
                UdiEntryType::SelfReported(Some(e)) => e.get_field_mut(field),
                UdiEntryType::Unknown(Some(e)) => e.get_field_mut(field),
                UdiEntryType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UnitsOfTime {
    #[doc = "year"]
    #[code = "a"]
    A(Option<Element>),
    #[doc = "day"]
    #[code = "d"]
    D(Option<Element>),
    #[doc = "hour"]
    #[code = "h"]
    H(Option<Element>),
    #[doc = "minute"]
    #[code = "min"]
    Min(Option<Element>),
    #[doc = "month"]
    #[code = "mo"]
    Mo(Option<Element>),
    #[doc = "second"]
    #[code = "s"]
    S(Option<Element>),
    #[doc = "week"]
    #[code = "wk"]
    Wk(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UnitsOfTime {
    fn default() -> Self {
        UnitsOfTime::Null(None)
    }
}
impl TryFrom<String> for UnitsOfTime {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "a" => Ok(UnitsOfTime::A(None)),
            "d" => Ok(UnitsOfTime::D(None)),
            "h" => Ok(UnitsOfTime::H(None)),
            "min" => Ok(UnitsOfTime::Min(None)),
            "mo" => Ok(UnitsOfTime::Mo(None)),
            "s" => Ok(UnitsOfTime::S(None)),
            "wk" => Ok(UnitsOfTime::Wk(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UnitsOfTime {
    fn into(self) -> Option<String> {
        match self {
            UnitsOfTime::A(_) => Some("a".to_string()),
            UnitsOfTime::D(_) => Some("d".to_string()),
            UnitsOfTime::H(_) => Some("h".to_string()),
            UnitsOfTime::Min(_) => Some("min".to_string()),
            UnitsOfTime::Mo(_) => Some("mo".to_string()),
            UnitsOfTime::S(_) => Some("s".to_string()),
            UnitsOfTime::Wk(_) => Some("wk".to_string()),
            UnitsOfTime::Null(_) => None,
        }
    }
}
impl MetaValue for UnitsOfTime {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UnitsOfTime::A(Some(e)) => e.get_field(field),
                UnitsOfTime::D(Some(e)) => e.get_field(field),
                UnitsOfTime::H(Some(e)) => e.get_field(field),
                UnitsOfTime::Min(Some(e)) => e.get_field(field),
                UnitsOfTime::Mo(Some(e)) => e.get_field(field),
                UnitsOfTime::S(Some(e)) => e.get_field(field),
                UnitsOfTime::Wk(Some(e)) => e.get_field(field),
                UnitsOfTime::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UnitsOfTime::A(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::D(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::H(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::Min(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::Mo(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::S(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::Wk(Some(e)) => e.get_field_mut(field),
                UnitsOfTime::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UnknownContentCode {
    #[doc = "Unknown Elements and Extensions"]
    #[code = "both"]
    Both(Option<Element>),
    #[doc = "Unknown Elements"]
    #[code = "elements"]
    Elements(Option<Element>),
    #[doc = "Unknown Extensions"]
    #[code = "extensions"]
    Extensions(Option<Element>),
    #[doc = "Neither Elements or Extensions"]
    #[code = "no"]
    No(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UnknownContentCode {
    fn default() -> Self {
        UnknownContentCode::Null(None)
    }
}
impl TryFrom<String> for UnknownContentCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "both" => Ok(UnknownContentCode::Both(None)),
            "elements" => Ok(UnknownContentCode::Elements(None)),
            "extensions" => Ok(UnknownContentCode::Extensions(None)),
            "no" => Ok(UnknownContentCode::No(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UnknownContentCode {
    fn into(self) -> Option<String> {
        match self {
            UnknownContentCode::Both(_) => Some("both".to_string()),
            UnknownContentCode::Elements(_) => Some("elements".to_string()),
            UnknownContentCode::Extensions(_) => Some("extensions".to_string()),
            UnknownContentCode::No(_) => Some("no".to_string()),
            UnknownContentCode::Null(_) => None,
        }
    }
}
impl MetaValue for UnknownContentCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UnknownContentCode::Both(Some(e)) => e.get_field(field),
                UnknownContentCode::Elements(Some(e)) => e.get_field(field),
                UnknownContentCode::Extensions(Some(e)) => e.get_field(field),
                UnknownContentCode::No(Some(e)) => e.get_field(field),
                UnknownContentCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UnknownContentCode::Both(Some(e)) => e.get_field_mut(field),
                UnknownContentCode::Elements(Some(e)) => e.get_field_mut(field),
                UnknownContentCode::Extensions(Some(e)) => e.get_field_mut(field),
                UnknownContentCode::No(Some(e)) => e.get_field_mut(field),
                UnknownContentCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UsageContextType {
    #[doc = "Age Range"]
    #[code = "age"]
    Age(Option<Element>),
    #[doc = "Clinical Focus"]
    #[code = "focus"]
    Focus(Option<Element>),
    #[doc = "Gender"]
    #[code = "gender"]
    Gender(Option<Element>),
    #[doc = "Program"]
    #[code = "program"]
    Program(Option<Element>),
    #[doc = "Species"]
    #[code = "species"]
    Species(Option<Element>),
    #[doc = "Workflow Task"]
    #[code = "task"]
    Task(Option<Element>),
    #[doc = "User Type"]
    #[code = "user"]
    User(Option<Element>),
    #[doc = "Clinical Venue"]
    #[code = "venue"]
    Venue(Option<Element>),
    #[doc = "Workflow Setting"]
    #[code = "workflow"]
    Workflow(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UsageContextType {
    fn default() -> Self {
        UsageContextType::Null(None)
    }
}
impl TryFrom<String> for UsageContextType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "age" => Ok(UsageContextType::Age(None)),
            "focus" => Ok(UsageContextType::Focus(None)),
            "gender" => Ok(UsageContextType::Gender(None)),
            "program" => Ok(UsageContextType::Program(None)),
            "species" => Ok(UsageContextType::Species(None)),
            "task" => Ok(UsageContextType::Task(None)),
            "user" => Ok(UsageContextType::User(None)),
            "venue" => Ok(UsageContextType::Venue(None)),
            "workflow" => Ok(UsageContextType::Workflow(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UsageContextType {
    fn into(self) -> Option<String> {
        match self {
            UsageContextType::Age(_) => Some("age".to_string()),
            UsageContextType::Focus(_) => Some("focus".to_string()),
            UsageContextType::Gender(_) => Some("gender".to_string()),
            UsageContextType::Program(_) => Some("program".to_string()),
            UsageContextType::Species(_) => Some("species".to_string()),
            UsageContextType::Task(_) => Some("task".to_string()),
            UsageContextType::User(_) => Some("user".to_string()),
            UsageContextType::Venue(_) => Some("venue".to_string()),
            UsageContextType::Workflow(_) => Some("workflow".to_string()),
            UsageContextType::Null(_) => None,
        }
    }
}
impl MetaValue for UsageContextType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UsageContextType::Age(Some(e)) => e.get_field(field),
                UsageContextType::Focus(Some(e)) => e.get_field(field),
                UsageContextType::Gender(Some(e)) => e.get_field(field),
                UsageContextType::Program(Some(e)) => e.get_field(field),
                UsageContextType::Species(Some(e)) => e.get_field(field),
                UsageContextType::Task(Some(e)) => e.get_field(field),
                UsageContextType::User(Some(e)) => e.get_field(field),
                UsageContextType::Venue(Some(e)) => e.get_field(field),
                UsageContextType::Workflow(Some(e)) => e.get_field(field),
                UsageContextType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UsageContextType::Age(Some(e)) => e.get_field_mut(field),
                UsageContextType::Focus(Some(e)) => e.get_field_mut(field),
                UsageContextType::Gender(Some(e)) => e.get_field_mut(field),
                UsageContextType::Program(Some(e)) => e.get_field_mut(field),
                UsageContextType::Species(Some(e)) => e.get_field_mut(field),
                UsageContextType::Task(Some(e)) => e.get_field_mut(field),
                UsageContextType::User(Some(e)) => e.get_field_mut(field),
                UsageContextType::Venue(Some(e)) => e.get_field_mut(field),
                UsageContextType::Workflow(Some(e)) => e.get_field_mut(field),
                UsageContextType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VariableType {
    #[doc = "Continuous"]
    #[code = "continuous"]
    Continuous(Option<Element>),
    #[doc = "Descriptive"]
    #[code = "descriptive"]
    Descriptive(Option<Element>),
    #[doc = "Dichotomous"]
    #[code = "dichotomous"]
    Dichotomous(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VariableType {
    fn default() -> Self {
        VariableType::Null(None)
    }
}
impl TryFrom<String> for VariableType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "continuous" => Ok(VariableType::Continuous(None)),
            "descriptive" => Ok(VariableType::Descriptive(None)),
            "dichotomous" => Ok(VariableType::Dichotomous(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VariableType {
    fn into(self) -> Option<String> {
        match self {
            VariableType::Continuous(_) => Some("continuous".to_string()),
            VariableType::Descriptive(_) => Some("descriptive".to_string()),
            VariableType::Dichotomous(_) => Some("dichotomous".to_string()),
            VariableType::Null(_) => None,
        }
    }
}
impl MetaValue for VariableType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VariableType::Continuous(Some(e)) => e.get_field(field),
                VariableType::Descriptive(Some(e)) => e.get_field(field),
                VariableType::Dichotomous(Some(e)) => e.get_field(field),
                VariableType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VariableType::Continuous(Some(e)) => e.get_field_mut(field),
                VariableType::Descriptive(Some(e)) => e.get_field_mut(field),
                VariableType::Dichotomous(Some(e)) => e.get_field_mut(field),
                VariableType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VariantState {
    #[doc = "absent"]
    #[code = "absent"]
    Absent(Option<Element>),
    #[doc = "negative"]
    #[code = "negative"]
    Negative(Option<Element>),
    #[doc = "positive"]
    #[code = "positive"]
    Positive(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VariantState {
    fn default() -> Self {
        VariantState::Null(None)
    }
}
impl TryFrom<String> for VariantState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "absent" => Ok(VariantState::Absent(None)),
            "negative" => Ok(VariantState::Negative(None)),
            "positive" => Ok(VariantState::Positive(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VariantState {
    fn into(self) -> Option<String> {
        match self {
            VariantState::Absent(_) => Some("absent".to_string()),
            VariantState::Negative(_) => Some("negative".to_string()),
            VariantState::Positive(_) => Some("positive".to_string()),
            VariantState::Null(_) => None,
        }
    }
}
impl MetaValue for VariantState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VariantState::Absent(Some(e)) => e.get_field(field),
                VariantState::Negative(Some(e)) => e.get_field(field),
                VariantState::Positive(Some(e)) => e.get_field(field),
                VariantState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VariantState::Absent(Some(e)) => e.get_field_mut(field),
                VariantState::Negative(Some(e)) => e.get_field_mut(field),
                VariantState::Positive(Some(e)) => e.get_field_mut(field),
                VariantState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultCanPushUpdates {
    #[doc = "No"]
    #[code = "no"]
    No(Option<Element>),
    #[doc = "Undetermined"]
    #[code = "undetermined"]
    Undetermined(Option<Element>),
    #[doc = "Yes"]
    #[code = "yes"]
    Yes(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultCanPushUpdates {
    fn default() -> Self {
        VerificationresultCanPushUpdates::Null(None)
    }
}
impl TryFrom<String> for VerificationresultCanPushUpdates {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "no" => Ok(VerificationresultCanPushUpdates::No(None)),
            "undetermined" => Ok(VerificationresultCanPushUpdates::Undetermined(None)),
            "yes" => Ok(VerificationresultCanPushUpdates::Yes(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultCanPushUpdates {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultCanPushUpdates::No(_) => Some("no".to_string()),
            VerificationresultCanPushUpdates::Undetermined(_) => Some("undetermined".to_string()),
            VerificationresultCanPushUpdates::Yes(_) => Some("yes".to_string()),
            VerificationresultCanPushUpdates::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultCanPushUpdates {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultCanPushUpdates::No(Some(e)) => e.get_field(field),
                VerificationresultCanPushUpdates::Undetermined(Some(e)) => e.get_field(field),
                VerificationresultCanPushUpdates::Yes(Some(e)) => e.get_field(field),
                VerificationresultCanPushUpdates::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultCanPushUpdates::No(Some(e)) => e.get_field_mut(field),
                VerificationresultCanPushUpdates::Undetermined(Some(e)) => e.get_field_mut(field),
                VerificationresultCanPushUpdates::Yes(Some(e)) => e.get_field_mut(field),
                VerificationresultCanPushUpdates::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultCommunicationMethod {
    #[doc = "Manual"]
    #[code = "manual"]
    Manual(Option<Element>),
    #[doc = "Portal"]
    #[code = "portal"]
    Portal(Option<Element>),
    #[doc = "Pull"]
    #[code = "pull"]
    Pull(Option<Element>),
    #[doc = "Push"]
    #[code = "push"]
    Push(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultCommunicationMethod {
    fn default() -> Self {
        VerificationresultCommunicationMethod::Null(None)
    }
}
impl TryFrom<String> for VerificationresultCommunicationMethod {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "manual" => Ok(VerificationresultCommunicationMethod::Manual(None)),
            "portal" => Ok(VerificationresultCommunicationMethod::Portal(None)),
            "pull" => Ok(VerificationresultCommunicationMethod::Pull(None)),
            "push" => Ok(VerificationresultCommunicationMethod::Push(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultCommunicationMethod {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultCommunicationMethod::Manual(_) => Some("manual".to_string()),
            VerificationresultCommunicationMethod::Portal(_) => Some("portal".to_string()),
            VerificationresultCommunicationMethod::Pull(_) => Some("pull".to_string()),
            VerificationresultCommunicationMethod::Push(_) => Some("push".to_string()),
            VerificationresultCommunicationMethod::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultCommunicationMethod {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultCommunicationMethod::Manual(Some(e)) => e.get_field(field),
                VerificationresultCommunicationMethod::Portal(Some(e)) => e.get_field(field),
                VerificationresultCommunicationMethod::Pull(Some(e)) => e.get_field(field),
                VerificationresultCommunicationMethod::Push(Some(e)) => e.get_field(field),
                VerificationresultCommunicationMethod::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultCommunicationMethod::Manual(Some(e)) => e.get_field_mut(field),
                VerificationresultCommunicationMethod::Portal(Some(e)) => e.get_field_mut(field),
                VerificationresultCommunicationMethod::Pull(Some(e)) => e.get_field_mut(field),
                VerificationresultCommunicationMethod::Push(Some(e)) => e.get_field_mut(field),
                VerificationresultCommunicationMethod::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultFailureAction {
    #[doc = "Fatal"]
    #[code = "fatal"]
    Fatal(Option<Element>),
    #[doc = "None"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "Record only"]
    #[code = "rec-only"]
    RecOnly(Option<Element>),
    #[doc = "Warning"]
    #[code = "warn"]
    Warn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultFailureAction {
    fn default() -> Self {
        VerificationresultFailureAction::Null(None)
    }
}
impl TryFrom<String> for VerificationresultFailureAction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fatal" => Ok(VerificationresultFailureAction::Fatal(None)),
            "none" => Ok(VerificationresultFailureAction::None(None)),
            "rec-only" => Ok(VerificationresultFailureAction::RecOnly(None)),
            "warn" => Ok(VerificationresultFailureAction::Warn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultFailureAction {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultFailureAction::Fatal(_) => Some("fatal".to_string()),
            VerificationresultFailureAction::None(_) => Some("none".to_string()),
            VerificationresultFailureAction::RecOnly(_) => Some("rec-only".to_string()),
            VerificationresultFailureAction::Warn(_) => Some("warn".to_string()),
            VerificationresultFailureAction::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultFailureAction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultFailureAction::Fatal(Some(e)) => e.get_field(field),
                VerificationresultFailureAction::None(Some(e)) => e.get_field(field),
                VerificationresultFailureAction::RecOnly(Some(e)) => e.get_field(field),
                VerificationresultFailureAction::Warn(Some(e)) => e.get_field(field),
                VerificationresultFailureAction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultFailureAction::Fatal(Some(e)) => e.get_field_mut(field),
                VerificationresultFailureAction::None(Some(e)) => e.get_field_mut(field),
                VerificationresultFailureAction::RecOnly(Some(e)) => e.get_field_mut(field),
                VerificationresultFailureAction::Warn(Some(e)) => e.get_field_mut(field),
                VerificationresultFailureAction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultNeed {
    #[doc = "Initial"]
    #[code = "initial"]
    Initial(Option<Element>),
    #[doc = "None"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "Periodic"]
    #[code = "periodic"]
    Periodic(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultNeed {
    fn default() -> Self {
        VerificationresultNeed::Null(None)
    }
}
impl TryFrom<String> for VerificationresultNeed {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "initial" => Ok(VerificationresultNeed::Initial(None)),
            "none" => Ok(VerificationresultNeed::None(None)),
            "periodic" => Ok(VerificationresultNeed::Periodic(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultNeed {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultNeed::Initial(_) => Some("initial".to_string()),
            VerificationresultNeed::None(_) => Some("none".to_string()),
            VerificationresultNeed::Periodic(_) => Some("periodic".to_string()),
            VerificationresultNeed::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultNeed {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultNeed::Initial(Some(e)) => e.get_field(field),
                VerificationresultNeed::None(Some(e)) => e.get_field(field),
                VerificationresultNeed::Periodic(Some(e)) => e.get_field(field),
                VerificationresultNeed::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultNeed::Initial(Some(e)) => e.get_field_mut(field),
                VerificationresultNeed::None(Some(e)) => e.get_field_mut(field),
                VerificationresultNeed::Periodic(Some(e)) => e.get_field_mut(field),
                VerificationresultNeed::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultPrimarySourceType {
    #[doc = "Authoritative source"]
    #[code = "auth-source"]
    AuthSource(Option<Element>),
    #[doc = "Continuing Education"]
    #[code = "cont-ed"]
    ContEd(Option<Element>),
    #[doc = "Issuing source"]
    #[code = "issuer"]
    Issuer(Option<Element>),
    #[doc = "Legal source"]
    #[code = "legal"]
    Legal(Option<Element>),
    #[doc = "License Board"]
    #[code = "lic-board"]
    LicBoard(Option<Element>),
    #[doc = "Postal Service"]
    #[code = "post-serv"]
    PostServ(Option<Element>),
    #[doc = "Primary Education"]
    #[code = "prim"]
    Prim(Option<Element>),
    #[doc = "Registration Authority"]
    #[code = "reg-auth"]
    RegAuth(Option<Element>),
    #[doc = "Relationship owner"]
    #[code = "rel-own"]
    RelOwn(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultPrimarySourceType {
    fn default() -> Self {
        VerificationresultPrimarySourceType::Null(None)
    }
}
impl TryFrom<String> for VerificationresultPrimarySourceType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "auth-source" => Ok(VerificationresultPrimarySourceType::AuthSource(None)),
            "cont-ed" => Ok(VerificationresultPrimarySourceType::ContEd(None)),
            "issuer" => Ok(VerificationresultPrimarySourceType::Issuer(None)),
            "legal" => Ok(VerificationresultPrimarySourceType::Legal(None)),
            "lic-board" => Ok(VerificationresultPrimarySourceType::LicBoard(None)),
            "post-serv" => Ok(VerificationresultPrimarySourceType::PostServ(None)),
            "prim" => Ok(VerificationresultPrimarySourceType::Prim(None)),
            "reg-auth" => Ok(VerificationresultPrimarySourceType::RegAuth(None)),
            "rel-own" => Ok(VerificationresultPrimarySourceType::RelOwn(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultPrimarySourceType {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultPrimarySourceType::AuthSource(_) => Some("auth-source".to_string()),
            VerificationresultPrimarySourceType::ContEd(_) => Some("cont-ed".to_string()),
            VerificationresultPrimarySourceType::Issuer(_) => Some("issuer".to_string()),
            VerificationresultPrimarySourceType::Legal(_) => Some("legal".to_string()),
            VerificationresultPrimarySourceType::LicBoard(_) => Some("lic-board".to_string()),
            VerificationresultPrimarySourceType::PostServ(_) => Some("post-serv".to_string()),
            VerificationresultPrimarySourceType::Prim(_) => Some("prim".to_string()),
            VerificationresultPrimarySourceType::RegAuth(_) => Some("reg-auth".to_string()),
            VerificationresultPrimarySourceType::RelOwn(_) => Some("rel-own".to_string()),
            VerificationresultPrimarySourceType::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultPrimarySourceType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultPrimarySourceType::AuthSource(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::ContEd(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::Issuer(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::Legal(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::LicBoard(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::PostServ(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::Prim(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::RegAuth(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::RelOwn(Some(e)) => e.get_field(field),
                VerificationresultPrimarySourceType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultPrimarySourceType::AuthSource(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::ContEd(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::Issuer(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::Legal(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::LicBoard(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::PostServ(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::Prim(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::RegAuth(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::RelOwn(Some(e)) => e.get_field_mut(field),
                VerificationresultPrimarySourceType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultPushTypeAvailable {
    #[doc = "Any changes"]
    #[code = "any"]
    Any(Option<Element>),
    #[doc = "As defined by source"]
    #[code = "source"]
    Source(Option<Element>),
    #[doc = "Specific requested changes"]
    #[code = "specific"]
    Specific(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultPushTypeAvailable {
    fn default() -> Self {
        VerificationresultPushTypeAvailable::Null(None)
    }
}
impl TryFrom<String> for VerificationresultPushTypeAvailable {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "any" => Ok(VerificationresultPushTypeAvailable::Any(None)),
            "source" => Ok(VerificationresultPushTypeAvailable::Source(None)),
            "specific" => Ok(VerificationresultPushTypeAvailable::Specific(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultPushTypeAvailable {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultPushTypeAvailable::Any(_) => Some("any".to_string()),
            VerificationresultPushTypeAvailable::Source(_) => Some("source".to_string()),
            VerificationresultPushTypeAvailable::Specific(_) => Some("specific".to_string()),
            VerificationresultPushTypeAvailable::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultPushTypeAvailable {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultPushTypeAvailable::Any(Some(e)) => e.get_field(field),
                VerificationresultPushTypeAvailable::Source(Some(e)) => e.get_field(field),
                VerificationresultPushTypeAvailable::Specific(Some(e)) => e.get_field(field),
                VerificationresultPushTypeAvailable::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultPushTypeAvailable::Any(Some(e)) => e.get_field_mut(field),
                VerificationresultPushTypeAvailable::Source(Some(e)) => e.get_field_mut(field),
                VerificationresultPushTypeAvailable::Specific(Some(e)) => e.get_field_mut(field),
                VerificationresultPushTypeAvailable::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultStatus {
    #[doc = "Attested"]
    #[code = "attested"]
    Attested(Option<Element>),
    #[doc = "In process"]
    #[code = "in-process"]
    InProcess(Option<Element>),
    #[doc = "Requires revalidation"]
    #[code = "req-revalid"]
    ReqRevalid(Option<Element>),
    #[doc = "Re-Validation failed"]
    #[code = "reval-fail"]
    RevalFail(Option<Element>),
    #[doc = "Validation failed"]
    #[code = "val-fail"]
    ValFail(Option<Element>),
    #[doc = "Validated"]
    #[code = "validated"]
    Validated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultStatus {
    fn default() -> Self {
        VerificationresultStatus::Null(None)
    }
}
impl TryFrom<String> for VerificationresultStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "attested" => Ok(VerificationresultStatus::Attested(None)),
            "in-process" => Ok(VerificationresultStatus::InProcess(None)),
            "req-revalid" => Ok(VerificationresultStatus::ReqRevalid(None)),
            "reval-fail" => Ok(VerificationresultStatus::RevalFail(None)),
            "val-fail" => Ok(VerificationresultStatus::ValFail(None)),
            "validated" => Ok(VerificationresultStatus::Validated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultStatus {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultStatus::Attested(_) => Some("attested".to_string()),
            VerificationresultStatus::InProcess(_) => Some("in-process".to_string()),
            VerificationresultStatus::ReqRevalid(_) => Some("req-revalid".to_string()),
            VerificationresultStatus::RevalFail(_) => Some("reval-fail".to_string()),
            VerificationresultStatus::ValFail(_) => Some("val-fail".to_string()),
            VerificationresultStatus::Validated(_) => Some("validated".to_string()),
            VerificationresultStatus::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultStatus::Attested(Some(e)) => e.get_field(field),
                VerificationresultStatus::InProcess(Some(e)) => e.get_field(field),
                VerificationresultStatus::ReqRevalid(Some(e)) => e.get_field(field),
                VerificationresultStatus::RevalFail(Some(e)) => e.get_field(field),
                VerificationresultStatus::ValFail(Some(e)) => e.get_field(field),
                VerificationresultStatus::Validated(Some(e)) => e.get_field(field),
                VerificationresultStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultStatus::Attested(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::InProcess(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::ReqRevalid(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::RevalFail(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::ValFail(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::Validated(Some(e)) => e.get_field_mut(field),
                VerificationresultStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultValidationProcess {
    #[doc = "edit check"]
    #[code = "edit-check"]
    EditCheck(Option<Element>),
    #[doc = "in context"]
    #[code = "in-context"]
    InContext(Option<Element>),
    #[doc = "multiple sources"]
    #[code = "multi"]
    Multi(Option<Element>),
    #[doc = "primary source"]
    #[code = "primary"]
    Primary(Option<Element>),
    #[doc = "standalone"]
    #[code = "standalone"]
    Standalone(Option<Element>),
    #[doc = "value set"]
    #[code = "valueset"]
    Valueset(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultValidationProcess {
    fn default() -> Self {
        VerificationresultValidationProcess::Null(None)
    }
}
impl TryFrom<String> for VerificationresultValidationProcess {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "edit-check" => Ok(VerificationresultValidationProcess::EditCheck(None)),
            "in-context" => Ok(VerificationresultValidationProcess::InContext(None)),
            "multi" => Ok(VerificationresultValidationProcess::Multi(None)),
            "primary" => Ok(VerificationresultValidationProcess::Primary(None)),
            "standalone" => Ok(VerificationresultValidationProcess::Standalone(None)),
            "valueset" => Ok(VerificationresultValidationProcess::Valueset(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultValidationProcess {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultValidationProcess::EditCheck(_) => Some("edit-check".to_string()),
            VerificationresultValidationProcess::InContext(_) => Some("in-context".to_string()),
            VerificationresultValidationProcess::Multi(_) => Some("multi".to_string()),
            VerificationresultValidationProcess::Primary(_) => Some("primary".to_string()),
            VerificationresultValidationProcess::Standalone(_) => Some("standalone".to_string()),
            VerificationresultValidationProcess::Valueset(_) => Some("valueset".to_string()),
            VerificationresultValidationProcess::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultValidationProcess {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultValidationProcess::EditCheck(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::InContext(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::Multi(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::Primary(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::Standalone(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::Valueset(Some(e)) => e.get_field(field),
                VerificationresultValidationProcess::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultValidationProcess::EditCheck(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::InContext(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::Multi(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::Primary(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::Standalone(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::Valueset(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationProcess::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultValidationStatus {
    #[doc = "Failed"]
    #[code = "failed"]
    Failed(Option<Element>),
    #[doc = "Successful"]
    #[code = "successful"]
    Successful(Option<Element>),
    #[doc = "Unknown"]
    #[code = "unknown"]
    Unknown(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultValidationStatus {
    fn default() -> Self {
        VerificationresultValidationStatus::Null(None)
    }
}
impl TryFrom<String> for VerificationresultValidationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "failed" => Ok(VerificationresultValidationStatus::Failed(None)),
            "successful" => Ok(VerificationresultValidationStatus::Successful(None)),
            "unknown" => Ok(VerificationresultValidationStatus::Unknown(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultValidationStatus {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultValidationStatus::Failed(_) => Some("failed".to_string()),
            VerificationresultValidationStatus::Successful(_) => Some("successful".to_string()),
            VerificationresultValidationStatus::Unknown(_) => Some("unknown".to_string()),
            VerificationresultValidationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultValidationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultValidationStatus::Failed(Some(e)) => e.get_field(field),
                VerificationresultValidationStatus::Successful(Some(e)) => e.get_field(field),
                VerificationresultValidationStatus::Unknown(Some(e)) => e.get_field(field),
                VerificationresultValidationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultValidationStatus::Failed(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationStatus::Successful(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationStatus::Unknown(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VerificationresultValidationType {
    #[doc = "Multiple Sources"]
    #[code = "multiple"]
    Multiple(Option<Element>),
    #[doc = "Nothing"]
    #[code = "nothing"]
    Nothing(Option<Element>),
    #[doc = "Primary Source"]
    #[code = "primary"]
    Primary(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VerificationresultValidationType {
    fn default() -> Self {
        VerificationresultValidationType::Null(None)
    }
}
impl TryFrom<String> for VerificationresultValidationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "multiple" => Ok(VerificationresultValidationType::Multiple(None)),
            "nothing" => Ok(VerificationresultValidationType::Nothing(None)),
            "primary" => Ok(VerificationresultValidationType::Primary(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VerificationresultValidationType {
    fn into(self) -> Option<String> {
        match self {
            VerificationresultValidationType::Multiple(_) => Some("multiple".to_string()),
            VerificationresultValidationType::Nothing(_) => Some("nothing".to_string()),
            VerificationresultValidationType::Primary(_) => Some("primary".to_string()),
            VerificationresultValidationType::Null(_) => None,
        }
    }
}
impl MetaValue for VerificationresultValidationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VerificationresultValidationType::Multiple(Some(e)) => e.get_field(field),
                VerificationresultValidationType::Nothing(Some(e)) => e.get_field(field),
                VerificationresultValidationType::Primary(Some(e)) => e.get_field(field),
                VerificationresultValidationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VerificationresultValidationType::Multiple(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationType::Nothing(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationType::Primary(Some(e)) => e.get_field_mut(field),
                VerificationresultValidationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VersioningPolicy {
    #[doc = "No VersionId Support"]
    #[code = "no-version"]
    NoVersion(Option<Element>),
    #[doc = "Versioned"]
    #[code = "versioned"]
    Versioned(Option<Element>),
    #[doc = "VersionId tracked fully"]
    #[code = "versioned-update"]
    VersionedUpdate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VersioningPolicy {
    fn default() -> Self {
        VersioningPolicy::Null(None)
    }
}
impl TryFrom<String> for VersioningPolicy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "no-version" => Ok(VersioningPolicy::NoVersion(None)),
            "versioned" => Ok(VersioningPolicy::Versioned(None)),
            "versioned-update" => Ok(VersioningPolicy::VersionedUpdate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VersioningPolicy {
    fn into(self) -> Option<String> {
        match self {
            VersioningPolicy::NoVersion(_) => Some("no-version".to_string()),
            VersioningPolicy::Versioned(_) => Some("versioned".to_string()),
            VersioningPolicy::VersionedUpdate(_) => Some("versioned-update".to_string()),
            VersioningPolicy::Null(_) => None,
        }
    }
}
impl MetaValue for VersioningPolicy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VersioningPolicy::NoVersion(Some(e)) => e.get_field(field),
                VersioningPolicy::Versioned(Some(e)) => e.get_field(field),
                VersioningPolicy::VersionedUpdate(Some(e)) => e.get_field(field),
                VersioningPolicy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VersioningPolicy::NoVersion(Some(e)) => e.get_field_mut(field),
                VersioningPolicy::Versioned(Some(e)) => e.get_field_mut(field),
                VersioningPolicy::VersionedUpdate(Some(e)) => e.get_field_mut(field),
                VersioningPolicy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VisionBaseCodes {
    #[doc = "Down"]
    #[code = "down"]
    Down(Option<Element>),
    #[doc = "In"]
    #[code = "in"]
    In(Option<Element>),
    #[doc = "Out"]
    #[code = "out"]
    Out(Option<Element>),
    #[doc = "Up"]
    #[code = "up"]
    Up(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VisionBaseCodes {
    fn default() -> Self {
        VisionBaseCodes::Null(None)
    }
}
impl TryFrom<String> for VisionBaseCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "down" => Ok(VisionBaseCodes::Down(None)),
            "in" => Ok(VisionBaseCodes::In(None)),
            "out" => Ok(VisionBaseCodes::Out(None)),
            "up" => Ok(VisionBaseCodes::Up(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VisionBaseCodes {
    fn into(self) -> Option<String> {
        match self {
            VisionBaseCodes::Down(_) => Some("down".to_string()),
            VisionBaseCodes::In(_) => Some("in".to_string()),
            VisionBaseCodes::Out(_) => Some("out".to_string()),
            VisionBaseCodes::Up(_) => Some("up".to_string()),
            VisionBaseCodes::Null(_) => None,
        }
    }
}
impl MetaValue for VisionBaseCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VisionBaseCodes::Down(Some(e)) => e.get_field(field),
                VisionBaseCodes::In(Some(e)) => e.get_field(field),
                VisionBaseCodes::Out(Some(e)) => e.get_field(field),
                VisionBaseCodes::Up(Some(e)) => e.get_field(field),
                VisionBaseCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VisionBaseCodes::Down(Some(e)) => e.get_field_mut(field),
                VisionBaseCodes::In(Some(e)) => e.get_field_mut(field),
                VisionBaseCodes::Out(Some(e)) => e.get_field_mut(field),
                VisionBaseCodes::Up(Some(e)) => e.get_field_mut(field),
                VisionBaseCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VisionEyeCodes {
    #[doc = "Left Eye"]
    #[code = "left"]
    Left(Option<Element>),
    #[doc = "Right Eye"]
    #[code = "right"]
    Right(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VisionEyeCodes {
    fn default() -> Self {
        VisionEyeCodes::Null(None)
    }
}
impl TryFrom<String> for VisionEyeCodes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "left" => Ok(VisionEyeCodes::Left(None)),
            "right" => Ok(VisionEyeCodes::Right(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VisionEyeCodes {
    fn into(self) -> Option<String> {
        match self {
            VisionEyeCodes::Left(_) => Some("left".to_string()),
            VisionEyeCodes::Right(_) => Some("right".to_string()),
            VisionEyeCodes::Null(_) => None,
        }
    }
}
impl MetaValue for VisionEyeCodes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VisionEyeCodes::Left(Some(e)) => e.get_field(field),
                VisionEyeCodes::Right(Some(e)) => e.get_field(field),
                VisionEyeCodes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VisionEyeCodes::Left(Some(e)) => e.get_field_mut(field),
                VisionEyeCodes::Right(Some(e)) => e.get_field_mut(field),
                VisionEyeCodes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum VisionProduct {
    #[doc = "Contact Lens"]
    #[code = "contact"]
    Contact(Option<Element>),
    #[doc = "Lens"]
    #[code = "lens"]
    Lens(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for VisionProduct {
    fn default() -> Self {
        VisionProduct::Null(None)
    }
}
impl TryFrom<String> for VisionProduct {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "contact" => Ok(VisionProduct::Contact(None)),
            "lens" => Ok(VisionProduct::Lens(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &VisionProduct {
    fn into(self) -> Option<String> {
        match self {
            VisionProduct::Contact(_) => Some("contact".to_string()),
            VisionProduct::Lens(_) => Some("lens".to_string()),
            VisionProduct::Null(_) => None,
        }
    }
}
impl MetaValue for VisionProduct {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                VisionProduct::Contact(Some(e)) => e.get_field(field),
                VisionProduct::Lens(Some(e)) => e.get_field(field),
                VisionProduct::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                VisionProduct::Contact(Some(e)) => e.get_field_mut(field),
                VisionProduct::Lens(Some(e)) => e.get_field_mut(field),
                VisionProduct::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum WrittenLanguage {
    #[doc = "Arabic"]
    #[code = "ar"]
    Ar(Option<Element>),
    #[doc = "Bengali"]
    #[code = "bn"]
    Bn(Option<Element>),
    #[doc = "Czech"]
    #[code = "cs"]
    Cs(Option<Element>),
    #[doc = "Danish"]
    #[code = "da"]
    Da(Option<Element>),
    #[doc = "German"]
    #[code = "de"]
    De(Option<Element>),
    #[doc = "Greek"]
    #[code = "el"]
    El(Option<Element>),
    #[doc = "English"]
    #[code = "en"]
    En(Option<Element>),
    #[doc = "Spanish"]
    #[code = "es"]
    Es(Option<Element>),
    #[doc = "Finnish"]
    #[code = "fi"]
    Fi(Option<Element>),
    #[doc = "French"]
    #[code = "fr"]
    Fr(Option<Element>),
    #[doc = "Frysian"]
    #[code = "fy"]
    Fy(Option<Element>),
    #[doc = "Hindi"]
    #[code = "hi"]
    Hi(Option<Element>),
    #[doc = "Croatian"]
    #[code = "hr"]
    Hr(Option<Element>),
    #[doc = "Italian"]
    #[code = "it"]
    It(Option<Element>),
    #[doc = "Japanese"]
    #[code = "ja"]
    Ja(Option<Element>),
    #[doc = "Korean"]
    #[code = "ko"]
    Ko(Option<Element>),
    #[doc = "Dutch"]
    #[code = "nl"]
    Nl(Option<Element>),
    #[doc = "Norwegian"]
    #[code = "no"]
    No(Option<Element>),
    #[doc = "Punjabi"]
    #[code = "pa"]
    Pa(Option<Element>),
    #[doc = "Polish"]
    #[code = "pl"]
    Pl(Option<Element>),
    #[doc = "Portuguese"]
    #[code = "pt"]
    Pt(Option<Element>),
    #[doc = "Russian"]
    #[code = "ru"]
    Ru(Option<Element>),
    #[doc = "Serbian"]
    #[code = "sr"]
    Sr(Option<Element>),
    #[doc = "Swedish"]
    #[code = "sv"]
    Sv(Option<Element>),
    #[doc = "Telegu"]
    #[code = "te"]
    Te(Option<Element>),
    #[doc = "Chinese"]
    #[code = "zh"]
    Zh(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for WrittenLanguage {
    fn default() -> Self {
        WrittenLanguage::Null(None)
    }
}
impl TryFrom<String> for WrittenLanguage {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ar" => Ok(WrittenLanguage::Ar(None)),
            "bn" => Ok(WrittenLanguage::Bn(None)),
            "cs" => Ok(WrittenLanguage::Cs(None)),
            "da" => Ok(WrittenLanguage::Da(None)),
            "de" => Ok(WrittenLanguage::De(None)),
            "el" => Ok(WrittenLanguage::El(None)),
            "en" => Ok(WrittenLanguage::En(None)),
            "es" => Ok(WrittenLanguage::Es(None)),
            "fi" => Ok(WrittenLanguage::Fi(None)),
            "fr" => Ok(WrittenLanguage::Fr(None)),
            "fy" => Ok(WrittenLanguage::Fy(None)),
            "hi" => Ok(WrittenLanguage::Hi(None)),
            "hr" => Ok(WrittenLanguage::Hr(None)),
            "it" => Ok(WrittenLanguage::It(None)),
            "ja" => Ok(WrittenLanguage::Ja(None)),
            "ko" => Ok(WrittenLanguage::Ko(None)),
            "nl" => Ok(WrittenLanguage::Nl(None)),
            "no" => Ok(WrittenLanguage::No(None)),
            "pa" => Ok(WrittenLanguage::Pa(None)),
            "pl" => Ok(WrittenLanguage::Pl(None)),
            "pt" => Ok(WrittenLanguage::Pt(None)),
            "ru" => Ok(WrittenLanguage::Ru(None)),
            "sr" => Ok(WrittenLanguage::Sr(None)),
            "sv" => Ok(WrittenLanguage::Sv(None)),
            "te" => Ok(WrittenLanguage::Te(None)),
            "zh" => Ok(WrittenLanguage::Zh(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &WrittenLanguage {
    fn into(self) -> Option<String> {
        match self {
            WrittenLanguage::Ar(_) => Some("ar".to_string()),
            WrittenLanguage::Bn(_) => Some("bn".to_string()),
            WrittenLanguage::Cs(_) => Some("cs".to_string()),
            WrittenLanguage::Da(_) => Some("da".to_string()),
            WrittenLanguage::De(_) => Some("de".to_string()),
            WrittenLanguage::El(_) => Some("el".to_string()),
            WrittenLanguage::En(_) => Some("en".to_string()),
            WrittenLanguage::Es(_) => Some("es".to_string()),
            WrittenLanguage::Fi(_) => Some("fi".to_string()),
            WrittenLanguage::Fr(_) => Some("fr".to_string()),
            WrittenLanguage::Fy(_) => Some("fy".to_string()),
            WrittenLanguage::Hi(_) => Some("hi".to_string()),
            WrittenLanguage::Hr(_) => Some("hr".to_string()),
            WrittenLanguage::It(_) => Some("it".to_string()),
            WrittenLanguage::Ja(_) => Some("ja".to_string()),
            WrittenLanguage::Ko(_) => Some("ko".to_string()),
            WrittenLanguage::Nl(_) => Some("nl".to_string()),
            WrittenLanguage::No(_) => Some("no".to_string()),
            WrittenLanguage::Pa(_) => Some("pa".to_string()),
            WrittenLanguage::Pl(_) => Some("pl".to_string()),
            WrittenLanguage::Pt(_) => Some("pt".to_string()),
            WrittenLanguage::Ru(_) => Some("ru".to_string()),
            WrittenLanguage::Sr(_) => Some("sr".to_string()),
            WrittenLanguage::Sv(_) => Some("sv".to_string()),
            WrittenLanguage::Te(_) => Some("te".to_string()),
            WrittenLanguage::Zh(_) => Some("zh".to_string()),
            WrittenLanguage::Null(_) => None,
        }
    }
}
impl MetaValue for WrittenLanguage {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                WrittenLanguage::Ar(Some(e)) => e.get_field(field),
                WrittenLanguage::Bn(Some(e)) => e.get_field(field),
                WrittenLanguage::Cs(Some(e)) => e.get_field(field),
                WrittenLanguage::Da(Some(e)) => e.get_field(field),
                WrittenLanguage::De(Some(e)) => e.get_field(field),
                WrittenLanguage::El(Some(e)) => e.get_field(field),
                WrittenLanguage::En(Some(e)) => e.get_field(field),
                WrittenLanguage::Es(Some(e)) => e.get_field(field),
                WrittenLanguage::Fi(Some(e)) => e.get_field(field),
                WrittenLanguage::Fr(Some(e)) => e.get_field(field),
                WrittenLanguage::Fy(Some(e)) => e.get_field(field),
                WrittenLanguage::Hi(Some(e)) => e.get_field(field),
                WrittenLanguage::Hr(Some(e)) => e.get_field(field),
                WrittenLanguage::It(Some(e)) => e.get_field(field),
                WrittenLanguage::Ja(Some(e)) => e.get_field(field),
                WrittenLanguage::Ko(Some(e)) => e.get_field(field),
                WrittenLanguage::Nl(Some(e)) => e.get_field(field),
                WrittenLanguage::No(Some(e)) => e.get_field(field),
                WrittenLanguage::Pa(Some(e)) => e.get_field(field),
                WrittenLanguage::Pl(Some(e)) => e.get_field(field),
                WrittenLanguage::Pt(Some(e)) => e.get_field(field),
                WrittenLanguage::Ru(Some(e)) => e.get_field(field),
                WrittenLanguage::Sr(Some(e)) => e.get_field(field),
                WrittenLanguage::Sv(Some(e)) => e.get_field(field),
                WrittenLanguage::Te(Some(e)) => e.get_field(field),
                WrittenLanguage::Zh(Some(e)) => e.get_field(field),
                WrittenLanguage::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                WrittenLanguage::Ar(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Bn(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Cs(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Da(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::De(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::El(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::En(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Es(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Fi(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Fr(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Fy(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Hi(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Hr(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::It(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Ja(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Ko(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Nl(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::No(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Pa(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Pl(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Pt(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Ru(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Sr(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Sv(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Te(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Zh(Some(e)) => e.get_field_mut(field),
                WrittenLanguage::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AcknowledgementCondition {
    #[doc = "Always"]
    #[code = "AL"]
    AL(Option<Element>),
    #[doc = "Error/reject only"]
    #[code = "ER"]
    ER(Option<Element>),
    #[doc = "Never"]
    #[code = "NE"]
    NE(Option<Element>),
    #[doc = "Successful only"]
    #[code = "SU"]
    SU(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AcknowledgementCondition {
    fn default() -> Self {
        V3AcknowledgementCondition::Null(None)
    }
}
impl TryFrom<String> for V3AcknowledgementCondition {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AL" => Ok(V3AcknowledgementCondition::AL(None)),
            "ER" => Ok(V3AcknowledgementCondition::ER(None)),
            "NE" => Ok(V3AcknowledgementCondition::NE(None)),
            "SU" => Ok(V3AcknowledgementCondition::SU(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AcknowledgementCondition {
    fn into(self) -> Option<String> {
        match self {
            V3AcknowledgementCondition::AL(_) => Some("AL".to_string()),
            V3AcknowledgementCondition::ER(_) => Some("ER".to_string()),
            V3AcknowledgementCondition::NE(_) => Some("NE".to_string()),
            V3AcknowledgementCondition::SU(_) => Some("SU".to_string()),
            V3AcknowledgementCondition::Null(_) => None,
        }
    }
}
impl MetaValue for V3AcknowledgementCondition {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AcknowledgementCondition::AL(Some(e)) => e.get_field(field),
                V3AcknowledgementCondition::ER(Some(e)) => e.get_field(field),
                V3AcknowledgementCondition::NE(Some(e)) => e.get_field(field),
                V3AcknowledgementCondition::SU(Some(e)) => e.get_field(field),
                V3AcknowledgementCondition::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AcknowledgementCondition::AL(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementCondition::ER(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementCondition::NE(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementCondition::SU(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementCondition::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AcknowledgementDetailCode {
    #[doc = "Internal system error"]
    #[code = "INTERR"]
    INTERR(Option<Element>),
    #[doc = "No storage space for message."]
    #[code = "NOSTORE"]
    NOSTORE(Option<Element>),
    #[doc = "Unsupported interaction"]
    #[code = "NS200"]
    NS200(Option<Element>),
    #[doc = "Unsupported processing id"]
    #[code = "NS202"]
    NS202(Option<Element>),
    #[doc = "Unsupported version id"]
    #[code = "NS203"]
    NS203(Option<Element>),
    #[doc = "Unsupported processing Mode"]
    #[code = "NS250"]
    NS250(Option<Element>),
    #[doc = "Unknown sender"]
    #[code = "NS260"]
    NS260(Option<Element>),
    #[doc = "Unrecognized attentionline"]
    #[code = "NS261"]
    NS261(Option<Element>),
    #[doc = "Message routing error, destination unreachable."]
    #[code = "RTEDEST"]
    RTEDEST(Option<Element>),
    #[doc = "Error: Message routing error, unknown destination."]
    #[code = "RTUDEST"]
    RTUDEST(Option<Element>),
    #[doc = "Message routing warning, destination unreachable."]
    #[code = "RTWDEST"]
    RTWDEST(Option<Element>),
    #[doc = "Syntax error"]
    #[code = "SYN"]
    SYN(Option<Element>),
    #[doc = "Required association missing"]
    #[code = "SYN100"]
    SYN100(Option<Element>),
    #[doc = "Required attribute missing"]
    #[code = "SYN101"]
    SYN101(Option<Element>),
    #[doc = "Data type error"]
    #[code = "SYN102"]
    SYN102(Option<Element>),
    #[doc = "Value not found in code system"]
    #[code = "SYN103"]
    SYN103(Option<Element>),
    #[doc = "Invalid code system in CNE"]
    #[code = "SYN104"]
    SYN104(Option<Element>),
    #[doc = "Required element missing"]
    #[code = "SYN105"]
    SYN105(Option<Element>),
    #[doc = "Terminology error"]
    #[code = "SYN106"]
    SYN106(Option<Element>),
    #[doc = "Deprecated code"]
    #[code = "SYN107"]
    SYN107(Option<Element>),
    #[doc = "Number of repetitions exceeds limit"]
    #[code = "SYN108"]
    SYN108(Option<Element>),
    #[doc = "Mandatory element with null value"]
    #[code = "SYN109"]
    SYN109(Option<Element>),
    #[doc = "Number of association repetitions exceeds limit"]
    #[code = "SYN110"]
    SYN110(Option<Element>),
    #[doc = "Value does not match fixed value"]
    #[code = "SYN111"]
    SYN111(Option<Element>),
    #[doc = "Number of attribute repetitions exceeds limit"]
    #[code = "SYN112"]
    SYN112(Option<Element>),
    #[doc = "Formal constraint violation"]
    #[code = "SYN113"]
    SYN113(Option<Element>),
    #[doc = "Insufficient repetitions"]
    #[code = "SYN114"]
    SYN114(Option<Element>),
    #[doc = "AcknowledgementDetailNotSupportedCode"]
    #[code = "_AcknowledgementDetailNotSupportedCode"]
    _AcknowledgementDetailNotSupportedCode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AcknowledgementDetailCode {
    fn default() -> Self {
        V3AcknowledgementDetailCode::Null(None)
    }
}
impl TryFrom<String> for V3AcknowledgementDetailCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "INTERR" => Ok(V3AcknowledgementDetailCode::INTERR(None)),
            "NOSTORE" => Ok(V3AcknowledgementDetailCode::NOSTORE(None)),
            "NS200" => Ok(V3AcknowledgementDetailCode::NS200(None)),
            "NS202" => Ok(V3AcknowledgementDetailCode::NS202(None)),
            "NS203" => Ok(V3AcknowledgementDetailCode::NS203(None)),
            "NS250" => Ok(V3AcknowledgementDetailCode::NS250(None)),
            "NS260" => Ok(V3AcknowledgementDetailCode::NS260(None)),
            "NS261" => Ok(V3AcknowledgementDetailCode::NS261(None)),
            "RTEDEST" => Ok(V3AcknowledgementDetailCode::RTEDEST(None)),
            "RTUDEST" => Ok(V3AcknowledgementDetailCode::RTUDEST(None)),
            "RTWDEST" => Ok(V3AcknowledgementDetailCode::RTWDEST(None)),
            "SYN" => Ok(V3AcknowledgementDetailCode::SYN(None)),
            "SYN100" => Ok(V3AcknowledgementDetailCode::SYN100(None)),
            "SYN101" => Ok(V3AcknowledgementDetailCode::SYN101(None)),
            "SYN102" => Ok(V3AcknowledgementDetailCode::SYN102(None)),
            "SYN103" => Ok(V3AcknowledgementDetailCode::SYN103(None)),
            "SYN104" => Ok(V3AcknowledgementDetailCode::SYN104(None)),
            "SYN105" => Ok(V3AcknowledgementDetailCode::SYN105(None)),
            "SYN106" => Ok(V3AcknowledgementDetailCode::SYN106(None)),
            "SYN107" => Ok(V3AcknowledgementDetailCode::SYN107(None)),
            "SYN108" => Ok(V3AcknowledgementDetailCode::SYN108(None)),
            "SYN109" => Ok(V3AcknowledgementDetailCode::SYN109(None)),
            "SYN110" => Ok(V3AcknowledgementDetailCode::SYN110(None)),
            "SYN111" => Ok(V3AcknowledgementDetailCode::SYN111(None)),
            "SYN112" => Ok(V3AcknowledgementDetailCode::SYN112(None)),
            "SYN113" => Ok(V3AcknowledgementDetailCode::SYN113(None)),
            "SYN114" => Ok(V3AcknowledgementDetailCode::SYN114(None)),
            "_AcknowledgementDetailNotSupportedCode" => {
                Ok(V3AcknowledgementDetailCode::_AcknowledgementDetailNotSupportedCode(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AcknowledgementDetailCode {
    fn into(self) -> Option<String> {
        match self {
            V3AcknowledgementDetailCode::INTERR(_) => Some("INTERR".to_string()),
            V3AcknowledgementDetailCode::NOSTORE(_) => Some("NOSTORE".to_string()),
            V3AcknowledgementDetailCode::NS200(_) => Some("NS200".to_string()),
            V3AcknowledgementDetailCode::NS202(_) => Some("NS202".to_string()),
            V3AcknowledgementDetailCode::NS203(_) => Some("NS203".to_string()),
            V3AcknowledgementDetailCode::NS250(_) => Some("NS250".to_string()),
            V3AcknowledgementDetailCode::NS260(_) => Some("NS260".to_string()),
            V3AcknowledgementDetailCode::NS261(_) => Some("NS261".to_string()),
            V3AcknowledgementDetailCode::RTEDEST(_) => Some("RTEDEST".to_string()),
            V3AcknowledgementDetailCode::RTUDEST(_) => Some("RTUDEST".to_string()),
            V3AcknowledgementDetailCode::RTWDEST(_) => Some("RTWDEST".to_string()),
            V3AcknowledgementDetailCode::SYN(_) => Some("SYN".to_string()),
            V3AcknowledgementDetailCode::SYN100(_) => Some("SYN100".to_string()),
            V3AcknowledgementDetailCode::SYN101(_) => Some("SYN101".to_string()),
            V3AcknowledgementDetailCode::SYN102(_) => Some("SYN102".to_string()),
            V3AcknowledgementDetailCode::SYN103(_) => Some("SYN103".to_string()),
            V3AcknowledgementDetailCode::SYN104(_) => Some("SYN104".to_string()),
            V3AcknowledgementDetailCode::SYN105(_) => Some("SYN105".to_string()),
            V3AcknowledgementDetailCode::SYN106(_) => Some("SYN106".to_string()),
            V3AcknowledgementDetailCode::SYN107(_) => Some("SYN107".to_string()),
            V3AcknowledgementDetailCode::SYN108(_) => Some("SYN108".to_string()),
            V3AcknowledgementDetailCode::SYN109(_) => Some("SYN109".to_string()),
            V3AcknowledgementDetailCode::SYN110(_) => Some("SYN110".to_string()),
            V3AcknowledgementDetailCode::SYN111(_) => Some("SYN111".to_string()),
            V3AcknowledgementDetailCode::SYN112(_) => Some("SYN112".to_string()),
            V3AcknowledgementDetailCode::SYN113(_) => Some("SYN113".to_string()),
            V3AcknowledgementDetailCode::SYN114(_) => Some("SYN114".to_string()),
            V3AcknowledgementDetailCode::_AcknowledgementDetailNotSupportedCode(_) => {
                Some("_AcknowledgementDetailNotSupportedCode".to_string())
            }
            V3AcknowledgementDetailCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3AcknowledgementDetailCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AcknowledgementDetailCode::INTERR(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NOSTORE(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS200(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS202(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS203(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS250(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS260(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::NS261(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::RTEDEST(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::RTUDEST(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::RTWDEST(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN100(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN101(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN102(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN103(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN104(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN105(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN106(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN107(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN108(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN109(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN110(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN111(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN112(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN113(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::SYN114(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailCode::_AcknowledgementDetailNotSupportedCode(Some(e)) => {
                    e.get_field(field)
                }
                V3AcknowledgementDetailCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AcknowledgementDetailCode::INTERR(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NOSTORE(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS200(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS202(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS203(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS250(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS260(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::NS261(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::RTEDEST(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::RTUDEST(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::RTWDEST(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN100(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN101(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN102(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN103(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN104(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN105(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN106(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN107(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN108(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN109(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN110(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN111(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN112(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN113(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::SYN114(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailCode::_AcknowledgementDetailNotSupportedCode(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3AcknowledgementDetailCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AcknowledgementDetailType {
    #[doc = "Error"]
    #[code = "E"]
    E(Option<Element>),
    #[code = "ERR"]
    ERR(Option<Element>),
    #[doc = "Information"]
    #[code = "I"]
    I(Option<Element>),
    #[code = "INFO"]
    INFO(Option<Element>),
    #[doc = "Warning"]
    #[code = "W"]
    W(Option<Element>),
    #[code = "WARN"]
    WARN(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AcknowledgementDetailType {
    fn default() -> Self {
        V3AcknowledgementDetailType::Null(None)
    }
}
impl TryFrom<String> for V3AcknowledgementDetailType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "E" => Ok(V3AcknowledgementDetailType::E(None)),
            "ERR" => Ok(V3AcknowledgementDetailType::ERR(None)),
            "I" => Ok(V3AcknowledgementDetailType::I(None)),
            "INFO" => Ok(V3AcknowledgementDetailType::INFO(None)),
            "W" => Ok(V3AcknowledgementDetailType::W(None)),
            "WARN" => Ok(V3AcknowledgementDetailType::WARN(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AcknowledgementDetailType {
    fn into(self) -> Option<String> {
        match self {
            V3AcknowledgementDetailType::E(_) => Some("E".to_string()),
            V3AcknowledgementDetailType::ERR(_) => Some("ERR".to_string()),
            V3AcknowledgementDetailType::I(_) => Some("I".to_string()),
            V3AcknowledgementDetailType::INFO(_) => Some("INFO".to_string()),
            V3AcknowledgementDetailType::W(_) => Some("W".to_string()),
            V3AcknowledgementDetailType::WARN(_) => Some("WARN".to_string()),
            V3AcknowledgementDetailType::Null(_) => None,
        }
    }
}
impl MetaValue for V3AcknowledgementDetailType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AcknowledgementDetailType::E(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::ERR(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::I(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::INFO(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::W(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::WARN(Some(e)) => e.get_field(field),
                V3AcknowledgementDetailType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AcknowledgementDetailType::E(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::ERR(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::I(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::INFO(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::W(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::WARN(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementDetailType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AcknowledgementType {
    #[doc = "Application Acknowledgement Accept"]
    #[code = "AA"]
    AA(Option<Element>),
    #[doc = "Application Acknowledgement Error"]
    #[code = "AE"]
    AE(Option<Element>),
    #[doc = "Application Acknowledgement Reject"]
    #[code = "AR"]
    AR(Option<Element>),
    #[doc = "Accept Acknowledgement Commit Accept"]
    #[code = "CA"]
    CA(Option<Element>),
    #[doc = "Accept Acknowledgement Commit Error"]
    #[code = "CE"]
    CE(Option<Element>),
    #[doc = "Accept Acknowledgement Commit Reject"]
    #[code = "CR"]
    CR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AcknowledgementType {
    fn default() -> Self {
        V3AcknowledgementType::Null(None)
    }
}
impl TryFrom<String> for V3AcknowledgementType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AA" => Ok(V3AcknowledgementType::AA(None)),
            "AE" => Ok(V3AcknowledgementType::AE(None)),
            "AR" => Ok(V3AcknowledgementType::AR(None)),
            "CA" => Ok(V3AcknowledgementType::CA(None)),
            "CE" => Ok(V3AcknowledgementType::CE(None)),
            "CR" => Ok(V3AcknowledgementType::CR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AcknowledgementType {
    fn into(self) -> Option<String> {
        match self {
            V3AcknowledgementType::AA(_) => Some("AA".to_string()),
            V3AcknowledgementType::AE(_) => Some("AE".to_string()),
            V3AcknowledgementType::AR(_) => Some("AR".to_string()),
            V3AcknowledgementType::CA(_) => Some("CA".to_string()),
            V3AcknowledgementType::CE(_) => Some("CE".to_string()),
            V3AcknowledgementType::CR(_) => Some("CR".to_string()),
            V3AcknowledgementType::Null(_) => None,
        }
    }
}
impl MetaValue for V3AcknowledgementType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AcknowledgementType::AA(Some(e)) => e.get_field(field),
                V3AcknowledgementType::AE(Some(e)) => e.get_field(field),
                V3AcknowledgementType::AR(Some(e)) => e.get_field(field),
                V3AcknowledgementType::CA(Some(e)) => e.get_field(field),
                V3AcknowledgementType::CE(Some(e)) => e.get_field(field),
                V3AcknowledgementType::CR(Some(e)) => e.get_field(field),
                V3AcknowledgementType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AcknowledgementType::AA(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::AE(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::AR(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::CA(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::CE(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::CR(Some(e)) => e.get_field_mut(field),
                V3AcknowledgementType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActExposureLevelCode {
    #[doc = "high"]
    #[code = "HIGH"]
    HIGH(Option<Element>),
    #[doc = "low"]
    #[code = "LOW"]
    LOW(Option<Element>),
    #[doc = "medium"]
    #[code = "MEDIUM"]
    MEDIUM(Option<Element>),
    #[doc = "ActExposureLevelCode"]
    #[code = "_ActExposureLevelCode"]
    _ActExposureLevelCode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActExposureLevelCode {
    fn default() -> Self {
        V3ActExposureLevelCode::Null(None)
    }
}
impl TryFrom<String> for V3ActExposureLevelCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "HIGH" => Ok(V3ActExposureLevelCode::HIGH(None)),
            "LOW" => Ok(V3ActExposureLevelCode::LOW(None)),
            "MEDIUM" => Ok(V3ActExposureLevelCode::MEDIUM(None)),
            "_ActExposureLevelCode" => Ok(V3ActExposureLevelCode::_ActExposureLevelCode(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActExposureLevelCode {
    fn into(self) -> Option<String> {
        match self {
            V3ActExposureLevelCode::HIGH(_) => Some("HIGH".to_string()),
            V3ActExposureLevelCode::LOW(_) => Some("LOW".to_string()),
            V3ActExposureLevelCode::MEDIUM(_) => Some("MEDIUM".to_string()),
            V3ActExposureLevelCode::_ActExposureLevelCode(_) => {
                Some("_ActExposureLevelCode".to_string())
            }
            V3ActExposureLevelCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActExposureLevelCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActExposureLevelCode::HIGH(Some(e)) => e.get_field(field),
                V3ActExposureLevelCode::LOW(Some(e)) => e.get_field(field),
                V3ActExposureLevelCode::MEDIUM(Some(e)) => e.get_field(field),
                V3ActExposureLevelCode::_ActExposureLevelCode(Some(e)) => e.get_field(field),
                V3ActExposureLevelCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActExposureLevelCode::HIGH(Some(e)) => e.get_field_mut(field),
                V3ActExposureLevelCode::LOW(Some(e)) => e.get_field_mut(field),
                V3ActExposureLevelCode::MEDIUM(Some(e)) => e.get_field_mut(field),
                V3ActExposureLevelCode::_ActExposureLevelCode(Some(e)) => e.get_field_mut(field),
                V3ActExposureLevelCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActInvoiceElementModifier {
    #[doc = "Electronic Form To Follow"]
    #[code = "EFORM"]
    EFORM(Option<Element>),
    #[doc = "Fax To Follow"]
    #[code = "FAX"]
    FAX(Option<Element>),
    #[doc = "Last Invoice"]
    #[code = "LINV"]
    LINV(Option<Element>),
    #[doc = "Paper Documentation To Follow"]
    #[code = "PAPER"]
    PAPER(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActInvoiceElementModifier {
    fn default() -> Self {
        V3ActInvoiceElementModifier::Null(None)
    }
}
impl TryFrom<String> for V3ActInvoiceElementModifier {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "EFORM" => Ok(V3ActInvoiceElementModifier::EFORM(None)),
            "FAX" => Ok(V3ActInvoiceElementModifier::FAX(None)),
            "LINV" => Ok(V3ActInvoiceElementModifier::LINV(None)),
            "PAPER" => Ok(V3ActInvoiceElementModifier::PAPER(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActInvoiceElementModifier {
    fn into(self) -> Option<String> {
        match self {
            V3ActInvoiceElementModifier::EFORM(_) => Some("EFORM".to_string()),
            V3ActInvoiceElementModifier::FAX(_) => Some("FAX".to_string()),
            V3ActInvoiceElementModifier::LINV(_) => Some("LINV".to_string()),
            V3ActInvoiceElementModifier::PAPER(_) => Some("PAPER".to_string()),
            V3ActInvoiceElementModifier::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActInvoiceElementModifier {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActInvoiceElementModifier::EFORM(Some(e)) => e.get_field(field),
                V3ActInvoiceElementModifier::FAX(Some(e)) => e.get_field(field),
                V3ActInvoiceElementModifier::LINV(Some(e)) => e.get_field(field),
                V3ActInvoiceElementModifier::PAPER(Some(e)) => e.get_field(field),
                V3ActInvoiceElementModifier::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActInvoiceElementModifier::EFORM(Some(e)) => e.get_field_mut(field),
                V3ActInvoiceElementModifier::FAX(Some(e)) => e.get_field_mut(field),
                V3ActInvoiceElementModifier::LINV(Some(e)) => e.get_field_mut(field),
                V3ActInvoiceElementModifier::PAPER(Some(e)) => e.get_field_mut(field),
                V3ActInvoiceElementModifier::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActMood {
    #[doc = "appointment"]
    #[code = "APT"]
    APT(Option<Element>),
    #[doc = "appointment request"]
    #[code = "ARQ"]
    ARQ(Option<Element>),
    #[doc = "criterion"]
    #[code = "CRT"]
    CRT(Option<Element>),
    #[doc = "definition"]
    #[code = "DEF"]
    DEF(Option<Element>),
    #[doc = "event (occurrence)"]
    #[code = "EVN"]
    EVN(Option<Element>),
    #[doc = "event criterion"]
    #[code = "EVN.CRT"]
    EVNCRT(Option<Element>),
    #[doc = "expectation"]
    #[code = "EXPEC"]
    EXPEC(Option<Element>),
    #[doc = "Goal"]
    #[code = "GOL"]
    GOL(Option<Element>),
    #[doc = "goal criterion"]
    #[code = "GOL.CRT"]
    GOLCRT(Option<Element>),
    #[doc = "intent"]
    #[code = "INT"]
    INT(Option<Element>),
    #[doc = "intent criterion"]
    #[code = "INT.CRT"]
    INTCRT(Option<Element>),
    #[doc = "option"]
    #[code = "OPT"]
    OPT(Option<Element>),
    #[doc = "permission"]
    #[code = "PERM"]
    PERM(Option<Element>),
    #[doc = "permission request"]
    #[code = "PERMRQ"]
    PERMRQ(Option<Element>),
    #[doc = "promise"]
    #[code = "PRMS"]
    PRMS(Option<Element>),
    #[doc = "promise criterion"]
    #[code = "PRMS.CRT"]
    PRMSCRT(Option<Element>),
    #[doc = "proposal"]
    #[code = "PRP"]
    PRP(Option<Element>),
    #[doc = "recommendation"]
    #[code = "RMD"]
    RMD(Option<Element>),
    #[doc = "request"]
    #[code = "RQO"]
    RQO(Option<Element>),
    #[doc = "request criterion"]
    #[code = "RQO.CRT"]
    RQOCRT(Option<Element>),
    #[doc = "risk"]
    #[code = "RSK"]
    RSK(Option<Element>),
    #[doc = "risk criterion"]
    #[code = "RSK.CRT"]
    RSKCRT(Option<Element>),
    #[doc = "resource slot"]
    #[code = "SLOT"]
    SLOT(Option<Element>),
    #[doc = "act request"]
    #[code = "_ActMoodActRequest"]
    _ActMoodActRequest(Option<Element>),
    #[doc = "ActMoodCompletionTrack"]
    #[code = "_ActMoodCompletionTrack"]
    _ActMoodCompletionTrack(Option<Element>),
    #[doc = "desire"]
    #[code = "_ActMoodDesire"]
    _ActMoodDesire(Option<Element>),
    #[doc = "potential"]
    #[code = "_ActMoodPotential"]
    _ActMoodPotential(Option<Element>),
    #[doc = "ActMoodPredicate"]
    #[code = "_ActMoodPredicate"]
    _ActMoodPredicate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActMood {
    fn default() -> Self {
        V3ActMood::Null(None)
    }
}
impl TryFrom<String> for V3ActMood {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "APT" => Ok(V3ActMood::APT(None)),
            "ARQ" => Ok(V3ActMood::ARQ(None)),
            "CRT" => Ok(V3ActMood::CRT(None)),
            "DEF" => Ok(V3ActMood::DEF(None)),
            "EVN" => Ok(V3ActMood::EVN(None)),
            "EVN.CRT" => Ok(V3ActMood::EVNCRT(None)),
            "EXPEC" => Ok(V3ActMood::EXPEC(None)),
            "GOL" => Ok(V3ActMood::GOL(None)),
            "GOL.CRT" => Ok(V3ActMood::GOLCRT(None)),
            "INT" => Ok(V3ActMood::INT(None)),
            "INT.CRT" => Ok(V3ActMood::INTCRT(None)),
            "OPT" => Ok(V3ActMood::OPT(None)),
            "PERM" => Ok(V3ActMood::PERM(None)),
            "PERMRQ" => Ok(V3ActMood::PERMRQ(None)),
            "PRMS" => Ok(V3ActMood::PRMS(None)),
            "PRMS.CRT" => Ok(V3ActMood::PRMSCRT(None)),
            "PRP" => Ok(V3ActMood::PRP(None)),
            "RMD" => Ok(V3ActMood::RMD(None)),
            "RQO" => Ok(V3ActMood::RQO(None)),
            "RQO.CRT" => Ok(V3ActMood::RQOCRT(None)),
            "RSK" => Ok(V3ActMood::RSK(None)),
            "RSK.CRT" => Ok(V3ActMood::RSKCRT(None)),
            "SLOT" => Ok(V3ActMood::SLOT(None)),
            "_ActMoodActRequest" => Ok(V3ActMood::_ActMoodActRequest(None)),
            "_ActMoodCompletionTrack" => Ok(V3ActMood::_ActMoodCompletionTrack(None)),
            "_ActMoodDesire" => Ok(V3ActMood::_ActMoodDesire(None)),
            "_ActMoodPotential" => Ok(V3ActMood::_ActMoodPotential(None)),
            "_ActMoodPredicate" => Ok(V3ActMood::_ActMoodPredicate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActMood {
    fn into(self) -> Option<String> {
        match self {
            V3ActMood::APT(_) => Some("APT".to_string()),
            V3ActMood::ARQ(_) => Some("ARQ".to_string()),
            V3ActMood::CRT(_) => Some("CRT".to_string()),
            V3ActMood::DEF(_) => Some("DEF".to_string()),
            V3ActMood::EVN(_) => Some("EVN".to_string()),
            V3ActMood::EVNCRT(_) => Some("EVN.CRT".to_string()),
            V3ActMood::EXPEC(_) => Some("EXPEC".to_string()),
            V3ActMood::GOL(_) => Some("GOL".to_string()),
            V3ActMood::GOLCRT(_) => Some("GOL.CRT".to_string()),
            V3ActMood::INT(_) => Some("INT".to_string()),
            V3ActMood::INTCRT(_) => Some("INT.CRT".to_string()),
            V3ActMood::OPT(_) => Some("OPT".to_string()),
            V3ActMood::PERM(_) => Some("PERM".to_string()),
            V3ActMood::PERMRQ(_) => Some("PERMRQ".to_string()),
            V3ActMood::PRMS(_) => Some("PRMS".to_string()),
            V3ActMood::PRMSCRT(_) => Some("PRMS.CRT".to_string()),
            V3ActMood::PRP(_) => Some("PRP".to_string()),
            V3ActMood::RMD(_) => Some("RMD".to_string()),
            V3ActMood::RQO(_) => Some("RQO".to_string()),
            V3ActMood::RQOCRT(_) => Some("RQO.CRT".to_string()),
            V3ActMood::RSK(_) => Some("RSK".to_string()),
            V3ActMood::RSKCRT(_) => Some("RSK.CRT".to_string()),
            V3ActMood::SLOT(_) => Some("SLOT".to_string()),
            V3ActMood::_ActMoodActRequest(_) => Some("_ActMoodActRequest".to_string()),
            V3ActMood::_ActMoodCompletionTrack(_) => Some("_ActMoodCompletionTrack".to_string()),
            V3ActMood::_ActMoodDesire(_) => Some("_ActMoodDesire".to_string()),
            V3ActMood::_ActMoodPotential(_) => Some("_ActMoodPotential".to_string()),
            V3ActMood::_ActMoodPredicate(_) => Some("_ActMoodPredicate".to_string()),
            V3ActMood::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActMood {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActMood::APT(Some(e)) => e.get_field(field),
                V3ActMood::ARQ(Some(e)) => e.get_field(field),
                V3ActMood::CRT(Some(e)) => e.get_field(field),
                V3ActMood::DEF(Some(e)) => e.get_field(field),
                V3ActMood::EVN(Some(e)) => e.get_field(field),
                V3ActMood::EVNCRT(Some(e)) => e.get_field(field),
                V3ActMood::EXPEC(Some(e)) => e.get_field(field),
                V3ActMood::GOL(Some(e)) => e.get_field(field),
                V3ActMood::GOLCRT(Some(e)) => e.get_field(field),
                V3ActMood::INT(Some(e)) => e.get_field(field),
                V3ActMood::INTCRT(Some(e)) => e.get_field(field),
                V3ActMood::OPT(Some(e)) => e.get_field(field),
                V3ActMood::PERM(Some(e)) => e.get_field(field),
                V3ActMood::PERMRQ(Some(e)) => e.get_field(field),
                V3ActMood::PRMS(Some(e)) => e.get_field(field),
                V3ActMood::PRMSCRT(Some(e)) => e.get_field(field),
                V3ActMood::PRP(Some(e)) => e.get_field(field),
                V3ActMood::RMD(Some(e)) => e.get_field(field),
                V3ActMood::RQO(Some(e)) => e.get_field(field),
                V3ActMood::RQOCRT(Some(e)) => e.get_field(field),
                V3ActMood::RSK(Some(e)) => e.get_field(field),
                V3ActMood::RSKCRT(Some(e)) => e.get_field(field),
                V3ActMood::SLOT(Some(e)) => e.get_field(field),
                V3ActMood::_ActMoodActRequest(Some(e)) => e.get_field(field),
                V3ActMood::_ActMoodCompletionTrack(Some(e)) => e.get_field(field),
                V3ActMood::_ActMoodDesire(Some(e)) => e.get_field(field),
                V3ActMood::_ActMoodPotential(Some(e)) => e.get_field(field),
                V3ActMood::_ActMoodPredicate(Some(e)) => e.get_field(field),
                V3ActMood::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActMood::APT(Some(e)) => e.get_field_mut(field),
                V3ActMood::ARQ(Some(e)) => e.get_field_mut(field),
                V3ActMood::CRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::DEF(Some(e)) => e.get_field_mut(field),
                V3ActMood::EVN(Some(e)) => e.get_field_mut(field),
                V3ActMood::EVNCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::EXPEC(Some(e)) => e.get_field_mut(field),
                V3ActMood::GOL(Some(e)) => e.get_field_mut(field),
                V3ActMood::GOLCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::INT(Some(e)) => e.get_field_mut(field),
                V3ActMood::INTCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::OPT(Some(e)) => e.get_field_mut(field),
                V3ActMood::PERM(Some(e)) => e.get_field_mut(field),
                V3ActMood::PERMRQ(Some(e)) => e.get_field_mut(field),
                V3ActMood::PRMS(Some(e)) => e.get_field_mut(field),
                V3ActMood::PRMSCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::PRP(Some(e)) => e.get_field_mut(field),
                V3ActMood::RMD(Some(e)) => e.get_field_mut(field),
                V3ActMood::RQO(Some(e)) => e.get_field_mut(field),
                V3ActMood::RQOCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::RSK(Some(e)) => e.get_field_mut(field),
                V3ActMood::RSKCRT(Some(e)) => e.get_field_mut(field),
                V3ActMood::SLOT(Some(e)) => e.get_field_mut(field),
                V3ActMood::_ActMoodActRequest(Some(e)) => e.get_field_mut(field),
                V3ActMood::_ActMoodCompletionTrack(Some(e)) => e.get_field_mut(field),
                V3ActMood::_ActMoodDesire(Some(e)) => e.get_field_mut(field),
                V3ActMood::_ActMoodPotential(Some(e)) => e.get_field_mut(field),
                V3ActMood::_ActMoodPredicate(Some(e)) => e.get_field_mut(field),
                V3ActMood::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActMoodIntent {
    #[doc = "appointment"]
    #[code = "APT"]
    APT(Option<Element>),
    #[doc = "appointment request"]
    #[code = "ARQ"]
    ARQ(Option<Element>),
    #[doc = "criterion"]
    #[code = "CRT"]
    CRT(Option<Element>),
    #[doc = "definition"]
    #[code = "DEF"]
    DEF(Option<Element>),
    #[doc = "event (occurrence)"]
    #[code = "EVN"]
    EVN(Option<Element>),
    #[doc = "event criterion"]
    #[code = "EVN.CRT"]
    EVNCRT(Option<Element>),
    #[doc = "expectation"]
    #[code = "EXPEC"]
    EXPEC(Option<Element>),
    #[doc = "Goal"]
    #[code = "GOL"]
    GOL(Option<Element>),
    #[doc = "goal criterion"]
    #[code = "GOL.CRT"]
    GOLCRT(Option<Element>),
    #[doc = "intent"]
    #[code = "INT"]
    INT(Option<Element>),
    #[doc = "intent criterion"]
    #[code = "INT.CRT"]
    INTCRT(Option<Element>),
    #[doc = "option"]
    #[code = "OPT"]
    OPT(Option<Element>),
    #[doc = "permission"]
    #[code = "PERM"]
    PERM(Option<Element>),
    #[doc = "permission request"]
    #[code = "PERMRQ"]
    PERMRQ(Option<Element>),
    #[doc = "promise"]
    #[code = "PRMS"]
    PRMS(Option<Element>),
    #[doc = "promise criterion"]
    #[code = "PRMS.CRT"]
    PRMSCRT(Option<Element>),
    #[doc = "proposal"]
    #[code = "PRP"]
    PRP(Option<Element>),
    #[doc = "recommendation"]
    #[code = "RMD"]
    RMD(Option<Element>),
    #[doc = "request"]
    #[code = "RQO"]
    RQO(Option<Element>),
    #[doc = "request criterion"]
    #[code = "RQO.CRT"]
    RQOCRT(Option<Element>),
    #[doc = "risk"]
    #[code = "RSK"]
    RSK(Option<Element>),
    #[doc = "risk criterion"]
    #[code = "RSK.CRT"]
    RSKCRT(Option<Element>),
    #[doc = "resource slot"]
    #[code = "SLOT"]
    SLOT(Option<Element>),
    #[doc = "act request"]
    #[code = "_ActMoodActRequest"]
    _ActMoodActRequest(Option<Element>),
    #[doc = "ActMoodCompletionTrack"]
    #[code = "_ActMoodCompletionTrack"]
    _ActMoodCompletionTrack(Option<Element>),
    #[doc = "desire"]
    #[code = "_ActMoodDesire"]
    _ActMoodDesire(Option<Element>),
    #[doc = "potential"]
    #[code = "_ActMoodPotential"]
    _ActMoodPotential(Option<Element>),
    #[doc = "ActMoodPredicate"]
    #[code = "_ActMoodPredicate"]
    _ActMoodPredicate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActMoodIntent {
    fn default() -> Self {
        V3ActMoodIntent::Null(None)
    }
}
impl TryFrom<String> for V3ActMoodIntent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "APT" => Ok(V3ActMoodIntent::APT(None)),
            "ARQ" => Ok(V3ActMoodIntent::ARQ(None)),
            "CRT" => Ok(V3ActMoodIntent::CRT(None)),
            "DEF" => Ok(V3ActMoodIntent::DEF(None)),
            "EVN" => Ok(V3ActMoodIntent::EVN(None)),
            "EVN.CRT" => Ok(V3ActMoodIntent::EVNCRT(None)),
            "EXPEC" => Ok(V3ActMoodIntent::EXPEC(None)),
            "GOL" => Ok(V3ActMoodIntent::GOL(None)),
            "GOL.CRT" => Ok(V3ActMoodIntent::GOLCRT(None)),
            "INT" => Ok(V3ActMoodIntent::INT(None)),
            "INT.CRT" => Ok(V3ActMoodIntent::INTCRT(None)),
            "OPT" => Ok(V3ActMoodIntent::OPT(None)),
            "PERM" => Ok(V3ActMoodIntent::PERM(None)),
            "PERMRQ" => Ok(V3ActMoodIntent::PERMRQ(None)),
            "PRMS" => Ok(V3ActMoodIntent::PRMS(None)),
            "PRMS.CRT" => Ok(V3ActMoodIntent::PRMSCRT(None)),
            "PRP" => Ok(V3ActMoodIntent::PRP(None)),
            "RMD" => Ok(V3ActMoodIntent::RMD(None)),
            "RQO" => Ok(V3ActMoodIntent::RQO(None)),
            "RQO.CRT" => Ok(V3ActMoodIntent::RQOCRT(None)),
            "RSK" => Ok(V3ActMoodIntent::RSK(None)),
            "RSK.CRT" => Ok(V3ActMoodIntent::RSKCRT(None)),
            "SLOT" => Ok(V3ActMoodIntent::SLOT(None)),
            "_ActMoodActRequest" => Ok(V3ActMoodIntent::_ActMoodActRequest(None)),
            "_ActMoodCompletionTrack" => Ok(V3ActMoodIntent::_ActMoodCompletionTrack(None)),
            "_ActMoodDesire" => Ok(V3ActMoodIntent::_ActMoodDesire(None)),
            "_ActMoodPotential" => Ok(V3ActMoodIntent::_ActMoodPotential(None)),
            "_ActMoodPredicate" => Ok(V3ActMoodIntent::_ActMoodPredicate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActMoodIntent {
    fn into(self) -> Option<String> {
        match self {
            V3ActMoodIntent::APT(_) => Some("APT".to_string()),
            V3ActMoodIntent::ARQ(_) => Some("ARQ".to_string()),
            V3ActMoodIntent::CRT(_) => Some("CRT".to_string()),
            V3ActMoodIntent::DEF(_) => Some("DEF".to_string()),
            V3ActMoodIntent::EVN(_) => Some("EVN".to_string()),
            V3ActMoodIntent::EVNCRT(_) => Some("EVN.CRT".to_string()),
            V3ActMoodIntent::EXPEC(_) => Some("EXPEC".to_string()),
            V3ActMoodIntent::GOL(_) => Some("GOL".to_string()),
            V3ActMoodIntent::GOLCRT(_) => Some("GOL.CRT".to_string()),
            V3ActMoodIntent::INT(_) => Some("INT".to_string()),
            V3ActMoodIntent::INTCRT(_) => Some("INT.CRT".to_string()),
            V3ActMoodIntent::OPT(_) => Some("OPT".to_string()),
            V3ActMoodIntent::PERM(_) => Some("PERM".to_string()),
            V3ActMoodIntent::PERMRQ(_) => Some("PERMRQ".to_string()),
            V3ActMoodIntent::PRMS(_) => Some("PRMS".to_string()),
            V3ActMoodIntent::PRMSCRT(_) => Some("PRMS.CRT".to_string()),
            V3ActMoodIntent::PRP(_) => Some("PRP".to_string()),
            V3ActMoodIntent::RMD(_) => Some("RMD".to_string()),
            V3ActMoodIntent::RQO(_) => Some("RQO".to_string()),
            V3ActMoodIntent::RQOCRT(_) => Some("RQO.CRT".to_string()),
            V3ActMoodIntent::RSK(_) => Some("RSK".to_string()),
            V3ActMoodIntent::RSKCRT(_) => Some("RSK.CRT".to_string()),
            V3ActMoodIntent::SLOT(_) => Some("SLOT".to_string()),
            V3ActMoodIntent::_ActMoodActRequest(_) => Some("_ActMoodActRequest".to_string()),
            V3ActMoodIntent::_ActMoodCompletionTrack(_) => {
                Some("_ActMoodCompletionTrack".to_string())
            }
            V3ActMoodIntent::_ActMoodDesire(_) => Some("_ActMoodDesire".to_string()),
            V3ActMoodIntent::_ActMoodPotential(_) => Some("_ActMoodPotential".to_string()),
            V3ActMoodIntent::_ActMoodPredicate(_) => Some("_ActMoodPredicate".to_string()),
            V3ActMoodIntent::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActMoodIntent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActMoodIntent::APT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::ARQ(Some(e)) => e.get_field(field),
                V3ActMoodIntent::CRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::DEF(Some(e)) => e.get_field(field),
                V3ActMoodIntent::EVN(Some(e)) => e.get_field(field),
                V3ActMoodIntent::EVNCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::EXPEC(Some(e)) => e.get_field(field),
                V3ActMoodIntent::GOL(Some(e)) => e.get_field(field),
                V3ActMoodIntent::GOLCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::INT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::INTCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::OPT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::PERM(Some(e)) => e.get_field(field),
                V3ActMoodIntent::PERMRQ(Some(e)) => e.get_field(field),
                V3ActMoodIntent::PRMS(Some(e)) => e.get_field(field),
                V3ActMoodIntent::PRMSCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::PRP(Some(e)) => e.get_field(field),
                V3ActMoodIntent::RMD(Some(e)) => e.get_field(field),
                V3ActMoodIntent::RQO(Some(e)) => e.get_field(field),
                V3ActMoodIntent::RQOCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::RSK(Some(e)) => e.get_field(field),
                V3ActMoodIntent::RSKCRT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::SLOT(Some(e)) => e.get_field(field),
                V3ActMoodIntent::_ActMoodActRequest(Some(e)) => e.get_field(field),
                V3ActMoodIntent::_ActMoodCompletionTrack(Some(e)) => e.get_field(field),
                V3ActMoodIntent::_ActMoodDesire(Some(e)) => e.get_field(field),
                V3ActMoodIntent::_ActMoodPotential(Some(e)) => e.get_field(field),
                V3ActMoodIntent::_ActMoodPredicate(Some(e)) => e.get_field(field),
                V3ActMoodIntent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActMoodIntent::APT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::ARQ(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::CRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::DEF(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::EVN(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::EVNCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::EXPEC(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::GOL(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::GOLCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::INT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::INTCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::OPT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::PERM(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::PERMRQ(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::PRMS(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::PRMSCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::PRP(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::RMD(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::RQO(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::RQOCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::RSK(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::RSKCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::SLOT(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::_ActMoodActRequest(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::_ActMoodCompletionTrack(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::_ActMoodDesire(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::_ActMoodPotential(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::_ActMoodPredicate(Some(e)) => e.get_field_mut(field),
                V3ActMoodIntent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActMoodPredicate {
    #[doc = "appointment"]
    #[code = "APT"]
    APT(Option<Element>),
    #[doc = "appointment request"]
    #[code = "ARQ"]
    ARQ(Option<Element>),
    #[doc = "criterion"]
    #[code = "CRT"]
    CRT(Option<Element>),
    #[doc = "definition"]
    #[code = "DEF"]
    DEF(Option<Element>),
    #[doc = "event (occurrence)"]
    #[code = "EVN"]
    EVN(Option<Element>),
    #[doc = "event criterion"]
    #[code = "EVN.CRT"]
    EVNCRT(Option<Element>),
    #[doc = "expectation"]
    #[code = "EXPEC"]
    EXPEC(Option<Element>),
    #[doc = "Goal"]
    #[code = "GOL"]
    GOL(Option<Element>),
    #[doc = "goal criterion"]
    #[code = "GOL.CRT"]
    GOLCRT(Option<Element>),
    #[doc = "intent"]
    #[code = "INT"]
    INT(Option<Element>),
    #[doc = "intent criterion"]
    #[code = "INT.CRT"]
    INTCRT(Option<Element>),
    #[doc = "option"]
    #[code = "OPT"]
    OPT(Option<Element>),
    #[doc = "permission"]
    #[code = "PERM"]
    PERM(Option<Element>),
    #[doc = "permission request"]
    #[code = "PERMRQ"]
    PERMRQ(Option<Element>),
    #[doc = "promise"]
    #[code = "PRMS"]
    PRMS(Option<Element>),
    #[doc = "promise criterion"]
    #[code = "PRMS.CRT"]
    PRMSCRT(Option<Element>),
    #[doc = "proposal"]
    #[code = "PRP"]
    PRP(Option<Element>),
    #[doc = "recommendation"]
    #[code = "RMD"]
    RMD(Option<Element>),
    #[doc = "request"]
    #[code = "RQO"]
    RQO(Option<Element>),
    #[doc = "request criterion"]
    #[code = "RQO.CRT"]
    RQOCRT(Option<Element>),
    #[doc = "risk"]
    #[code = "RSK"]
    RSK(Option<Element>),
    #[doc = "risk criterion"]
    #[code = "RSK.CRT"]
    RSKCRT(Option<Element>),
    #[doc = "resource slot"]
    #[code = "SLOT"]
    SLOT(Option<Element>),
    #[doc = "act request"]
    #[code = "_ActMoodActRequest"]
    _ActMoodActRequest(Option<Element>),
    #[doc = "ActMoodCompletionTrack"]
    #[code = "_ActMoodCompletionTrack"]
    _ActMoodCompletionTrack(Option<Element>),
    #[doc = "desire"]
    #[code = "_ActMoodDesire"]
    _ActMoodDesire(Option<Element>),
    #[doc = "potential"]
    #[code = "_ActMoodPotential"]
    _ActMoodPotential(Option<Element>),
    #[doc = "ActMoodPredicate"]
    #[code = "_ActMoodPredicate"]
    _ActMoodPredicate(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActMoodPredicate {
    fn default() -> Self {
        V3ActMoodPredicate::Null(None)
    }
}
impl TryFrom<String> for V3ActMoodPredicate {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "APT" => Ok(V3ActMoodPredicate::APT(None)),
            "ARQ" => Ok(V3ActMoodPredicate::ARQ(None)),
            "CRT" => Ok(V3ActMoodPredicate::CRT(None)),
            "DEF" => Ok(V3ActMoodPredicate::DEF(None)),
            "EVN" => Ok(V3ActMoodPredicate::EVN(None)),
            "EVN.CRT" => Ok(V3ActMoodPredicate::EVNCRT(None)),
            "EXPEC" => Ok(V3ActMoodPredicate::EXPEC(None)),
            "GOL" => Ok(V3ActMoodPredicate::GOL(None)),
            "GOL.CRT" => Ok(V3ActMoodPredicate::GOLCRT(None)),
            "INT" => Ok(V3ActMoodPredicate::INT(None)),
            "INT.CRT" => Ok(V3ActMoodPredicate::INTCRT(None)),
            "OPT" => Ok(V3ActMoodPredicate::OPT(None)),
            "PERM" => Ok(V3ActMoodPredicate::PERM(None)),
            "PERMRQ" => Ok(V3ActMoodPredicate::PERMRQ(None)),
            "PRMS" => Ok(V3ActMoodPredicate::PRMS(None)),
            "PRMS.CRT" => Ok(V3ActMoodPredicate::PRMSCRT(None)),
            "PRP" => Ok(V3ActMoodPredicate::PRP(None)),
            "RMD" => Ok(V3ActMoodPredicate::RMD(None)),
            "RQO" => Ok(V3ActMoodPredicate::RQO(None)),
            "RQO.CRT" => Ok(V3ActMoodPredicate::RQOCRT(None)),
            "RSK" => Ok(V3ActMoodPredicate::RSK(None)),
            "RSK.CRT" => Ok(V3ActMoodPredicate::RSKCRT(None)),
            "SLOT" => Ok(V3ActMoodPredicate::SLOT(None)),
            "_ActMoodActRequest" => Ok(V3ActMoodPredicate::_ActMoodActRequest(None)),
            "_ActMoodCompletionTrack" => Ok(V3ActMoodPredicate::_ActMoodCompletionTrack(None)),
            "_ActMoodDesire" => Ok(V3ActMoodPredicate::_ActMoodDesire(None)),
            "_ActMoodPotential" => Ok(V3ActMoodPredicate::_ActMoodPotential(None)),
            "_ActMoodPredicate" => Ok(V3ActMoodPredicate::_ActMoodPredicate(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActMoodPredicate {
    fn into(self) -> Option<String> {
        match self {
            V3ActMoodPredicate::APT(_) => Some("APT".to_string()),
            V3ActMoodPredicate::ARQ(_) => Some("ARQ".to_string()),
            V3ActMoodPredicate::CRT(_) => Some("CRT".to_string()),
            V3ActMoodPredicate::DEF(_) => Some("DEF".to_string()),
            V3ActMoodPredicate::EVN(_) => Some("EVN".to_string()),
            V3ActMoodPredicate::EVNCRT(_) => Some("EVN.CRT".to_string()),
            V3ActMoodPredicate::EXPEC(_) => Some("EXPEC".to_string()),
            V3ActMoodPredicate::GOL(_) => Some("GOL".to_string()),
            V3ActMoodPredicate::GOLCRT(_) => Some("GOL.CRT".to_string()),
            V3ActMoodPredicate::INT(_) => Some("INT".to_string()),
            V3ActMoodPredicate::INTCRT(_) => Some("INT.CRT".to_string()),
            V3ActMoodPredicate::OPT(_) => Some("OPT".to_string()),
            V3ActMoodPredicate::PERM(_) => Some("PERM".to_string()),
            V3ActMoodPredicate::PERMRQ(_) => Some("PERMRQ".to_string()),
            V3ActMoodPredicate::PRMS(_) => Some("PRMS".to_string()),
            V3ActMoodPredicate::PRMSCRT(_) => Some("PRMS.CRT".to_string()),
            V3ActMoodPredicate::PRP(_) => Some("PRP".to_string()),
            V3ActMoodPredicate::RMD(_) => Some("RMD".to_string()),
            V3ActMoodPredicate::RQO(_) => Some("RQO".to_string()),
            V3ActMoodPredicate::RQOCRT(_) => Some("RQO.CRT".to_string()),
            V3ActMoodPredicate::RSK(_) => Some("RSK".to_string()),
            V3ActMoodPredicate::RSKCRT(_) => Some("RSK.CRT".to_string()),
            V3ActMoodPredicate::SLOT(_) => Some("SLOT".to_string()),
            V3ActMoodPredicate::_ActMoodActRequest(_) => Some("_ActMoodActRequest".to_string()),
            V3ActMoodPredicate::_ActMoodCompletionTrack(_) => {
                Some("_ActMoodCompletionTrack".to_string())
            }
            V3ActMoodPredicate::_ActMoodDesire(_) => Some("_ActMoodDesire".to_string()),
            V3ActMoodPredicate::_ActMoodPotential(_) => Some("_ActMoodPotential".to_string()),
            V3ActMoodPredicate::_ActMoodPredicate(_) => Some("_ActMoodPredicate".to_string()),
            V3ActMoodPredicate::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActMoodPredicate {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActMoodPredicate::APT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::ARQ(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::CRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::DEF(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::EVN(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::EVNCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::EXPEC(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::GOL(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::GOLCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::INT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::INTCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::OPT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::PERM(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::PERMRQ(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::PRMS(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::PRMSCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::PRP(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::RMD(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::RQO(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::RQOCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::RSK(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::RSKCRT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::SLOT(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::_ActMoodActRequest(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::_ActMoodCompletionTrack(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::_ActMoodDesire(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::_ActMoodPotential(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::_ActMoodPredicate(Some(e)) => e.get_field(field),
                V3ActMoodPredicate::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActMoodPredicate::APT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::ARQ(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::CRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::DEF(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::EVN(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::EVNCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::EXPEC(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::GOL(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::GOLCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::INT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::INTCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::OPT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::PERM(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::PERMRQ(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::PRMS(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::PRMSCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::PRP(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::RMD(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::RQO(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::RQOCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::RSK(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::RSKCRT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::SLOT(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::_ActMoodActRequest(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::_ActMoodCompletionTrack(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::_ActMoodDesire(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::_ActMoodPotential(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::_ActMoodPredicate(Some(e)) => e.get_field_mut(field),
                V3ActMoodPredicate::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActPriority {
    #[doc = "ASAP"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "callback results"]
    #[code = "CR"]
    CR(Option<Element>),
    #[doc = "callback for scheduling"]
    #[code = "CS"]
    CS(Option<Element>),
    #[doc = "callback placer for scheduling"]
    #[code = "CSP"]
    CSP(Option<Element>),
    #[doc = "contact recipient for scheduling"]
    #[code = "CSR"]
    CSR(Option<Element>),
    #[doc = "elective"]
    #[code = "EL"]
    EL(Option<Element>),
    #[doc = "emergency"]
    #[code = "EM"]
    EM(Option<Element>),
    #[doc = "preop"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "as needed"]
    #[code = "PRN"]
    PRN(Option<Element>),
    #[doc = "routine"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "rush reporting"]
    #[code = "RR"]
    RR(Option<Element>),
    #[doc = "stat"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "timing critical"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "use as directed"]
    #[code = "UD"]
    UD(Option<Element>),
    #[doc = "urgent"]
    #[code = "UR"]
    UR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActPriority {
    fn default() -> Self {
        V3ActPriority::Null(None)
    }
}
impl TryFrom<String> for V3ActPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3ActPriority::A(None)),
            "CR" => Ok(V3ActPriority::CR(None)),
            "CS" => Ok(V3ActPriority::CS(None)),
            "CSP" => Ok(V3ActPriority::CSP(None)),
            "CSR" => Ok(V3ActPriority::CSR(None)),
            "EL" => Ok(V3ActPriority::EL(None)),
            "EM" => Ok(V3ActPriority::EM(None)),
            "P" => Ok(V3ActPriority::P(None)),
            "PRN" => Ok(V3ActPriority::PRN(None)),
            "R" => Ok(V3ActPriority::R(None)),
            "RR" => Ok(V3ActPriority::RR(None)),
            "S" => Ok(V3ActPriority::S(None)),
            "T" => Ok(V3ActPriority::T(None)),
            "UD" => Ok(V3ActPriority::UD(None)),
            "UR" => Ok(V3ActPriority::UR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActPriority {
    fn into(self) -> Option<String> {
        match self {
            V3ActPriority::A(_) => Some("A".to_string()),
            V3ActPriority::CR(_) => Some("CR".to_string()),
            V3ActPriority::CS(_) => Some("CS".to_string()),
            V3ActPriority::CSP(_) => Some("CSP".to_string()),
            V3ActPriority::CSR(_) => Some("CSR".to_string()),
            V3ActPriority::EL(_) => Some("EL".to_string()),
            V3ActPriority::EM(_) => Some("EM".to_string()),
            V3ActPriority::P(_) => Some("P".to_string()),
            V3ActPriority::PRN(_) => Some("PRN".to_string()),
            V3ActPriority::R(_) => Some("R".to_string()),
            V3ActPriority::RR(_) => Some("RR".to_string()),
            V3ActPriority::S(_) => Some("S".to_string()),
            V3ActPriority::T(_) => Some("T".to_string()),
            V3ActPriority::UD(_) => Some("UD".to_string()),
            V3ActPriority::UR(_) => Some("UR".to_string()),
            V3ActPriority::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActPriority::A(Some(e)) => e.get_field(field),
                V3ActPriority::CR(Some(e)) => e.get_field(field),
                V3ActPriority::CS(Some(e)) => e.get_field(field),
                V3ActPriority::CSP(Some(e)) => e.get_field(field),
                V3ActPriority::CSR(Some(e)) => e.get_field(field),
                V3ActPriority::EL(Some(e)) => e.get_field(field),
                V3ActPriority::EM(Some(e)) => e.get_field(field),
                V3ActPriority::P(Some(e)) => e.get_field(field),
                V3ActPriority::PRN(Some(e)) => e.get_field(field),
                V3ActPriority::R(Some(e)) => e.get_field(field),
                V3ActPriority::RR(Some(e)) => e.get_field(field),
                V3ActPriority::S(Some(e)) => e.get_field(field),
                V3ActPriority::T(Some(e)) => e.get_field(field),
                V3ActPriority::UD(Some(e)) => e.get_field(field),
                V3ActPriority::UR(Some(e)) => e.get_field(field),
                V3ActPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActPriority::A(Some(e)) => e.get_field_mut(field),
                V3ActPriority::CR(Some(e)) => e.get_field_mut(field),
                V3ActPriority::CS(Some(e)) => e.get_field_mut(field),
                V3ActPriority::CSP(Some(e)) => e.get_field_mut(field),
                V3ActPriority::CSR(Some(e)) => e.get_field_mut(field),
                V3ActPriority::EL(Some(e)) => e.get_field_mut(field),
                V3ActPriority::EM(Some(e)) => e.get_field_mut(field),
                V3ActPriority::P(Some(e)) => e.get_field_mut(field),
                V3ActPriority::PRN(Some(e)) => e.get_field_mut(field),
                V3ActPriority::R(Some(e)) => e.get_field_mut(field),
                V3ActPriority::RR(Some(e)) => e.get_field_mut(field),
                V3ActPriority::S(Some(e)) => e.get_field_mut(field),
                V3ActPriority::T(Some(e)) => e.get_field_mut(field),
                V3ActPriority::UD(Some(e)) => e.get_field_mut(field),
                V3ActPriority::UR(Some(e)) => e.get_field_mut(field),
                V3ActPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActRelationshipCheckpoint {
    #[doc = "beginning"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "end"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "entry"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "through"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "exit"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActRelationshipCheckpoint {
    fn default() -> Self {
        V3ActRelationshipCheckpoint::Null(None)
    }
}
impl TryFrom<String> for V3ActRelationshipCheckpoint {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(V3ActRelationshipCheckpoint::B(None)),
            "E" => Ok(V3ActRelationshipCheckpoint::E(None)),
            "S" => Ok(V3ActRelationshipCheckpoint::S(None)),
            "T" => Ok(V3ActRelationshipCheckpoint::T(None)),
            "X" => Ok(V3ActRelationshipCheckpoint::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActRelationshipCheckpoint {
    fn into(self) -> Option<String> {
        match self {
            V3ActRelationshipCheckpoint::B(_) => Some("B".to_string()),
            V3ActRelationshipCheckpoint::E(_) => Some("E".to_string()),
            V3ActRelationshipCheckpoint::S(_) => Some("S".to_string()),
            V3ActRelationshipCheckpoint::T(_) => Some("T".to_string()),
            V3ActRelationshipCheckpoint::X(_) => Some("X".to_string()),
            V3ActRelationshipCheckpoint::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActRelationshipCheckpoint {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActRelationshipCheckpoint::B(Some(e)) => e.get_field(field),
                V3ActRelationshipCheckpoint::E(Some(e)) => e.get_field(field),
                V3ActRelationshipCheckpoint::S(Some(e)) => e.get_field(field),
                V3ActRelationshipCheckpoint::T(Some(e)) => e.get_field(field),
                V3ActRelationshipCheckpoint::X(Some(e)) => e.get_field(field),
                V3ActRelationshipCheckpoint::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActRelationshipCheckpoint::B(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipCheckpoint::E(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipCheckpoint::S(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipCheckpoint::T(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipCheckpoint::X(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipCheckpoint::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActRelationshipJoin {
    #[doc = "detached"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "kill"]
    #[code = "K"]
    K(Option<Element>),
    #[doc = "wait"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "exclusive wait"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActRelationshipJoin {
    fn default() -> Self {
        V3ActRelationshipJoin::Null(None)
    }
}
impl TryFrom<String> for V3ActRelationshipJoin {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "D" => Ok(V3ActRelationshipJoin::D(None)),
            "K" => Ok(V3ActRelationshipJoin::K(None)),
            "W" => Ok(V3ActRelationshipJoin::W(None)),
            "X" => Ok(V3ActRelationshipJoin::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActRelationshipJoin {
    fn into(self) -> Option<String> {
        match self {
            V3ActRelationshipJoin::D(_) => Some("D".to_string()),
            V3ActRelationshipJoin::K(_) => Some("K".to_string()),
            V3ActRelationshipJoin::W(_) => Some("W".to_string()),
            V3ActRelationshipJoin::X(_) => Some("X".to_string()),
            V3ActRelationshipJoin::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActRelationshipJoin {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActRelationshipJoin::D(Some(e)) => e.get_field(field),
                V3ActRelationshipJoin::K(Some(e)) => e.get_field(field),
                V3ActRelationshipJoin::W(Some(e)) => e.get_field(field),
                V3ActRelationshipJoin::X(Some(e)) => e.get_field(field),
                V3ActRelationshipJoin::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActRelationshipJoin::D(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipJoin::K(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipJoin::W(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipJoin::X(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipJoin::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActRelationshipSplit {
    #[doc = "exclusive try once"]
    #[code = "E1"]
    E1(Option<Element>),
    #[doc = "exclusive wait"]
    #[code = "EW"]
    EW(Option<Element>),
    #[doc = "inclusive try once"]
    #[code = "I1"]
    I1(Option<Element>),
    #[doc = "inclusive wait"]
    #[code = "IW"]
    IW(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActRelationshipSplit {
    fn default() -> Self {
        V3ActRelationshipSplit::Null(None)
    }
}
impl TryFrom<String> for V3ActRelationshipSplit {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "E1" => Ok(V3ActRelationshipSplit::E1(None)),
            "EW" => Ok(V3ActRelationshipSplit::EW(None)),
            "I1" => Ok(V3ActRelationshipSplit::I1(None)),
            "IW" => Ok(V3ActRelationshipSplit::IW(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActRelationshipSplit {
    fn into(self) -> Option<String> {
        match self {
            V3ActRelationshipSplit::E1(_) => Some("E1".to_string()),
            V3ActRelationshipSplit::EW(_) => Some("EW".to_string()),
            V3ActRelationshipSplit::I1(_) => Some("I1".to_string()),
            V3ActRelationshipSplit::IW(_) => Some("IW".to_string()),
            V3ActRelationshipSplit::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActRelationshipSplit {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActRelationshipSplit::E1(Some(e)) => e.get_field(field),
                V3ActRelationshipSplit::EW(Some(e)) => e.get_field(field),
                V3ActRelationshipSplit::I1(Some(e)) => e.get_field(field),
                V3ActRelationshipSplit::IW(Some(e)) => e.get_field(field),
                V3ActRelationshipSplit::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActRelationshipSplit::E1(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSplit::EW(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSplit::I1(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSplit::IW(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSplit::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActRelationshipSubset {
    #[doc = "ActRelationshipExpectedSubset"]
    #[code = "ActRelationshipExpectedSubset"]
    ActRelationshipExpectedSubset(Option<Element>),
    #[doc = "ActRelationshipPastSubset"]
    #[code = "ActRelationshipPastSubset"]
    ActRelationshipPastSubset(Option<Element>),
    #[doc = "first known"]
    #[code = "FIRST"]
    FIRST(Option<Element>),
    #[doc = "future summary"]
    #[code = "FUTSUM"]
    FUTSUM(Option<Element>),
    #[doc = "expected future"]
    #[code = "FUTURE"]
    FUTURE(Option<Element>),
    #[doc = "expected last"]
    #[code = "LAST"]
    LAST(Option<Element>),
    #[doc = "maximum"]
    #[code = "MAX"]
    MAX(Option<Element>),
    #[doc = "minimum"]
    #[code = "MIN"]
    MIN(Option<Element>),
    #[doc = "expected next"]
    #[code = "NEXT"]
    NEXT(Option<Element>),
    #[doc = "previous"]
    #[code = "PAST"]
    PAST(Option<Element>),
    #[doc = "previous summary"]
    #[code = "PREVSUM"]
    PREVSUM(Option<Element>),
    #[doc = "most recent"]
    #[code = "RECENT"]
    RECENT(Option<Element>),
    #[doc = "summary"]
    #[code = "SUM"]
    SUM(Option<Element>),
    #[doc = "ParticipationSubset"]
    #[code = "_ParticipationSubset"]
    _ParticipationSubset(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActRelationshipSubset {
    fn default() -> Self {
        V3ActRelationshipSubset::Null(None)
    }
}
impl TryFrom<String> for V3ActRelationshipSubset {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ActRelationshipExpectedSubset" => {
                Ok(V3ActRelationshipSubset::ActRelationshipExpectedSubset(None))
            }
            "ActRelationshipPastSubset" => {
                Ok(V3ActRelationshipSubset::ActRelationshipPastSubset(None))
            }
            "FIRST" => Ok(V3ActRelationshipSubset::FIRST(None)),
            "FUTSUM" => Ok(V3ActRelationshipSubset::FUTSUM(None)),
            "FUTURE" => Ok(V3ActRelationshipSubset::FUTURE(None)),
            "LAST" => Ok(V3ActRelationshipSubset::LAST(None)),
            "MAX" => Ok(V3ActRelationshipSubset::MAX(None)),
            "MIN" => Ok(V3ActRelationshipSubset::MIN(None)),
            "NEXT" => Ok(V3ActRelationshipSubset::NEXT(None)),
            "PAST" => Ok(V3ActRelationshipSubset::PAST(None)),
            "PREVSUM" => Ok(V3ActRelationshipSubset::PREVSUM(None)),
            "RECENT" => Ok(V3ActRelationshipSubset::RECENT(None)),
            "SUM" => Ok(V3ActRelationshipSubset::SUM(None)),
            "_ParticipationSubset" => Ok(V3ActRelationshipSubset::_ParticipationSubset(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActRelationshipSubset {
    fn into(self) -> Option<String> {
        match self {
            V3ActRelationshipSubset::ActRelationshipExpectedSubset(_) => {
                Some("ActRelationshipExpectedSubset".to_string())
            }
            V3ActRelationshipSubset::ActRelationshipPastSubset(_) => {
                Some("ActRelationshipPastSubset".to_string())
            }
            V3ActRelationshipSubset::FIRST(_) => Some("FIRST".to_string()),
            V3ActRelationshipSubset::FUTSUM(_) => Some("FUTSUM".to_string()),
            V3ActRelationshipSubset::FUTURE(_) => Some("FUTURE".to_string()),
            V3ActRelationshipSubset::LAST(_) => Some("LAST".to_string()),
            V3ActRelationshipSubset::MAX(_) => Some("MAX".to_string()),
            V3ActRelationshipSubset::MIN(_) => Some("MIN".to_string()),
            V3ActRelationshipSubset::NEXT(_) => Some("NEXT".to_string()),
            V3ActRelationshipSubset::PAST(_) => Some("PAST".to_string()),
            V3ActRelationshipSubset::PREVSUM(_) => Some("PREVSUM".to_string()),
            V3ActRelationshipSubset::RECENT(_) => Some("RECENT".to_string()),
            V3ActRelationshipSubset::SUM(_) => Some("SUM".to_string()),
            V3ActRelationshipSubset::_ParticipationSubset(_) => {
                Some("_ParticipationSubset".to_string())
            }
            V3ActRelationshipSubset::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActRelationshipSubset {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActRelationshipSubset::ActRelationshipExpectedSubset(Some(e)) => {
                    e.get_field(field)
                }
                V3ActRelationshipSubset::ActRelationshipPastSubset(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::FIRST(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::FUTSUM(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::FUTURE(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::LAST(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::MAX(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::MIN(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::NEXT(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::PAST(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::PREVSUM(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::RECENT(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::SUM(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::_ParticipationSubset(Some(e)) => e.get_field(field),
                V3ActRelationshipSubset::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActRelationshipSubset::ActRelationshipExpectedSubset(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ActRelationshipSubset::ActRelationshipPastSubset(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ActRelationshipSubset::FIRST(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::FUTSUM(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::FUTURE(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::LAST(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::MAX(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::MIN(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::NEXT(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::PAST(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::PREVSUM(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::RECENT(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::SUM(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::_ParticipationSubset(Some(e)) => e.get_field_mut(field),
                V3ActRelationshipSubset::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActSite {
    #[doc = "bilateral ears"]
    #[code = "BE"]
    BE(Option<Element>),
    #[doc = "bilateral nares"]
    #[code = "BN"]
    BN(Option<Element>),
    #[doc = "buttock"]
    #[code = "BU"]
    BU(Option<Element>),
    #[doc = "left arm"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "left anterior chest"]
    #[code = "LAC"]
    LAC(Option<Element>),
    #[doc = "left antecubital fossa"]
    #[code = "LACF"]
    LACF(Option<Element>),
    #[doc = "left deltoid"]
    #[code = "LD"]
    LD(Option<Element>),
    #[doc = "left ear"]
    #[code = "LE"]
    LE(Option<Element>),
    #[doc = "left external jugular"]
    #[code = "LEJ"]
    LEJ(Option<Element>),
    #[doc = "left foot"]
    #[code = "LF"]
    LF(Option<Element>),
    #[doc = "left gluteus medius"]
    #[code = "LG"]
    LG(Option<Element>),
    #[doc = "left hand"]
    #[code = "LH"]
    LH(Option<Element>),
    #[doc = "left internal jugular"]
    #[code = "LIJ"]
    LIJ(Option<Element>),
    #[doc = "left lower abd quadrant"]
    #[code = "LLAQ"]
    LLAQ(Option<Element>),
    #[doc = "left lower forearm"]
    #[code = "LLFA"]
    LLFA(Option<Element>),
    #[doc = "left mid forearm"]
    #[code = "LMFA"]
    LMFA(Option<Element>),
    #[doc = "left naris"]
    #[code = "LN"]
    LN(Option<Element>),
    #[doc = "left posterior chest"]
    #[code = "LPC"]
    LPC(Option<Element>),
    #[doc = "left subclavian"]
    #[code = "LSC"]
    LSC(Option<Element>),
    #[doc = "left thigh"]
    #[code = "LT"]
    LT(Option<Element>),
    #[doc = "left upper arm"]
    #[code = "LUA"]
    LUA(Option<Element>),
    #[doc = "left upper abd quadrant"]
    #[code = "LUAQ"]
    LUAQ(Option<Element>),
    #[doc = "left upper forearm"]
    #[code = "LUFA"]
    LUFA(Option<Element>),
    #[doc = "left ventragluteal"]
    #[code = "LVG"]
    LVG(Option<Element>),
    #[doc = "left vastus lateralis"]
    #[code = "LVL"]
    LVL(Option<Element>),
    #[doc = "right eye"]
    #[code = "OD"]
    OD(Option<Element>),
    #[doc = "left eye"]
    #[code = "OS"]
    OS(Option<Element>),
    #[doc = "bilateral eyes"]
    #[code = "OU"]
    OU(Option<Element>),
    #[doc = "perianal"]
    #[code = "PA"]
    PA(Option<Element>),
    #[doc = "perineal"]
    #[code = "PERIN"]
    PERIN(Option<Element>),
    #[doc = "right arm"]
    #[code = "RA"]
    RA(Option<Element>),
    #[doc = "right anterior chest"]
    #[code = "RAC"]
    RAC(Option<Element>),
    #[doc = "right antecubital fossa"]
    #[code = "RACF"]
    RACF(Option<Element>),
    #[doc = "right deltoid"]
    #[code = "RD"]
    RD(Option<Element>),
    #[doc = "right ear"]
    #[code = "RE"]
    RE(Option<Element>),
    #[doc = "right external jugular"]
    #[code = "REJ"]
    REJ(Option<Element>),
    #[doc = "right foot"]
    #[code = "RF"]
    RF(Option<Element>),
    #[doc = "right gluteus medius"]
    #[code = "RG"]
    RG(Option<Element>),
    #[doc = "right hand"]
    #[code = "RH"]
    RH(Option<Element>),
    #[doc = "right internal jugular"]
    #[code = "RIJ"]
    RIJ(Option<Element>),
    #[doc = "right lower abd quadrant"]
    #[code = "RLAQ"]
    RLAQ(Option<Element>),
    #[doc = "right lower forearm"]
    #[code = "RLFA"]
    RLFA(Option<Element>),
    #[doc = "right mid forearm"]
    #[code = "RMFA"]
    RMFA(Option<Element>),
    #[doc = "right naris"]
    #[code = "RN"]
    RN(Option<Element>),
    #[doc = "right posterior chest"]
    #[code = "RPC"]
    RPC(Option<Element>),
    #[doc = "right subclavian"]
    #[code = "RSC"]
    RSC(Option<Element>),
    #[doc = "right thigh"]
    #[code = "RT"]
    RT(Option<Element>),
    #[doc = "right upper arm"]
    #[code = "RUA"]
    RUA(Option<Element>),
    #[doc = "right upper abd quadrant"]
    #[code = "RUAQ"]
    RUAQ(Option<Element>),
    #[doc = "right upper forearm"]
    #[code = "RUFA"]
    RUFA(Option<Element>),
    #[doc = "right ventragluteal"]
    #[code = "RVG"]
    RVG(Option<Element>),
    #[doc = "right vastus lateralis"]
    #[code = "RVL"]
    RVL(Option<Element>),
    #[doc = "HumanActSite"]
    #[code = "_HumanActSite"]
    _HumanActSite(Option<Element>),
    #[doc = "HumanSubstanceAdministrationSite"]
    #[code = "_HumanSubstanceAdministrationSite"]
    _HumanSubstanceAdministrationSite(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActSite {
    fn default() -> Self {
        V3ActSite::Null(None)
    }
}
impl TryFrom<String> for V3ActSite {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BE" => Ok(V3ActSite::BE(None)),
            "BN" => Ok(V3ActSite::BN(None)),
            "BU" => Ok(V3ActSite::BU(None)),
            "LA" => Ok(V3ActSite::LA(None)),
            "LAC" => Ok(V3ActSite::LAC(None)),
            "LACF" => Ok(V3ActSite::LACF(None)),
            "LD" => Ok(V3ActSite::LD(None)),
            "LE" => Ok(V3ActSite::LE(None)),
            "LEJ" => Ok(V3ActSite::LEJ(None)),
            "LF" => Ok(V3ActSite::LF(None)),
            "LG" => Ok(V3ActSite::LG(None)),
            "LH" => Ok(V3ActSite::LH(None)),
            "LIJ" => Ok(V3ActSite::LIJ(None)),
            "LLAQ" => Ok(V3ActSite::LLAQ(None)),
            "LLFA" => Ok(V3ActSite::LLFA(None)),
            "LMFA" => Ok(V3ActSite::LMFA(None)),
            "LN" => Ok(V3ActSite::LN(None)),
            "LPC" => Ok(V3ActSite::LPC(None)),
            "LSC" => Ok(V3ActSite::LSC(None)),
            "LT" => Ok(V3ActSite::LT(None)),
            "LUA" => Ok(V3ActSite::LUA(None)),
            "LUAQ" => Ok(V3ActSite::LUAQ(None)),
            "LUFA" => Ok(V3ActSite::LUFA(None)),
            "LVG" => Ok(V3ActSite::LVG(None)),
            "LVL" => Ok(V3ActSite::LVL(None)),
            "OD" => Ok(V3ActSite::OD(None)),
            "OS" => Ok(V3ActSite::OS(None)),
            "OU" => Ok(V3ActSite::OU(None)),
            "PA" => Ok(V3ActSite::PA(None)),
            "PERIN" => Ok(V3ActSite::PERIN(None)),
            "RA" => Ok(V3ActSite::RA(None)),
            "RAC" => Ok(V3ActSite::RAC(None)),
            "RACF" => Ok(V3ActSite::RACF(None)),
            "RD" => Ok(V3ActSite::RD(None)),
            "RE" => Ok(V3ActSite::RE(None)),
            "REJ" => Ok(V3ActSite::REJ(None)),
            "RF" => Ok(V3ActSite::RF(None)),
            "RG" => Ok(V3ActSite::RG(None)),
            "RH" => Ok(V3ActSite::RH(None)),
            "RIJ" => Ok(V3ActSite::RIJ(None)),
            "RLAQ" => Ok(V3ActSite::RLAQ(None)),
            "RLFA" => Ok(V3ActSite::RLFA(None)),
            "RMFA" => Ok(V3ActSite::RMFA(None)),
            "RN" => Ok(V3ActSite::RN(None)),
            "RPC" => Ok(V3ActSite::RPC(None)),
            "RSC" => Ok(V3ActSite::RSC(None)),
            "RT" => Ok(V3ActSite::RT(None)),
            "RUA" => Ok(V3ActSite::RUA(None)),
            "RUAQ" => Ok(V3ActSite::RUAQ(None)),
            "RUFA" => Ok(V3ActSite::RUFA(None)),
            "RVG" => Ok(V3ActSite::RVG(None)),
            "RVL" => Ok(V3ActSite::RVL(None)),
            "_HumanActSite" => Ok(V3ActSite::_HumanActSite(None)),
            "_HumanSubstanceAdministrationSite" => {
                Ok(V3ActSite::_HumanSubstanceAdministrationSite(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActSite {
    fn into(self) -> Option<String> {
        match self {
            V3ActSite::BE(_) => Some("BE".to_string()),
            V3ActSite::BN(_) => Some("BN".to_string()),
            V3ActSite::BU(_) => Some("BU".to_string()),
            V3ActSite::LA(_) => Some("LA".to_string()),
            V3ActSite::LAC(_) => Some("LAC".to_string()),
            V3ActSite::LACF(_) => Some("LACF".to_string()),
            V3ActSite::LD(_) => Some("LD".to_string()),
            V3ActSite::LE(_) => Some("LE".to_string()),
            V3ActSite::LEJ(_) => Some("LEJ".to_string()),
            V3ActSite::LF(_) => Some("LF".to_string()),
            V3ActSite::LG(_) => Some("LG".to_string()),
            V3ActSite::LH(_) => Some("LH".to_string()),
            V3ActSite::LIJ(_) => Some("LIJ".to_string()),
            V3ActSite::LLAQ(_) => Some("LLAQ".to_string()),
            V3ActSite::LLFA(_) => Some("LLFA".to_string()),
            V3ActSite::LMFA(_) => Some("LMFA".to_string()),
            V3ActSite::LN(_) => Some("LN".to_string()),
            V3ActSite::LPC(_) => Some("LPC".to_string()),
            V3ActSite::LSC(_) => Some("LSC".to_string()),
            V3ActSite::LT(_) => Some("LT".to_string()),
            V3ActSite::LUA(_) => Some("LUA".to_string()),
            V3ActSite::LUAQ(_) => Some("LUAQ".to_string()),
            V3ActSite::LUFA(_) => Some("LUFA".to_string()),
            V3ActSite::LVG(_) => Some("LVG".to_string()),
            V3ActSite::LVL(_) => Some("LVL".to_string()),
            V3ActSite::OD(_) => Some("OD".to_string()),
            V3ActSite::OS(_) => Some("OS".to_string()),
            V3ActSite::OU(_) => Some("OU".to_string()),
            V3ActSite::PA(_) => Some("PA".to_string()),
            V3ActSite::PERIN(_) => Some("PERIN".to_string()),
            V3ActSite::RA(_) => Some("RA".to_string()),
            V3ActSite::RAC(_) => Some("RAC".to_string()),
            V3ActSite::RACF(_) => Some("RACF".to_string()),
            V3ActSite::RD(_) => Some("RD".to_string()),
            V3ActSite::RE(_) => Some("RE".to_string()),
            V3ActSite::REJ(_) => Some("REJ".to_string()),
            V3ActSite::RF(_) => Some("RF".to_string()),
            V3ActSite::RG(_) => Some("RG".to_string()),
            V3ActSite::RH(_) => Some("RH".to_string()),
            V3ActSite::RIJ(_) => Some("RIJ".to_string()),
            V3ActSite::RLAQ(_) => Some("RLAQ".to_string()),
            V3ActSite::RLFA(_) => Some("RLFA".to_string()),
            V3ActSite::RMFA(_) => Some("RMFA".to_string()),
            V3ActSite::RN(_) => Some("RN".to_string()),
            V3ActSite::RPC(_) => Some("RPC".to_string()),
            V3ActSite::RSC(_) => Some("RSC".to_string()),
            V3ActSite::RT(_) => Some("RT".to_string()),
            V3ActSite::RUA(_) => Some("RUA".to_string()),
            V3ActSite::RUAQ(_) => Some("RUAQ".to_string()),
            V3ActSite::RUFA(_) => Some("RUFA".to_string()),
            V3ActSite::RVG(_) => Some("RVG".to_string()),
            V3ActSite::RVL(_) => Some("RVL".to_string()),
            V3ActSite::_HumanActSite(_) => Some("_HumanActSite".to_string()),
            V3ActSite::_HumanSubstanceAdministrationSite(_) => {
                Some("_HumanSubstanceAdministrationSite".to_string())
            }
            V3ActSite::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActSite {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActSite::BE(Some(e)) => e.get_field(field),
                V3ActSite::BN(Some(e)) => e.get_field(field),
                V3ActSite::BU(Some(e)) => e.get_field(field),
                V3ActSite::LA(Some(e)) => e.get_field(field),
                V3ActSite::LAC(Some(e)) => e.get_field(field),
                V3ActSite::LACF(Some(e)) => e.get_field(field),
                V3ActSite::LD(Some(e)) => e.get_field(field),
                V3ActSite::LE(Some(e)) => e.get_field(field),
                V3ActSite::LEJ(Some(e)) => e.get_field(field),
                V3ActSite::LF(Some(e)) => e.get_field(field),
                V3ActSite::LG(Some(e)) => e.get_field(field),
                V3ActSite::LH(Some(e)) => e.get_field(field),
                V3ActSite::LIJ(Some(e)) => e.get_field(field),
                V3ActSite::LLAQ(Some(e)) => e.get_field(field),
                V3ActSite::LLFA(Some(e)) => e.get_field(field),
                V3ActSite::LMFA(Some(e)) => e.get_field(field),
                V3ActSite::LN(Some(e)) => e.get_field(field),
                V3ActSite::LPC(Some(e)) => e.get_field(field),
                V3ActSite::LSC(Some(e)) => e.get_field(field),
                V3ActSite::LT(Some(e)) => e.get_field(field),
                V3ActSite::LUA(Some(e)) => e.get_field(field),
                V3ActSite::LUAQ(Some(e)) => e.get_field(field),
                V3ActSite::LUFA(Some(e)) => e.get_field(field),
                V3ActSite::LVG(Some(e)) => e.get_field(field),
                V3ActSite::LVL(Some(e)) => e.get_field(field),
                V3ActSite::OD(Some(e)) => e.get_field(field),
                V3ActSite::OS(Some(e)) => e.get_field(field),
                V3ActSite::OU(Some(e)) => e.get_field(field),
                V3ActSite::PA(Some(e)) => e.get_field(field),
                V3ActSite::PERIN(Some(e)) => e.get_field(field),
                V3ActSite::RA(Some(e)) => e.get_field(field),
                V3ActSite::RAC(Some(e)) => e.get_field(field),
                V3ActSite::RACF(Some(e)) => e.get_field(field),
                V3ActSite::RD(Some(e)) => e.get_field(field),
                V3ActSite::RE(Some(e)) => e.get_field(field),
                V3ActSite::REJ(Some(e)) => e.get_field(field),
                V3ActSite::RF(Some(e)) => e.get_field(field),
                V3ActSite::RG(Some(e)) => e.get_field(field),
                V3ActSite::RH(Some(e)) => e.get_field(field),
                V3ActSite::RIJ(Some(e)) => e.get_field(field),
                V3ActSite::RLAQ(Some(e)) => e.get_field(field),
                V3ActSite::RLFA(Some(e)) => e.get_field(field),
                V3ActSite::RMFA(Some(e)) => e.get_field(field),
                V3ActSite::RN(Some(e)) => e.get_field(field),
                V3ActSite::RPC(Some(e)) => e.get_field(field),
                V3ActSite::RSC(Some(e)) => e.get_field(field),
                V3ActSite::RT(Some(e)) => e.get_field(field),
                V3ActSite::RUA(Some(e)) => e.get_field(field),
                V3ActSite::RUAQ(Some(e)) => e.get_field(field),
                V3ActSite::RUFA(Some(e)) => e.get_field(field),
                V3ActSite::RVG(Some(e)) => e.get_field(field),
                V3ActSite::RVL(Some(e)) => e.get_field(field),
                V3ActSite::_HumanActSite(Some(e)) => e.get_field(field),
                V3ActSite::_HumanSubstanceAdministrationSite(Some(e)) => e.get_field(field),
                V3ActSite::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActSite::BE(Some(e)) => e.get_field_mut(field),
                V3ActSite::BN(Some(e)) => e.get_field_mut(field),
                V3ActSite::BU(Some(e)) => e.get_field_mut(field),
                V3ActSite::LA(Some(e)) => e.get_field_mut(field),
                V3ActSite::LAC(Some(e)) => e.get_field_mut(field),
                V3ActSite::LACF(Some(e)) => e.get_field_mut(field),
                V3ActSite::LD(Some(e)) => e.get_field_mut(field),
                V3ActSite::LE(Some(e)) => e.get_field_mut(field),
                V3ActSite::LEJ(Some(e)) => e.get_field_mut(field),
                V3ActSite::LF(Some(e)) => e.get_field_mut(field),
                V3ActSite::LG(Some(e)) => e.get_field_mut(field),
                V3ActSite::LH(Some(e)) => e.get_field_mut(field),
                V3ActSite::LIJ(Some(e)) => e.get_field_mut(field),
                V3ActSite::LLAQ(Some(e)) => e.get_field_mut(field),
                V3ActSite::LLFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::LMFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::LN(Some(e)) => e.get_field_mut(field),
                V3ActSite::LPC(Some(e)) => e.get_field_mut(field),
                V3ActSite::LSC(Some(e)) => e.get_field_mut(field),
                V3ActSite::LT(Some(e)) => e.get_field_mut(field),
                V3ActSite::LUA(Some(e)) => e.get_field_mut(field),
                V3ActSite::LUAQ(Some(e)) => e.get_field_mut(field),
                V3ActSite::LUFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::LVG(Some(e)) => e.get_field_mut(field),
                V3ActSite::LVL(Some(e)) => e.get_field_mut(field),
                V3ActSite::OD(Some(e)) => e.get_field_mut(field),
                V3ActSite::OS(Some(e)) => e.get_field_mut(field),
                V3ActSite::OU(Some(e)) => e.get_field_mut(field),
                V3ActSite::PA(Some(e)) => e.get_field_mut(field),
                V3ActSite::PERIN(Some(e)) => e.get_field_mut(field),
                V3ActSite::RA(Some(e)) => e.get_field_mut(field),
                V3ActSite::RAC(Some(e)) => e.get_field_mut(field),
                V3ActSite::RACF(Some(e)) => e.get_field_mut(field),
                V3ActSite::RD(Some(e)) => e.get_field_mut(field),
                V3ActSite::RE(Some(e)) => e.get_field_mut(field),
                V3ActSite::REJ(Some(e)) => e.get_field_mut(field),
                V3ActSite::RF(Some(e)) => e.get_field_mut(field),
                V3ActSite::RG(Some(e)) => e.get_field_mut(field),
                V3ActSite::RH(Some(e)) => e.get_field_mut(field),
                V3ActSite::RIJ(Some(e)) => e.get_field_mut(field),
                V3ActSite::RLAQ(Some(e)) => e.get_field_mut(field),
                V3ActSite::RLFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::RMFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::RN(Some(e)) => e.get_field_mut(field),
                V3ActSite::RPC(Some(e)) => e.get_field_mut(field),
                V3ActSite::RSC(Some(e)) => e.get_field_mut(field),
                V3ActSite::RT(Some(e)) => e.get_field_mut(field),
                V3ActSite::RUA(Some(e)) => e.get_field_mut(field),
                V3ActSite::RUAQ(Some(e)) => e.get_field_mut(field),
                V3ActSite::RUFA(Some(e)) => e.get_field_mut(field),
                V3ActSite::RVG(Some(e)) => e.get_field_mut(field),
                V3ActSite::RVL(Some(e)) => e.get_field_mut(field),
                V3ActSite::_HumanActSite(Some(e)) => e.get_field_mut(field),
                V3ActSite::_HumanSubstanceAdministrationSite(Some(e)) => e.get_field_mut(field),
                V3ActSite::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActStatus {
    #[doc = "aborted"]
    #[code = "aborted"]
    Aborted(Option<Element>),
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "held"]
    #[code = "held"]
    Held(Option<Element>),
    #[doc = "new"]
    #[code = "new"]
    New(Option<Element>),
    #[doc = "normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "nullified"]
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[doc = "obsolete"]
    #[code = "obsolete"]
    Obsolete(Option<Element>),
    #[doc = "suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActStatus {
    fn default() -> Self {
        V3ActStatus::Null(None)
    }
}
impl TryFrom<String> for V3ActStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aborted" => Ok(V3ActStatus::Aborted(None)),
            "active" => Ok(V3ActStatus::Active(None)),
            "cancelled" => Ok(V3ActStatus::Cancelled(None)),
            "completed" => Ok(V3ActStatus::Completed(None)),
            "held" => Ok(V3ActStatus::Held(None)),
            "new" => Ok(V3ActStatus::New(None)),
            "normal" => Ok(V3ActStatus::Normal(None)),
            "nullified" => Ok(V3ActStatus::Nullified(None)),
            "obsolete" => Ok(V3ActStatus::Obsolete(None)),
            "suspended" => Ok(V3ActStatus::Suspended(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActStatus {
    fn into(self) -> Option<String> {
        match self {
            V3ActStatus::Aborted(_) => Some("aborted".to_string()),
            V3ActStatus::Active(_) => Some("active".to_string()),
            V3ActStatus::Cancelled(_) => Some("cancelled".to_string()),
            V3ActStatus::Completed(_) => Some("completed".to_string()),
            V3ActStatus::Held(_) => Some("held".to_string()),
            V3ActStatus::New(_) => Some("new".to_string()),
            V3ActStatus::Normal(_) => Some("normal".to_string()),
            V3ActStatus::Nullified(_) => Some("nullified".to_string()),
            V3ActStatus::Obsolete(_) => Some("obsolete".to_string()),
            V3ActStatus::Suspended(_) => Some("suspended".to_string()),
            V3ActStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActStatus::Aborted(Some(e)) => e.get_field(field),
                V3ActStatus::Active(Some(e)) => e.get_field(field),
                V3ActStatus::Cancelled(Some(e)) => e.get_field(field),
                V3ActStatus::Completed(Some(e)) => e.get_field(field),
                V3ActStatus::Held(Some(e)) => e.get_field(field),
                V3ActStatus::New(Some(e)) => e.get_field(field),
                V3ActStatus::Normal(Some(e)) => e.get_field(field),
                V3ActStatus::Nullified(Some(e)) => e.get_field(field),
                V3ActStatus::Obsolete(Some(e)) => e.get_field(field),
                V3ActStatus::Suspended(Some(e)) => e.get_field(field),
                V3ActStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActStatus::Aborted(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Active(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Completed(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Held(Some(e)) => e.get_field_mut(field),
                V3ActStatus::New(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Normal(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Nullified(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Obsolete(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Suspended(Some(e)) => e.get_field_mut(field),
                V3ActStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActSubstanceAdminSubstitutionCode {
    #[doc = "brand composition"]
    #[code = "BC"]
    BC(Option<Element>),
    #[doc = "equivalent"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "equivalent composition"]
    #[code = "EC"]
    EC(Option<Element>),
    #[doc = "formulary"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "generic composition"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "none"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "therapeutic brand"]
    #[code = "TB"]
    TB(Option<Element>),
    #[doc = "therapeutic alternative"]
    #[code = "TE"]
    TE(Option<Element>),
    #[doc = "therapeutic generic"]
    #[code = "TG"]
    TG(Option<Element>),
    #[doc = "ActSubstanceAdminSubstitutionCode"]
    #[code = "_ActSubstanceAdminSubstitutionCode"]
    _ActSubstanceAdminSubstitutionCode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActSubstanceAdminSubstitutionCode {
    fn default() -> Self {
        V3ActSubstanceAdminSubstitutionCode::Null(None)
    }
}
impl TryFrom<String> for V3ActSubstanceAdminSubstitutionCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BC" => Ok(V3ActSubstanceAdminSubstitutionCode::BC(None)),
            "E" => Ok(V3ActSubstanceAdminSubstitutionCode::E(None)),
            "EC" => Ok(V3ActSubstanceAdminSubstitutionCode::EC(None)),
            "F" => Ok(V3ActSubstanceAdminSubstitutionCode::F(None)),
            "G" => Ok(V3ActSubstanceAdminSubstitutionCode::G(None)),
            "N" => Ok(V3ActSubstanceAdminSubstitutionCode::N(None)),
            "TB" => Ok(V3ActSubstanceAdminSubstitutionCode::TB(None)),
            "TE" => Ok(V3ActSubstanceAdminSubstitutionCode::TE(None)),
            "TG" => Ok(V3ActSubstanceAdminSubstitutionCode::TG(None)),
            "_ActSubstanceAdminSubstitutionCode" => {
                Ok(V3ActSubstanceAdminSubstitutionCode::_ActSubstanceAdminSubstitutionCode(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActSubstanceAdminSubstitutionCode {
    fn into(self) -> Option<String> {
        match self {
            V3ActSubstanceAdminSubstitutionCode::BC(_) => Some("BC".to_string()),
            V3ActSubstanceAdminSubstitutionCode::E(_) => Some("E".to_string()),
            V3ActSubstanceAdminSubstitutionCode::EC(_) => Some("EC".to_string()),
            V3ActSubstanceAdminSubstitutionCode::F(_) => Some("F".to_string()),
            V3ActSubstanceAdminSubstitutionCode::G(_) => Some("G".to_string()),
            V3ActSubstanceAdminSubstitutionCode::N(_) => Some("N".to_string()),
            V3ActSubstanceAdminSubstitutionCode::TB(_) => Some("TB".to_string()),
            V3ActSubstanceAdminSubstitutionCode::TE(_) => Some("TE".to_string()),
            V3ActSubstanceAdminSubstitutionCode::TG(_) => Some("TG".to_string()),
            V3ActSubstanceAdminSubstitutionCode::_ActSubstanceAdminSubstitutionCode(_) => {
                Some("_ActSubstanceAdminSubstitutionCode".to_string())
            }
            V3ActSubstanceAdminSubstitutionCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActSubstanceAdminSubstitutionCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActSubstanceAdminSubstitutionCode::BC(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::E(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::EC(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::F(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::G(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::N(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::TB(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::TE(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::TG(Some(e)) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::_ActSubstanceAdminSubstitutionCode(Some(
                    e,
                )) => e.get_field(field),
                V3ActSubstanceAdminSubstitutionCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActSubstanceAdminSubstitutionCode::BC(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::E(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::EC(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::F(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::G(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::N(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::TB(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::TE(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::TG(Some(e)) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::_ActSubstanceAdminSubstitutionCode(Some(
                    e,
                )) => e.get_field_mut(field),
                V3ActSubstanceAdminSubstitutionCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActUSPrivacyLaw {
    #[doc = "42 CFR Part2"]
    #[code = "42CFRPart2"]
    V42CFRPart2(Option<Element>),
    #[doc = "Common Rule"]
    #[code = "CommonRule"]
    CommonRule(Option<Element>),
    #[doc = "HIPAA notice of privacy practices"]
    #[code = "HIPAANOPP"]
    HIPAANOPP(Option<Element>),
    #[doc = "HIPAA psychotherapy notes"]
    #[code = "HIPAAPsyNotes"]
    HIPAAPsyNotes(Option<Element>),
    #[doc = "HIPAA self-pay"]
    #[code = "HIPAASelfPay"]
    HIPAASelfPay(Option<Element>),
    #[doc = "Title 38 Section 7332"]
    #[code = "Title38Section7332"]
    Title38Section7332(Option<Element>),
    #[doc = "ActUSPrivacyLaw"]
    #[code = "_ActUSPrivacyLaw"]
    _ActUSPrivacyLaw(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActUSPrivacyLaw {
    fn default() -> Self {
        V3ActUSPrivacyLaw::Null(None)
    }
}
impl TryFrom<String> for V3ActUSPrivacyLaw {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "42CFRPart2" => Ok(V3ActUSPrivacyLaw::V42CFRPart2(None)),
            "CommonRule" => Ok(V3ActUSPrivacyLaw::CommonRule(None)),
            "HIPAANOPP" => Ok(V3ActUSPrivacyLaw::HIPAANOPP(None)),
            "HIPAAPsyNotes" => Ok(V3ActUSPrivacyLaw::HIPAAPsyNotes(None)),
            "HIPAASelfPay" => Ok(V3ActUSPrivacyLaw::HIPAASelfPay(None)),
            "Title38Section7332" => Ok(V3ActUSPrivacyLaw::Title38Section7332(None)),
            "_ActUSPrivacyLaw" => Ok(V3ActUSPrivacyLaw::_ActUSPrivacyLaw(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActUSPrivacyLaw {
    fn into(self) -> Option<String> {
        match self {
            V3ActUSPrivacyLaw::V42CFRPart2(_) => Some("42CFRPart2".to_string()),
            V3ActUSPrivacyLaw::CommonRule(_) => Some("CommonRule".to_string()),
            V3ActUSPrivacyLaw::HIPAANOPP(_) => Some("HIPAANOPP".to_string()),
            V3ActUSPrivacyLaw::HIPAAPsyNotes(_) => Some("HIPAAPsyNotes".to_string()),
            V3ActUSPrivacyLaw::HIPAASelfPay(_) => Some("HIPAASelfPay".to_string()),
            V3ActUSPrivacyLaw::Title38Section7332(_) => Some("Title38Section7332".to_string()),
            V3ActUSPrivacyLaw::_ActUSPrivacyLaw(_) => Some("_ActUSPrivacyLaw".to_string()),
            V3ActUSPrivacyLaw::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActUSPrivacyLaw {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActUSPrivacyLaw::V42CFRPart2(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::CommonRule(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::HIPAANOPP(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::HIPAAPsyNotes(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::HIPAASelfPay(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::Title38Section7332(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::_ActUSPrivacyLaw(Some(e)) => e.get_field(field),
                V3ActUSPrivacyLaw::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActUSPrivacyLaw::V42CFRPart2(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::CommonRule(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::HIPAANOPP(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::HIPAAPsyNotes(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::HIPAASelfPay(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::Title38Section7332(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::_ActUSPrivacyLaw(Some(e)) => e.get_field_mut(field),
                V3ActUSPrivacyLaw::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ActUncertainty {
    #[doc = "stated with no assertion of uncertainty"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "stated with uncertainty"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ActUncertainty {
    fn default() -> Self {
        V3ActUncertainty::Null(None)
    }
}
impl TryFrom<String> for V3ActUncertainty {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "N" => Ok(V3ActUncertainty::N(None)),
            "U" => Ok(V3ActUncertainty::U(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ActUncertainty {
    fn into(self) -> Option<String> {
        match self {
            V3ActUncertainty::N(_) => Some("N".to_string()),
            V3ActUncertainty::U(_) => Some("U".to_string()),
            V3ActUncertainty::Null(_) => None,
        }
    }
}
impl MetaValue for V3ActUncertainty {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ActUncertainty::N(Some(e)) => e.get_field(field),
                V3ActUncertainty::U(Some(e)) => e.get_field(field),
                V3ActUncertainty::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ActUncertainty::N(Some(e)) => e.get_field_mut(field),
                V3ActUncertainty::U(Some(e)) => e.get_field_mut(field),
                V3ActUncertainty::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AddressPartType {
    #[doc = "additional locator"]
    #[code = "ADL"]
    ADL(Option<Element>),
    #[doc = "address line"]
    #[code = "AL"]
    AL(Option<Element>),
    #[doc = "building number numeric"]
    #[code = "BNN"]
    BNN(Option<Element>),
    #[doc = "building number"]
    #[code = "BNR"]
    BNR(Option<Element>),
    #[doc = "building number suffix"]
    #[code = "BNS"]
    BNS(Option<Element>),
    #[doc = "care of"]
    #[code = "CAR"]
    CAR(Option<Element>),
    #[doc = "census tract"]
    #[code = "CEN"]
    CEN(Option<Element>),
    #[doc = "country"]
    #[code = "CNT"]
    CNT(Option<Element>),
    #[doc = "county or parish"]
    #[code = "CPA"]
    CPA(Option<Element>),
    #[doc = "municipality"]
    #[code = "CTY"]
    CTY(Option<Element>),
    #[doc = "delivery address line"]
    #[code = "DAL"]
    DAL(Option<Element>),
    #[doc = "delimiter"]
    #[code = "DEL"]
    DEL(Option<Element>),
    #[doc = "delivery installation type"]
    #[code = "DINST"]
    DINST(Option<Element>),
    #[doc = "delivery installation area"]
    #[code = "DINSTA"]
    DINSTA(Option<Element>),
    #[doc = "delivery installation qualifier"]
    #[code = "DINSTQ"]
    DINSTQ(Option<Element>),
    #[doc = "direction"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "delivery mode"]
    #[code = "DMOD"]
    DMOD(Option<Element>),
    #[doc = "delivery mode identifier"]
    #[code = "DMODID"]
    DMODID(Option<Element>),
    #[doc = "delivery point identifier"]
    #[code = "DPID"]
    DPID(Option<Element>),
    #[doc = "intersection"]
    #[code = "INT"]
    INT(Option<Element>),
    #[doc = "post box"]
    #[code = "POB"]
    POB(Option<Element>),
    #[doc = "precinct"]
    #[code = "PRE"]
    PRE(Option<Element>),
    #[doc = "street address line"]
    #[code = "SAL"]
    SAL(Option<Element>),
    #[doc = "state or province"]
    #[code = "STA"]
    STA(Option<Element>),
    #[doc = "street name base"]
    #[code = "STB"]
    STB(Option<Element>),
    #[doc = "street name"]
    #[code = "STR"]
    STR(Option<Element>),
    #[doc = "street type"]
    #[code = "STTYP"]
    STTYP(Option<Element>),
    #[doc = "unit identifier"]
    #[code = "UNID"]
    UNID(Option<Element>),
    #[doc = "unit designator"]
    #[code = "UNIT"]
    UNIT(Option<Element>),
    #[doc = "postal code"]
    #[code = "ZIP"]
    ZIP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AddressPartType {
    fn default() -> Self {
        V3AddressPartType::Null(None)
    }
}
impl TryFrom<String> for V3AddressPartType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADL" => Ok(V3AddressPartType::ADL(None)),
            "AL" => Ok(V3AddressPartType::AL(None)),
            "BNN" => Ok(V3AddressPartType::BNN(None)),
            "BNR" => Ok(V3AddressPartType::BNR(None)),
            "BNS" => Ok(V3AddressPartType::BNS(None)),
            "CAR" => Ok(V3AddressPartType::CAR(None)),
            "CEN" => Ok(V3AddressPartType::CEN(None)),
            "CNT" => Ok(V3AddressPartType::CNT(None)),
            "CPA" => Ok(V3AddressPartType::CPA(None)),
            "CTY" => Ok(V3AddressPartType::CTY(None)),
            "DAL" => Ok(V3AddressPartType::DAL(None)),
            "DEL" => Ok(V3AddressPartType::DEL(None)),
            "DINST" => Ok(V3AddressPartType::DINST(None)),
            "DINSTA" => Ok(V3AddressPartType::DINSTA(None)),
            "DINSTQ" => Ok(V3AddressPartType::DINSTQ(None)),
            "DIR" => Ok(V3AddressPartType::DIR(None)),
            "DMOD" => Ok(V3AddressPartType::DMOD(None)),
            "DMODID" => Ok(V3AddressPartType::DMODID(None)),
            "DPID" => Ok(V3AddressPartType::DPID(None)),
            "INT" => Ok(V3AddressPartType::INT(None)),
            "POB" => Ok(V3AddressPartType::POB(None)),
            "PRE" => Ok(V3AddressPartType::PRE(None)),
            "SAL" => Ok(V3AddressPartType::SAL(None)),
            "STA" => Ok(V3AddressPartType::STA(None)),
            "STB" => Ok(V3AddressPartType::STB(None)),
            "STR" => Ok(V3AddressPartType::STR(None)),
            "STTYP" => Ok(V3AddressPartType::STTYP(None)),
            "UNID" => Ok(V3AddressPartType::UNID(None)),
            "UNIT" => Ok(V3AddressPartType::UNIT(None)),
            "ZIP" => Ok(V3AddressPartType::ZIP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AddressPartType {
    fn into(self) -> Option<String> {
        match self {
            V3AddressPartType::ADL(_) => Some("ADL".to_string()),
            V3AddressPartType::AL(_) => Some("AL".to_string()),
            V3AddressPartType::BNN(_) => Some("BNN".to_string()),
            V3AddressPartType::BNR(_) => Some("BNR".to_string()),
            V3AddressPartType::BNS(_) => Some("BNS".to_string()),
            V3AddressPartType::CAR(_) => Some("CAR".to_string()),
            V3AddressPartType::CEN(_) => Some("CEN".to_string()),
            V3AddressPartType::CNT(_) => Some("CNT".to_string()),
            V3AddressPartType::CPA(_) => Some("CPA".to_string()),
            V3AddressPartType::CTY(_) => Some("CTY".to_string()),
            V3AddressPartType::DAL(_) => Some("DAL".to_string()),
            V3AddressPartType::DEL(_) => Some("DEL".to_string()),
            V3AddressPartType::DINST(_) => Some("DINST".to_string()),
            V3AddressPartType::DINSTA(_) => Some("DINSTA".to_string()),
            V3AddressPartType::DINSTQ(_) => Some("DINSTQ".to_string()),
            V3AddressPartType::DIR(_) => Some("DIR".to_string()),
            V3AddressPartType::DMOD(_) => Some("DMOD".to_string()),
            V3AddressPartType::DMODID(_) => Some("DMODID".to_string()),
            V3AddressPartType::DPID(_) => Some("DPID".to_string()),
            V3AddressPartType::INT(_) => Some("INT".to_string()),
            V3AddressPartType::POB(_) => Some("POB".to_string()),
            V3AddressPartType::PRE(_) => Some("PRE".to_string()),
            V3AddressPartType::SAL(_) => Some("SAL".to_string()),
            V3AddressPartType::STA(_) => Some("STA".to_string()),
            V3AddressPartType::STB(_) => Some("STB".to_string()),
            V3AddressPartType::STR(_) => Some("STR".to_string()),
            V3AddressPartType::STTYP(_) => Some("STTYP".to_string()),
            V3AddressPartType::UNID(_) => Some("UNID".to_string()),
            V3AddressPartType::UNIT(_) => Some("UNIT".to_string()),
            V3AddressPartType::ZIP(_) => Some("ZIP".to_string()),
            V3AddressPartType::Null(_) => None,
        }
    }
}
impl MetaValue for V3AddressPartType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AddressPartType::ADL(Some(e)) => e.get_field(field),
                V3AddressPartType::AL(Some(e)) => e.get_field(field),
                V3AddressPartType::BNN(Some(e)) => e.get_field(field),
                V3AddressPartType::BNR(Some(e)) => e.get_field(field),
                V3AddressPartType::BNS(Some(e)) => e.get_field(field),
                V3AddressPartType::CAR(Some(e)) => e.get_field(field),
                V3AddressPartType::CEN(Some(e)) => e.get_field(field),
                V3AddressPartType::CNT(Some(e)) => e.get_field(field),
                V3AddressPartType::CPA(Some(e)) => e.get_field(field),
                V3AddressPartType::CTY(Some(e)) => e.get_field(field),
                V3AddressPartType::DAL(Some(e)) => e.get_field(field),
                V3AddressPartType::DEL(Some(e)) => e.get_field(field),
                V3AddressPartType::DINST(Some(e)) => e.get_field(field),
                V3AddressPartType::DINSTA(Some(e)) => e.get_field(field),
                V3AddressPartType::DINSTQ(Some(e)) => e.get_field(field),
                V3AddressPartType::DIR(Some(e)) => e.get_field(field),
                V3AddressPartType::DMOD(Some(e)) => e.get_field(field),
                V3AddressPartType::DMODID(Some(e)) => e.get_field(field),
                V3AddressPartType::DPID(Some(e)) => e.get_field(field),
                V3AddressPartType::INT(Some(e)) => e.get_field(field),
                V3AddressPartType::POB(Some(e)) => e.get_field(field),
                V3AddressPartType::PRE(Some(e)) => e.get_field(field),
                V3AddressPartType::SAL(Some(e)) => e.get_field(field),
                V3AddressPartType::STA(Some(e)) => e.get_field(field),
                V3AddressPartType::STB(Some(e)) => e.get_field(field),
                V3AddressPartType::STR(Some(e)) => e.get_field(field),
                V3AddressPartType::STTYP(Some(e)) => e.get_field(field),
                V3AddressPartType::UNID(Some(e)) => e.get_field(field),
                V3AddressPartType::UNIT(Some(e)) => e.get_field(field),
                V3AddressPartType::ZIP(Some(e)) => e.get_field(field),
                V3AddressPartType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AddressPartType::ADL(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::AL(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::BNN(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::BNR(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::BNS(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::CAR(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::CEN(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::CNT(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::CPA(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::CTY(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DAL(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DEL(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DINST(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DINSTA(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DINSTQ(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DIR(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DMOD(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DMODID(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::DPID(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::INT(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::POB(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::PRE(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::SAL(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::STA(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::STB(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::STR(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::STTYP(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::UNID(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::UNIT(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::ZIP(Some(e)) => e.get_field_mut(field),
                V3AddressPartType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AddressUse {
    #[doc = "answering service"]
    #[code = "AS"]
    AS(Option<Element>),
    #[doc = "bad address"]
    #[code = "BAD"]
    BAD(Option<Element>),
    #[doc = "confidential address"]
    #[code = "CONF"]
    CONF(Option<Element>),
    #[doc = "direct"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "emergency contact"]
    #[code = "EC"]
    EC(Option<Element>),
    #[doc = "home address"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "primary home"]
    #[code = "HP"]
    HP(Option<Element>),
    #[doc = "vacation home"]
    #[code = "HV"]
    HV(Option<Element>),
    #[doc = "mobile contact)"]
    #[code = "MC"]
    MC(Option<Element>),
    #[doc = "no longer in use"]
    #[code = "OLD"]
    OLD(Option<Element>),
    #[doc = "pager"]
    #[code = "PG"]
    PG(Option<Element>),
    #[doc = "physical visit address"]
    #[code = "PHYS"]
    PHYS(Option<Element>),
    #[doc = "postal address"]
    #[code = "PST"]
    PST(Option<Element>),
    #[doc = "public"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "temporary address"]
    #[code = "TMP"]
    TMP(Option<Element>),
    #[doc = "work place"]
    #[code = "WP"]
    WP(Option<Element>),
    #[doc = "_GeneralAddressUse"]
    #[code = "_GeneralAddressUse"]
    _GeneralAddressUse(Option<Element>),
    #[doc = "_PostalAddressUse"]
    #[code = "_PostalAddressUse"]
    _PostalAddressUse(Option<Element>),
    #[doc = "_TelecommunicationAddressUse"]
    #[code = "_TelecommunicationAddressUse"]
    _TelecommunicationAddressUse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AddressUse {
    fn default() -> Self {
        V3AddressUse::Null(None)
    }
}
impl TryFrom<String> for V3AddressUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AS" => Ok(V3AddressUse::AS(None)),
            "BAD" => Ok(V3AddressUse::BAD(None)),
            "CONF" => Ok(V3AddressUse::CONF(None)),
            "DIR" => Ok(V3AddressUse::DIR(None)),
            "EC" => Ok(V3AddressUse::EC(None)),
            "H" => Ok(V3AddressUse::H(None)),
            "HP" => Ok(V3AddressUse::HP(None)),
            "HV" => Ok(V3AddressUse::HV(None)),
            "MC" => Ok(V3AddressUse::MC(None)),
            "OLD" => Ok(V3AddressUse::OLD(None)),
            "PG" => Ok(V3AddressUse::PG(None)),
            "PHYS" => Ok(V3AddressUse::PHYS(None)),
            "PST" => Ok(V3AddressUse::PST(None)),
            "PUB" => Ok(V3AddressUse::PUB(None)),
            "TMP" => Ok(V3AddressUse::TMP(None)),
            "WP" => Ok(V3AddressUse::WP(None)),
            "_GeneralAddressUse" => Ok(V3AddressUse::_GeneralAddressUse(None)),
            "_PostalAddressUse" => Ok(V3AddressUse::_PostalAddressUse(None)),
            "_TelecommunicationAddressUse" => Ok(V3AddressUse::_TelecommunicationAddressUse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AddressUse {
    fn into(self) -> Option<String> {
        match self {
            V3AddressUse::AS(_) => Some("AS".to_string()),
            V3AddressUse::BAD(_) => Some("BAD".to_string()),
            V3AddressUse::CONF(_) => Some("CONF".to_string()),
            V3AddressUse::DIR(_) => Some("DIR".to_string()),
            V3AddressUse::EC(_) => Some("EC".to_string()),
            V3AddressUse::H(_) => Some("H".to_string()),
            V3AddressUse::HP(_) => Some("HP".to_string()),
            V3AddressUse::HV(_) => Some("HV".to_string()),
            V3AddressUse::MC(_) => Some("MC".to_string()),
            V3AddressUse::OLD(_) => Some("OLD".to_string()),
            V3AddressUse::PG(_) => Some("PG".to_string()),
            V3AddressUse::PHYS(_) => Some("PHYS".to_string()),
            V3AddressUse::PST(_) => Some("PST".to_string()),
            V3AddressUse::PUB(_) => Some("PUB".to_string()),
            V3AddressUse::TMP(_) => Some("TMP".to_string()),
            V3AddressUse::WP(_) => Some("WP".to_string()),
            V3AddressUse::_GeneralAddressUse(_) => Some("_GeneralAddressUse".to_string()),
            V3AddressUse::_PostalAddressUse(_) => Some("_PostalAddressUse".to_string()),
            V3AddressUse::_TelecommunicationAddressUse(_) => {
                Some("_TelecommunicationAddressUse".to_string())
            }
            V3AddressUse::Null(_) => None,
        }
    }
}
impl MetaValue for V3AddressUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AddressUse::AS(Some(e)) => e.get_field(field),
                V3AddressUse::BAD(Some(e)) => e.get_field(field),
                V3AddressUse::CONF(Some(e)) => e.get_field(field),
                V3AddressUse::DIR(Some(e)) => e.get_field(field),
                V3AddressUse::EC(Some(e)) => e.get_field(field),
                V3AddressUse::H(Some(e)) => e.get_field(field),
                V3AddressUse::HP(Some(e)) => e.get_field(field),
                V3AddressUse::HV(Some(e)) => e.get_field(field),
                V3AddressUse::MC(Some(e)) => e.get_field(field),
                V3AddressUse::OLD(Some(e)) => e.get_field(field),
                V3AddressUse::PG(Some(e)) => e.get_field(field),
                V3AddressUse::PHYS(Some(e)) => e.get_field(field),
                V3AddressUse::PST(Some(e)) => e.get_field(field),
                V3AddressUse::PUB(Some(e)) => e.get_field(field),
                V3AddressUse::TMP(Some(e)) => e.get_field(field),
                V3AddressUse::WP(Some(e)) => e.get_field(field),
                V3AddressUse::_GeneralAddressUse(Some(e)) => e.get_field(field),
                V3AddressUse::_PostalAddressUse(Some(e)) => e.get_field(field),
                V3AddressUse::_TelecommunicationAddressUse(Some(e)) => e.get_field(field),
                V3AddressUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AddressUse::AS(Some(e)) => e.get_field_mut(field),
                V3AddressUse::BAD(Some(e)) => e.get_field_mut(field),
                V3AddressUse::CONF(Some(e)) => e.get_field_mut(field),
                V3AddressUse::DIR(Some(e)) => e.get_field_mut(field),
                V3AddressUse::EC(Some(e)) => e.get_field_mut(field),
                V3AddressUse::H(Some(e)) => e.get_field_mut(field),
                V3AddressUse::HP(Some(e)) => e.get_field_mut(field),
                V3AddressUse::HV(Some(e)) => e.get_field_mut(field),
                V3AddressUse::MC(Some(e)) => e.get_field_mut(field),
                V3AddressUse::OLD(Some(e)) => e.get_field_mut(field),
                V3AddressUse::PG(Some(e)) => e.get_field_mut(field),
                V3AddressUse::PHYS(Some(e)) => e.get_field_mut(field),
                V3AddressUse::PST(Some(e)) => e.get_field_mut(field),
                V3AddressUse::PUB(Some(e)) => e.get_field_mut(field),
                V3AddressUse::TMP(Some(e)) => e.get_field_mut(field),
                V3AddressUse::WP(Some(e)) => e.get_field_mut(field),
                V3AddressUse::_GeneralAddressUse(Some(e)) => e.get_field_mut(field),
                V3AddressUse::_PostalAddressUse(Some(e)) => e.get_field_mut(field),
                V3AddressUse::_TelecommunicationAddressUse(Some(e)) => e.get_field_mut(field),
                V3AddressUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3AdministrativeGender {
    #[doc = "Female"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "Male"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "Undifferentiated"]
    #[code = "UN"]
    UN(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3AdministrativeGender {
    fn default() -> Self {
        V3AdministrativeGender::Null(None)
    }
}
impl TryFrom<String> for V3AdministrativeGender {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "F" => Ok(V3AdministrativeGender::F(None)),
            "M" => Ok(V3AdministrativeGender::M(None)),
            "UN" => Ok(V3AdministrativeGender::UN(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3AdministrativeGender {
    fn into(self) -> Option<String> {
        match self {
            V3AdministrativeGender::F(_) => Some("F".to_string()),
            V3AdministrativeGender::M(_) => Some("M".to_string()),
            V3AdministrativeGender::UN(_) => Some("UN".to_string()),
            V3AdministrativeGender::Null(_) => None,
        }
    }
}
impl MetaValue for V3AdministrativeGender {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3AdministrativeGender::F(Some(e)) => e.get_field(field),
                V3AdministrativeGender::M(Some(e)) => e.get_field(field),
                V3AdministrativeGender::UN(Some(e)) => e.get_field(field),
                V3AdministrativeGender::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3AdministrativeGender::F(Some(e)) => e.get_field_mut(field),
                V3AdministrativeGender::M(Some(e)) => e.get_field_mut(field),
                V3AdministrativeGender::UN(Some(e)) => e.get_field_mut(field),
                V3AdministrativeGender::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Calendar {
    #[doc = "Gregorian"]
    #[code = "GREG"]
    GREG(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Calendar {
    fn default() -> Self {
        V3Calendar::Null(None)
    }
}
impl TryFrom<String> for V3Calendar {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "GREG" => Ok(V3Calendar::GREG(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Calendar {
    fn into(self) -> Option<String> {
        match self {
            V3Calendar::GREG(_) => Some("GREG".to_string()),
            V3Calendar::Null(_) => None,
        }
    }
}
impl MetaValue for V3Calendar {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Calendar::GREG(Some(e)) => e.get_field(field),
                V3Calendar::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Calendar::GREG(Some(e)) => e.get_field_mut(field),
                V3Calendar::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3CalendarCycle {
    #[doc = "day (continuous)"]
    #[code = "CD"]
    CD(Option<Element>),
    #[doc = "hour (continuous)"]
    #[code = "CH"]
    CH(Option<Element>),
    #[doc = "month (continuous)"]
    #[code = "CM"]
    CM(Option<Element>),
    #[doc = "minute (continuous)"]
    #[code = "CN"]
    CN(Option<Element>),
    #[doc = "second (continuous)"]
    #[code = "CS"]
    CS(Option<Element>),
    #[doc = "week (continuous)"]
    #[code = "CW"]
    CW(Option<Element>),
    #[doc = "year"]
    #[code = "CY"]
    CY(Option<Element>),
    #[doc = "day of the month"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "day of the week (begins with Monday)"]
    #[code = "DW"]
    DW(Option<Element>),
    #[doc = "day of the year"]
    #[code = "DY"]
    DY(Option<Element>),
    #[doc = "hour of the day"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "month of the year"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "minute of the hour"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "second of the minute"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "week of the month"]
    #[code = "WM"]
    WM(Option<Element>),
    #[doc = "week of the year"]
    #[code = "WY"]
    WY(Option<Element>),
    #[doc = "CalendarCycleOneLetter"]
    #[code = "_CalendarCycleOneLetter"]
    _CalendarCycleOneLetter(Option<Element>),
    #[doc = "CalendarCycleTwoLetter"]
    #[code = "_CalendarCycleTwoLetter"]
    _CalendarCycleTwoLetter(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3CalendarCycle {
    fn default() -> Self {
        V3CalendarCycle::Null(None)
    }
}
impl TryFrom<String> for V3CalendarCycle {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CD" => Ok(V3CalendarCycle::CD(None)),
            "CH" => Ok(V3CalendarCycle::CH(None)),
            "CM" => Ok(V3CalendarCycle::CM(None)),
            "CN" => Ok(V3CalendarCycle::CN(None)),
            "CS" => Ok(V3CalendarCycle::CS(None)),
            "CW" => Ok(V3CalendarCycle::CW(None)),
            "CY" => Ok(V3CalendarCycle::CY(None)),
            "D" => Ok(V3CalendarCycle::D(None)),
            "DW" => Ok(V3CalendarCycle::DW(None)),
            "DY" => Ok(V3CalendarCycle::DY(None)),
            "H" => Ok(V3CalendarCycle::H(None)),
            "M" => Ok(V3CalendarCycle::M(None)),
            "N" => Ok(V3CalendarCycle::N(None)),
            "S" => Ok(V3CalendarCycle::S(None)),
            "WM" => Ok(V3CalendarCycle::WM(None)),
            "WY" => Ok(V3CalendarCycle::WY(None)),
            "_CalendarCycleOneLetter" => Ok(V3CalendarCycle::_CalendarCycleOneLetter(None)),
            "_CalendarCycleTwoLetter" => Ok(V3CalendarCycle::_CalendarCycleTwoLetter(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3CalendarCycle {
    fn into(self) -> Option<String> {
        match self {
            V3CalendarCycle::CD(_) => Some("CD".to_string()),
            V3CalendarCycle::CH(_) => Some("CH".to_string()),
            V3CalendarCycle::CM(_) => Some("CM".to_string()),
            V3CalendarCycle::CN(_) => Some("CN".to_string()),
            V3CalendarCycle::CS(_) => Some("CS".to_string()),
            V3CalendarCycle::CW(_) => Some("CW".to_string()),
            V3CalendarCycle::CY(_) => Some("CY".to_string()),
            V3CalendarCycle::D(_) => Some("D".to_string()),
            V3CalendarCycle::DW(_) => Some("DW".to_string()),
            V3CalendarCycle::DY(_) => Some("DY".to_string()),
            V3CalendarCycle::H(_) => Some("H".to_string()),
            V3CalendarCycle::M(_) => Some("M".to_string()),
            V3CalendarCycle::N(_) => Some("N".to_string()),
            V3CalendarCycle::S(_) => Some("S".to_string()),
            V3CalendarCycle::WM(_) => Some("WM".to_string()),
            V3CalendarCycle::WY(_) => Some("WY".to_string()),
            V3CalendarCycle::_CalendarCycleOneLetter(_) => {
                Some("_CalendarCycleOneLetter".to_string())
            }
            V3CalendarCycle::_CalendarCycleTwoLetter(_) => {
                Some("_CalendarCycleTwoLetter".to_string())
            }
            V3CalendarCycle::Null(_) => None,
        }
    }
}
impl MetaValue for V3CalendarCycle {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3CalendarCycle::CD(Some(e)) => e.get_field(field),
                V3CalendarCycle::CH(Some(e)) => e.get_field(field),
                V3CalendarCycle::CM(Some(e)) => e.get_field(field),
                V3CalendarCycle::CN(Some(e)) => e.get_field(field),
                V3CalendarCycle::CS(Some(e)) => e.get_field(field),
                V3CalendarCycle::CW(Some(e)) => e.get_field(field),
                V3CalendarCycle::CY(Some(e)) => e.get_field(field),
                V3CalendarCycle::D(Some(e)) => e.get_field(field),
                V3CalendarCycle::DW(Some(e)) => e.get_field(field),
                V3CalendarCycle::DY(Some(e)) => e.get_field(field),
                V3CalendarCycle::H(Some(e)) => e.get_field(field),
                V3CalendarCycle::M(Some(e)) => e.get_field(field),
                V3CalendarCycle::N(Some(e)) => e.get_field(field),
                V3CalendarCycle::S(Some(e)) => e.get_field(field),
                V3CalendarCycle::WM(Some(e)) => e.get_field(field),
                V3CalendarCycle::WY(Some(e)) => e.get_field(field),
                V3CalendarCycle::_CalendarCycleOneLetter(Some(e)) => e.get_field(field),
                V3CalendarCycle::_CalendarCycleTwoLetter(Some(e)) => e.get_field(field),
                V3CalendarCycle::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3CalendarCycle::CD(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CH(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CM(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CN(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CS(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CW(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::CY(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::D(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::DW(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::DY(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::H(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::M(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::N(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::S(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::WM(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::WY(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::_CalendarCycleOneLetter(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::_CalendarCycleTwoLetter(Some(e)) => e.get_field_mut(field),
                V3CalendarCycle::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3CalendarType {
    #[doc = "Gregorian"]
    #[code = "GREG"]
    GREG(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3CalendarType {
    fn default() -> Self {
        V3CalendarType::Null(None)
    }
}
impl TryFrom<String> for V3CalendarType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "GREG" => Ok(V3CalendarType::GREG(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3CalendarType {
    fn into(self) -> Option<String> {
        match self {
            V3CalendarType::GREG(_) => Some("GREG".to_string()),
            V3CalendarType::Null(_) => None,
        }
    }
}
impl MetaValue for V3CalendarType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3CalendarType::GREG(Some(e)) => e.get_field(field),
                V3CalendarType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3CalendarType::GREG(Some(e)) => e.get_field_mut(field),
                V3CalendarType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Charset {
    #[doc = "EBCDIC"]
    #[code = "EBCDIC"]
    EBCDIC(Option<Element>),
    #[doc = "ISO-10646-UCS-2"]
    #[code = "ISO-10646-UCS-2"]
    ISO10646UCS2(Option<Element>),
    #[doc = "ISO-10646-UCS-4"]
    #[code = "ISO-10646-UCS-4"]
    ISO10646UCS4(Option<Element>),
    #[doc = "ISO-8859-1"]
    #[code = "ISO-8859-1"]
    ISO88591(Option<Element>),
    #[doc = "ISO-8859-2"]
    #[code = "ISO-8859-2"]
    ISO88592(Option<Element>),
    #[doc = "ISO-8859-5"]
    #[code = "ISO-8859-5"]
    ISO88595(Option<Element>),
    #[doc = "JIS-2022-JP"]
    #[code = "JIS-2022-JP"]
    JIS2022JP(Option<Element>),
    #[doc = "US-ASCII"]
    #[code = "US-ASCII"]
    USASCII(Option<Element>),
    #[doc = "UTF-7"]
    #[code = "UTF-7"]
    UTF7(Option<Element>),
    #[doc = "UTF-8"]
    #[code = "UTF-8"]
    UTF8(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Charset {
    fn default() -> Self {
        V3Charset::Null(None)
    }
}
impl TryFrom<String> for V3Charset {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "EBCDIC" => Ok(V3Charset::EBCDIC(None)),
            "ISO-10646-UCS-2" => Ok(V3Charset::ISO10646UCS2(None)),
            "ISO-10646-UCS-4" => Ok(V3Charset::ISO10646UCS4(None)),
            "ISO-8859-1" => Ok(V3Charset::ISO88591(None)),
            "ISO-8859-2" => Ok(V3Charset::ISO88592(None)),
            "ISO-8859-5" => Ok(V3Charset::ISO88595(None)),
            "JIS-2022-JP" => Ok(V3Charset::JIS2022JP(None)),
            "US-ASCII" => Ok(V3Charset::USASCII(None)),
            "UTF-7" => Ok(V3Charset::UTF7(None)),
            "UTF-8" => Ok(V3Charset::UTF8(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Charset {
    fn into(self) -> Option<String> {
        match self {
            V3Charset::EBCDIC(_) => Some("EBCDIC".to_string()),
            V3Charset::ISO10646UCS2(_) => Some("ISO-10646-UCS-2".to_string()),
            V3Charset::ISO10646UCS4(_) => Some("ISO-10646-UCS-4".to_string()),
            V3Charset::ISO88591(_) => Some("ISO-8859-1".to_string()),
            V3Charset::ISO88592(_) => Some("ISO-8859-2".to_string()),
            V3Charset::ISO88595(_) => Some("ISO-8859-5".to_string()),
            V3Charset::JIS2022JP(_) => Some("JIS-2022-JP".to_string()),
            V3Charset::USASCII(_) => Some("US-ASCII".to_string()),
            V3Charset::UTF7(_) => Some("UTF-7".to_string()),
            V3Charset::UTF8(_) => Some("UTF-8".to_string()),
            V3Charset::Null(_) => None,
        }
    }
}
impl MetaValue for V3Charset {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Charset::EBCDIC(Some(e)) => e.get_field(field),
                V3Charset::ISO10646UCS2(Some(e)) => e.get_field(field),
                V3Charset::ISO10646UCS4(Some(e)) => e.get_field(field),
                V3Charset::ISO88591(Some(e)) => e.get_field(field),
                V3Charset::ISO88592(Some(e)) => e.get_field(field),
                V3Charset::ISO88595(Some(e)) => e.get_field(field),
                V3Charset::JIS2022JP(Some(e)) => e.get_field(field),
                V3Charset::USASCII(Some(e)) => e.get_field(field),
                V3Charset::UTF7(Some(e)) => e.get_field(field),
                V3Charset::UTF8(Some(e)) => e.get_field(field),
                V3Charset::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Charset::EBCDIC(Some(e)) => e.get_field_mut(field),
                V3Charset::ISO10646UCS2(Some(e)) => e.get_field_mut(field),
                V3Charset::ISO10646UCS4(Some(e)) => e.get_field_mut(field),
                V3Charset::ISO88591(Some(e)) => e.get_field_mut(field),
                V3Charset::ISO88592(Some(e)) => e.get_field_mut(field),
                V3Charset::ISO88595(Some(e)) => e.get_field_mut(field),
                V3Charset::JIS2022JP(Some(e)) => e.get_field_mut(field),
                V3Charset::USASCII(Some(e)) => e.get_field_mut(field),
                V3Charset::UTF7(Some(e)) => e.get_field_mut(field),
                V3Charset::UTF8(Some(e)) => e.get_field_mut(field),
                V3Charset::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3CodingRationale {
    #[doc = "HL7 Specified or Mandated"]
    #[code = "HL7"]
    HL7(Option<Element>),
    #[doc = "originally produced code"]
    #[code = "O"]
    O(Option<Element>),
    #[doc = "original and required"]
    #[code = "OR"]
    OR(Option<Element>),
    #[doc = "post-coded"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "post-coded and required"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "required"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Both HL7 mandated and the original code"]
    #[code = "SH"]
    SH(Option<Element>),
    #[doc = "Source (or original) code"]
    #[code = "SRC"]
    SRC(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3CodingRationale {
    fn default() -> Self {
        V3CodingRationale::Null(None)
    }
}
impl TryFrom<String> for V3CodingRationale {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "HL7" => Ok(V3CodingRationale::HL7(None)),
            "O" => Ok(V3CodingRationale::O(None)),
            "OR" => Ok(V3CodingRationale::OR(None)),
            "P" => Ok(V3CodingRationale::P(None)),
            "PR" => Ok(V3CodingRationale::PR(None)),
            "R" => Ok(V3CodingRationale::R(None)),
            "SH" => Ok(V3CodingRationale::SH(None)),
            "SRC" => Ok(V3CodingRationale::SRC(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3CodingRationale {
    fn into(self) -> Option<String> {
        match self {
            V3CodingRationale::HL7(_) => Some("HL7".to_string()),
            V3CodingRationale::O(_) => Some("O".to_string()),
            V3CodingRationale::OR(_) => Some("OR".to_string()),
            V3CodingRationale::P(_) => Some("P".to_string()),
            V3CodingRationale::PR(_) => Some("PR".to_string()),
            V3CodingRationale::R(_) => Some("R".to_string()),
            V3CodingRationale::SH(_) => Some("SH".to_string()),
            V3CodingRationale::SRC(_) => Some("SRC".to_string()),
            V3CodingRationale::Null(_) => None,
        }
    }
}
impl MetaValue for V3CodingRationale {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3CodingRationale::HL7(Some(e)) => e.get_field(field),
                V3CodingRationale::O(Some(e)) => e.get_field(field),
                V3CodingRationale::OR(Some(e)) => e.get_field(field),
                V3CodingRationale::P(Some(e)) => e.get_field(field),
                V3CodingRationale::PR(Some(e)) => e.get_field(field),
                V3CodingRationale::R(Some(e)) => e.get_field(field),
                V3CodingRationale::SH(Some(e)) => e.get_field(field),
                V3CodingRationale::SRC(Some(e)) => e.get_field(field),
                V3CodingRationale::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3CodingRationale::HL7(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::O(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::OR(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::P(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::PR(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::R(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::SH(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::SRC(Some(e)) => e.get_field_mut(field),
                V3CodingRationale::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3CommunicationFunctionType {
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "respond to"]
    #[code = "RSP"]
    RSP(Option<Element>),
    #[doc = "sender"]
    #[code = "SND"]
    SND(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3CommunicationFunctionType {
    fn default() -> Self {
        V3CommunicationFunctionType::Null(None)
    }
}
impl TryFrom<String> for V3CommunicationFunctionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "RCV" => Ok(V3CommunicationFunctionType::RCV(None)),
            "RSP" => Ok(V3CommunicationFunctionType::RSP(None)),
            "SND" => Ok(V3CommunicationFunctionType::SND(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3CommunicationFunctionType {
    fn into(self) -> Option<String> {
        match self {
            V3CommunicationFunctionType::RCV(_) => Some("RCV".to_string()),
            V3CommunicationFunctionType::RSP(_) => Some("RSP".to_string()),
            V3CommunicationFunctionType::SND(_) => Some("SND".to_string()),
            V3CommunicationFunctionType::Null(_) => None,
        }
    }
}
impl MetaValue for V3CommunicationFunctionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3CommunicationFunctionType::RCV(Some(e)) => e.get_field(field),
                V3CommunicationFunctionType::RSP(Some(e)) => e.get_field(field),
                V3CommunicationFunctionType::SND(Some(e)) => e.get_field(field),
                V3CommunicationFunctionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3CommunicationFunctionType::RCV(Some(e)) => e.get_field_mut(field),
                V3CommunicationFunctionType::RSP(Some(e)) => e.get_field_mut(field),
                V3CommunicationFunctionType::SND(Some(e)) => e.get_field_mut(field),
                V3CommunicationFunctionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3CompressionAlgorithm {
    #[doc = "bzip"]
    #[code = "BZ"]
    BZ(Option<Element>),
    #[doc = "deflate"]
    #[code = "DF"]
    DF(Option<Element>),
    #[doc = "gzip"]
    #[code = "GZ"]
    GZ(Option<Element>),
    #[doc = "compress"]
    #[code = "Z"]
    Z(Option<Element>),
    #[doc = "Z7"]
    #[code = "Z7"]
    Z7(Option<Element>),
    #[doc = "zlib"]
    #[code = "ZL"]
    ZL(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3CompressionAlgorithm {
    fn default() -> Self {
        V3CompressionAlgorithm::Null(None)
    }
}
impl TryFrom<String> for V3CompressionAlgorithm {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BZ" => Ok(V3CompressionAlgorithm::BZ(None)),
            "DF" => Ok(V3CompressionAlgorithm::DF(None)),
            "GZ" => Ok(V3CompressionAlgorithm::GZ(None)),
            "Z" => Ok(V3CompressionAlgorithm::Z(None)),
            "Z7" => Ok(V3CompressionAlgorithm::Z7(None)),
            "ZL" => Ok(V3CompressionAlgorithm::ZL(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3CompressionAlgorithm {
    fn into(self) -> Option<String> {
        match self {
            V3CompressionAlgorithm::BZ(_) => Some("BZ".to_string()),
            V3CompressionAlgorithm::DF(_) => Some("DF".to_string()),
            V3CompressionAlgorithm::GZ(_) => Some("GZ".to_string()),
            V3CompressionAlgorithm::Z(_) => Some("Z".to_string()),
            V3CompressionAlgorithm::Z7(_) => Some("Z7".to_string()),
            V3CompressionAlgorithm::ZL(_) => Some("ZL".to_string()),
            V3CompressionAlgorithm::Null(_) => None,
        }
    }
}
impl MetaValue for V3CompressionAlgorithm {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3CompressionAlgorithm::BZ(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::DF(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::GZ(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::Z(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::Z7(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::ZL(Some(e)) => e.get_field(field),
                V3CompressionAlgorithm::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3CompressionAlgorithm::BZ(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::DF(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::GZ(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::Z(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::Z7(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::ZL(Some(e)) => e.get_field_mut(field),
                V3CompressionAlgorithm::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Confidentiality {
    #[doc = "business"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "celebrity"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "clinician"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "substance abuse related"]
    #[code = "ETH"]
    ETH(Option<Element>),
    #[doc = "HIV related"]
    #[code = "HIV"]
    HIV(Option<Element>),
    #[doc = "individual"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "low"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "moderate"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "normal"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "psychiatry relate"]
    #[code = "PSY"]
    PSY(Option<Element>),
    #[doc = "restricted"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "sensitive"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "sexual and domestic violence related"]
    #[code = "SDV"]
    SDV(Option<Element>),
    #[doc = "taboo"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "unrestricted"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "very restricted"]
    #[code = "V"]
    V(Option<Element>),
    #[doc = "Confidentiality"]
    #[code = "_Confidentiality"]
    _Confidentiality(Option<Element>),
    #[doc = "ConfidentialityByAccessKind"]
    #[code = "_ConfidentialityByAccessKind"]
    _ConfidentialityByAccessKind(Option<Element>),
    #[doc = "ConfidentialityByInfoType"]
    #[code = "_ConfidentialityByInfoType"]
    _ConfidentialityByInfoType(Option<Element>),
    #[doc = "ConfidentialityModifiers"]
    #[code = "_ConfidentialityModifiers"]
    _ConfidentialityModifiers(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Confidentiality {
    fn default() -> Self {
        V3Confidentiality::Null(None)
    }
}
impl TryFrom<String> for V3Confidentiality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(V3Confidentiality::B(None)),
            "C" => Ok(V3Confidentiality::C(None)),
            "D" => Ok(V3Confidentiality::D(None)),
            "ETH" => Ok(V3Confidentiality::ETH(None)),
            "HIV" => Ok(V3Confidentiality::HIV(None)),
            "I" => Ok(V3Confidentiality::I(None)),
            "L" => Ok(V3Confidentiality::L(None)),
            "M" => Ok(V3Confidentiality::M(None)),
            "N" => Ok(V3Confidentiality::N(None)),
            "PSY" => Ok(V3Confidentiality::PSY(None)),
            "R" => Ok(V3Confidentiality::R(None)),
            "S" => Ok(V3Confidentiality::S(None)),
            "SDV" => Ok(V3Confidentiality::SDV(None)),
            "T" => Ok(V3Confidentiality::T(None)),
            "U" => Ok(V3Confidentiality::U(None)),
            "V" => Ok(V3Confidentiality::V(None)),
            "_Confidentiality" => Ok(V3Confidentiality::_Confidentiality(None)),
            "_ConfidentialityByAccessKind" => {
                Ok(V3Confidentiality::_ConfidentialityByAccessKind(None))
            }
            "_ConfidentialityByInfoType" => Ok(V3Confidentiality::_ConfidentialityByInfoType(None)),
            "_ConfidentialityModifiers" => Ok(V3Confidentiality::_ConfidentialityModifiers(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Confidentiality {
    fn into(self) -> Option<String> {
        match self {
            V3Confidentiality::B(_) => Some("B".to_string()),
            V3Confidentiality::C(_) => Some("C".to_string()),
            V3Confidentiality::D(_) => Some("D".to_string()),
            V3Confidentiality::ETH(_) => Some("ETH".to_string()),
            V3Confidentiality::HIV(_) => Some("HIV".to_string()),
            V3Confidentiality::I(_) => Some("I".to_string()),
            V3Confidentiality::L(_) => Some("L".to_string()),
            V3Confidentiality::M(_) => Some("M".to_string()),
            V3Confidentiality::N(_) => Some("N".to_string()),
            V3Confidentiality::PSY(_) => Some("PSY".to_string()),
            V3Confidentiality::R(_) => Some("R".to_string()),
            V3Confidentiality::S(_) => Some("S".to_string()),
            V3Confidentiality::SDV(_) => Some("SDV".to_string()),
            V3Confidentiality::T(_) => Some("T".to_string()),
            V3Confidentiality::U(_) => Some("U".to_string()),
            V3Confidentiality::V(_) => Some("V".to_string()),
            V3Confidentiality::_Confidentiality(_) => Some("_Confidentiality".to_string()),
            V3Confidentiality::_ConfidentialityByAccessKind(_) => {
                Some("_ConfidentialityByAccessKind".to_string())
            }
            V3Confidentiality::_ConfidentialityByInfoType(_) => {
                Some("_ConfidentialityByInfoType".to_string())
            }
            V3Confidentiality::_ConfidentialityModifiers(_) => {
                Some("_ConfidentialityModifiers".to_string())
            }
            V3Confidentiality::Null(_) => None,
        }
    }
}
impl MetaValue for V3Confidentiality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Confidentiality::B(Some(e)) => e.get_field(field),
                V3Confidentiality::C(Some(e)) => e.get_field(field),
                V3Confidentiality::D(Some(e)) => e.get_field(field),
                V3Confidentiality::ETH(Some(e)) => e.get_field(field),
                V3Confidentiality::HIV(Some(e)) => e.get_field(field),
                V3Confidentiality::I(Some(e)) => e.get_field(field),
                V3Confidentiality::L(Some(e)) => e.get_field(field),
                V3Confidentiality::M(Some(e)) => e.get_field(field),
                V3Confidentiality::N(Some(e)) => e.get_field(field),
                V3Confidentiality::PSY(Some(e)) => e.get_field(field),
                V3Confidentiality::R(Some(e)) => e.get_field(field),
                V3Confidentiality::S(Some(e)) => e.get_field(field),
                V3Confidentiality::SDV(Some(e)) => e.get_field(field),
                V3Confidentiality::T(Some(e)) => e.get_field(field),
                V3Confidentiality::U(Some(e)) => e.get_field(field),
                V3Confidentiality::V(Some(e)) => e.get_field(field),
                V3Confidentiality::_Confidentiality(Some(e)) => e.get_field(field),
                V3Confidentiality::_ConfidentialityByAccessKind(Some(e)) => e.get_field(field),
                V3Confidentiality::_ConfidentialityByInfoType(Some(e)) => e.get_field(field),
                V3Confidentiality::_ConfidentialityModifiers(Some(e)) => e.get_field(field),
                V3Confidentiality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Confidentiality::B(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::C(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::D(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::ETH(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::HIV(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::I(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::L(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::M(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::N(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::PSY(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::R(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::S(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::SDV(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::T(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::U(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::V(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::_Confidentiality(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::_ConfidentialityByAccessKind(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::_ConfidentialityByInfoType(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::_ConfidentialityModifiers(Some(e)) => e.get_field_mut(field),
                V3Confidentiality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ConfidentialityClassification {
    #[code = "L"]
    L(Option<Element>),
    #[code = "M"]
    M(Option<Element>),
    #[code = "N"]
    N(Option<Element>),
    #[code = "R"]
    R(Option<Element>),
    #[code = "U"]
    U(Option<Element>),
    #[code = "V"]
    V(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ConfidentialityClassification {
    fn default() -> Self {
        V3ConfidentialityClassification::Null(None)
    }
}
impl TryFrom<String> for V3ConfidentialityClassification {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "L" => Ok(V3ConfidentialityClassification::L(None)),
            "M" => Ok(V3ConfidentialityClassification::M(None)),
            "N" => Ok(V3ConfidentialityClassification::N(None)),
            "R" => Ok(V3ConfidentialityClassification::R(None)),
            "U" => Ok(V3ConfidentialityClassification::U(None)),
            "V" => Ok(V3ConfidentialityClassification::V(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ConfidentialityClassification {
    fn into(self) -> Option<String> {
        match self {
            V3ConfidentialityClassification::L(_) => Some("L".to_string()),
            V3ConfidentialityClassification::M(_) => Some("M".to_string()),
            V3ConfidentialityClassification::N(_) => Some("N".to_string()),
            V3ConfidentialityClassification::R(_) => Some("R".to_string()),
            V3ConfidentialityClassification::U(_) => Some("U".to_string()),
            V3ConfidentialityClassification::V(_) => Some("V".to_string()),
            V3ConfidentialityClassification::Null(_) => None,
        }
    }
}
impl MetaValue for V3ConfidentialityClassification {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ConfidentialityClassification::L(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::M(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::N(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::R(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::U(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::V(Some(e)) => e.get_field(field),
                V3ConfidentialityClassification::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ConfidentialityClassification::L(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::M(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::N(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::R(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::U(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::V(Some(e)) => e.get_field_mut(field),
                V3ConfidentialityClassification::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ContainerCap {
    #[doc = "ChildProof"]
    #[code = "CHILD"]
    CHILD(Option<Element>),
    #[doc = "EasyOpen"]
    #[code = "EASY"]
    EASY(Option<Element>),
    #[doc = "Film"]
    #[code = "FILM"]
    FILM(Option<Element>),
    #[doc = "Foil"]
    #[code = "FOIL"]
    FOIL(Option<Element>),
    #[doc = "Push Cap"]
    #[code = "PUSH"]
    PUSH(Option<Element>),
    #[doc = "Screw Cap"]
    #[code = "SCR"]
    SCR(Option<Element>),
    #[doc = "MedicationCap"]
    #[code = "_MedicationCap"]
    _MedicationCap(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ContainerCap {
    fn default() -> Self {
        V3ContainerCap::Null(None)
    }
}
impl TryFrom<String> for V3ContainerCap {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CHILD" => Ok(V3ContainerCap::CHILD(None)),
            "EASY" => Ok(V3ContainerCap::EASY(None)),
            "FILM" => Ok(V3ContainerCap::FILM(None)),
            "FOIL" => Ok(V3ContainerCap::FOIL(None)),
            "PUSH" => Ok(V3ContainerCap::PUSH(None)),
            "SCR" => Ok(V3ContainerCap::SCR(None)),
            "_MedicationCap" => Ok(V3ContainerCap::_MedicationCap(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ContainerCap {
    fn into(self) -> Option<String> {
        match self {
            V3ContainerCap::CHILD(_) => Some("CHILD".to_string()),
            V3ContainerCap::EASY(_) => Some("EASY".to_string()),
            V3ContainerCap::FILM(_) => Some("FILM".to_string()),
            V3ContainerCap::FOIL(_) => Some("FOIL".to_string()),
            V3ContainerCap::PUSH(_) => Some("PUSH".to_string()),
            V3ContainerCap::SCR(_) => Some("SCR".to_string()),
            V3ContainerCap::_MedicationCap(_) => Some("_MedicationCap".to_string()),
            V3ContainerCap::Null(_) => None,
        }
    }
}
impl MetaValue for V3ContainerCap {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ContainerCap::CHILD(Some(e)) => e.get_field(field),
                V3ContainerCap::EASY(Some(e)) => e.get_field(field),
                V3ContainerCap::FILM(Some(e)) => e.get_field(field),
                V3ContainerCap::FOIL(Some(e)) => e.get_field(field),
                V3ContainerCap::PUSH(Some(e)) => e.get_field(field),
                V3ContainerCap::SCR(Some(e)) => e.get_field(field),
                V3ContainerCap::_MedicationCap(Some(e)) => e.get_field(field),
                V3ContainerCap::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ContainerCap::CHILD(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::EASY(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::FILM(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::FOIL(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::PUSH(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::SCR(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::_MedicationCap(Some(e)) => e.get_field_mut(field),
                V3ContainerCap::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ContainerSeparator {
    #[doc = "Gel"]
    #[code = "GEL"]
    GEL(Option<Element>),
    #[doc = "None"]
    #[code = "NONE"]
    NONE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ContainerSeparator {
    fn default() -> Self {
        V3ContainerSeparator::Null(None)
    }
}
impl TryFrom<String> for V3ContainerSeparator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "GEL" => Ok(V3ContainerSeparator::GEL(None)),
            "NONE" => Ok(V3ContainerSeparator::NONE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ContainerSeparator {
    fn into(self) -> Option<String> {
        match self {
            V3ContainerSeparator::GEL(_) => Some("GEL".to_string()),
            V3ContainerSeparator::NONE(_) => Some("NONE".to_string()),
            V3ContainerSeparator::Null(_) => None,
        }
    }
}
impl MetaValue for V3ContainerSeparator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ContainerSeparator::GEL(Some(e)) => e.get_field(field),
                V3ContainerSeparator::NONE(Some(e)) => e.get_field(field),
                V3ContainerSeparator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ContainerSeparator::GEL(Some(e)) => e.get_field_mut(field),
                V3ContainerSeparator::NONE(Some(e)) => e.get_field_mut(field),
                V3ContainerSeparator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ContentProcessingMode {
    #[doc = "Sequential"]
    #[code = "SEQL"]
    SEQL(Option<Element>),
    #[doc = "Unordered"]
    #[code = "UNOR"]
    UNOR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ContentProcessingMode {
    fn default() -> Self {
        V3ContentProcessingMode::Null(None)
    }
}
impl TryFrom<String> for V3ContentProcessingMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "SEQL" => Ok(V3ContentProcessingMode::SEQL(None)),
            "UNOR" => Ok(V3ContentProcessingMode::UNOR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ContentProcessingMode {
    fn into(self) -> Option<String> {
        match self {
            V3ContentProcessingMode::SEQL(_) => Some("SEQL".to_string()),
            V3ContentProcessingMode::UNOR(_) => Some("UNOR".to_string()),
            V3ContentProcessingMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ContentProcessingMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ContentProcessingMode::SEQL(Some(e)) => e.get_field(field),
                V3ContentProcessingMode::UNOR(Some(e)) => e.get_field(field),
                V3ContentProcessingMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ContentProcessingMode::SEQL(Some(e)) => e.get_field_mut(field),
                V3ContentProcessingMode::UNOR(Some(e)) => e.get_field_mut(field),
                V3ContentProcessingMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ContextControl {
    #[doc = "additive, non-propagating"]
    #[code = "AN"]
    AN(Option<Element>),
    #[doc = "additive, propagating"]
    #[code = "AP"]
    AP(Option<Element>),
    #[doc = "overriding, non-propagating"]
    #[code = "ON"]
    ON(Option<Element>),
    #[doc = "overriding, propagating"]
    #[code = "OP"]
    OP(Option<Element>),
    #[doc = "ContextControlAdditive"]
    #[code = "_ContextControlAdditive"]
    _ContextControlAdditive(Option<Element>),
    #[doc = "ContextControlNonPropagating"]
    #[code = "_ContextControlNonPropagating"]
    _ContextControlNonPropagating(Option<Element>),
    #[doc = "ContextControlOverriding"]
    #[code = "_ContextControlOverriding"]
    _ContextControlOverriding(Option<Element>),
    #[doc = "ContextControlPropagating"]
    #[code = "_ContextControlPropagating"]
    _ContextControlPropagating(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ContextControl {
    fn default() -> Self {
        V3ContextControl::Null(None)
    }
}
impl TryFrom<String> for V3ContextControl {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AN" => Ok(V3ContextControl::AN(None)),
            "AP" => Ok(V3ContextControl::AP(None)),
            "ON" => Ok(V3ContextControl::ON(None)),
            "OP" => Ok(V3ContextControl::OP(None)),
            "_ContextControlAdditive" => Ok(V3ContextControl::_ContextControlAdditive(None)),
            "_ContextControlNonPropagating" => {
                Ok(V3ContextControl::_ContextControlNonPropagating(None))
            }
            "_ContextControlOverriding" => Ok(V3ContextControl::_ContextControlOverriding(None)),
            "_ContextControlPropagating" => Ok(V3ContextControl::_ContextControlPropagating(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ContextControl {
    fn into(self) -> Option<String> {
        match self {
            V3ContextControl::AN(_) => Some("AN".to_string()),
            V3ContextControl::AP(_) => Some("AP".to_string()),
            V3ContextControl::ON(_) => Some("ON".to_string()),
            V3ContextControl::OP(_) => Some("OP".to_string()),
            V3ContextControl::_ContextControlAdditive(_) => {
                Some("_ContextControlAdditive".to_string())
            }
            V3ContextControl::_ContextControlNonPropagating(_) => {
                Some("_ContextControlNonPropagating".to_string())
            }
            V3ContextControl::_ContextControlOverriding(_) => {
                Some("_ContextControlOverriding".to_string())
            }
            V3ContextControl::_ContextControlPropagating(_) => {
                Some("_ContextControlPropagating".to_string())
            }
            V3ContextControl::Null(_) => None,
        }
    }
}
impl MetaValue for V3ContextControl {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ContextControl::AN(Some(e)) => e.get_field(field),
                V3ContextControl::AP(Some(e)) => e.get_field(field),
                V3ContextControl::ON(Some(e)) => e.get_field(field),
                V3ContextControl::OP(Some(e)) => e.get_field(field),
                V3ContextControl::_ContextControlAdditive(Some(e)) => e.get_field(field),
                V3ContextControl::_ContextControlNonPropagating(Some(e)) => e.get_field(field),
                V3ContextControl::_ContextControlOverriding(Some(e)) => e.get_field(field),
                V3ContextControl::_ContextControlPropagating(Some(e)) => e.get_field(field),
                V3ContextControl::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ContextControl::AN(Some(e)) => e.get_field_mut(field),
                V3ContextControl::AP(Some(e)) => e.get_field_mut(field),
                V3ContextControl::ON(Some(e)) => e.get_field_mut(field),
                V3ContextControl::OP(Some(e)) => e.get_field_mut(field),
                V3ContextControl::_ContextControlAdditive(Some(e)) => e.get_field_mut(field),
                V3ContextControl::_ContextControlNonPropagating(Some(e)) => e.get_field_mut(field),
                V3ContextControl::_ContextControlOverriding(Some(e)) => e.get_field_mut(field),
                V3ContextControl::_ContextControlPropagating(Some(e)) => e.get_field_mut(field),
                V3ContextControl::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3DataOperation {
    #[doc = "abort"]
    #[code = "ABORT"]
    ABORT(Option<Element>),
    #[doc = "activate"]
    #[code = "ACTIVATE"]
    ACTIVATE(Option<Element>),
    #[doc = "append"]
    #[code = "APPEND"]
    APPEND(Option<Element>),
    #[doc = "cancel"]
    #[code = "CANCEL"]
    CANCEL(Option<Element>),
    #[doc = "complete"]
    #[code = "COMPLETE"]
    COMPLETE(Option<Element>),
    #[doc = "create"]
    #[code = "CREATE"]
    CREATE(Option<Element>),
    #[doc = "delete"]
    #[code = "DELETE"]
    DELETE(Option<Element>),
    #[doc = "execute"]
    #[code = "EXECUTE"]
    EXECUTE(Option<Element>),
    #[doc = "hold"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "jump"]
    #[code = "JUMP"]
    JUMP(Option<Element>),
    #[doc = "modify status"]
    #[code = "MODIFYSTATUS"]
    MODIFYSTATUS(Option<Element>),
    #[doc = "nullify"]
    #[code = "NULLIFY"]
    NULLIFY(Option<Element>),
    #[doc = "obsolete"]
    #[code = "OBSOLETE"]
    OBSOLETE(Option<Element>),
    #[doc = "operate"]
    #[code = "OPERATE"]
    OPERATE(Option<Element>),
    #[doc = "reactivate"]
    #[code = "REACTIVATE"]
    REACTIVATE(Option<Element>),
    #[doc = "read"]
    #[code = "READ"]
    READ(Option<Element>),
    #[doc = "release"]
    #[code = "RELEASE"]
    RELEASE(Option<Element>),
    #[doc = "resume"]
    #[code = "RESUME"]
    RESUME(Option<Element>),
    #[doc = "suspend"]
    #[code = "SUSPEND"]
    SUSPEND(Option<Element>),
    #[doc = "revise"]
    #[code = "UPDATE"]
    UPDATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3DataOperation {
    fn default() -> Self {
        V3DataOperation::Null(None)
    }
}
impl TryFrom<String> for V3DataOperation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ABORT" => Ok(V3DataOperation::ABORT(None)),
            "ACTIVATE" => Ok(V3DataOperation::ACTIVATE(None)),
            "APPEND" => Ok(V3DataOperation::APPEND(None)),
            "CANCEL" => Ok(V3DataOperation::CANCEL(None)),
            "COMPLETE" => Ok(V3DataOperation::COMPLETE(None)),
            "CREATE" => Ok(V3DataOperation::CREATE(None)),
            "DELETE" => Ok(V3DataOperation::DELETE(None)),
            "EXECUTE" => Ok(V3DataOperation::EXECUTE(None)),
            "HOLD" => Ok(V3DataOperation::HOLD(None)),
            "JUMP" => Ok(V3DataOperation::JUMP(None)),
            "MODIFYSTATUS" => Ok(V3DataOperation::MODIFYSTATUS(None)),
            "NULLIFY" => Ok(V3DataOperation::NULLIFY(None)),
            "OBSOLETE" => Ok(V3DataOperation::OBSOLETE(None)),
            "OPERATE" => Ok(V3DataOperation::OPERATE(None)),
            "REACTIVATE" => Ok(V3DataOperation::REACTIVATE(None)),
            "READ" => Ok(V3DataOperation::READ(None)),
            "RELEASE" => Ok(V3DataOperation::RELEASE(None)),
            "RESUME" => Ok(V3DataOperation::RESUME(None)),
            "SUSPEND" => Ok(V3DataOperation::SUSPEND(None)),
            "UPDATE" => Ok(V3DataOperation::UPDATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3DataOperation {
    fn into(self) -> Option<String> {
        match self {
            V3DataOperation::ABORT(_) => Some("ABORT".to_string()),
            V3DataOperation::ACTIVATE(_) => Some("ACTIVATE".to_string()),
            V3DataOperation::APPEND(_) => Some("APPEND".to_string()),
            V3DataOperation::CANCEL(_) => Some("CANCEL".to_string()),
            V3DataOperation::COMPLETE(_) => Some("COMPLETE".to_string()),
            V3DataOperation::CREATE(_) => Some("CREATE".to_string()),
            V3DataOperation::DELETE(_) => Some("DELETE".to_string()),
            V3DataOperation::EXECUTE(_) => Some("EXECUTE".to_string()),
            V3DataOperation::HOLD(_) => Some("HOLD".to_string()),
            V3DataOperation::JUMP(_) => Some("JUMP".to_string()),
            V3DataOperation::MODIFYSTATUS(_) => Some("MODIFYSTATUS".to_string()),
            V3DataOperation::NULLIFY(_) => Some("NULLIFY".to_string()),
            V3DataOperation::OBSOLETE(_) => Some("OBSOLETE".to_string()),
            V3DataOperation::OPERATE(_) => Some("OPERATE".to_string()),
            V3DataOperation::REACTIVATE(_) => Some("REACTIVATE".to_string()),
            V3DataOperation::READ(_) => Some("READ".to_string()),
            V3DataOperation::RELEASE(_) => Some("RELEASE".to_string()),
            V3DataOperation::RESUME(_) => Some("RESUME".to_string()),
            V3DataOperation::SUSPEND(_) => Some("SUSPEND".to_string()),
            V3DataOperation::UPDATE(_) => Some("UPDATE".to_string()),
            V3DataOperation::Null(_) => None,
        }
    }
}
impl MetaValue for V3DataOperation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3DataOperation::ABORT(Some(e)) => e.get_field(field),
                V3DataOperation::ACTIVATE(Some(e)) => e.get_field(field),
                V3DataOperation::APPEND(Some(e)) => e.get_field(field),
                V3DataOperation::CANCEL(Some(e)) => e.get_field(field),
                V3DataOperation::COMPLETE(Some(e)) => e.get_field(field),
                V3DataOperation::CREATE(Some(e)) => e.get_field(field),
                V3DataOperation::DELETE(Some(e)) => e.get_field(field),
                V3DataOperation::EXECUTE(Some(e)) => e.get_field(field),
                V3DataOperation::HOLD(Some(e)) => e.get_field(field),
                V3DataOperation::JUMP(Some(e)) => e.get_field(field),
                V3DataOperation::MODIFYSTATUS(Some(e)) => e.get_field(field),
                V3DataOperation::NULLIFY(Some(e)) => e.get_field(field),
                V3DataOperation::OBSOLETE(Some(e)) => e.get_field(field),
                V3DataOperation::OPERATE(Some(e)) => e.get_field(field),
                V3DataOperation::REACTIVATE(Some(e)) => e.get_field(field),
                V3DataOperation::READ(Some(e)) => e.get_field(field),
                V3DataOperation::RELEASE(Some(e)) => e.get_field(field),
                V3DataOperation::RESUME(Some(e)) => e.get_field(field),
                V3DataOperation::SUSPEND(Some(e)) => e.get_field(field),
                V3DataOperation::UPDATE(Some(e)) => e.get_field(field),
                V3DataOperation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3DataOperation::ABORT(Some(e)) => e.get_field_mut(field),
                V3DataOperation::ACTIVATE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::APPEND(Some(e)) => e.get_field_mut(field),
                V3DataOperation::CANCEL(Some(e)) => e.get_field_mut(field),
                V3DataOperation::COMPLETE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::CREATE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::DELETE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::EXECUTE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::HOLD(Some(e)) => e.get_field_mut(field),
                V3DataOperation::JUMP(Some(e)) => e.get_field_mut(field),
                V3DataOperation::MODIFYSTATUS(Some(e)) => e.get_field_mut(field),
                V3DataOperation::NULLIFY(Some(e)) => e.get_field_mut(field),
                V3DataOperation::OBSOLETE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::OPERATE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::REACTIVATE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::READ(Some(e)) => e.get_field_mut(field),
                V3DataOperation::RELEASE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::RESUME(Some(e)) => e.get_field_mut(field),
                V3DataOperation::SUSPEND(Some(e)) => e.get_field_mut(field),
                V3DataOperation::UPDATE(Some(e)) => e.get_field_mut(field),
                V3DataOperation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3DeviceAlertLevel {
    #[doc = "Critical"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "Normal"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "Serious"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Warning"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3DeviceAlertLevel {
    fn default() -> Self {
        V3DeviceAlertLevel::Null(None)
    }
}
impl TryFrom<String> for V3DeviceAlertLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C" => Ok(V3DeviceAlertLevel::C(None)),
            "N" => Ok(V3DeviceAlertLevel::N(None)),
            "S" => Ok(V3DeviceAlertLevel::S(None)),
            "W" => Ok(V3DeviceAlertLevel::W(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3DeviceAlertLevel {
    fn into(self) -> Option<String> {
        match self {
            V3DeviceAlertLevel::C(_) => Some("C".to_string()),
            V3DeviceAlertLevel::N(_) => Some("N".to_string()),
            V3DeviceAlertLevel::S(_) => Some("S".to_string()),
            V3DeviceAlertLevel::W(_) => Some("W".to_string()),
            V3DeviceAlertLevel::Null(_) => None,
        }
    }
}
impl MetaValue for V3DeviceAlertLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3DeviceAlertLevel::C(Some(e)) => e.get_field(field),
                V3DeviceAlertLevel::N(Some(e)) => e.get_field(field),
                V3DeviceAlertLevel::S(Some(e)) => e.get_field(field),
                V3DeviceAlertLevel::W(Some(e)) => e.get_field(field),
                V3DeviceAlertLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3DeviceAlertLevel::C(Some(e)) => e.get_field_mut(field),
                V3DeviceAlertLevel::N(Some(e)) => e.get_field_mut(field),
                V3DeviceAlertLevel::S(Some(e)) => e.get_field_mut(field),
                V3DeviceAlertLevel::W(Some(e)) => e.get_field_mut(field),
                V3DeviceAlertLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3DocumentCompletion {
    #[doc = "authenticated"]
    #[code = "AU"]
    AU(Option<Element>),
    #[doc = "dictated"]
    #[code = "DI"]
    DI(Option<Element>),
    #[doc = "documented"]
    #[code = "DO"]
    DO(Option<Element>),
    #[doc = "incomplete"]
    #[code = "IN"]
    IN(Option<Element>),
    #[doc = "in progress"]
    #[code = "IP"]
    IP(Option<Element>),
    #[doc = "legally authenticated"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "nullified document"]
    #[code = "NU"]
    NU(Option<Element>),
    #[doc = "pre-authenticated"]
    #[code = "PA"]
    PA(Option<Element>),
    #[doc = "unsigned completed document"]
    #[code = "UC"]
    UC(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3DocumentCompletion {
    fn default() -> Self {
        V3DocumentCompletion::Null(None)
    }
}
impl TryFrom<String> for V3DocumentCompletion {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AU" => Ok(V3DocumentCompletion::AU(None)),
            "DI" => Ok(V3DocumentCompletion::DI(None)),
            "DO" => Ok(V3DocumentCompletion::DO(None)),
            "IN" => Ok(V3DocumentCompletion::IN(None)),
            "IP" => Ok(V3DocumentCompletion::IP(None)),
            "LA" => Ok(V3DocumentCompletion::LA(None)),
            "NU" => Ok(V3DocumentCompletion::NU(None)),
            "PA" => Ok(V3DocumentCompletion::PA(None)),
            "UC" => Ok(V3DocumentCompletion::UC(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3DocumentCompletion {
    fn into(self) -> Option<String> {
        match self {
            V3DocumentCompletion::AU(_) => Some("AU".to_string()),
            V3DocumentCompletion::DI(_) => Some("DI".to_string()),
            V3DocumentCompletion::DO(_) => Some("DO".to_string()),
            V3DocumentCompletion::IN(_) => Some("IN".to_string()),
            V3DocumentCompletion::IP(_) => Some("IP".to_string()),
            V3DocumentCompletion::LA(_) => Some("LA".to_string()),
            V3DocumentCompletion::NU(_) => Some("NU".to_string()),
            V3DocumentCompletion::PA(_) => Some("PA".to_string()),
            V3DocumentCompletion::UC(_) => Some("UC".to_string()),
            V3DocumentCompletion::Null(_) => None,
        }
    }
}
impl MetaValue for V3DocumentCompletion {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3DocumentCompletion::AU(Some(e)) => e.get_field(field),
                V3DocumentCompletion::DI(Some(e)) => e.get_field(field),
                V3DocumentCompletion::DO(Some(e)) => e.get_field(field),
                V3DocumentCompletion::IN(Some(e)) => e.get_field(field),
                V3DocumentCompletion::IP(Some(e)) => e.get_field(field),
                V3DocumentCompletion::LA(Some(e)) => e.get_field(field),
                V3DocumentCompletion::NU(Some(e)) => e.get_field(field),
                V3DocumentCompletion::PA(Some(e)) => e.get_field(field),
                V3DocumentCompletion::UC(Some(e)) => e.get_field(field),
                V3DocumentCompletion::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3DocumentCompletion::AU(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::DI(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::DO(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::IN(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::IP(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::LA(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::NU(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::PA(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::UC(Some(e)) => e.get_field_mut(field),
                V3DocumentCompletion::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3DocumentStorage {
    #[doc = "active and archived"]
    #[code = "AA"]
    AA(Option<Element>),
    #[doc = "active"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "archived (not active)"]
    #[code = "AR"]
    AR(Option<Element>),
    #[doc = "purged"]
    #[code = "PU"]
    PU(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3DocumentStorage {
    fn default() -> Self {
        V3DocumentStorage::Null(None)
    }
}
impl TryFrom<String> for V3DocumentStorage {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AA" => Ok(V3DocumentStorage::AA(None)),
            "AC" => Ok(V3DocumentStorage::AC(None)),
            "AR" => Ok(V3DocumentStorage::AR(None)),
            "PU" => Ok(V3DocumentStorage::PU(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3DocumentStorage {
    fn into(self) -> Option<String> {
        match self {
            V3DocumentStorage::AA(_) => Some("AA".to_string()),
            V3DocumentStorage::AC(_) => Some("AC".to_string()),
            V3DocumentStorage::AR(_) => Some("AR".to_string()),
            V3DocumentStorage::PU(_) => Some("PU".to_string()),
            V3DocumentStorage::Null(_) => None,
        }
    }
}
impl MetaValue for V3DocumentStorage {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3DocumentStorage::AA(Some(e)) => e.get_field(field),
                V3DocumentStorage::AC(Some(e)) => e.get_field(field),
                V3DocumentStorage::AR(Some(e)) => e.get_field(field),
                V3DocumentStorage::PU(Some(e)) => e.get_field(field),
                V3DocumentStorage::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3DocumentStorage::AA(Some(e)) => e.get_field_mut(field),
                V3DocumentStorage::AC(Some(e)) => e.get_field_mut(field),
                V3DocumentStorage::AR(Some(e)) => e.get_field_mut(field),
                V3DocumentStorage::PU(Some(e)) => e.get_field_mut(field),
                V3DocumentStorage::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EducationLevel {
    #[doc = "Associate's or technical degree complete"]
    #[code = "ASSOC"]
    ASSOC(Option<Element>),
    #[doc = "College or baccalaureate degree complete"]
    #[code = "BD"]
    BD(Option<Element>),
    #[doc = "Elementary School"]
    #[code = "ELEM"]
    ELEM(Option<Element>),
    #[doc = "Graduate or professional Degree complete"]
    #[code = "GD"]
    GD(Option<Element>),
    #[doc = "High School or secondary school degree complete"]
    #[code = "HS"]
    HS(Option<Element>),
    #[doc = "Some post-baccalaureate education"]
    #[code = "PB"]
    PB(Option<Element>),
    #[doc = "Doctoral or post graduate education"]
    #[code = "POSTG"]
    POSTG(Option<Element>),
    #[doc = "Some College education"]
    #[code = "SCOL"]
    SCOL(Option<Element>),
    #[doc = "Some secondary or high school education"]
    #[code = "SEC"]
    SEC(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EducationLevel {
    fn default() -> Self {
        V3EducationLevel::Null(None)
    }
}
impl TryFrom<String> for V3EducationLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ASSOC" => Ok(V3EducationLevel::ASSOC(None)),
            "BD" => Ok(V3EducationLevel::BD(None)),
            "ELEM" => Ok(V3EducationLevel::ELEM(None)),
            "GD" => Ok(V3EducationLevel::GD(None)),
            "HS" => Ok(V3EducationLevel::HS(None)),
            "PB" => Ok(V3EducationLevel::PB(None)),
            "POSTG" => Ok(V3EducationLevel::POSTG(None)),
            "SCOL" => Ok(V3EducationLevel::SCOL(None)),
            "SEC" => Ok(V3EducationLevel::SEC(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EducationLevel {
    fn into(self) -> Option<String> {
        match self {
            V3EducationLevel::ASSOC(_) => Some("ASSOC".to_string()),
            V3EducationLevel::BD(_) => Some("BD".to_string()),
            V3EducationLevel::ELEM(_) => Some("ELEM".to_string()),
            V3EducationLevel::GD(_) => Some("GD".to_string()),
            V3EducationLevel::HS(_) => Some("HS".to_string()),
            V3EducationLevel::PB(_) => Some("PB".to_string()),
            V3EducationLevel::POSTG(_) => Some("POSTG".to_string()),
            V3EducationLevel::SCOL(_) => Some("SCOL".to_string()),
            V3EducationLevel::SEC(_) => Some("SEC".to_string()),
            V3EducationLevel::Null(_) => None,
        }
    }
}
impl MetaValue for V3EducationLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EducationLevel::ASSOC(Some(e)) => e.get_field(field),
                V3EducationLevel::BD(Some(e)) => e.get_field(field),
                V3EducationLevel::ELEM(Some(e)) => e.get_field(field),
                V3EducationLevel::GD(Some(e)) => e.get_field(field),
                V3EducationLevel::HS(Some(e)) => e.get_field(field),
                V3EducationLevel::PB(Some(e)) => e.get_field(field),
                V3EducationLevel::POSTG(Some(e)) => e.get_field(field),
                V3EducationLevel::SCOL(Some(e)) => e.get_field(field),
                V3EducationLevel::SEC(Some(e)) => e.get_field(field),
                V3EducationLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EducationLevel::ASSOC(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::BD(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::ELEM(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::GD(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::HS(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::PB(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::POSTG(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::SCOL(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::SEC(Some(e)) => e.get_field_mut(field),
                V3EducationLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EmployeeJobClass {
    #[doc = "full-time"]
    #[code = "FT"]
    FT(Option<Element>),
    #[doc = "part-time"]
    #[code = "PT"]
    PT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EmployeeJobClass {
    fn default() -> Self {
        V3EmployeeJobClass::Null(None)
    }
}
impl TryFrom<String> for V3EmployeeJobClass {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "FT" => Ok(V3EmployeeJobClass::FT(None)),
            "PT" => Ok(V3EmployeeJobClass::PT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EmployeeJobClass {
    fn into(self) -> Option<String> {
        match self {
            V3EmployeeJobClass::FT(_) => Some("FT".to_string()),
            V3EmployeeJobClass::PT(_) => Some("PT".to_string()),
            V3EmployeeJobClass::Null(_) => None,
        }
    }
}
impl MetaValue for V3EmployeeJobClass {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EmployeeJobClass::FT(Some(e)) => e.get_field(field),
                V3EmployeeJobClass::PT(Some(e)) => e.get_field(field),
                V3EmployeeJobClass::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EmployeeJobClass::FT(Some(e)) => e.get_field_mut(field),
                V3EmployeeJobClass::PT(Some(e)) => e.get_field_mut(field),
                V3EmployeeJobClass::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EncounterAdmissionSource {
    #[doc = "emergency"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "labor and delivery"]
    #[code = "LD"]
    LD(Option<Element>),
    #[doc = "newborn"]
    #[code = "NB"]
    NB(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EncounterAdmissionSource {
    fn default() -> Self {
        V3EncounterAdmissionSource::Null(None)
    }
}
impl TryFrom<String> for V3EncounterAdmissionSource {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "E" => Ok(V3EncounterAdmissionSource::E(None)),
            "LD" => Ok(V3EncounterAdmissionSource::LD(None)),
            "NB" => Ok(V3EncounterAdmissionSource::NB(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EncounterAdmissionSource {
    fn into(self) -> Option<String> {
        match self {
            V3EncounterAdmissionSource::E(_) => Some("E".to_string()),
            V3EncounterAdmissionSource::LD(_) => Some("LD".to_string()),
            V3EncounterAdmissionSource::NB(_) => Some("NB".to_string()),
            V3EncounterAdmissionSource::Null(_) => None,
        }
    }
}
impl MetaValue for V3EncounterAdmissionSource {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EncounterAdmissionSource::E(Some(e)) => e.get_field(field),
                V3EncounterAdmissionSource::LD(Some(e)) => e.get_field(field),
                V3EncounterAdmissionSource::NB(Some(e)) => e.get_field(field),
                V3EncounterAdmissionSource::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EncounterAdmissionSource::E(Some(e)) => e.get_field_mut(field),
                V3EncounterAdmissionSource::LD(Some(e)) => e.get_field_mut(field),
                V3EncounterAdmissionSource::NB(Some(e)) => e.get_field_mut(field),
                V3EncounterAdmissionSource::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EncounterSpecialCourtesy {
    #[doc = "extended courtesy"]
    #[code = "EXT"]
    EXT(Option<Element>),
    #[doc = "normal courtesy"]
    #[code = "NRM"]
    NRM(Option<Element>),
    #[doc = "professional courtesy"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "staff"]
    #[code = "STF"]
    STF(Option<Element>),
    #[doc = "very important person"]
    #[code = "VIP"]
    VIP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EncounterSpecialCourtesy {
    fn default() -> Self {
        V3EncounterSpecialCourtesy::Null(None)
    }
}
impl TryFrom<String> for V3EncounterSpecialCourtesy {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "EXT" => Ok(V3EncounterSpecialCourtesy::EXT(None)),
            "NRM" => Ok(V3EncounterSpecialCourtesy::NRM(None)),
            "PRF" => Ok(V3EncounterSpecialCourtesy::PRF(None)),
            "STF" => Ok(V3EncounterSpecialCourtesy::STF(None)),
            "VIP" => Ok(V3EncounterSpecialCourtesy::VIP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EncounterSpecialCourtesy {
    fn into(self) -> Option<String> {
        match self {
            V3EncounterSpecialCourtesy::EXT(_) => Some("EXT".to_string()),
            V3EncounterSpecialCourtesy::NRM(_) => Some("NRM".to_string()),
            V3EncounterSpecialCourtesy::PRF(_) => Some("PRF".to_string()),
            V3EncounterSpecialCourtesy::STF(_) => Some("STF".to_string()),
            V3EncounterSpecialCourtesy::VIP(_) => Some("VIP".to_string()),
            V3EncounterSpecialCourtesy::Null(_) => None,
        }
    }
}
impl MetaValue for V3EncounterSpecialCourtesy {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EncounterSpecialCourtesy::EXT(Some(e)) => e.get_field(field),
                V3EncounterSpecialCourtesy::NRM(Some(e)) => e.get_field(field),
                V3EncounterSpecialCourtesy::PRF(Some(e)) => e.get_field(field),
                V3EncounterSpecialCourtesy::STF(Some(e)) => e.get_field(field),
                V3EncounterSpecialCourtesy::VIP(Some(e)) => e.get_field(field),
                V3EncounterSpecialCourtesy::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EncounterSpecialCourtesy::EXT(Some(e)) => e.get_field_mut(field),
                V3EncounterSpecialCourtesy::NRM(Some(e)) => e.get_field_mut(field),
                V3EncounterSpecialCourtesy::PRF(Some(e)) => e.get_field_mut(field),
                V3EncounterSpecialCourtesy::STF(Some(e)) => e.get_field_mut(field),
                V3EncounterSpecialCourtesy::VIP(Some(e)) => e.get_field_mut(field),
                V3EncounterSpecialCourtesy::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClass {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClass {
    fn default() -> Self {
        V3EntityClass::Null(None)
    }
}
impl TryFrom<String> for V3EntityClass {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClass::ANM(None)),
            "CER" => Ok(V3EntityClass::CER(None)),
            "CHEM" => Ok(V3EntityClass::CHEM(None)),
            "CITY" => Ok(V3EntityClass::CITY(None)),
            "CONT" => Ok(V3EntityClass::CONT(None)),
            "COUNTRY" => Ok(V3EntityClass::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClass::COUNTY(None)),
            "DEV" => Ok(V3EntityClass::DEV(None)),
            "ENT" => Ok(V3EntityClass::ENT(None)),
            "FOOD" => Ok(V3EntityClass::FOOD(None)),
            "HCE" => Ok(V3EntityClass::HCE(None)),
            "HOLD" => Ok(V3EntityClass::HOLD(None)),
            "LIV" => Ok(V3EntityClass::LIV(None)),
            "MAT" => Ok(V3EntityClass::MAT(None)),
            "MIC" => Ok(V3EntityClass::MIC(None)),
            "MMAT" => Ok(V3EntityClass::MMAT(None)),
            "MODDV" => Ok(V3EntityClass::MODDV(None)),
            "NAT" => Ok(V3EntityClass::NAT(None)),
            "NLIV" => Ok(V3EntityClass::NLIV(None)),
            "ORG" => Ok(V3EntityClass::ORG(None)),
            "PLC" => Ok(V3EntityClass::PLC(None)),
            "PLNT" => Ok(V3EntityClass::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClass::PROVINCE(None)),
            "PSN" => Ok(V3EntityClass::PSN(None)),
            "PUB" => Ok(V3EntityClass::PUB(None)),
            "RGRP" => Ok(V3EntityClass::RGRP(None)),
            "STATE" => Ok(V3EntityClass::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClass {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClass::ANM(_) => Some("ANM".to_string()),
            V3EntityClass::CER(_) => Some("CER".to_string()),
            V3EntityClass::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClass::CITY(_) => Some("CITY".to_string()),
            V3EntityClass::CONT(_) => Some("CONT".to_string()),
            V3EntityClass::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClass::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClass::DEV(_) => Some("DEV".to_string()),
            V3EntityClass::ENT(_) => Some("ENT".to_string()),
            V3EntityClass::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClass::HCE(_) => Some("HCE".to_string()),
            V3EntityClass::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClass::LIV(_) => Some("LIV".to_string()),
            V3EntityClass::MAT(_) => Some("MAT".to_string()),
            V3EntityClass::MIC(_) => Some("MIC".to_string()),
            V3EntityClass::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClass::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClass::NAT(_) => Some("NAT".to_string()),
            V3EntityClass::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClass::ORG(_) => Some("ORG".to_string()),
            V3EntityClass::PLC(_) => Some("PLC".to_string()),
            V3EntityClass::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClass::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClass::PSN(_) => Some("PSN".to_string()),
            V3EntityClass::PUB(_) => Some("PUB".to_string()),
            V3EntityClass::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClass::STATE(_) => Some("STATE".to_string()),
            V3EntityClass::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClass {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClass::ANM(Some(e)) => e.get_field(field),
                V3EntityClass::CER(Some(e)) => e.get_field(field),
                V3EntityClass::CHEM(Some(e)) => e.get_field(field),
                V3EntityClass::CITY(Some(e)) => e.get_field(field),
                V3EntityClass::CONT(Some(e)) => e.get_field(field),
                V3EntityClass::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClass::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClass::DEV(Some(e)) => e.get_field(field),
                V3EntityClass::ENT(Some(e)) => e.get_field(field),
                V3EntityClass::FOOD(Some(e)) => e.get_field(field),
                V3EntityClass::HCE(Some(e)) => e.get_field(field),
                V3EntityClass::HOLD(Some(e)) => e.get_field(field),
                V3EntityClass::LIV(Some(e)) => e.get_field(field),
                V3EntityClass::MAT(Some(e)) => e.get_field(field),
                V3EntityClass::MIC(Some(e)) => e.get_field(field),
                V3EntityClass::MMAT(Some(e)) => e.get_field(field),
                V3EntityClass::MODDV(Some(e)) => e.get_field(field),
                V3EntityClass::NAT(Some(e)) => e.get_field(field),
                V3EntityClass::NLIV(Some(e)) => e.get_field(field),
                V3EntityClass::ORG(Some(e)) => e.get_field(field),
                V3EntityClass::PLC(Some(e)) => e.get_field(field),
                V3EntityClass::PLNT(Some(e)) => e.get_field(field),
                V3EntityClass::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClass::PSN(Some(e)) => e.get_field(field),
                V3EntityClass::PUB(Some(e)) => e.get_field(field),
                V3EntityClass::RGRP(Some(e)) => e.get_field(field),
                V3EntityClass::STATE(Some(e)) => e.get_field(field),
                V3EntityClass::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClass::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClass::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClass::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClass::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClass::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClass::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClass::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClass::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClass::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClass::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClass::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClass::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClass::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClass::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClass::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClass::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClass::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClass::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClass::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClass::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClass::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClass::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClass::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassDevice {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassDevice {
    fn default() -> Self {
        V3EntityClassDevice::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassDevice {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassDevice::ANM(None)),
            "CER" => Ok(V3EntityClassDevice::CER(None)),
            "CHEM" => Ok(V3EntityClassDevice::CHEM(None)),
            "CITY" => Ok(V3EntityClassDevice::CITY(None)),
            "CONT" => Ok(V3EntityClassDevice::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassDevice::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassDevice::COUNTY(None)),
            "DEV" => Ok(V3EntityClassDevice::DEV(None)),
            "ENT" => Ok(V3EntityClassDevice::ENT(None)),
            "FOOD" => Ok(V3EntityClassDevice::FOOD(None)),
            "HCE" => Ok(V3EntityClassDevice::HCE(None)),
            "HOLD" => Ok(V3EntityClassDevice::HOLD(None)),
            "LIV" => Ok(V3EntityClassDevice::LIV(None)),
            "MAT" => Ok(V3EntityClassDevice::MAT(None)),
            "MIC" => Ok(V3EntityClassDevice::MIC(None)),
            "MMAT" => Ok(V3EntityClassDevice::MMAT(None)),
            "MODDV" => Ok(V3EntityClassDevice::MODDV(None)),
            "NAT" => Ok(V3EntityClassDevice::NAT(None)),
            "NLIV" => Ok(V3EntityClassDevice::NLIV(None)),
            "ORG" => Ok(V3EntityClassDevice::ORG(None)),
            "PLC" => Ok(V3EntityClassDevice::PLC(None)),
            "PLNT" => Ok(V3EntityClassDevice::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassDevice::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassDevice::PSN(None)),
            "PUB" => Ok(V3EntityClassDevice::PUB(None)),
            "RGRP" => Ok(V3EntityClassDevice::RGRP(None)),
            "STATE" => Ok(V3EntityClassDevice::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassDevice {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassDevice::ANM(_) => Some("ANM".to_string()),
            V3EntityClassDevice::CER(_) => Some("CER".to_string()),
            V3EntityClassDevice::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassDevice::CITY(_) => Some("CITY".to_string()),
            V3EntityClassDevice::CONT(_) => Some("CONT".to_string()),
            V3EntityClassDevice::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassDevice::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassDevice::DEV(_) => Some("DEV".to_string()),
            V3EntityClassDevice::ENT(_) => Some("ENT".to_string()),
            V3EntityClassDevice::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassDevice::HCE(_) => Some("HCE".to_string()),
            V3EntityClassDevice::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassDevice::LIV(_) => Some("LIV".to_string()),
            V3EntityClassDevice::MAT(_) => Some("MAT".to_string()),
            V3EntityClassDevice::MIC(_) => Some("MIC".to_string()),
            V3EntityClassDevice::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassDevice::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassDevice::NAT(_) => Some("NAT".to_string()),
            V3EntityClassDevice::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassDevice::ORG(_) => Some("ORG".to_string()),
            V3EntityClassDevice::PLC(_) => Some("PLC".to_string()),
            V3EntityClassDevice::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassDevice::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassDevice::PSN(_) => Some("PSN".to_string()),
            V3EntityClassDevice::PUB(_) => Some("PUB".to_string()),
            V3EntityClassDevice::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassDevice::STATE(_) => Some("STATE".to_string()),
            V3EntityClassDevice::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassDevice {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassDevice::ANM(Some(e)) => e.get_field(field),
                V3EntityClassDevice::CER(Some(e)) => e.get_field(field),
                V3EntityClassDevice::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassDevice::CITY(Some(e)) => e.get_field(field),
                V3EntityClassDevice::CONT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassDevice::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassDevice::DEV(Some(e)) => e.get_field(field),
                V3EntityClassDevice::ENT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassDevice::HCE(Some(e)) => e.get_field(field),
                V3EntityClassDevice::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassDevice::LIV(Some(e)) => e.get_field(field),
                V3EntityClassDevice::MAT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::MIC(Some(e)) => e.get_field(field),
                V3EntityClassDevice::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassDevice::NAT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassDevice::ORG(Some(e)) => e.get_field(field),
                V3EntityClassDevice::PLC(Some(e)) => e.get_field(field),
                V3EntityClassDevice::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassDevice::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassDevice::PSN(Some(e)) => e.get_field(field),
                V3EntityClassDevice::PUB(Some(e)) => e.get_field(field),
                V3EntityClassDevice::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassDevice::STATE(Some(e)) => e.get_field(field),
                V3EntityClassDevice::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassDevice::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassDevice::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassLivingSubject {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassLivingSubject {
    fn default() -> Self {
        V3EntityClassLivingSubject::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassLivingSubject {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassLivingSubject::ANM(None)),
            "CER" => Ok(V3EntityClassLivingSubject::CER(None)),
            "CHEM" => Ok(V3EntityClassLivingSubject::CHEM(None)),
            "CITY" => Ok(V3EntityClassLivingSubject::CITY(None)),
            "CONT" => Ok(V3EntityClassLivingSubject::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassLivingSubject::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassLivingSubject::COUNTY(None)),
            "DEV" => Ok(V3EntityClassLivingSubject::DEV(None)),
            "ENT" => Ok(V3EntityClassLivingSubject::ENT(None)),
            "FOOD" => Ok(V3EntityClassLivingSubject::FOOD(None)),
            "HCE" => Ok(V3EntityClassLivingSubject::HCE(None)),
            "HOLD" => Ok(V3EntityClassLivingSubject::HOLD(None)),
            "LIV" => Ok(V3EntityClassLivingSubject::LIV(None)),
            "MAT" => Ok(V3EntityClassLivingSubject::MAT(None)),
            "MIC" => Ok(V3EntityClassLivingSubject::MIC(None)),
            "MMAT" => Ok(V3EntityClassLivingSubject::MMAT(None)),
            "MODDV" => Ok(V3EntityClassLivingSubject::MODDV(None)),
            "NAT" => Ok(V3EntityClassLivingSubject::NAT(None)),
            "NLIV" => Ok(V3EntityClassLivingSubject::NLIV(None)),
            "ORG" => Ok(V3EntityClassLivingSubject::ORG(None)),
            "PLC" => Ok(V3EntityClassLivingSubject::PLC(None)),
            "PLNT" => Ok(V3EntityClassLivingSubject::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassLivingSubject::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassLivingSubject::PSN(None)),
            "PUB" => Ok(V3EntityClassLivingSubject::PUB(None)),
            "RGRP" => Ok(V3EntityClassLivingSubject::RGRP(None)),
            "STATE" => Ok(V3EntityClassLivingSubject::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassLivingSubject {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassLivingSubject::ANM(_) => Some("ANM".to_string()),
            V3EntityClassLivingSubject::CER(_) => Some("CER".to_string()),
            V3EntityClassLivingSubject::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassLivingSubject::CITY(_) => Some("CITY".to_string()),
            V3EntityClassLivingSubject::CONT(_) => Some("CONT".to_string()),
            V3EntityClassLivingSubject::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassLivingSubject::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassLivingSubject::DEV(_) => Some("DEV".to_string()),
            V3EntityClassLivingSubject::ENT(_) => Some("ENT".to_string()),
            V3EntityClassLivingSubject::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassLivingSubject::HCE(_) => Some("HCE".to_string()),
            V3EntityClassLivingSubject::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassLivingSubject::LIV(_) => Some("LIV".to_string()),
            V3EntityClassLivingSubject::MAT(_) => Some("MAT".to_string()),
            V3EntityClassLivingSubject::MIC(_) => Some("MIC".to_string()),
            V3EntityClassLivingSubject::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassLivingSubject::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassLivingSubject::NAT(_) => Some("NAT".to_string()),
            V3EntityClassLivingSubject::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassLivingSubject::ORG(_) => Some("ORG".to_string()),
            V3EntityClassLivingSubject::PLC(_) => Some("PLC".to_string()),
            V3EntityClassLivingSubject::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassLivingSubject::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassLivingSubject::PSN(_) => Some("PSN".to_string()),
            V3EntityClassLivingSubject::PUB(_) => Some("PUB".to_string()),
            V3EntityClassLivingSubject::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassLivingSubject::STATE(_) => Some("STATE".to_string()),
            V3EntityClassLivingSubject::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassLivingSubject {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassLivingSubject::ANM(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::CER(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::CITY(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::CONT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::DEV(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::ENT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::HCE(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::LIV(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::MAT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::MIC(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::NAT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::ORG(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::PLC(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::PSN(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::PUB(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::STATE(Some(e)) => e.get_field(field),
                V3EntityClassLivingSubject::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassLivingSubject::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassLivingSubject::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassManufacturedMaterial {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassManufacturedMaterial {
    fn default() -> Self {
        V3EntityClassManufacturedMaterial::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassManufacturedMaterial {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassManufacturedMaterial::ANM(None)),
            "CER" => Ok(V3EntityClassManufacturedMaterial::CER(None)),
            "CHEM" => Ok(V3EntityClassManufacturedMaterial::CHEM(None)),
            "CITY" => Ok(V3EntityClassManufacturedMaterial::CITY(None)),
            "CONT" => Ok(V3EntityClassManufacturedMaterial::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassManufacturedMaterial::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassManufacturedMaterial::COUNTY(None)),
            "DEV" => Ok(V3EntityClassManufacturedMaterial::DEV(None)),
            "ENT" => Ok(V3EntityClassManufacturedMaterial::ENT(None)),
            "FOOD" => Ok(V3EntityClassManufacturedMaterial::FOOD(None)),
            "HCE" => Ok(V3EntityClassManufacturedMaterial::HCE(None)),
            "HOLD" => Ok(V3EntityClassManufacturedMaterial::HOLD(None)),
            "LIV" => Ok(V3EntityClassManufacturedMaterial::LIV(None)),
            "MAT" => Ok(V3EntityClassManufacturedMaterial::MAT(None)),
            "MIC" => Ok(V3EntityClassManufacturedMaterial::MIC(None)),
            "MMAT" => Ok(V3EntityClassManufacturedMaterial::MMAT(None)),
            "MODDV" => Ok(V3EntityClassManufacturedMaterial::MODDV(None)),
            "NAT" => Ok(V3EntityClassManufacturedMaterial::NAT(None)),
            "NLIV" => Ok(V3EntityClassManufacturedMaterial::NLIV(None)),
            "ORG" => Ok(V3EntityClassManufacturedMaterial::ORG(None)),
            "PLC" => Ok(V3EntityClassManufacturedMaterial::PLC(None)),
            "PLNT" => Ok(V3EntityClassManufacturedMaterial::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassManufacturedMaterial::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassManufacturedMaterial::PSN(None)),
            "PUB" => Ok(V3EntityClassManufacturedMaterial::PUB(None)),
            "RGRP" => Ok(V3EntityClassManufacturedMaterial::RGRP(None)),
            "STATE" => Ok(V3EntityClassManufacturedMaterial::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassManufacturedMaterial {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassManufacturedMaterial::ANM(_) => Some("ANM".to_string()),
            V3EntityClassManufacturedMaterial::CER(_) => Some("CER".to_string()),
            V3EntityClassManufacturedMaterial::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassManufacturedMaterial::CITY(_) => Some("CITY".to_string()),
            V3EntityClassManufacturedMaterial::CONT(_) => Some("CONT".to_string()),
            V3EntityClassManufacturedMaterial::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassManufacturedMaterial::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassManufacturedMaterial::DEV(_) => Some("DEV".to_string()),
            V3EntityClassManufacturedMaterial::ENT(_) => Some("ENT".to_string()),
            V3EntityClassManufacturedMaterial::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassManufacturedMaterial::HCE(_) => Some("HCE".to_string()),
            V3EntityClassManufacturedMaterial::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassManufacturedMaterial::LIV(_) => Some("LIV".to_string()),
            V3EntityClassManufacturedMaterial::MAT(_) => Some("MAT".to_string()),
            V3EntityClassManufacturedMaterial::MIC(_) => Some("MIC".to_string()),
            V3EntityClassManufacturedMaterial::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassManufacturedMaterial::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassManufacturedMaterial::NAT(_) => Some("NAT".to_string()),
            V3EntityClassManufacturedMaterial::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassManufacturedMaterial::ORG(_) => Some("ORG".to_string()),
            V3EntityClassManufacturedMaterial::PLC(_) => Some("PLC".to_string()),
            V3EntityClassManufacturedMaterial::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassManufacturedMaterial::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassManufacturedMaterial::PSN(_) => Some("PSN".to_string()),
            V3EntityClassManufacturedMaterial::PUB(_) => Some("PUB".to_string()),
            V3EntityClassManufacturedMaterial::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassManufacturedMaterial::STATE(_) => Some("STATE".to_string()),
            V3EntityClassManufacturedMaterial::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassManufacturedMaterial {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassManufacturedMaterial::ANM(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::CER(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::CITY(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::CONT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::DEV(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::ENT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::HCE(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::LIV(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::MAT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::MIC(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::NAT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::ORG(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::PLC(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::PSN(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::PUB(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::STATE(Some(e)) => e.get_field(field),
                V3EntityClassManufacturedMaterial::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassManufacturedMaterial::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassManufacturedMaterial::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassOrganization {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassOrganization {
    fn default() -> Self {
        V3EntityClassOrganization::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassOrganization {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassOrganization::ANM(None)),
            "CER" => Ok(V3EntityClassOrganization::CER(None)),
            "CHEM" => Ok(V3EntityClassOrganization::CHEM(None)),
            "CITY" => Ok(V3EntityClassOrganization::CITY(None)),
            "CONT" => Ok(V3EntityClassOrganization::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassOrganization::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassOrganization::COUNTY(None)),
            "DEV" => Ok(V3EntityClassOrganization::DEV(None)),
            "ENT" => Ok(V3EntityClassOrganization::ENT(None)),
            "FOOD" => Ok(V3EntityClassOrganization::FOOD(None)),
            "HCE" => Ok(V3EntityClassOrganization::HCE(None)),
            "HOLD" => Ok(V3EntityClassOrganization::HOLD(None)),
            "LIV" => Ok(V3EntityClassOrganization::LIV(None)),
            "MAT" => Ok(V3EntityClassOrganization::MAT(None)),
            "MIC" => Ok(V3EntityClassOrganization::MIC(None)),
            "MMAT" => Ok(V3EntityClassOrganization::MMAT(None)),
            "MODDV" => Ok(V3EntityClassOrganization::MODDV(None)),
            "NAT" => Ok(V3EntityClassOrganization::NAT(None)),
            "NLIV" => Ok(V3EntityClassOrganization::NLIV(None)),
            "ORG" => Ok(V3EntityClassOrganization::ORG(None)),
            "PLC" => Ok(V3EntityClassOrganization::PLC(None)),
            "PLNT" => Ok(V3EntityClassOrganization::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassOrganization::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassOrganization::PSN(None)),
            "PUB" => Ok(V3EntityClassOrganization::PUB(None)),
            "RGRP" => Ok(V3EntityClassOrganization::RGRP(None)),
            "STATE" => Ok(V3EntityClassOrganization::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassOrganization {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassOrganization::ANM(_) => Some("ANM".to_string()),
            V3EntityClassOrganization::CER(_) => Some("CER".to_string()),
            V3EntityClassOrganization::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassOrganization::CITY(_) => Some("CITY".to_string()),
            V3EntityClassOrganization::CONT(_) => Some("CONT".to_string()),
            V3EntityClassOrganization::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassOrganization::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassOrganization::DEV(_) => Some("DEV".to_string()),
            V3EntityClassOrganization::ENT(_) => Some("ENT".to_string()),
            V3EntityClassOrganization::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassOrganization::HCE(_) => Some("HCE".to_string()),
            V3EntityClassOrganization::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassOrganization::LIV(_) => Some("LIV".to_string()),
            V3EntityClassOrganization::MAT(_) => Some("MAT".to_string()),
            V3EntityClassOrganization::MIC(_) => Some("MIC".to_string()),
            V3EntityClassOrganization::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassOrganization::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassOrganization::NAT(_) => Some("NAT".to_string()),
            V3EntityClassOrganization::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassOrganization::ORG(_) => Some("ORG".to_string()),
            V3EntityClassOrganization::PLC(_) => Some("PLC".to_string()),
            V3EntityClassOrganization::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassOrganization::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassOrganization::PSN(_) => Some("PSN".to_string()),
            V3EntityClassOrganization::PUB(_) => Some("PUB".to_string()),
            V3EntityClassOrganization::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassOrganization::STATE(_) => Some("STATE".to_string()),
            V3EntityClassOrganization::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassOrganization {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassOrganization::ANM(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::CER(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::CITY(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::CONT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::DEV(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::ENT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::HCE(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::LIV(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::MAT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::MIC(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::NAT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::ORG(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::PLC(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::PSN(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::PUB(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::STATE(Some(e)) => e.get_field(field),
                V3EntityClassOrganization::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassOrganization::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassOrganization::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassPlace {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassPlace {
    fn default() -> Self {
        V3EntityClassPlace::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassPlace {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassPlace::ANM(None)),
            "CER" => Ok(V3EntityClassPlace::CER(None)),
            "CHEM" => Ok(V3EntityClassPlace::CHEM(None)),
            "CITY" => Ok(V3EntityClassPlace::CITY(None)),
            "CONT" => Ok(V3EntityClassPlace::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassPlace::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassPlace::COUNTY(None)),
            "DEV" => Ok(V3EntityClassPlace::DEV(None)),
            "ENT" => Ok(V3EntityClassPlace::ENT(None)),
            "FOOD" => Ok(V3EntityClassPlace::FOOD(None)),
            "HCE" => Ok(V3EntityClassPlace::HCE(None)),
            "HOLD" => Ok(V3EntityClassPlace::HOLD(None)),
            "LIV" => Ok(V3EntityClassPlace::LIV(None)),
            "MAT" => Ok(V3EntityClassPlace::MAT(None)),
            "MIC" => Ok(V3EntityClassPlace::MIC(None)),
            "MMAT" => Ok(V3EntityClassPlace::MMAT(None)),
            "MODDV" => Ok(V3EntityClassPlace::MODDV(None)),
            "NAT" => Ok(V3EntityClassPlace::NAT(None)),
            "NLIV" => Ok(V3EntityClassPlace::NLIV(None)),
            "ORG" => Ok(V3EntityClassPlace::ORG(None)),
            "PLC" => Ok(V3EntityClassPlace::PLC(None)),
            "PLNT" => Ok(V3EntityClassPlace::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassPlace::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassPlace::PSN(None)),
            "PUB" => Ok(V3EntityClassPlace::PUB(None)),
            "RGRP" => Ok(V3EntityClassPlace::RGRP(None)),
            "STATE" => Ok(V3EntityClassPlace::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassPlace {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassPlace::ANM(_) => Some("ANM".to_string()),
            V3EntityClassPlace::CER(_) => Some("CER".to_string()),
            V3EntityClassPlace::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassPlace::CITY(_) => Some("CITY".to_string()),
            V3EntityClassPlace::CONT(_) => Some("CONT".to_string()),
            V3EntityClassPlace::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassPlace::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassPlace::DEV(_) => Some("DEV".to_string()),
            V3EntityClassPlace::ENT(_) => Some("ENT".to_string()),
            V3EntityClassPlace::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassPlace::HCE(_) => Some("HCE".to_string()),
            V3EntityClassPlace::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassPlace::LIV(_) => Some("LIV".to_string()),
            V3EntityClassPlace::MAT(_) => Some("MAT".to_string()),
            V3EntityClassPlace::MIC(_) => Some("MIC".to_string()),
            V3EntityClassPlace::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassPlace::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassPlace::NAT(_) => Some("NAT".to_string()),
            V3EntityClassPlace::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassPlace::ORG(_) => Some("ORG".to_string()),
            V3EntityClassPlace::PLC(_) => Some("PLC".to_string()),
            V3EntityClassPlace::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassPlace::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassPlace::PSN(_) => Some("PSN".to_string()),
            V3EntityClassPlace::PUB(_) => Some("PUB".to_string()),
            V3EntityClassPlace::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassPlace::STATE(_) => Some("STATE".to_string()),
            V3EntityClassPlace::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassPlace {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassPlace::ANM(Some(e)) => e.get_field(field),
                V3EntityClassPlace::CER(Some(e)) => e.get_field(field),
                V3EntityClassPlace::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassPlace::CITY(Some(e)) => e.get_field(field),
                V3EntityClassPlace::CONT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassPlace::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassPlace::DEV(Some(e)) => e.get_field(field),
                V3EntityClassPlace::ENT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassPlace::HCE(Some(e)) => e.get_field(field),
                V3EntityClassPlace::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassPlace::LIV(Some(e)) => e.get_field(field),
                V3EntityClassPlace::MAT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::MIC(Some(e)) => e.get_field(field),
                V3EntityClassPlace::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassPlace::NAT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassPlace::ORG(Some(e)) => e.get_field(field),
                V3EntityClassPlace::PLC(Some(e)) => e.get_field(field),
                V3EntityClassPlace::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassPlace::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassPlace::PSN(Some(e)) => e.get_field(field),
                V3EntityClassPlace::PUB(Some(e)) => e.get_field(field),
                V3EntityClassPlace::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassPlace::STATE(Some(e)) => e.get_field(field),
                V3EntityClassPlace::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassPlace::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassPlace::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityClassRoot {
    #[doc = "animal"]
    #[code = "ANM"]
    ANM(Option<Element>),
    #[doc = "certificate representation"]
    #[code = "CER"]
    CER(Option<Element>),
    #[doc = "chemical substance"]
    #[code = "CHEM"]
    CHEM(Option<Element>),
    #[doc = "city or town"]
    #[code = "CITY"]
    CITY(Option<Element>),
    #[doc = "container"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "country"]
    #[code = "COUNTRY"]
    COUNTRY(Option<Element>),
    #[doc = "county or parish"]
    #[code = "COUNTY"]
    COUNTY(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "entity"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "food"]
    #[code = "FOOD"]
    FOOD(Option<Element>),
    #[doc = "health chart entity"]
    #[code = "HCE"]
    HCE(Option<Element>),
    #[doc = "holder"]
    #[code = "HOLD"]
    HOLD(Option<Element>),
    #[doc = "living subject"]
    #[code = "LIV"]
    LIV(Option<Element>),
    #[doc = "material"]
    #[code = "MAT"]
    MAT(Option<Element>),
    #[doc = "microorganism"]
    #[code = "MIC"]
    MIC(Option<Element>),
    #[doc = "manufactured material"]
    #[code = "MMAT"]
    MMAT(Option<Element>),
    #[doc = "imaging modality"]
    #[code = "MODDV"]
    MODDV(Option<Element>),
    #[doc = "Nation"]
    #[code = "NAT"]
    NAT(Option<Element>),
    #[doc = "non-person living subject"]
    #[code = "NLIV"]
    NLIV(Option<Element>),
    #[doc = "organization"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "place"]
    #[code = "PLC"]
    PLC(Option<Element>),
    #[doc = "plant"]
    #[code = "PLNT"]
    PLNT(Option<Element>),
    #[doc = "state or province"]
    #[code = "PROVINCE"]
    PROVINCE(Option<Element>),
    #[doc = "person"]
    #[code = "PSN"]
    PSN(Option<Element>),
    #[doc = "public institution"]
    #[code = "PUB"]
    PUB(Option<Element>),
    #[doc = "group"]
    #[code = "RGRP"]
    RGRP(Option<Element>),
    #[doc = "state"]
    #[code = "STATE"]
    STATE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityClassRoot {
    fn default() -> Self {
        V3EntityClassRoot::Null(None)
    }
}
impl TryFrom<String> for V3EntityClassRoot {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ANM" => Ok(V3EntityClassRoot::ANM(None)),
            "CER" => Ok(V3EntityClassRoot::CER(None)),
            "CHEM" => Ok(V3EntityClassRoot::CHEM(None)),
            "CITY" => Ok(V3EntityClassRoot::CITY(None)),
            "CONT" => Ok(V3EntityClassRoot::CONT(None)),
            "COUNTRY" => Ok(V3EntityClassRoot::COUNTRY(None)),
            "COUNTY" => Ok(V3EntityClassRoot::COUNTY(None)),
            "DEV" => Ok(V3EntityClassRoot::DEV(None)),
            "ENT" => Ok(V3EntityClassRoot::ENT(None)),
            "FOOD" => Ok(V3EntityClassRoot::FOOD(None)),
            "HCE" => Ok(V3EntityClassRoot::HCE(None)),
            "HOLD" => Ok(V3EntityClassRoot::HOLD(None)),
            "LIV" => Ok(V3EntityClassRoot::LIV(None)),
            "MAT" => Ok(V3EntityClassRoot::MAT(None)),
            "MIC" => Ok(V3EntityClassRoot::MIC(None)),
            "MMAT" => Ok(V3EntityClassRoot::MMAT(None)),
            "MODDV" => Ok(V3EntityClassRoot::MODDV(None)),
            "NAT" => Ok(V3EntityClassRoot::NAT(None)),
            "NLIV" => Ok(V3EntityClassRoot::NLIV(None)),
            "ORG" => Ok(V3EntityClassRoot::ORG(None)),
            "PLC" => Ok(V3EntityClassRoot::PLC(None)),
            "PLNT" => Ok(V3EntityClassRoot::PLNT(None)),
            "PROVINCE" => Ok(V3EntityClassRoot::PROVINCE(None)),
            "PSN" => Ok(V3EntityClassRoot::PSN(None)),
            "PUB" => Ok(V3EntityClassRoot::PUB(None)),
            "RGRP" => Ok(V3EntityClassRoot::RGRP(None)),
            "STATE" => Ok(V3EntityClassRoot::STATE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityClassRoot {
    fn into(self) -> Option<String> {
        match self {
            V3EntityClassRoot::ANM(_) => Some("ANM".to_string()),
            V3EntityClassRoot::CER(_) => Some("CER".to_string()),
            V3EntityClassRoot::CHEM(_) => Some("CHEM".to_string()),
            V3EntityClassRoot::CITY(_) => Some("CITY".to_string()),
            V3EntityClassRoot::CONT(_) => Some("CONT".to_string()),
            V3EntityClassRoot::COUNTRY(_) => Some("COUNTRY".to_string()),
            V3EntityClassRoot::COUNTY(_) => Some("COUNTY".to_string()),
            V3EntityClassRoot::DEV(_) => Some("DEV".to_string()),
            V3EntityClassRoot::ENT(_) => Some("ENT".to_string()),
            V3EntityClassRoot::FOOD(_) => Some("FOOD".to_string()),
            V3EntityClassRoot::HCE(_) => Some("HCE".to_string()),
            V3EntityClassRoot::HOLD(_) => Some("HOLD".to_string()),
            V3EntityClassRoot::LIV(_) => Some("LIV".to_string()),
            V3EntityClassRoot::MAT(_) => Some("MAT".to_string()),
            V3EntityClassRoot::MIC(_) => Some("MIC".to_string()),
            V3EntityClassRoot::MMAT(_) => Some("MMAT".to_string()),
            V3EntityClassRoot::MODDV(_) => Some("MODDV".to_string()),
            V3EntityClassRoot::NAT(_) => Some("NAT".to_string()),
            V3EntityClassRoot::NLIV(_) => Some("NLIV".to_string()),
            V3EntityClassRoot::ORG(_) => Some("ORG".to_string()),
            V3EntityClassRoot::PLC(_) => Some("PLC".to_string()),
            V3EntityClassRoot::PLNT(_) => Some("PLNT".to_string()),
            V3EntityClassRoot::PROVINCE(_) => Some("PROVINCE".to_string()),
            V3EntityClassRoot::PSN(_) => Some("PSN".to_string()),
            V3EntityClassRoot::PUB(_) => Some("PUB".to_string()),
            V3EntityClassRoot::RGRP(_) => Some("RGRP".to_string()),
            V3EntityClassRoot::STATE(_) => Some("STATE".to_string()),
            V3EntityClassRoot::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityClassRoot {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityClassRoot::ANM(Some(e)) => e.get_field(field),
                V3EntityClassRoot::CER(Some(e)) => e.get_field(field),
                V3EntityClassRoot::CHEM(Some(e)) => e.get_field(field),
                V3EntityClassRoot::CITY(Some(e)) => e.get_field(field),
                V3EntityClassRoot::CONT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::COUNTRY(Some(e)) => e.get_field(field),
                V3EntityClassRoot::COUNTY(Some(e)) => e.get_field(field),
                V3EntityClassRoot::DEV(Some(e)) => e.get_field(field),
                V3EntityClassRoot::ENT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::FOOD(Some(e)) => e.get_field(field),
                V3EntityClassRoot::HCE(Some(e)) => e.get_field(field),
                V3EntityClassRoot::HOLD(Some(e)) => e.get_field(field),
                V3EntityClassRoot::LIV(Some(e)) => e.get_field(field),
                V3EntityClassRoot::MAT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::MIC(Some(e)) => e.get_field(field),
                V3EntityClassRoot::MMAT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::MODDV(Some(e)) => e.get_field(field),
                V3EntityClassRoot::NAT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::NLIV(Some(e)) => e.get_field(field),
                V3EntityClassRoot::ORG(Some(e)) => e.get_field(field),
                V3EntityClassRoot::PLC(Some(e)) => e.get_field(field),
                V3EntityClassRoot::PLNT(Some(e)) => e.get_field(field),
                V3EntityClassRoot::PROVINCE(Some(e)) => e.get_field(field),
                V3EntityClassRoot::PSN(Some(e)) => e.get_field(field),
                V3EntityClassRoot::PUB(Some(e)) => e.get_field(field),
                V3EntityClassRoot::RGRP(Some(e)) => e.get_field(field),
                V3EntityClassRoot::STATE(Some(e)) => e.get_field(field),
                V3EntityClassRoot::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityClassRoot::ANM(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::CER(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::CHEM(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::CITY(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::CONT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::COUNTRY(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::COUNTY(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::ENT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::FOOD(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::HCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::HOLD(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::LIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::MAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::MIC(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::MMAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::MODDV(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::NAT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::NLIV(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::ORG(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::PLC(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::PLNT(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::PROVINCE(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::PSN(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::PUB(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::RGRP(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::STATE(Some(e)) => e.get_field_mut(field),
                V3EntityClassRoot::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityDeterminer {
    #[doc = "specific group"]
    #[code = "GROUP"]
    GROUP(Option<Element>),
    #[doc = "described group"]
    #[code = "GROUPKIND"]
    GROUPKIND(Option<Element>),
    #[doc = "specific"]
    #[code = "INSTANCE"]
    INSTANCE(Option<Element>),
    #[doc = "described"]
    #[code = "KIND"]
    KIND(Option<Element>),
    #[doc = "described quantified"]
    #[code = "QUANTIFIED_KIND"]
    QUANTIFIED_KIND(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityDeterminer {
    fn default() -> Self {
        V3EntityDeterminer::Null(None)
    }
}
impl TryFrom<String> for V3EntityDeterminer {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "GROUP" => Ok(V3EntityDeterminer::GROUP(None)),
            "GROUPKIND" => Ok(V3EntityDeterminer::GROUPKIND(None)),
            "INSTANCE" => Ok(V3EntityDeterminer::INSTANCE(None)),
            "KIND" => Ok(V3EntityDeterminer::KIND(None)),
            "QUANTIFIED_KIND" => Ok(V3EntityDeterminer::QUANTIFIED_KIND(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityDeterminer {
    fn into(self) -> Option<String> {
        match self {
            V3EntityDeterminer::GROUP(_) => Some("GROUP".to_string()),
            V3EntityDeterminer::GROUPKIND(_) => Some("GROUPKIND".to_string()),
            V3EntityDeterminer::INSTANCE(_) => Some("INSTANCE".to_string()),
            V3EntityDeterminer::KIND(_) => Some("KIND".to_string()),
            V3EntityDeterminer::QUANTIFIED_KIND(_) => Some("QUANTIFIED_KIND".to_string()),
            V3EntityDeterminer::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityDeterminer {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityDeterminer::GROUP(Some(e)) => e.get_field(field),
                V3EntityDeterminer::GROUPKIND(Some(e)) => e.get_field(field),
                V3EntityDeterminer::INSTANCE(Some(e)) => e.get_field(field),
                V3EntityDeterminer::KIND(Some(e)) => e.get_field(field),
                V3EntityDeterminer::QUANTIFIED_KIND(Some(e)) => e.get_field(field),
                V3EntityDeterminer::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityDeterminer::GROUP(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminer::GROUPKIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminer::INSTANCE(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminer::KIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminer::QUANTIFIED_KIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminer::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityDeterminerDetermined {
    #[doc = "specific group"]
    #[code = "GROUP"]
    GROUP(Option<Element>),
    #[doc = "described group"]
    #[code = "GROUPKIND"]
    GROUPKIND(Option<Element>),
    #[doc = "specific"]
    #[code = "INSTANCE"]
    INSTANCE(Option<Element>),
    #[doc = "described"]
    #[code = "KIND"]
    KIND(Option<Element>),
    #[doc = "described quantified"]
    #[code = "QUANTIFIED_KIND"]
    QUANTIFIED_KIND(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityDeterminerDetermined {
    fn default() -> Self {
        V3EntityDeterminerDetermined::Null(None)
    }
}
impl TryFrom<String> for V3EntityDeterminerDetermined {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "GROUP" => Ok(V3EntityDeterminerDetermined::GROUP(None)),
            "GROUPKIND" => Ok(V3EntityDeterminerDetermined::GROUPKIND(None)),
            "INSTANCE" => Ok(V3EntityDeterminerDetermined::INSTANCE(None)),
            "KIND" => Ok(V3EntityDeterminerDetermined::KIND(None)),
            "QUANTIFIED_KIND" => Ok(V3EntityDeterminerDetermined::QUANTIFIED_KIND(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityDeterminerDetermined {
    fn into(self) -> Option<String> {
        match self {
            V3EntityDeterminerDetermined::GROUP(_) => Some("GROUP".to_string()),
            V3EntityDeterminerDetermined::GROUPKIND(_) => Some("GROUPKIND".to_string()),
            V3EntityDeterminerDetermined::INSTANCE(_) => Some("INSTANCE".to_string()),
            V3EntityDeterminerDetermined::KIND(_) => Some("KIND".to_string()),
            V3EntityDeterminerDetermined::QUANTIFIED_KIND(_) => Some("QUANTIFIED_KIND".to_string()),
            V3EntityDeterminerDetermined::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityDeterminerDetermined {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityDeterminerDetermined::GROUP(Some(e)) => e.get_field(field),
                V3EntityDeterminerDetermined::GROUPKIND(Some(e)) => e.get_field(field),
                V3EntityDeterminerDetermined::INSTANCE(Some(e)) => e.get_field(field),
                V3EntityDeterminerDetermined::KIND(Some(e)) => e.get_field(field),
                V3EntityDeterminerDetermined::QUANTIFIED_KIND(Some(e)) => e.get_field(field),
                V3EntityDeterminerDetermined::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityDeterminerDetermined::GROUP(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminerDetermined::GROUPKIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminerDetermined::INSTANCE(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminerDetermined::KIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminerDetermined::QUANTIFIED_KIND(Some(e)) => e.get_field_mut(field),
                V3EntityDeterminerDetermined::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityHandling {
    #[doc = "Ambient Temperature"]
    #[code = "AMB"]
    AMB(Option<Element>),
    #[doc = "Body Temperature"]
    #[code = "C37"]
    C37(Option<Element>),
    #[doc = "Critical Ambient temperature"]
    #[code = "CAMB"]
    CAMB(Option<Element>),
    #[doc = "Protect from Air"]
    #[code = "CATM"]
    CATM(Option<Element>),
    #[doc = "Critical frozen"]
    #[code = "CFRZ"]
    CFRZ(Option<Element>),
    #[doc = "Critical refrigerated temperature"]
    #[code = "CREF"]
    CREF(Option<Element>),
    #[doc = "Deep Frozen"]
    #[code = "DFRZ"]
    DFRZ(Option<Element>),
    #[doc = "dry"]
    #[code = "DRY"]
    DRY(Option<Element>),
    #[doc = "frozen"]
    #[code = "FRZ"]
    FRZ(Option<Element>),
    #[doc = "Metal Free"]
    #[code = "MTLF"]
    MTLF(Option<Element>),
    #[doc = "nitrogen"]
    #[code = "NTR"]
    NTR(Option<Element>),
    #[doc = "Protect from Light"]
    #[code = "PRTL"]
    PRTL(Option<Element>),
    #[doc = "do not shake"]
    #[code = "PSA"]
    PSA(Option<Element>),
    #[doc = "no shock"]
    #[code = "PSO"]
    PSO(Option<Element>),
    #[doc = "Refrigerated temperature"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Shake before use"]
    #[code = "SBU"]
    SBU(Option<Element>),
    #[doc = "Ultra frozen"]
    #[code = "UFRZ"]
    UFRZ(Option<Element>),
    #[doc = "upright"]
    #[code = "UPR"]
    UPR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityHandling {
    fn default() -> Self {
        V3EntityHandling::Null(None)
    }
}
impl TryFrom<String> for V3EntityHandling {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AMB" => Ok(V3EntityHandling::AMB(None)),
            "C37" => Ok(V3EntityHandling::C37(None)),
            "CAMB" => Ok(V3EntityHandling::CAMB(None)),
            "CATM" => Ok(V3EntityHandling::CATM(None)),
            "CFRZ" => Ok(V3EntityHandling::CFRZ(None)),
            "CREF" => Ok(V3EntityHandling::CREF(None)),
            "DFRZ" => Ok(V3EntityHandling::DFRZ(None)),
            "DRY" => Ok(V3EntityHandling::DRY(None)),
            "FRZ" => Ok(V3EntityHandling::FRZ(None)),
            "MTLF" => Ok(V3EntityHandling::MTLF(None)),
            "NTR" => Ok(V3EntityHandling::NTR(None)),
            "PRTL" => Ok(V3EntityHandling::PRTL(None)),
            "PSA" => Ok(V3EntityHandling::PSA(None)),
            "PSO" => Ok(V3EntityHandling::PSO(None)),
            "REF" => Ok(V3EntityHandling::REF(None)),
            "SBU" => Ok(V3EntityHandling::SBU(None)),
            "UFRZ" => Ok(V3EntityHandling::UFRZ(None)),
            "UPR" => Ok(V3EntityHandling::UPR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityHandling {
    fn into(self) -> Option<String> {
        match self {
            V3EntityHandling::AMB(_) => Some("AMB".to_string()),
            V3EntityHandling::C37(_) => Some("C37".to_string()),
            V3EntityHandling::CAMB(_) => Some("CAMB".to_string()),
            V3EntityHandling::CATM(_) => Some("CATM".to_string()),
            V3EntityHandling::CFRZ(_) => Some("CFRZ".to_string()),
            V3EntityHandling::CREF(_) => Some("CREF".to_string()),
            V3EntityHandling::DFRZ(_) => Some("DFRZ".to_string()),
            V3EntityHandling::DRY(_) => Some("DRY".to_string()),
            V3EntityHandling::FRZ(_) => Some("FRZ".to_string()),
            V3EntityHandling::MTLF(_) => Some("MTLF".to_string()),
            V3EntityHandling::NTR(_) => Some("NTR".to_string()),
            V3EntityHandling::PRTL(_) => Some("PRTL".to_string()),
            V3EntityHandling::PSA(_) => Some("PSA".to_string()),
            V3EntityHandling::PSO(_) => Some("PSO".to_string()),
            V3EntityHandling::REF(_) => Some("REF".to_string()),
            V3EntityHandling::SBU(_) => Some("SBU".to_string()),
            V3EntityHandling::UFRZ(_) => Some("UFRZ".to_string()),
            V3EntityHandling::UPR(_) => Some("UPR".to_string()),
            V3EntityHandling::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityHandling {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityHandling::AMB(Some(e)) => e.get_field(field),
                V3EntityHandling::C37(Some(e)) => e.get_field(field),
                V3EntityHandling::CAMB(Some(e)) => e.get_field(field),
                V3EntityHandling::CATM(Some(e)) => e.get_field(field),
                V3EntityHandling::CFRZ(Some(e)) => e.get_field(field),
                V3EntityHandling::CREF(Some(e)) => e.get_field(field),
                V3EntityHandling::DFRZ(Some(e)) => e.get_field(field),
                V3EntityHandling::DRY(Some(e)) => e.get_field(field),
                V3EntityHandling::FRZ(Some(e)) => e.get_field(field),
                V3EntityHandling::MTLF(Some(e)) => e.get_field(field),
                V3EntityHandling::NTR(Some(e)) => e.get_field(field),
                V3EntityHandling::PRTL(Some(e)) => e.get_field(field),
                V3EntityHandling::PSA(Some(e)) => e.get_field(field),
                V3EntityHandling::PSO(Some(e)) => e.get_field(field),
                V3EntityHandling::REF(Some(e)) => e.get_field(field),
                V3EntityHandling::SBU(Some(e)) => e.get_field(field),
                V3EntityHandling::UFRZ(Some(e)) => e.get_field(field),
                V3EntityHandling::UPR(Some(e)) => e.get_field(field),
                V3EntityHandling::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityHandling::AMB(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::C37(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::CAMB(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::CATM(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::CFRZ(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::CREF(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::DFRZ(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::DRY(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::FRZ(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::MTLF(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::NTR(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::PRTL(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::PSA(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::PSO(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::REF(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::SBU(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::UFRZ(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::UPR(Some(e)) => e.get_field_mut(field),
                V3EntityHandling::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNamePartQualifier {
    #[doc = "academic"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "adopted"]
    #[code = "AD"]
    AD(Option<Element>),
    #[doc = "birth"]
    #[code = "BR"]
    BR(Option<Element>),
    #[doc = "callme"]
    #[code = "CL"]
    CL(Option<Element>),
    #[doc = "container name"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "device name"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "FlavorName"]
    #[code = "FLAV"]
    FLAV(Option<Element>),
    #[doc = "FormulationPartName"]
    #[code = "FORMUL"]
    FORMUL(Option<Element>),
    #[doc = "form name"]
    #[code = "FRM"]
    FRM(Option<Element>),
    #[doc = "initial"]
    #[code = "IN"]
    IN(Option<Element>),
    #[doc = "invented name"]
    #[code = "INV"]
    INV(Option<Element>),
    #[doc = "Legal status"]
    #[code = "LS"]
    LS(Option<Element>),
    #[doc = "nobility"]
    #[code = "NB"]
    NB(Option<Element>),
    #[doc = "TargetPopulationName"]
    #[code = "POPUL"]
    POPUL(Option<Element>),
    #[doc = "professional"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "PharmaceuticalEntityNamePartQualifiers"]
    #[code = "PharmaceuticalEntityNamePartQualifiers"]
    PharmaceuticalEntityNamePartQualifiers(Option<Element>),
    #[doc = "scientific name"]
    #[code = "SCI"]
    SCI(Option<Element>),
    #[doc = "spouse"]
    #[code = "SP"]
    SP(Option<Element>),
    #[doc = "strength name"]
    #[code = "STR"]
    STR(Option<Element>),
    #[doc = "TimeOrPeriodName"]
    #[code = "TIME"]
    TIME(Option<Element>),
    #[doc = "title"]
    #[code = "TITLE"]
    TITLE(Option<Element>),
    #[doc = "trademark name"]
    #[code = "TMK"]
    TMK(Option<Element>),
    #[doc = "intended use name"]
    #[code = "USE"]
    USE(Option<Element>),
    #[doc = "voorvoegsel"]
    #[code = "VV"]
    VV(Option<Element>),
    #[doc = "OrganizationNamePartQualifier"]
    #[code = "_OrganizationNamePartQualifier"]
    _OrganizationNamePartQualifier(Option<Element>),
    #[doc = "PersonNamePartAffixTypes"]
    #[code = "_PersonNamePartAffixTypes"]
    _PersonNamePartAffixTypes(Option<Element>),
    #[doc = "PersonNamePartChangeQualifier"]
    #[code = "_PersonNamePartChangeQualifier"]
    _PersonNamePartChangeQualifier(Option<Element>),
    #[doc = "PersonNamePartMiscQualifier"]
    #[code = "_PersonNamePartMiscQualifier"]
    _PersonNamePartMiscQualifier(Option<Element>),
    #[doc = "PersonNamePartQualifier"]
    #[code = "_PersonNamePartQualifier"]
    _PersonNamePartQualifier(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNamePartQualifier {
    fn default() -> Self {
        V3EntityNamePartQualifier::Null(None)
    }
}
impl TryFrom<String> for V3EntityNamePartQualifier {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AC" => Ok(V3EntityNamePartQualifier::AC(None)),
            "AD" => Ok(V3EntityNamePartQualifier::AD(None)),
            "BR" => Ok(V3EntityNamePartQualifier::BR(None)),
            "CL" => Ok(V3EntityNamePartQualifier::CL(None)),
            "CON" => Ok(V3EntityNamePartQualifier::CON(None)),
            "DEV" => Ok(V3EntityNamePartQualifier::DEV(None)),
            "FLAV" => Ok(V3EntityNamePartQualifier::FLAV(None)),
            "FORMUL" => Ok(V3EntityNamePartQualifier::FORMUL(None)),
            "FRM" => Ok(V3EntityNamePartQualifier::FRM(None)),
            "IN" => Ok(V3EntityNamePartQualifier::IN(None)),
            "INV" => Ok(V3EntityNamePartQualifier::INV(None)),
            "LS" => Ok(V3EntityNamePartQualifier::LS(None)),
            "NB" => Ok(V3EntityNamePartQualifier::NB(None)),
            "POPUL" => Ok(V3EntityNamePartQualifier::POPUL(None)),
            "PR" => Ok(V3EntityNamePartQualifier::PR(None)),
            "PharmaceuticalEntityNamePartQualifiers" => {
                Ok(V3EntityNamePartQualifier::PharmaceuticalEntityNamePartQualifiers(None))
            }
            "SCI" => Ok(V3EntityNamePartQualifier::SCI(None)),
            "SP" => Ok(V3EntityNamePartQualifier::SP(None)),
            "STR" => Ok(V3EntityNamePartQualifier::STR(None)),
            "TIME" => Ok(V3EntityNamePartQualifier::TIME(None)),
            "TITLE" => Ok(V3EntityNamePartQualifier::TITLE(None)),
            "TMK" => Ok(V3EntityNamePartQualifier::TMK(None)),
            "USE" => Ok(V3EntityNamePartQualifier::USE(None)),
            "VV" => Ok(V3EntityNamePartQualifier::VV(None)),
            "_OrganizationNamePartQualifier" => Ok(
                V3EntityNamePartQualifier::_OrganizationNamePartQualifier(None),
            ),
            "_PersonNamePartAffixTypes" => {
                Ok(V3EntityNamePartQualifier::_PersonNamePartAffixTypes(None))
            }
            "_PersonNamePartChangeQualifier" => Ok(
                V3EntityNamePartQualifier::_PersonNamePartChangeQualifier(None),
            ),
            "_PersonNamePartMiscQualifier" => Ok(
                V3EntityNamePartQualifier::_PersonNamePartMiscQualifier(None),
            ),
            "_PersonNamePartQualifier" => {
                Ok(V3EntityNamePartQualifier::_PersonNamePartQualifier(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNamePartQualifier {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNamePartQualifier::AC(_) => Some("AC".to_string()),
            V3EntityNamePartQualifier::AD(_) => Some("AD".to_string()),
            V3EntityNamePartQualifier::BR(_) => Some("BR".to_string()),
            V3EntityNamePartQualifier::CL(_) => Some("CL".to_string()),
            V3EntityNamePartQualifier::CON(_) => Some("CON".to_string()),
            V3EntityNamePartQualifier::DEV(_) => Some("DEV".to_string()),
            V3EntityNamePartQualifier::FLAV(_) => Some("FLAV".to_string()),
            V3EntityNamePartQualifier::FORMUL(_) => Some("FORMUL".to_string()),
            V3EntityNamePartQualifier::FRM(_) => Some("FRM".to_string()),
            V3EntityNamePartQualifier::IN(_) => Some("IN".to_string()),
            V3EntityNamePartQualifier::INV(_) => Some("INV".to_string()),
            V3EntityNamePartQualifier::LS(_) => Some("LS".to_string()),
            V3EntityNamePartQualifier::NB(_) => Some("NB".to_string()),
            V3EntityNamePartQualifier::POPUL(_) => Some("POPUL".to_string()),
            V3EntityNamePartQualifier::PR(_) => Some("PR".to_string()),
            V3EntityNamePartQualifier::PharmaceuticalEntityNamePartQualifiers(_) => {
                Some("PharmaceuticalEntityNamePartQualifiers".to_string())
            }
            V3EntityNamePartQualifier::SCI(_) => Some("SCI".to_string()),
            V3EntityNamePartQualifier::SP(_) => Some("SP".to_string()),
            V3EntityNamePartQualifier::STR(_) => Some("STR".to_string()),
            V3EntityNamePartQualifier::TIME(_) => Some("TIME".to_string()),
            V3EntityNamePartQualifier::TITLE(_) => Some("TITLE".to_string()),
            V3EntityNamePartQualifier::TMK(_) => Some("TMK".to_string()),
            V3EntityNamePartQualifier::USE(_) => Some("USE".to_string()),
            V3EntityNamePartQualifier::VV(_) => Some("VV".to_string()),
            V3EntityNamePartQualifier::_OrganizationNamePartQualifier(_) => {
                Some("_OrganizationNamePartQualifier".to_string())
            }
            V3EntityNamePartQualifier::_PersonNamePartAffixTypes(_) => {
                Some("_PersonNamePartAffixTypes".to_string())
            }
            V3EntityNamePartQualifier::_PersonNamePartChangeQualifier(_) => {
                Some("_PersonNamePartChangeQualifier".to_string())
            }
            V3EntityNamePartQualifier::_PersonNamePartMiscQualifier(_) => {
                Some("_PersonNamePartMiscQualifier".to_string())
            }
            V3EntityNamePartQualifier::_PersonNamePartQualifier(_) => {
                Some("_PersonNamePartQualifier".to_string())
            }
            V3EntityNamePartQualifier::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNamePartQualifier {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNamePartQualifier::AC(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::AD(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::BR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::CL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::CON(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::DEV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::FLAV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::FORMUL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::FRM(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::IN(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::INV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::LS(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::NB(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::POPUL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::PR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::PharmaceuticalEntityNamePartQualifiers(Some(e)) => {
                    e.get_field(field)
                }
                V3EntityNamePartQualifier::SCI(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::SP(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::STR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::TIME(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::TITLE(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::TMK(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::USE(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::VV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::_OrganizationNamePartQualifier(Some(e)) => {
                    e.get_field(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartAffixTypes(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::_PersonNamePartChangeQualifier(Some(e)) => {
                    e.get_field(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartMiscQualifier(Some(e)) => {
                    e.get_field(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartQualifier(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifier::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNamePartQualifier::AC(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::AD(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::BR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::CL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::CON(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::FLAV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::FORMUL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::FRM(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::IN(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::INV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::LS(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::NB(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::POPUL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::PR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::PharmaceuticalEntityNamePartQualifiers(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::SCI(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::SP(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::STR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::TIME(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::TITLE(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::TMK(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::USE(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::VV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifier::_OrganizationNamePartQualifier(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartAffixTypes(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartChangeQualifier(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartMiscQualifier(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::_PersonNamePartQualifier(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifier::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNamePartQualifierR2 {
    #[doc = "academic"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "acquired"]
    #[code = "AD"]
    AD(Option<Element>),
    #[doc = "birth"]
    #[code = "BR"]
    BR(Option<Element>),
    #[doc = "callme"]
    #[code = "CL"]
    CL(Option<Element>),
    #[doc = "container name"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "device name"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "FlavorName"]
    #[code = "FLAV"]
    FLAV(Option<Element>),
    #[doc = "FormulationPartName"]
    #[code = "FORMUL"]
    FORMUL(Option<Element>),
    #[doc = "form name"]
    #[code = "FRM"]
    FRM(Option<Element>),
    #[doc = "honorific"]
    #[code = "HON"]
    HON(Option<Element>),
    #[doc = "initial"]
    #[code = "IN"]
    IN(Option<Element>),
    #[doc = "invented name"]
    #[code = "INV"]
    INV(Option<Element>),
    #[doc = "legal status"]
    #[code = "LS"]
    LS(Option<Element>),
    #[doc = "middle name"]
    #[code = "MID"]
    MID(Option<Element>),
    #[doc = "nobility"]
    #[code = "NB"]
    NB(Option<Element>),
    #[doc = "prefix"]
    #[code = "PFX"]
    PFX(Option<Element>),
    #[doc = "TargetPopulationName"]
    #[code = "POPUL"]
    POPUL(Option<Element>),
    #[doc = "professional"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "PharmaceuticalEntityNamePartQualifiers"]
    #[code = "PharmaceuticalEntityNamePartQualifiers"]
    PharmaceuticalEntityNamePartQualifiers(Option<Element>),
    #[doc = "scientific name"]
    #[code = "SCI"]
    SCI(Option<Element>),
    #[doc = "suffix"]
    #[code = "SFX"]
    SFX(Option<Element>),
    #[doc = "spouse"]
    #[code = "SP"]
    SP(Option<Element>),
    #[doc = "strength name"]
    #[code = "STR"]
    STR(Option<Element>),
    #[doc = "TimeOrPeriodName"]
    #[code = "TIME"]
    TIME(Option<Element>),
    #[doc = "trademark name"]
    #[code = "TMK"]
    TMK(Option<Element>),
    #[doc = "TitleStyles"]
    #[code = "TitleStyles"]
    TitleStyles(Option<Element>),
    #[doc = "intended use name"]
    #[code = "USE"]
    USE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNamePartQualifierR2 {
    fn default() -> Self {
        V3EntityNamePartQualifierR2::Null(None)
    }
}
impl TryFrom<String> for V3EntityNamePartQualifierR2 {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AC" => Ok(V3EntityNamePartQualifierR2::AC(None)),
            "AD" => Ok(V3EntityNamePartQualifierR2::AD(None)),
            "BR" => Ok(V3EntityNamePartQualifierR2::BR(None)),
            "CL" => Ok(V3EntityNamePartQualifierR2::CL(None)),
            "CON" => Ok(V3EntityNamePartQualifierR2::CON(None)),
            "DEV" => Ok(V3EntityNamePartQualifierR2::DEV(None)),
            "FLAV" => Ok(V3EntityNamePartQualifierR2::FLAV(None)),
            "FORMUL" => Ok(V3EntityNamePartQualifierR2::FORMUL(None)),
            "FRM" => Ok(V3EntityNamePartQualifierR2::FRM(None)),
            "HON" => Ok(V3EntityNamePartQualifierR2::HON(None)),
            "IN" => Ok(V3EntityNamePartQualifierR2::IN(None)),
            "INV" => Ok(V3EntityNamePartQualifierR2::INV(None)),
            "LS" => Ok(V3EntityNamePartQualifierR2::LS(None)),
            "MID" => Ok(V3EntityNamePartQualifierR2::MID(None)),
            "NB" => Ok(V3EntityNamePartQualifierR2::NB(None)),
            "PFX" => Ok(V3EntityNamePartQualifierR2::PFX(None)),
            "POPUL" => Ok(V3EntityNamePartQualifierR2::POPUL(None)),
            "PR" => Ok(V3EntityNamePartQualifierR2::PR(None)),
            "PharmaceuticalEntityNamePartQualifiers" => {
                Ok(V3EntityNamePartQualifierR2::PharmaceuticalEntityNamePartQualifiers(None))
            }
            "SCI" => Ok(V3EntityNamePartQualifierR2::SCI(None)),
            "SFX" => Ok(V3EntityNamePartQualifierR2::SFX(None)),
            "SP" => Ok(V3EntityNamePartQualifierR2::SP(None)),
            "STR" => Ok(V3EntityNamePartQualifierR2::STR(None)),
            "TIME" => Ok(V3EntityNamePartQualifierR2::TIME(None)),
            "TMK" => Ok(V3EntityNamePartQualifierR2::TMK(None)),
            "TitleStyles" => Ok(V3EntityNamePartQualifierR2::TitleStyles(None)),
            "USE" => Ok(V3EntityNamePartQualifierR2::USE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNamePartQualifierR2 {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNamePartQualifierR2::AC(_) => Some("AC".to_string()),
            V3EntityNamePartQualifierR2::AD(_) => Some("AD".to_string()),
            V3EntityNamePartQualifierR2::BR(_) => Some("BR".to_string()),
            V3EntityNamePartQualifierR2::CL(_) => Some("CL".to_string()),
            V3EntityNamePartQualifierR2::CON(_) => Some("CON".to_string()),
            V3EntityNamePartQualifierR2::DEV(_) => Some("DEV".to_string()),
            V3EntityNamePartQualifierR2::FLAV(_) => Some("FLAV".to_string()),
            V3EntityNamePartQualifierR2::FORMUL(_) => Some("FORMUL".to_string()),
            V3EntityNamePartQualifierR2::FRM(_) => Some("FRM".to_string()),
            V3EntityNamePartQualifierR2::HON(_) => Some("HON".to_string()),
            V3EntityNamePartQualifierR2::IN(_) => Some("IN".to_string()),
            V3EntityNamePartQualifierR2::INV(_) => Some("INV".to_string()),
            V3EntityNamePartQualifierR2::LS(_) => Some("LS".to_string()),
            V3EntityNamePartQualifierR2::MID(_) => Some("MID".to_string()),
            V3EntityNamePartQualifierR2::NB(_) => Some("NB".to_string()),
            V3EntityNamePartQualifierR2::PFX(_) => Some("PFX".to_string()),
            V3EntityNamePartQualifierR2::POPUL(_) => Some("POPUL".to_string()),
            V3EntityNamePartQualifierR2::PR(_) => Some("PR".to_string()),
            V3EntityNamePartQualifierR2::PharmaceuticalEntityNamePartQualifiers(_) => {
                Some("PharmaceuticalEntityNamePartQualifiers".to_string())
            }
            V3EntityNamePartQualifierR2::SCI(_) => Some("SCI".to_string()),
            V3EntityNamePartQualifierR2::SFX(_) => Some("SFX".to_string()),
            V3EntityNamePartQualifierR2::SP(_) => Some("SP".to_string()),
            V3EntityNamePartQualifierR2::STR(_) => Some("STR".to_string()),
            V3EntityNamePartQualifierR2::TIME(_) => Some("TIME".to_string()),
            V3EntityNamePartQualifierR2::TMK(_) => Some("TMK".to_string()),
            V3EntityNamePartQualifierR2::TitleStyles(_) => Some("TitleStyles".to_string()),
            V3EntityNamePartQualifierR2::USE(_) => Some("USE".to_string()),
            V3EntityNamePartQualifierR2::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNamePartQualifierR2 {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNamePartQualifierR2::AC(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::AD(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::BR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::CL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::CON(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::DEV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::FLAV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::FORMUL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::FRM(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::HON(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::IN(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::INV(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::LS(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::MID(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::NB(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::PFX(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::POPUL(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::PR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::PharmaceuticalEntityNamePartQualifiers(Some(e)) => {
                    e.get_field(field)
                }
                V3EntityNamePartQualifierR2::SCI(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::SFX(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::SP(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::STR(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::TIME(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::TMK(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::TitleStyles(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::USE(Some(e)) => e.get_field(field),
                V3EntityNamePartQualifierR2::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNamePartQualifierR2::AC(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::AD(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::BR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::CL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::CON(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::DEV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::FLAV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::FORMUL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::FRM(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::HON(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::IN(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::INV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::LS(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::MID(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::NB(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::PFX(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::POPUL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::PR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::PharmaceuticalEntityNamePartQualifiers(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3EntityNamePartQualifierR2::SCI(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::SFX(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::SP(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::STR(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::TIME(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::TMK(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::TitleStyles(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::USE(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartQualifierR2::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNamePartType {
    #[doc = "delimiter"]
    #[code = "DEL"]
    DEL(Option<Element>),
    #[doc = "family"]
    #[code = "FAM"]
    FAM(Option<Element>),
    #[doc = "given"]
    #[code = "GIV"]
    GIV(Option<Element>),
    #[doc = "prefix"]
    #[code = "PFX"]
    PFX(Option<Element>),
    #[doc = "suffix"]
    #[code = "SFX"]
    SFX(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNamePartType {
    fn default() -> Self {
        V3EntityNamePartType::Null(None)
    }
}
impl TryFrom<String> for V3EntityNamePartType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DEL" => Ok(V3EntityNamePartType::DEL(None)),
            "FAM" => Ok(V3EntityNamePartType::FAM(None)),
            "GIV" => Ok(V3EntityNamePartType::GIV(None)),
            "PFX" => Ok(V3EntityNamePartType::PFX(None)),
            "SFX" => Ok(V3EntityNamePartType::SFX(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNamePartType {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNamePartType::DEL(_) => Some("DEL".to_string()),
            V3EntityNamePartType::FAM(_) => Some("FAM".to_string()),
            V3EntityNamePartType::GIV(_) => Some("GIV".to_string()),
            V3EntityNamePartType::PFX(_) => Some("PFX".to_string()),
            V3EntityNamePartType::SFX(_) => Some("SFX".to_string()),
            V3EntityNamePartType::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNamePartType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNamePartType::DEL(Some(e)) => e.get_field(field),
                V3EntityNamePartType::FAM(Some(e)) => e.get_field(field),
                V3EntityNamePartType::GIV(Some(e)) => e.get_field(field),
                V3EntityNamePartType::PFX(Some(e)) => e.get_field(field),
                V3EntityNamePartType::SFX(Some(e)) => e.get_field(field),
                V3EntityNamePartType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNamePartType::DEL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartType::FAM(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartType::GIV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartType::PFX(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartType::SFX(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNamePartTypeR2 {
    #[doc = "delimiter"]
    #[code = "DEL"]
    DEL(Option<Element>),
    #[doc = "family"]
    #[code = "FAM"]
    FAM(Option<Element>),
    #[doc = "given"]
    #[code = "GIV"]
    GIV(Option<Element>),
    #[doc = "title"]
    #[code = "TITLE"]
    TITLE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNamePartTypeR2 {
    fn default() -> Self {
        V3EntityNamePartTypeR2::Null(None)
    }
}
impl TryFrom<String> for V3EntityNamePartTypeR2 {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DEL" => Ok(V3EntityNamePartTypeR2::DEL(None)),
            "FAM" => Ok(V3EntityNamePartTypeR2::FAM(None)),
            "GIV" => Ok(V3EntityNamePartTypeR2::GIV(None)),
            "TITLE" => Ok(V3EntityNamePartTypeR2::TITLE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNamePartTypeR2 {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNamePartTypeR2::DEL(_) => Some("DEL".to_string()),
            V3EntityNamePartTypeR2::FAM(_) => Some("FAM".to_string()),
            V3EntityNamePartTypeR2::GIV(_) => Some("GIV".to_string()),
            V3EntityNamePartTypeR2::TITLE(_) => Some("TITLE".to_string()),
            V3EntityNamePartTypeR2::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNamePartTypeR2 {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNamePartTypeR2::DEL(Some(e)) => e.get_field(field),
                V3EntityNamePartTypeR2::FAM(Some(e)) => e.get_field(field),
                V3EntityNamePartTypeR2::GIV(Some(e)) => e.get_field(field),
                V3EntityNamePartTypeR2::TITLE(Some(e)) => e.get_field(field),
                V3EntityNamePartTypeR2::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNamePartTypeR2::DEL(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartTypeR2::FAM(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartTypeR2::GIV(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartTypeR2::TITLE(Some(e)) => e.get_field_mut(field),
                V3EntityNamePartTypeR2::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNameUse {
    #[doc = "Artist/Stage"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Alphabetic"]
    #[code = "ABC"]
    ABC(Option<Element>),
    #[doc = "assigned"]
    #[code = "ASGN"]
    ASGN(Option<Element>),
    #[doc = "License"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "Indigenous/Tribal"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Ideographic"]
    #[code = "IDE"]
    IDE(Option<Element>),
    #[doc = "Legal"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "official registry"]
    #[code = "OR"]
    OR(Option<Element>),
    #[doc = "pseudonym"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "phonetic"]
    #[code = "PHON"]
    PHON(Option<Element>),
    #[doc = "Religious"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Soundex"]
    #[code = "SNDX"]
    SNDX(Option<Element>),
    #[doc = "search"]
    #[code = "SRCH"]
    SRCH(Option<Element>),
    #[doc = "Syllabic"]
    #[code = "SYL"]
    SYL(Option<Element>),
    #[doc = "NameRepresentationUse"]
    #[code = "_NameRepresentationUse"]
    _NameRepresentationUse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNameUse {
    fn default() -> Self {
        V3EntityNameUse::Null(None)
    }
}
impl TryFrom<String> for V3EntityNameUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3EntityNameUse::A(None)),
            "ABC" => Ok(V3EntityNameUse::ABC(None)),
            "ASGN" => Ok(V3EntityNameUse::ASGN(None)),
            "C" => Ok(V3EntityNameUse::C(None)),
            "I" => Ok(V3EntityNameUse::I(None)),
            "IDE" => Ok(V3EntityNameUse::IDE(None)),
            "L" => Ok(V3EntityNameUse::L(None)),
            "OR" => Ok(V3EntityNameUse::OR(None)),
            "P" => Ok(V3EntityNameUse::P(None)),
            "PHON" => Ok(V3EntityNameUse::PHON(None)),
            "R" => Ok(V3EntityNameUse::R(None)),
            "SNDX" => Ok(V3EntityNameUse::SNDX(None)),
            "SRCH" => Ok(V3EntityNameUse::SRCH(None)),
            "SYL" => Ok(V3EntityNameUse::SYL(None)),
            "_NameRepresentationUse" => Ok(V3EntityNameUse::_NameRepresentationUse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNameUse {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNameUse::A(_) => Some("A".to_string()),
            V3EntityNameUse::ABC(_) => Some("ABC".to_string()),
            V3EntityNameUse::ASGN(_) => Some("ASGN".to_string()),
            V3EntityNameUse::C(_) => Some("C".to_string()),
            V3EntityNameUse::I(_) => Some("I".to_string()),
            V3EntityNameUse::IDE(_) => Some("IDE".to_string()),
            V3EntityNameUse::L(_) => Some("L".to_string()),
            V3EntityNameUse::OR(_) => Some("OR".to_string()),
            V3EntityNameUse::P(_) => Some("P".to_string()),
            V3EntityNameUse::PHON(_) => Some("PHON".to_string()),
            V3EntityNameUse::R(_) => Some("R".to_string()),
            V3EntityNameUse::SNDX(_) => Some("SNDX".to_string()),
            V3EntityNameUse::SRCH(_) => Some("SRCH".to_string()),
            V3EntityNameUse::SYL(_) => Some("SYL".to_string()),
            V3EntityNameUse::_NameRepresentationUse(_) => {
                Some("_NameRepresentationUse".to_string())
            }
            V3EntityNameUse::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNameUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNameUse::A(Some(e)) => e.get_field(field),
                V3EntityNameUse::ABC(Some(e)) => e.get_field(field),
                V3EntityNameUse::ASGN(Some(e)) => e.get_field(field),
                V3EntityNameUse::C(Some(e)) => e.get_field(field),
                V3EntityNameUse::I(Some(e)) => e.get_field(field),
                V3EntityNameUse::IDE(Some(e)) => e.get_field(field),
                V3EntityNameUse::L(Some(e)) => e.get_field(field),
                V3EntityNameUse::OR(Some(e)) => e.get_field(field),
                V3EntityNameUse::P(Some(e)) => e.get_field(field),
                V3EntityNameUse::PHON(Some(e)) => e.get_field(field),
                V3EntityNameUse::R(Some(e)) => e.get_field(field),
                V3EntityNameUse::SNDX(Some(e)) => e.get_field(field),
                V3EntityNameUse::SRCH(Some(e)) => e.get_field(field),
                V3EntityNameUse::SYL(Some(e)) => e.get_field(field),
                V3EntityNameUse::_NameRepresentationUse(Some(e)) => e.get_field(field),
                V3EntityNameUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNameUse::A(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::ABC(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::ASGN(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::C(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::I(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::IDE(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::L(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::OR(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::P(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::PHON(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::R(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::SNDX(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::SRCH(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::SYL(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::_NameRepresentationUse(Some(e)) => e.get_field_mut(field),
                V3EntityNameUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityNameUseR2 {
    #[doc = "business name"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "alphabetic"]
    #[code = "ABC"]
    ABC(Option<Element>),
    #[doc = "Anonymous"]
    #[code = "ANON"]
    ANON(Option<Element>),
    #[doc = "Assumed"]
    #[code = "Assumed"]
    Assumed(Option<Element>),
    #[doc = "customary"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "do not use"]
    #[code = "DN"]
    DN(Option<Element>),
    #[doc = "Indigenous/Tribal"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "ideographic"]
    #[code = "IDE"]
    IDE(Option<Element>),
    #[doc = "maiden name"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "NameRepresentationUse"]
    #[code = "NameRepresentationUse"]
    NameRepresentationUse(Option<Element>),
    #[doc = "no longer in use"]
    #[code = "OLD"]
    OLD(Option<Element>),
    #[doc = "official registry name"]
    #[code = "OR"]
    OR(Option<Element>),
    #[doc = "Other/Pseudonym/Alias"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "phonetic"]
    #[code = "PHON"]
    PHON(Option<Element>),
    #[doc = "religious"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "search"]
    #[code = "SRCH"]
    SRCH(Option<Element>),
    #[doc = "syllabic"]
    #[code = "SYL"]
    SYL(Option<Element>),
    #[doc = "temporary"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityNameUseR2 {
    fn default() -> Self {
        V3EntityNameUseR2::Null(None)
    }
}
impl TryFrom<String> for V3EntityNameUseR2 {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3EntityNameUseR2::A(None)),
            "ABC" => Ok(V3EntityNameUseR2::ABC(None)),
            "ANON" => Ok(V3EntityNameUseR2::ANON(None)),
            "Assumed" => Ok(V3EntityNameUseR2::Assumed(None)),
            "C" => Ok(V3EntityNameUseR2::C(None)),
            "DN" => Ok(V3EntityNameUseR2::DN(None)),
            "I" => Ok(V3EntityNameUseR2::I(None)),
            "IDE" => Ok(V3EntityNameUseR2::IDE(None)),
            "M" => Ok(V3EntityNameUseR2::M(None)),
            "NameRepresentationUse" => Ok(V3EntityNameUseR2::NameRepresentationUse(None)),
            "OLD" => Ok(V3EntityNameUseR2::OLD(None)),
            "OR" => Ok(V3EntityNameUseR2::OR(None)),
            "P" => Ok(V3EntityNameUseR2::P(None)),
            "PHON" => Ok(V3EntityNameUseR2::PHON(None)),
            "R" => Ok(V3EntityNameUseR2::R(None)),
            "SRCH" => Ok(V3EntityNameUseR2::SRCH(None)),
            "SYL" => Ok(V3EntityNameUseR2::SYL(None)),
            "T" => Ok(V3EntityNameUseR2::T(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityNameUseR2 {
    fn into(self) -> Option<String> {
        match self {
            V3EntityNameUseR2::A(_) => Some("A".to_string()),
            V3EntityNameUseR2::ABC(_) => Some("ABC".to_string()),
            V3EntityNameUseR2::ANON(_) => Some("ANON".to_string()),
            V3EntityNameUseR2::Assumed(_) => Some("Assumed".to_string()),
            V3EntityNameUseR2::C(_) => Some("C".to_string()),
            V3EntityNameUseR2::DN(_) => Some("DN".to_string()),
            V3EntityNameUseR2::I(_) => Some("I".to_string()),
            V3EntityNameUseR2::IDE(_) => Some("IDE".to_string()),
            V3EntityNameUseR2::M(_) => Some("M".to_string()),
            V3EntityNameUseR2::NameRepresentationUse(_) => {
                Some("NameRepresentationUse".to_string())
            }
            V3EntityNameUseR2::OLD(_) => Some("OLD".to_string()),
            V3EntityNameUseR2::OR(_) => Some("OR".to_string()),
            V3EntityNameUseR2::P(_) => Some("P".to_string()),
            V3EntityNameUseR2::PHON(_) => Some("PHON".to_string()),
            V3EntityNameUseR2::R(_) => Some("R".to_string()),
            V3EntityNameUseR2::SRCH(_) => Some("SRCH".to_string()),
            V3EntityNameUseR2::SYL(_) => Some("SYL".to_string()),
            V3EntityNameUseR2::T(_) => Some("T".to_string()),
            V3EntityNameUseR2::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityNameUseR2 {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityNameUseR2::A(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::ABC(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::ANON(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::Assumed(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::C(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::DN(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::I(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::IDE(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::M(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::NameRepresentationUse(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::OLD(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::OR(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::P(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::PHON(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::R(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::SRCH(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::SYL(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::T(Some(e)) => e.get_field(field),
                V3EntityNameUseR2::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityNameUseR2::A(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::ABC(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::ANON(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::Assumed(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::C(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::DN(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::I(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::IDE(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::M(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::NameRepresentationUse(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::OLD(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::OR(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::P(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::PHON(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::R(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::SRCH(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::SYL(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::T(Some(e)) => e.get_field_mut(field),
                V3EntityNameUseR2::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityRisk {
    #[doc = "aggressive"]
    #[code = "AGG"]
    AGG(Option<Element>),
    #[doc = "biohazard"]
    #[code = "BHZ"]
    BHZ(Option<Element>),
    #[doc = "Biological"]
    #[code = "BIO"]
    BIO(Option<Element>),
    #[doc = "Corrosive"]
    #[code = "COR"]
    COR(Option<Element>),
    #[doc = "Escape Risk"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "explosive"]
    #[code = "EXP"]
    EXP(Option<Element>),
    #[doc = "inflammable"]
    #[code = "IFL"]
    IFL(Option<Element>),
    #[doc = "infectious"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "injury hazard"]
    #[code = "INJ"]
    INJ(Option<Element>),
    #[doc = "poison"]
    #[code = "POI"]
    POI(Option<Element>),
    #[doc = "radioactive"]
    #[code = "RAD"]
    RAD(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityRisk {
    fn default() -> Self {
        V3EntityRisk::Null(None)
    }
}
impl TryFrom<String> for V3EntityRisk {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AGG" => Ok(V3EntityRisk::AGG(None)),
            "BHZ" => Ok(V3EntityRisk::BHZ(None)),
            "BIO" => Ok(V3EntityRisk::BIO(None)),
            "COR" => Ok(V3EntityRisk::COR(None)),
            "ESC" => Ok(V3EntityRisk::ESC(None)),
            "EXP" => Ok(V3EntityRisk::EXP(None)),
            "IFL" => Ok(V3EntityRisk::IFL(None)),
            "INF" => Ok(V3EntityRisk::INF(None)),
            "INJ" => Ok(V3EntityRisk::INJ(None)),
            "POI" => Ok(V3EntityRisk::POI(None)),
            "RAD" => Ok(V3EntityRisk::RAD(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityRisk {
    fn into(self) -> Option<String> {
        match self {
            V3EntityRisk::AGG(_) => Some("AGG".to_string()),
            V3EntityRisk::BHZ(_) => Some("BHZ".to_string()),
            V3EntityRisk::BIO(_) => Some("BIO".to_string()),
            V3EntityRisk::COR(_) => Some("COR".to_string()),
            V3EntityRisk::ESC(_) => Some("ESC".to_string()),
            V3EntityRisk::EXP(_) => Some("EXP".to_string()),
            V3EntityRisk::IFL(_) => Some("IFL".to_string()),
            V3EntityRisk::INF(_) => Some("INF".to_string()),
            V3EntityRisk::INJ(_) => Some("INJ".to_string()),
            V3EntityRisk::POI(_) => Some("POI".to_string()),
            V3EntityRisk::RAD(_) => Some("RAD".to_string()),
            V3EntityRisk::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityRisk {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityRisk::AGG(Some(e)) => e.get_field(field),
                V3EntityRisk::BHZ(Some(e)) => e.get_field(field),
                V3EntityRisk::BIO(Some(e)) => e.get_field(field),
                V3EntityRisk::COR(Some(e)) => e.get_field(field),
                V3EntityRisk::ESC(Some(e)) => e.get_field(field),
                V3EntityRisk::EXP(Some(e)) => e.get_field(field),
                V3EntityRisk::IFL(Some(e)) => e.get_field(field),
                V3EntityRisk::INF(Some(e)) => e.get_field(field),
                V3EntityRisk::INJ(Some(e)) => e.get_field(field),
                V3EntityRisk::POI(Some(e)) => e.get_field(field),
                V3EntityRisk::RAD(Some(e)) => e.get_field(field),
                V3EntityRisk::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityRisk::AGG(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::BHZ(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::BIO(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::COR(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::ESC(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::EXP(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::IFL(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::INF(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::INJ(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::POI(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::RAD(Some(e)) => e.get_field_mut(field),
                V3EntityRisk::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EntityStatus {
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "inactive"]
    #[code = "inactive"]
    Inactive(Option<Element>),
    #[doc = "normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "nullified"]
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[doc = "terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EntityStatus {
    fn default() -> Self {
        V3EntityStatus::Null(None)
    }
}
impl TryFrom<String> for V3EntityStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(V3EntityStatus::Active(None)),
            "inactive" => Ok(V3EntityStatus::Inactive(None)),
            "normal" => Ok(V3EntityStatus::Normal(None)),
            "nullified" => Ok(V3EntityStatus::Nullified(None)),
            "terminated" => Ok(V3EntityStatus::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EntityStatus {
    fn into(self) -> Option<String> {
        match self {
            V3EntityStatus::Active(_) => Some("active".to_string()),
            V3EntityStatus::Inactive(_) => Some("inactive".to_string()),
            V3EntityStatus::Normal(_) => Some("normal".to_string()),
            V3EntityStatus::Nullified(_) => Some("nullified".to_string()),
            V3EntityStatus::Terminated(_) => Some("terminated".to_string()),
            V3EntityStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3EntityStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EntityStatus::Active(Some(e)) => e.get_field(field),
                V3EntityStatus::Inactive(Some(e)) => e.get_field(field),
                V3EntityStatus::Normal(Some(e)) => e.get_field(field),
                V3EntityStatus::Nullified(Some(e)) => e.get_field(field),
                V3EntityStatus::Terminated(Some(e)) => e.get_field(field),
                V3EntityStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EntityStatus::Active(Some(e)) => e.get_field_mut(field),
                V3EntityStatus::Inactive(Some(e)) => e.get_field_mut(field),
                V3EntityStatus::Normal(Some(e)) => e.get_field_mut(field),
                V3EntityStatus::Nullified(Some(e)) => e.get_field_mut(field),
                V3EntityStatus::Terminated(Some(e)) => e.get_field_mut(field),
                V3EntityStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3EquipmentAlertLevel {
    #[doc = "Critical"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "Normal"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "Serious"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Warning"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3EquipmentAlertLevel {
    fn default() -> Self {
        V3EquipmentAlertLevel::Null(None)
    }
}
impl TryFrom<String> for V3EquipmentAlertLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C" => Ok(V3EquipmentAlertLevel::C(None)),
            "N" => Ok(V3EquipmentAlertLevel::N(None)),
            "S" => Ok(V3EquipmentAlertLevel::S(None)),
            "W" => Ok(V3EquipmentAlertLevel::W(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3EquipmentAlertLevel {
    fn into(self) -> Option<String> {
        match self {
            V3EquipmentAlertLevel::C(_) => Some("C".to_string()),
            V3EquipmentAlertLevel::N(_) => Some("N".to_string()),
            V3EquipmentAlertLevel::S(_) => Some("S".to_string()),
            V3EquipmentAlertLevel::W(_) => Some("W".to_string()),
            V3EquipmentAlertLevel::Null(_) => None,
        }
    }
}
impl MetaValue for V3EquipmentAlertLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3EquipmentAlertLevel::C(Some(e)) => e.get_field(field),
                V3EquipmentAlertLevel::N(Some(e)) => e.get_field(field),
                V3EquipmentAlertLevel::S(Some(e)) => e.get_field(field),
                V3EquipmentAlertLevel::W(Some(e)) => e.get_field(field),
                V3EquipmentAlertLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3EquipmentAlertLevel::C(Some(e)) => e.get_field_mut(field),
                V3EquipmentAlertLevel::N(Some(e)) => e.get_field_mut(field),
                V3EquipmentAlertLevel::S(Some(e)) => e.get_field_mut(field),
                V3EquipmentAlertLevel::W(Some(e)) => e.get_field_mut(field),
                V3EquipmentAlertLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Ethnicity {
    #[doc = "Hispanic or Latino"]
    #[code = "2135-2"]
    V21352(Option<Element>),
    #[doc = "Spaniard"]
    #[code = "2137-8"]
    V21378(Option<Element>),
    #[doc = "Andalusian"]
    #[code = "2138-6"]
    V21386(Option<Element>),
    #[doc = "Asturian"]
    #[code = "2139-4"]
    V21394(Option<Element>),
    #[doc = "Castillian"]
    #[code = "2140-2"]
    V21402(Option<Element>),
    #[doc = "Catalonian"]
    #[code = "2141-0"]
    V21410(Option<Element>),
    #[doc = "Belearic Islander"]
    #[code = "2142-8"]
    V21428(Option<Element>),
    #[doc = "Gallego"]
    #[code = "2143-6"]
    V21436(Option<Element>),
    #[doc = "Valencian"]
    #[code = "2144-4"]
    V21444(Option<Element>),
    #[doc = "Canarian"]
    #[code = "2145-1"]
    V21451(Option<Element>),
    #[doc = "Spanish Basque"]
    #[code = "2146-9"]
    V21469(Option<Element>),
    #[doc = "Mexican"]
    #[code = "2148-5"]
    V21485(Option<Element>),
    #[doc = "Mexican American"]
    #[code = "2149-3"]
    V21493(Option<Element>),
    #[doc = "Mexicano"]
    #[code = "2150-1"]
    V21501(Option<Element>),
    #[doc = "Chicano"]
    #[code = "2151-9"]
    V21519(Option<Element>),
    #[doc = "La Raza"]
    #[code = "2152-7"]
    V21527(Option<Element>),
    #[doc = "Mexican American Indian"]
    #[code = "2153-5"]
    V21535(Option<Element>),
    #[doc = "Central American"]
    #[code = "2155-0"]
    V21550(Option<Element>),
    #[doc = "Costa Rican"]
    #[code = "2156-8"]
    V21568(Option<Element>),
    #[doc = "Guatemalan"]
    #[code = "2157-6"]
    V21576(Option<Element>),
    #[doc = "Honduran"]
    #[code = "2158-4"]
    V21584(Option<Element>),
    #[doc = "Nicaraguan"]
    #[code = "2159-2"]
    V21592(Option<Element>),
    #[doc = "Panamanian"]
    #[code = "2160-0"]
    V21600(Option<Element>),
    #[doc = "Salvadoran"]
    #[code = "2161-8"]
    V21618(Option<Element>),
    #[doc = "Central American Indian"]
    #[code = "2162-6"]
    V21626(Option<Element>),
    #[doc = "Canal Zone"]
    #[code = "2163-4"]
    V21634(Option<Element>),
    #[doc = "South American"]
    #[code = "2165-9"]
    V21659(Option<Element>),
    #[doc = "Argentinean"]
    #[code = "2166-7"]
    V21667(Option<Element>),
    #[doc = "Bolivian"]
    #[code = "2167-5"]
    V21675(Option<Element>),
    #[doc = "Chilean"]
    #[code = "2168-3"]
    V21683(Option<Element>),
    #[doc = "Colombian"]
    #[code = "2169-1"]
    V21691(Option<Element>),
    #[doc = "Ecuadorian"]
    #[code = "2170-9"]
    V21709(Option<Element>),
    #[doc = "Paraguayan"]
    #[code = "2171-7"]
    V21717(Option<Element>),
    #[doc = "Peruvian"]
    #[code = "2172-5"]
    V21725(Option<Element>),
    #[doc = "Uruguayan"]
    #[code = "2173-3"]
    V21733(Option<Element>),
    #[doc = "Venezuelan"]
    #[code = "2174-1"]
    V21741(Option<Element>),
    #[doc = "South American Indian"]
    #[code = "2175-8"]
    V21758(Option<Element>),
    #[doc = "Criollo"]
    #[code = "2176-6"]
    V21766(Option<Element>),
    #[doc = "Latin American"]
    #[code = "2178-2"]
    V21782(Option<Element>),
    #[doc = "Puerto Rican"]
    #[code = "2180-8"]
    V21808(Option<Element>),
    #[doc = "Cuban"]
    #[code = "2182-4"]
    V21824(Option<Element>),
    #[doc = "Dominican"]
    #[code = "2184-0"]
    V21840(Option<Element>),
    #[doc = "Not Hispanic or Latino"]
    #[code = "2186-5"]
    V21865(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Ethnicity {
    fn default() -> Self {
        V3Ethnicity::Null(None)
    }
}
impl TryFrom<String> for V3Ethnicity {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "2135-2" => Ok(V3Ethnicity::V21352(None)),
            "2137-8" => Ok(V3Ethnicity::V21378(None)),
            "2138-6" => Ok(V3Ethnicity::V21386(None)),
            "2139-4" => Ok(V3Ethnicity::V21394(None)),
            "2140-2" => Ok(V3Ethnicity::V21402(None)),
            "2141-0" => Ok(V3Ethnicity::V21410(None)),
            "2142-8" => Ok(V3Ethnicity::V21428(None)),
            "2143-6" => Ok(V3Ethnicity::V21436(None)),
            "2144-4" => Ok(V3Ethnicity::V21444(None)),
            "2145-1" => Ok(V3Ethnicity::V21451(None)),
            "2146-9" => Ok(V3Ethnicity::V21469(None)),
            "2148-5" => Ok(V3Ethnicity::V21485(None)),
            "2149-3" => Ok(V3Ethnicity::V21493(None)),
            "2150-1" => Ok(V3Ethnicity::V21501(None)),
            "2151-9" => Ok(V3Ethnicity::V21519(None)),
            "2152-7" => Ok(V3Ethnicity::V21527(None)),
            "2153-5" => Ok(V3Ethnicity::V21535(None)),
            "2155-0" => Ok(V3Ethnicity::V21550(None)),
            "2156-8" => Ok(V3Ethnicity::V21568(None)),
            "2157-6" => Ok(V3Ethnicity::V21576(None)),
            "2158-4" => Ok(V3Ethnicity::V21584(None)),
            "2159-2" => Ok(V3Ethnicity::V21592(None)),
            "2160-0" => Ok(V3Ethnicity::V21600(None)),
            "2161-8" => Ok(V3Ethnicity::V21618(None)),
            "2162-6" => Ok(V3Ethnicity::V21626(None)),
            "2163-4" => Ok(V3Ethnicity::V21634(None)),
            "2165-9" => Ok(V3Ethnicity::V21659(None)),
            "2166-7" => Ok(V3Ethnicity::V21667(None)),
            "2167-5" => Ok(V3Ethnicity::V21675(None)),
            "2168-3" => Ok(V3Ethnicity::V21683(None)),
            "2169-1" => Ok(V3Ethnicity::V21691(None)),
            "2170-9" => Ok(V3Ethnicity::V21709(None)),
            "2171-7" => Ok(V3Ethnicity::V21717(None)),
            "2172-5" => Ok(V3Ethnicity::V21725(None)),
            "2173-3" => Ok(V3Ethnicity::V21733(None)),
            "2174-1" => Ok(V3Ethnicity::V21741(None)),
            "2175-8" => Ok(V3Ethnicity::V21758(None)),
            "2176-6" => Ok(V3Ethnicity::V21766(None)),
            "2178-2" => Ok(V3Ethnicity::V21782(None)),
            "2180-8" => Ok(V3Ethnicity::V21808(None)),
            "2182-4" => Ok(V3Ethnicity::V21824(None)),
            "2184-0" => Ok(V3Ethnicity::V21840(None)),
            "2186-5" => Ok(V3Ethnicity::V21865(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Ethnicity {
    fn into(self) -> Option<String> {
        match self {
            V3Ethnicity::V21352(_) => Some("2135-2".to_string()),
            V3Ethnicity::V21378(_) => Some("2137-8".to_string()),
            V3Ethnicity::V21386(_) => Some("2138-6".to_string()),
            V3Ethnicity::V21394(_) => Some("2139-4".to_string()),
            V3Ethnicity::V21402(_) => Some("2140-2".to_string()),
            V3Ethnicity::V21410(_) => Some("2141-0".to_string()),
            V3Ethnicity::V21428(_) => Some("2142-8".to_string()),
            V3Ethnicity::V21436(_) => Some("2143-6".to_string()),
            V3Ethnicity::V21444(_) => Some("2144-4".to_string()),
            V3Ethnicity::V21451(_) => Some("2145-1".to_string()),
            V3Ethnicity::V21469(_) => Some("2146-9".to_string()),
            V3Ethnicity::V21485(_) => Some("2148-5".to_string()),
            V3Ethnicity::V21493(_) => Some("2149-3".to_string()),
            V3Ethnicity::V21501(_) => Some("2150-1".to_string()),
            V3Ethnicity::V21519(_) => Some("2151-9".to_string()),
            V3Ethnicity::V21527(_) => Some("2152-7".to_string()),
            V3Ethnicity::V21535(_) => Some("2153-5".to_string()),
            V3Ethnicity::V21550(_) => Some("2155-0".to_string()),
            V3Ethnicity::V21568(_) => Some("2156-8".to_string()),
            V3Ethnicity::V21576(_) => Some("2157-6".to_string()),
            V3Ethnicity::V21584(_) => Some("2158-4".to_string()),
            V3Ethnicity::V21592(_) => Some("2159-2".to_string()),
            V3Ethnicity::V21600(_) => Some("2160-0".to_string()),
            V3Ethnicity::V21618(_) => Some("2161-8".to_string()),
            V3Ethnicity::V21626(_) => Some("2162-6".to_string()),
            V3Ethnicity::V21634(_) => Some("2163-4".to_string()),
            V3Ethnicity::V21659(_) => Some("2165-9".to_string()),
            V3Ethnicity::V21667(_) => Some("2166-7".to_string()),
            V3Ethnicity::V21675(_) => Some("2167-5".to_string()),
            V3Ethnicity::V21683(_) => Some("2168-3".to_string()),
            V3Ethnicity::V21691(_) => Some("2169-1".to_string()),
            V3Ethnicity::V21709(_) => Some("2170-9".to_string()),
            V3Ethnicity::V21717(_) => Some("2171-7".to_string()),
            V3Ethnicity::V21725(_) => Some("2172-5".to_string()),
            V3Ethnicity::V21733(_) => Some("2173-3".to_string()),
            V3Ethnicity::V21741(_) => Some("2174-1".to_string()),
            V3Ethnicity::V21758(_) => Some("2175-8".to_string()),
            V3Ethnicity::V21766(_) => Some("2176-6".to_string()),
            V3Ethnicity::V21782(_) => Some("2178-2".to_string()),
            V3Ethnicity::V21808(_) => Some("2180-8".to_string()),
            V3Ethnicity::V21824(_) => Some("2182-4".to_string()),
            V3Ethnicity::V21840(_) => Some("2184-0".to_string()),
            V3Ethnicity::V21865(_) => Some("2186-5".to_string()),
            V3Ethnicity::Null(_) => None,
        }
    }
}
impl MetaValue for V3Ethnicity {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Ethnicity::V21352(Some(e)) => e.get_field(field),
                V3Ethnicity::V21378(Some(e)) => e.get_field(field),
                V3Ethnicity::V21386(Some(e)) => e.get_field(field),
                V3Ethnicity::V21394(Some(e)) => e.get_field(field),
                V3Ethnicity::V21402(Some(e)) => e.get_field(field),
                V3Ethnicity::V21410(Some(e)) => e.get_field(field),
                V3Ethnicity::V21428(Some(e)) => e.get_field(field),
                V3Ethnicity::V21436(Some(e)) => e.get_field(field),
                V3Ethnicity::V21444(Some(e)) => e.get_field(field),
                V3Ethnicity::V21451(Some(e)) => e.get_field(field),
                V3Ethnicity::V21469(Some(e)) => e.get_field(field),
                V3Ethnicity::V21485(Some(e)) => e.get_field(field),
                V3Ethnicity::V21493(Some(e)) => e.get_field(field),
                V3Ethnicity::V21501(Some(e)) => e.get_field(field),
                V3Ethnicity::V21519(Some(e)) => e.get_field(field),
                V3Ethnicity::V21527(Some(e)) => e.get_field(field),
                V3Ethnicity::V21535(Some(e)) => e.get_field(field),
                V3Ethnicity::V21550(Some(e)) => e.get_field(field),
                V3Ethnicity::V21568(Some(e)) => e.get_field(field),
                V3Ethnicity::V21576(Some(e)) => e.get_field(field),
                V3Ethnicity::V21584(Some(e)) => e.get_field(field),
                V3Ethnicity::V21592(Some(e)) => e.get_field(field),
                V3Ethnicity::V21600(Some(e)) => e.get_field(field),
                V3Ethnicity::V21618(Some(e)) => e.get_field(field),
                V3Ethnicity::V21626(Some(e)) => e.get_field(field),
                V3Ethnicity::V21634(Some(e)) => e.get_field(field),
                V3Ethnicity::V21659(Some(e)) => e.get_field(field),
                V3Ethnicity::V21667(Some(e)) => e.get_field(field),
                V3Ethnicity::V21675(Some(e)) => e.get_field(field),
                V3Ethnicity::V21683(Some(e)) => e.get_field(field),
                V3Ethnicity::V21691(Some(e)) => e.get_field(field),
                V3Ethnicity::V21709(Some(e)) => e.get_field(field),
                V3Ethnicity::V21717(Some(e)) => e.get_field(field),
                V3Ethnicity::V21725(Some(e)) => e.get_field(field),
                V3Ethnicity::V21733(Some(e)) => e.get_field(field),
                V3Ethnicity::V21741(Some(e)) => e.get_field(field),
                V3Ethnicity::V21758(Some(e)) => e.get_field(field),
                V3Ethnicity::V21766(Some(e)) => e.get_field(field),
                V3Ethnicity::V21782(Some(e)) => e.get_field(field),
                V3Ethnicity::V21808(Some(e)) => e.get_field(field),
                V3Ethnicity::V21824(Some(e)) => e.get_field(field),
                V3Ethnicity::V21840(Some(e)) => e.get_field(field),
                V3Ethnicity::V21865(Some(e)) => e.get_field(field),
                V3Ethnicity::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Ethnicity::V21352(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21378(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21386(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21394(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21402(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21410(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21428(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21436(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21444(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21451(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21469(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21485(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21493(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21501(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21519(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21527(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21535(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21550(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21568(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21576(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21584(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21592(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21600(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21618(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21626(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21634(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21659(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21667(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21675(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21683(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21691(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21709(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21717(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21725(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21733(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21741(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21758(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21766(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21782(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21808(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21824(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21840(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::V21865(Some(e)) => e.get_field_mut(field),
                V3Ethnicity::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ExposureMode {
    #[doc = "airborne"]
    #[code = "AIRBORNE"]
    AIRBORNE(Option<Element>),
    #[doc = "contact"]
    #[code = "CONTACT"]
    CONTACT(Option<Element>),
    #[doc = "foodborne"]
    #[code = "FOODBORNE"]
    FOODBORNE(Option<Element>),
    #[doc = "waterborne"]
    #[code = "WATERBORNE"]
    WATERBORNE(Option<Element>),
    #[doc = "ExposureMode"]
    #[code = "_ExposureMode"]
    _ExposureMode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ExposureMode {
    fn default() -> Self {
        V3ExposureMode::Null(None)
    }
}
impl TryFrom<String> for V3ExposureMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AIRBORNE" => Ok(V3ExposureMode::AIRBORNE(None)),
            "CONTACT" => Ok(V3ExposureMode::CONTACT(None)),
            "FOODBORNE" => Ok(V3ExposureMode::FOODBORNE(None)),
            "WATERBORNE" => Ok(V3ExposureMode::WATERBORNE(None)),
            "_ExposureMode" => Ok(V3ExposureMode::_ExposureMode(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ExposureMode {
    fn into(self) -> Option<String> {
        match self {
            V3ExposureMode::AIRBORNE(_) => Some("AIRBORNE".to_string()),
            V3ExposureMode::CONTACT(_) => Some("CONTACT".to_string()),
            V3ExposureMode::FOODBORNE(_) => Some("FOODBORNE".to_string()),
            V3ExposureMode::WATERBORNE(_) => Some("WATERBORNE".to_string()),
            V3ExposureMode::_ExposureMode(_) => Some("_ExposureMode".to_string()),
            V3ExposureMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ExposureMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ExposureMode::AIRBORNE(Some(e)) => e.get_field(field),
                V3ExposureMode::CONTACT(Some(e)) => e.get_field(field),
                V3ExposureMode::FOODBORNE(Some(e)) => e.get_field(field),
                V3ExposureMode::WATERBORNE(Some(e)) => e.get_field(field),
                V3ExposureMode::_ExposureMode(Some(e)) => e.get_field(field),
                V3ExposureMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ExposureMode::AIRBORNE(Some(e)) => e.get_field_mut(field),
                V3ExposureMode::CONTACT(Some(e)) => e.get_field_mut(field),
                V3ExposureMode::FOODBORNE(Some(e)) => e.get_field_mut(field),
                V3ExposureMode::WATERBORNE(Some(e)) => e.get_field_mut(field),
                V3ExposureMode::_ExposureMode(Some(e)) => e.get_field_mut(field),
                V3ExposureMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3GTSAbbreviation {
    #[doc = "AM"]
    #[code = "AM"]
    AM(Option<Element>),
    #[doc = "at bedtime"]
    #[code = "BED"]
    BED(Option<Element>),
    #[doc = "BID"]
    #[code = "BID"]
    BID(Option<Element>),
    #[doc = "JB"]
    #[code = "JB"]
    JB(Option<Element>),
    #[doc = "JE"]
    #[code = "JE"]
    JE(Option<Element>),
    #[doc = "GTSAbbreviationHolidays"]
    #[code = "JH"]
    JH(Option<Element>),
    #[doc = "JHCHREAS"]
    #[code = "JHCHREAS"]
    JHCHREAS(Option<Element>),
    #[doc = "JHCHRGFR"]
    #[code = "JHCHRGFR"]
    JHCHRGFR(Option<Element>),
    #[doc = "JHCHRNEW"]
    #[code = "JHCHRNEW"]
    JHCHRNEW(Option<Element>),
    #[doc = "JHCHRPEN"]
    #[code = "JHCHRPEN"]
    JHCHRPEN(Option<Element>),
    #[doc = "JHCHRXME"]
    #[code = "JHCHRXME"]
    JHCHRXME(Option<Element>),
    #[doc = "JHCHRXMS"]
    #[code = "JHCHRXMS"]
    JHCHRXMS(Option<Element>),
    #[doc = "The Netherlands National Holidays"]
    #[code = "JHNNL"]
    JHNNL(Option<Element>),
    #[doc = "Liberation day (May 5 every five years)"]
    #[code = "JHNNLLD"]
    JHNNLLD(Option<Element>),
    #[doc = "Queen's day (April 30)"]
    #[code = "JHNNLQD"]
    JHNNLQD(Option<Element>),
    #[doc = "Sinterklaas (December 5)"]
    #[code = "JHNNLSK"]
    JHNNLSK(Option<Element>),
    #[doc = "GTSAbbreviationHolidaysUSNational"]
    #[code = "JHNUS"]
    JHNUS(Option<Element>),
    #[doc = "JHNUSCLM"]
    #[code = "JHNUSCLM"]
    JHNUSCLM(Option<Element>),
    #[doc = "JHNUSIND"]
    #[code = "JHNUSIND"]
    JHNUSIND(Option<Element>),
    #[doc = "JHNUSIND1"]
    #[code = "JHNUSIND1"]
    JHNUSIND1(Option<Element>),
    #[doc = "JHNUSIND5"]
    #[code = "JHNUSIND5"]
    JHNUSIND5(Option<Element>),
    #[doc = "JHNUSLBR"]
    #[code = "JHNUSLBR"]
    JHNUSLBR(Option<Element>),
    #[doc = "JHNUSMEM"]
    #[code = "JHNUSMEM"]
    JHNUSMEM(Option<Element>),
    #[doc = "JHNUSMEM5"]
    #[code = "JHNUSMEM5"]
    JHNUSMEM5(Option<Element>),
    #[doc = "JHNUSMEM6"]
    #[code = "JHNUSMEM6"]
    JHNUSMEM6(Option<Element>),
    #[doc = "JHNUSMLK"]
    #[code = "JHNUSMLK"]
    JHNUSMLK(Option<Element>),
    #[doc = "JHNUSPRE"]
    #[code = "JHNUSPRE"]
    JHNUSPRE(Option<Element>),
    #[doc = "JHNUSTKS"]
    #[code = "JHNUSTKS"]
    JHNUSTKS(Option<Element>),
    #[doc = "JHNUSTKS5"]
    #[code = "JHNUSTKS5"]
    JHNUSTKS5(Option<Element>),
    #[doc = "JHNUSVET"]
    #[code = "JHNUSVET"]
    JHNUSVET(Option<Element>),
    #[doc = "monthly"]
    #[code = "MO"]
    MO(Option<Element>),
    #[doc = "PM"]
    #[code = "PM"]
    PM(Option<Element>),
    #[doc = "every hour"]
    #[code = "Q1H"]
    Q1H(Option<Element>),
    #[doc = "every 2 hours"]
    #[code = "Q2H"]
    Q2H(Option<Element>),
    #[doc = "every 3 hours"]
    #[code = "Q3H"]
    Q3H(Option<Element>),
    #[doc = "Q4H"]
    #[code = "Q4H"]
    Q4H(Option<Element>),
    #[doc = "Q6H"]
    #[code = "Q6H"]
    Q6H(Option<Element>),
    #[doc = "every 8 hours"]
    #[code = "Q8H"]
    Q8H(Option<Element>),
    #[doc = "QD"]
    #[code = "QD"]
    QD(Option<Element>),
    #[doc = "QID"]
    #[code = "QID"]
    QID(Option<Element>),
    #[doc = "QOD"]
    #[code = "QOD"]
    QOD(Option<Element>),
    #[doc = "TID"]
    #[code = "TID"]
    TID(Option<Element>),
    #[doc = "weekly"]
    #[code = "WK"]
    WK(Option<Element>),
    #[doc = "GTSAbbreviationHolidaysChristianRoman"]
    #[code = "_GTSAbbreviationHolidaysChristianRoman"]
    _GTSAbbreviationHolidaysChristianRoman(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3GTSAbbreviation {
    fn default() -> Self {
        V3GTSAbbreviation::Null(None)
    }
}
impl TryFrom<String> for V3GTSAbbreviation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AM" => Ok(V3GTSAbbreviation::AM(None)),
            "BED" => Ok(V3GTSAbbreviation::BED(None)),
            "BID" => Ok(V3GTSAbbreviation::BID(None)),
            "JB" => Ok(V3GTSAbbreviation::JB(None)),
            "JE" => Ok(V3GTSAbbreviation::JE(None)),
            "JH" => Ok(V3GTSAbbreviation::JH(None)),
            "JHCHREAS" => Ok(V3GTSAbbreviation::JHCHREAS(None)),
            "JHCHRGFR" => Ok(V3GTSAbbreviation::JHCHRGFR(None)),
            "JHCHRNEW" => Ok(V3GTSAbbreviation::JHCHRNEW(None)),
            "JHCHRPEN" => Ok(V3GTSAbbreviation::JHCHRPEN(None)),
            "JHCHRXME" => Ok(V3GTSAbbreviation::JHCHRXME(None)),
            "JHCHRXMS" => Ok(V3GTSAbbreviation::JHCHRXMS(None)),
            "JHNNL" => Ok(V3GTSAbbreviation::JHNNL(None)),
            "JHNNLLD" => Ok(V3GTSAbbreviation::JHNNLLD(None)),
            "JHNNLQD" => Ok(V3GTSAbbreviation::JHNNLQD(None)),
            "JHNNLSK" => Ok(V3GTSAbbreviation::JHNNLSK(None)),
            "JHNUS" => Ok(V3GTSAbbreviation::JHNUS(None)),
            "JHNUSCLM" => Ok(V3GTSAbbreviation::JHNUSCLM(None)),
            "JHNUSIND" => Ok(V3GTSAbbreviation::JHNUSIND(None)),
            "JHNUSIND1" => Ok(V3GTSAbbreviation::JHNUSIND1(None)),
            "JHNUSIND5" => Ok(V3GTSAbbreviation::JHNUSIND5(None)),
            "JHNUSLBR" => Ok(V3GTSAbbreviation::JHNUSLBR(None)),
            "JHNUSMEM" => Ok(V3GTSAbbreviation::JHNUSMEM(None)),
            "JHNUSMEM5" => Ok(V3GTSAbbreviation::JHNUSMEM5(None)),
            "JHNUSMEM6" => Ok(V3GTSAbbreviation::JHNUSMEM6(None)),
            "JHNUSMLK" => Ok(V3GTSAbbreviation::JHNUSMLK(None)),
            "JHNUSPRE" => Ok(V3GTSAbbreviation::JHNUSPRE(None)),
            "JHNUSTKS" => Ok(V3GTSAbbreviation::JHNUSTKS(None)),
            "JHNUSTKS5" => Ok(V3GTSAbbreviation::JHNUSTKS5(None)),
            "JHNUSVET" => Ok(V3GTSAbbreviation::JHNUSVET(None)),
            "MO" => Ok(V3GTSAbbreviation::MO(None)),
            "PM" => Ok(V3GTSAbbreviation::PM(None)),
            "Q1H" => Ok(V3GTSAbbreviation::Q1H(None)),
            "Q2H" => Ok(V3GTSAbbreviation::Q2H(None)),
            "Q3H" => Ok(V3GTSAbbreviation::Q3H(None)),
            "Q4H" => Ok(V3GTSAbbreviation::Q4H(None)),
            "Q6H" => Ok(V3GTSAbbreviation::Q6H(None)),
            "Q8H" => Ok(V3GTSAbbreviation::Q8H(None)),
            "QD" => Ok(V3GTSAbbreviation::QD(None)),
            "QID" => Ok(V3GTSAbbreviation::QID(None)),
            "QOD" => Ok(V3GTSAbbreviation::QOD(None)),
            "TID" => Ok(V3GTSAbbreviation::TID(None)),
            "WK" => Ok(V3GTSAbbreviation::WK(None)),
            "_GTSAbbreviationHolidaysChristianRoman" => Ok(
                V3GTSAbbreviation::_GTSAbbreviationHolidaysChristianRoman(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3GTSAbbreviation {
    fn into(self) -> Option<String> {
        match self {
            V3GTSAbbreviation::AM(_) => Some("AM".to_string()),
            V3GTSAbbreviation::BED(_) => Some("BED".to_string()),
            V3GTSAbbreviation::BID(_) => Some("BID".to_string()),
            V3GTSAbbreviation::JB(_) => Some("JB".to_string()),
            V3GTSAbbreviation::JE(_) => Some("JE".to_string()),
            V3GTSAbbreviation::JH(_) => Some("JH".to_string()),
            V3GTSAbbreviation::JHCHREAS(_) => Some("JHCHREAS".to_string()),
            V3GTSAbbreviation::JHCHRGFR(_) => Some("JHCHRGFR".to_string()),
            V3GTSAbbreviation::JHCHRNEW(_) => Some("JHCHRNEW".to_string()),
            V3GTSAbbreviation::JHCHRPEN(_) => Some("JHCHRPEN".to_string()),
            V3GTSAbbreviation::JHCHRXME(_) => Some("JHCHRXME".to_string()),
            V3GTSAbbreviation::JHCHRXMS(_) => Some("JHCHRXMS".to_string()),
            V3GTSAbbreviation::JHNNL(_) => Some("JHNNL".to_string()),
            V3GTSAbbreviation::JHNNLLD(_) => Some("JHNNLLD".to_string()),
            V3GTSAbbreviation::JHNNLQD(_) => Some("JHNNLQD".to_string()),
            V3GTSAbbreviation::JHNNLSK(_) => Some("JHNNLSK".to_string()),
            V3GTSAbbreviation::JHNUS(_) => Some("JHNUS".to_string()),
            V3GTSAbbreviation::JHNUSCLM(_) => Some("JHNUSCLM".to_string()),
            V3GTSAbbreviation::JHNUSIND(_) => Some("JHNUSIND".to_string()),
            V3GTSAbbreviation::JHNUSIND1(_) => Some("JHNUSIND1".to_string()),
            V3GTSAbbreviation::JHNUSIND5(_) => Some("JHNUSIND5".to_string()),
            V3GTSAbbreviation::JHNUSLBR(_) => Some("JHNUSLBR".to_string()),
            V3GTSAbbreviation::JHNUSMEM(_) => Some("JHNUSMEM".to_string()),
            V3GTSAbbreviation::JHNUSMEM5(_) => Some("JHNUSMEM5".to_string()),
            V3GTSAbbreviation::JHNUSMEM6(_) => Some("JHNUSMEM6".to_string()),
            V3GTSAbbreviation::JHNUSMLK(_) => Some("JHNUSMLK".to_string()),
            V3GTSAbbreviation::JHNUSPRE(_) => Some("JHNUSPRE".to_string()),
            V3GTSAbbreviation::JHNUSTKS(_) => Some("JHNUSTKS".to_string()),
            V3GTSAbbreviation::JHNUSTKS5(_) => Some("JHNUSTKS5".to_string()),
            V3GTSAbbreviation::JHNUSVET(_) => Some("JHNUSVET".to_string()),
            V3GTSAbbreviation::MO(_) => Some("MO".to_string()),
            V3GTSAbbreviation::PM(_) => Some("PM".to_string()),
            V3GTSAbbreviation::Q1H(_) => Some("Q1H".to_string()),
            V3GTSAbbreviation::Q2H(_) => Some("Q2H".to_string()),
            V3GTSAbbreviation::Q3H(_) => Some("Q3H".to_string()),
            V3GTSAbbreviation::Q4H(_) => Some("Q4H".to_string()),
            V3GTSAbbreviation::Q6H(_) => Some("Q6H".to_string()),
            V3GTSAbbreviation::Q8H(_) => Some("Q8H".to_string()),
            V3GTSAbbreviation::QD(_) => Some("QD".to_string()),
            V3GTSAbbreviation::QID(_) => Some("QID".to_string()),
            V3GTSAbbreviation::QOD(_) => Some("QOD".to_string()),
            V3GTSAbbreviation::TID(_) => Some("TID".to_string()),
            V3GTSAbbreviation::WK(_) => Some("WK".to_string()),
            V3GTSAbbreviation::_GTSAbbreviationHolidaysChristianRoman(_) => {
                Some("_GTSAbbreviationHolidaysChristianRoman".to_string())
            }
            V3GTSAbbreviation::Null(_) => None,
        }
    }
}
impl MetaValue for V3GTSAbbreviation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3GTSAbbreviation::AM(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::BED(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::BID(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JB(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JE(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JH(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHREAS(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHRGFR(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHRNEW(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHRPEN(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHRXME(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHCHRXMS(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNNL(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNNLLD(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNNLQD(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNNLSK(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUS(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSCLM(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSIND(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSIND1(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSIND5(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSLBR(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSMEM(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSMEM5(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSMEM6(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSMLK(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSPRE(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSTKS(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSTKS5(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::JHNUSVET(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::MO(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::PM(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q1H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q2H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q3H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q4H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q6H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::Q8H(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::QD(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::QID(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::QOD(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::TID(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::WK(Some(e)) => e.get_field(field),
                V3GTSAbbreviation::_GTSAbbreviationHolidaysChristianRoman(Some(e)) => {
                    e.get_field(field)
                }
                V3GTSAbbreviation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3GTSAbbreviation::AM(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::BED(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::BID(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JB(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JE(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JH(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHREAS(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHRGFR(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHRNEW(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHRPEN(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHRXME(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHCHRXMS(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNNL(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNNLLD(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNNLQD(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNNLSK(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUS(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSCLM(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSIND(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSIND1(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSIND5(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSLBR(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSMEM(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSMEM5(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSMEM6(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSMLK(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSPRE(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSTKS(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSTKS5(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::JHNUSVET(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::MO(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::PM(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q1H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q2H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q3H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q4H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q6H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::Q8H(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::QD(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::QID(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::QOD(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::TID(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::WK(Some(e)) => e.get_field_mut(field),
                V3GTSAbbreviation::_GTSAbbreviationHolidaysChristianRoman(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3GTSAbbreviation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3GenderStatus {
    #[doc = "Intact"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Neutered"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3GenderStatus {
    fn default() -> Self {
        V3GenderStatus::Null(None)
    }
}
impl TryFrom<String> for V3GenderStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "I" => Ok(V3GenderStatus::I(None)),
            "N" => Ok(V3GenderStatus::N(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3GenderStatus {
    fn into(self) -> Option<String> {
        match self {
            V3GenderStatus::I(_) => Some("I".to_string()),
            V3GenderStatus::N(_) => Some("N".to_string()),
            V3GenderStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3GenderStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3GenderStatus::I(Some(e)) => e.get_field(field),
                V3GenderStatus::N(Some(e)) => e.get_field(field),
                V3GenderStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3GenderStatus::I(Some(e)) => e.get_field_mut(field),
                V3GenderStatus::N(Some(e)) => e.get_field_mut(field),
                V3GenderStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3GeneralPurposeOfUse {
    #[code = "COVERAGE"]
    COVERAGE(Option<Element>),
    #[code = "ETREAT"]
    ETREAT(Option<Element>),
    #[code = "HMARKT"]
    HMARKT(Option<Element>),
    #[code = "HOPERAT"]
    HOPERAT(Option<Element>),
    #[code = "HPAYMT"]
    HPAYMT(Option<Element>),
    #[code = "HRESCH"]
    HRESCH(Option<Element>),
    #[code = "PATRQT"]
    PATRQT(Option<Element>),
    #[code = "PUBHLTH"]
    PUBHLTH(Option<Element>),
    #[code = "TREAT"]
    TREAT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3GeneralPurposeOfUse {
    fn default() -> Self {
        V3GeneralPurposeOfUse::Null(None)
    }
}
impl TryFrom<String> for V3GeneralPurposeOfUse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "COVERAGE" => Ok(V3GeneralPurposeOfUse::COVERAGE(None)),
            "ETREAT" => Ok(V3GeneralPurposeOfUse::ETREAT(None)),
            "HMARKT" => Ok(V3GeneralPurposeOfUse::HMARKT(None)),
            "HOPERAT" => Ok(V3GeneralPurposeOfUse::HOPERAT(None)),
            "HPAYMT" => Ok(V3GeneralPurposeOfUse::HPAYMT(None)),
            "HRESCH" => Ok(V3GeneralPurposeOfUse::HRESCH(None)),
            "PATRQT" => Ok(V3GeneralPurposeOfUse::PATRQT(None)),
            "PUBHLTH" => Ok(V3GeneralPurposeOfUse::PUBHLTH(None)),
            "TREAT" => Ok(V3GeneralPurposeOfUse::TREAT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3GeneralPurposeOfUse {
    fn into(self) -> Option<String> {
        match self {
            V3GeneralPurposeOfUse::COVERAGE(_) => Some("COVERAGE".to_string()),
            V3GeneralPurposeOfUse::ETREAT(_) => Some("ETREAT".to_string()),
            V3GeneralPurposeOfUse::HMARKT(_) => Some("HMARKT".to_string()),
            V3GeneralPurposeOfUse::HOPERAT(_) => Some("HOPERAT".to_string()),
            V3GeneralPurposeOfUse::HPAYMT(_) => Some("HPAYMT".to_string()),
            V3GeneralPurposeOfUse::HRESCH(_) => Some("HRESCH".to_string()),
            V3GeneralPurposeOfUse::PATRQT(_) => Some("PATRQT".to_string()),
            V3GeneralPurposeOfUse::PUBHLTH(_) => Some("PUBHLTH".to_string()),
            V3GeneralPurposeOfUse::TREAT(_) => Some("TREAT".to_string()),
            V3GeneralPurposeOfUse::Null(_) => None,
        }
    }
}
impl MetaValue for V3GeneralPurposeOfUse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3GeneralPurposeOfUse::COVERAGE(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::ETREAT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::HMARKT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::HOPERAT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::HPAYMT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::HRESCH(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::PATRQT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::PUBHLTH(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::TREAT(Some(e)) => e.get_field(field),
                V3GeneralPurposeOfUse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3GeneralPurposeOfUse::COVERAGE(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::ETREAT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::HMARKT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::HOPERAT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::HPAYMT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::HRESCH(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::PATRQT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::PUBHLTH(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::TREAT(Some(e)) => e.get_field_mut(field),
                V3GeneralPurposeOfUse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3HL7ContextConductionStyle {
    #[doc = "conduction-indicator-based"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "inferred"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "vocabulary-based"]
    #[code = "V"]
    V(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3HL7ContextConductionStyle {
    fn default() -> Self {
        V3HL7ContextConductionStyle::Null(None)
    }
}
impl TryFrom<String> for V3HL7ContextConductionStyle {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C" => Ok(V3HL7ContextConductionStyle::C(None)),
            "I" => Ok(V3HL7ContextConductionStyle::I(None)),
            "V" => Ok(V3HL7ContextConductionStyle::V(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3HL7ContextConductionStyle {
    fn into(self) -> Option<String> {
        match self {
            V3HL7ContextConductionStyle::C(_) => Some("C".to_string()),
            V3HL7ContextConductionStyle::I(_) => Some("I".to_string()),
            V3HL7ContextConductionStyle::V(_) => Some("V".to_string()),
            V3HL7ContextConductionStyle::Null(_) => None,
        }
    }
}
impl MetaValue for V3HL7ContextConductionStyle {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3HL7ContextConductionStyle::C(Some(e)) => e.get_field(field),
                V3HL7ContextConductionStyle::I(Some(e)) => e.get_field(field),
                V3HL7ContextConductionStyle::V(Some(e)) => e.get_field(field),
                V3HL7ContextConductionStyle::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3HL7ContextConductionStyle::C(Some(e)) => e.get_field_mut(field),
                V3HL7ContextConductionStyle::I(Some(e)) => e.get_field_mut(field),
                V3HL7ContextConductionStyle::V(Some(e)) => e.get_field_mut(field),
                V3HL7ContextConductionStyle::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3HL7StandardVersionCode {
    #[doc = "Ballot 2008 January"]
    #[code = "Ballot2008Jan"]
    Ballot2008Jan(Option<Element>),
    #[doc = "Ballot 2008 May"]
    #[code = "Ballot2008May"]
    Ballot2008May(Option<Element>),
    #[doc = "Ballot 2008 September"]
    #[code = "Ballot2008Sep"]
    Ballot2008Sep(Option<Element>),
    #[doc = "Ballot 2009 January"]
    #[code = "Ballot2009Jan"]
    Ballot2009Jan(Option<Element>),
    #[doc = "Ballot 2009 May"]
    #[code = "Ballot2009May"]
    Ballot2009May(Option<Element>),
    #[doc = "Ballot 2009 September"]
    #[code = "Ballot2009Sep"]
    Ballot2009Sep(Option<Element>),
    #[doc = "Ballot 2010 Jan"]
    #[code = "Ballot2010Jan"]
    Ballot2010Jan(Option<Element>),
    #[doc = "Ballot 2010 May"]
    #[code = "Ballot2010May"]
    Ballot2010May(Option<Element>),
    #[doc = "Ballot 2010 Sep"]
    #[code = "Ballot2010Sep"]
    Ballot2010Sep(Option<Element>),
    #[doc = "Ballot 2011 Jan"]
    #[code = "Ballot2011Jan"]
    Ballot2011Jan(Option<Element>),
    #[doc = "Ballot 2011 May"]
    #[code = "Ballot2011May"]
    Ballot2011May(Option<Element>),
    #[doc = "Ballot 2011 Sep"]
    #[code = "Ballot2011Sep"]
    Ballot2011Sep(Option<Element>),
    #[doc = "Ballot 2012 Jan"]
    #[code = "Ballot2012Jan"]
    Ballot2012Jan(Option<Element>),
    #[doc = "Ballot 2012 May"]
    #[code = "Ballot2012May"]
    Ballot2012May(Option<Element>),
    #[doc = "Ballot 2012 Sep"]
    #[code = "Ballot2012Sep"]
    Ballot2012Sep(Option<Element>),
    #[doc = "HL7 Version V3-2003-12"]
    #[code = "V3-2003-12"]
    V3200312(Option<Element>),
    #[doc = "2005 Normative Edition"]
    #[code = "V3-2005N"]
    V32005N(Option<Element>),
    #[doc = "2006 Normative Edition"]
    #[code = "V3-2006N"]
    V32006N(Option<Element>),
    #[doc = "2007 Normative Edition"]
    #[code = "V3-2007N"]
    V32007N(Option<Element>),
    #[doc = "2008 Normative Edition"]
    #[code = "V3-2008N"]
    V32008N(Option<Element>),
    #[doc = "2009 Normative Edition"]
    #[code = "V3-2009N"]
    V32009N(Option<Element>),
    #[doc = "2010 Normative Edition"]
    #[code = "V3-2010N"]
    V32010N(Option<Element>),
    #[doc = "2011 Normative Edition"]
    #[code = "V3-2011N"]
    V32011N(Option<Element>),
    #[doc = "2012 Normative Edition"]
    #[code = "V3-2012N"]
    V32012N(Option<Element>),
    #[doc = "Version3 Pre-release #1"]
    #[code = "V3PR1"]
    V3PR1(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3HL7StandardVersionCode {
    fn default() -> Self {
        V3HL7StandardVersionCode::Null(None)
    }
}
impl TryFrom<String> for V3HL7StandardVersionCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Ballot2008Jan" => Ok(V3HL7StandardVersionCode::Ballot2008Jan(None)),
            "Ballot2008May" => Ok(V3HL7StandardVersionCode::Ballot2008May(None)),
            "Ballot2008Sep" => Ok(V3HL7StandardVersionCode::Ballot2008Sep(None)),
            "Ballot2009Jan" => Ok(V3HL7StandardVersionCode::Ballot2009Jan(None)),
            "Ballot2009May" => Ok(V3HL7StandardVersionCode::Ballot2009May(None)),
            "Ballot2009Sep" => Ok(V3HL7StandardVersionCode::Ballot2009Sep(None)),
            "Ballot2010Jan" => Ok(V3HL7StandardVersionCode::Ballot2010Jan(None)),
            "Ballot2010May" => Ok(V3HL7StandardVersionCode::Ballot2010May(None)),
            "Ballot2010Sep" => Ok(V3HL7StandardVersionCode::Ballot2010Sep(None)),
            "Ballot2011Jan" => Ok(V3HL7StandardVersionCode::Ballot2011Jan(None)),
            "Ballot2011May" => Ok(V3HL7StandardVersionCode::Ballot2011May(None)),
            "Ballot2011Sep" => Ok(V3HL7StandardVersionCode::Ballot2011Sep(None)),
            "Ballot2012Jan" => Ok(V3HL7StandardVersionCode::Ballot2012Jan(None)),
            "Ballot2012May" => Ok(V3HL7StandardVersionCode::Ballot2012May(None)),
            "Ballot2012Sep" => Ok(V3HL7StandardVersionCode::Ballot2012Sep(None)),
            "V3-2003-12" => Ok(V3HL7StandardVersionCode::V3200312(None)),
            "V3-2005N" => Ok(V3HL7StandardVersionCode::V32005N(None)),
            "V3-2006N" => Ok(V3HL7StandardVersionCode::V32006N(None)),
            "V3-2007N" => Ok(V3HL7StandardVersionCode::V32007N(None)),
            "V3-2008N" => Ok(V3HL7StandardVersionCode::V32008N(None)),
            "V3-2009N" => Ok(V3HL7StandardVersionCode::V32009N(None)),
            "V3-2010N" => Ok(V3HL7StandardVersionCode::V32010N(None)),
            "V3-2011N" => Ok(V3HL7StandardVersionCode::V32011N(None)),
            "V3-2012N" => Ok(V3HL7StandardVersionCode::V32012N(None)),
            "V3PR1" => Ok(V3HL7StandardVersionCode::V3PR1(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3HL7StandardVersionCode {
    fn into(self) -> Option<String> {
        match self {
            V3HL7StandardVersionCode::Ballot2008Jan(_) => Some("Ballot2008Jan".to_string()),
            V3HL7StandardVersionCode::Ballot2008May(_) => Some("Ballot2008May".to_string()),
            V3HL7StandardVersionCode::Ballot2008Sep(_) => Some("Ballot2008Sep".to_string()),
            V3HL7StandardVersionCode::Ballot2009Jan(_) => Some("Ballot2009Jan".to_string()),
            V3HL7StandardVersionCode::Ballot2009May(_) => Some("Ballot2009May".to_string()),
            V3HL7StandardVersionCode::Ballot2009Sep(_) => Some("Ballot2009Sep".to_string()),
            V3HL7StandardVersionCode::Ballot2010Jan(_) => Some("Ballot2010Jan".to_string()),
            V3HL7StandardVersionCode::Ballot2010May(_) => Some("Ballot2010May".to_string()),
            V3HL7StandardVersionCode::Ballot2010Sep(_) => Some("Ballot2010Sep".to_string()),
            V3HL7StandardVersionCode::Ballot2011Jan(_) => Some("Ballot2011Jan".to_string()),
            V3HL7StandardVersionCode::Ballot2011May(_) => Some("Ballot2011May".to_string()),
            V3HL7StandardVersionCode::Ballot2011Sep(_) => Some("Ballot2011Sep".to_string()),
            V3HL7StandardVersionCode::Ballot2012Jan(_) => Some("Ballot2012Jan".to_string()),
            V3HL7StandardVersionCode::Ballot2012May(_) => Some("Ballot2012May".to_string()),
            V3HL7StandardVersionCode::Ballot2012Sep(_) => Some("Ballot2012Sep".to_string()),
            V3HL7StandardVersionCode::V3200312(_) => Some("V3-2003-12".to_string()),
            V3HL7StandardVersionCode::V32005N(_) => Some("V3-2005N".to_string()),
            V3HL7StandardVersionCode::V32006N(_) => Some("V3-2006N".to_string()),
            V3HL7StandardVersionCode::V32007N(_) => Some("V3-2007N".to_string()),
            V3HL7StandardVersionCode::V32008N(_) => Some("V3-2008N".to_string()),
            V3HL7StandardVersionCode::V32009N(_) => Some("V3-2009N".to_string()),
            V3HL7StandardVersionCode::V32010N(_) => Some("V3-2010N".to_string()),
            V3HL7StandardVersionCode::V32011N(_) => Some("V3-2011N".to_string()),
            V3HL7StandardVersionCode::V32012N(_) => Some("V3-2012N".to_string()),
            V3HL7StandardVersionCode::V3PR1(_) => Some("V3PR1".to_string()),
            V3HL7StandardVersionCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3HL7StandardVersionCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3HL7StandardVersionCode::Ballot2008Jan(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2008May(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2008Sep(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2009Jan(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2009May(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2009Sep(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2010Jan(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2010May(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2010Sep(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2011Jan(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2011May(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2011Sep(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2012Jan(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2012May(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Ballot2012Sep(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V3200312(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32005N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32006N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32007N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32008N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32009N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32010N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32011N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V32012N(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::V3PR1(Some(e)) => e.get_field(field),
                V3HL7StandardVersionCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3HL7StandardVersionCode::Ballot2008Jan(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2008May(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2008Sep(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2009Jan(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2009May(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2009Sep(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2010Jan(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2010May(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2010Sep(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2011Jan(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2011May(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2011Sep(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2012Jan(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2012May(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Ballot2012Sep(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V3200312(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32005N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32006N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32007N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32008N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32009N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32010N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32011N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V32012N(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::V3PR1(Some(e)) => e.get_field_mut(field),
                V3HL7StandardVersionCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3HL7UpdateMode {
    #[doc = "Add"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Add or Replace"]
    #[code = "AR"]
    AR(Option<Element>),
    #[doc = "Add or Update"]
    #[code = "AU"]
    AU(Option<Element>),
    #[doc = "Remove"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Set Add"]
    #[code = "ESA"]
    ESA(Option<Element>),
    #[doc = "Set Add or Change"]
    #[code = "ESAC"]
    ESAC(Option<Element>),
    #[doc = "Set Change"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "Set Delete"]
    #[code = "ESD"]
    ESD(Option<Element>),
    #[doc = "Ignore"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Key"]
    #[code = "K"]
    K(Option<Element>),
    #[doc = "No Change"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "Replace"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Reference"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Unknown"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "Verify"]
    #[code = "V"]
    V(Option<Element>),
    #[doc = "SetUpdateMode"]
    #[code = "_SetUpdateMode"]
    _SetUpdateMode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3HL7UpdateMode {
    fn default() -> Self {
        V3HL7UpdateMode::Null(None)
    }
}
impl TryFrom<String> for V3HL7UpdateMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3HL7UpdateMode::A(None)),
            "AR" => Ok(V3HL7UpdateMode::AR(None)),
            "AU" => Ok(V3HL7UpdateMode::AU(None)),
            "D" => Ok(V3HL7UpdateMode::D(None)),
            "ESA" => Ok(V3HL7UpdateMode::ESA(None)),
            "ESAC" => Ok(V3HL7UpdateMode::ESAC(None)),
            "ESC" => Ok(V3HL7UpdateMode::ESC(None)),
            "ESD" => Ok(V3HL7UpdateMode::ESD(None)),
            "I" => Ok(V3HL7UpdateMode::I(None)),
            "K" => Ok(V3HL7UpdateMode::K(None)),
            "N" => Ok(V3HL7UpdateMode::N(None)),
            "R" => Ok(V3HL7UpdateMode::R(None)),
            "REF" => Ok(V3HL7UpdateMode::REF(None)),
            "U" => Ok(V3HL7UpdateMode::U(None)),
            "V" => Ok(V3HL7UpdateMode::V(None)),
            "_SetUpdateMode" => Ok(V3HL7UpdateMode::_SetUpdateMode(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3HL7UpdateMode {
    fn into(self) -> Option<String> {
        match self {
            V3HL7UpdateMode::A(_) => Some("A".to_string()),
            V3HL7UpdateMode::AR(_) => Some("AR".to_string()),
            V3HL7UpdateMode::AU(_) => Some("AU".to_string()),
            V3HL7UpdateMode::D(_) => Some("D".to_string()),
            V3HL7UpdateMode::ESA(_) => Some("ESA".to_string()),
            V3HL7UpdateMode::ESAC(_) => Some("ESAC".to_string()),
            V3HL7UpdateMode::ESC(_) => Some("ESC".to_string()),
            V3HL7UpdateMode::ESD(_) => Some("ESD".to_string()),
            V3HL7UpdateMode::I(_) => Some("I".to_string()),
            V3HL7UpdateMode::K(_) => Some("K".to_string()),
            V3HL7UpdateMode::N(_) => Some("N".to_string()),
            V3HL7UpdateMode::R(_) => Some("R".to_string()),
            V3HL7UpdateMode::REF(_) => Some("REF".to_string()),
            V3HL7UpdateMode::U(_) => Some("U".to_string()),
            V3HL7UpdateMode::V(_) => Some("V".to_string()),
            V3HL7UpdateMode::_SetUpdateMode(_) => Some("_SetUpdateMode".to_string()),
            V3HL7UpdateMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3HL7UpdateMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3HL7UpdateMode::A(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::AR(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::AU(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::D(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::ESA(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::ESAC(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::ESC(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::ESD(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::I(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::K(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::N(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::R(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::REF(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::U(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::V(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::_SetUpdateMode(Some(e)) => e.get_field(field),
                V3HL7UpdateMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3HL7UpdateMode::A(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::AR(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::AU(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::D(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::ESA(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::ESAC(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::ESC(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::ESD(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::I(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::K(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::N(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::R(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::REF(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::U(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::V(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::_SetUpdateMode(Some(e)) => e.get_field_mut(field),
                V3HL7UpdateMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3HtmlLinkType {
    #[doc = "alternate"]
    #[code = "alternate"]
    Alternate(Option<Element>),
    #[doc = "appendix"]
    #[code = "appendix"]
    Appendix(Option<Element>),
    #[doc = "bookmark"]
    #[code = "bookmark"]
    Bookmark(Option<Element>),
    #[doc = "chapter"]
    #[code = "chapter"]
    Chapter(Option<Element>),
    #[doc = "contents"]
    #[code = "contents"]
    Contents(Option<Element>),
    #[doc = "copyright"]
    #[code = "copyright"]
    Copyright(Option<Element>),
    #[doc = "glossary"]
    #[code = "glossary"]
    Glossary(Option<Element>),
    #[doc = "help"]
    #[code = "help"]
    Help(Option<Element>),
    #[doc = "index"]
    #[code = "index"]
    Index(Option<Element>),
    #[doc = "next"]
    #[code = "next"]
    Next(Option<Element>),
    #[doc = "prev"]
    #[code = "prev"]
    Prev(Option<Element>),
    #[doc = "section"]
    #[code = "section"]
    Section(Option<Element>),
    #[doc = "start"]
    #[code = "start"]
    Start(Option<Element>),
    #[doc = "stylesheet"]
    #[code = "stylesheet"]
    Stylesheet(Option<Element>),
    #[doc = "subsection"]
    #[code = "subsection"]
    Subsection(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3HtmlLinkType {
    fn default() -> Self {
        V3HtmlLinkType::Null(None)
    }
}
impl TryFrom<String> for V3HtmlLinkType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "alternate" => Ok(V3HtmlLinkType::Alternate(None)),
            "appendix" => Ok(V3HtmlLinkType::Appendix(None)),
            "bookmark" => Ok(V3HtmlLinkType::Bookmark(None)),
            "chapter" => Ok(V3HtmlLinkType::Chapter(None)),
            "contents" => Ok(V3HtmlLinkType::Contents(None)),
            "copyright" => Ok(V3HtmlLinkType::Copyright(None)),
            "glossary" => Ok(V3HtmlLinkType::Glossary(None)),
            "help" => Ok(V3HtmlLinkType::Help(None)),
            "index" => Ok(V3HtmlLinkType::Index(None)),
            "next" => Ok(V3HtmlLinkType::Next(None)),
            "prev" => Ok(V3HtmlLinkType::Prev(None)),
            "section" => Ok(V3HtmlLinkType::Section(None)),
            "start" => Ok(V3HtmlLinkType::Start(None)),
            "stylesheet" => Ok(V3HtmlLinkType::Stylesheet(None)),
            "subsection" => Ok(V3HtmlLinkType::Subsection(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3HtmlLinkType {
    fn into(self) -> Option<String> {
        match self {
            V3HtmlLinkType::Alternate(_) => Some("alternate".to_string()),
            V3HtmlLinkType::Appendix(_) => Some("appendix".to_string()),
            V3HtmlLinkType::Bookmark(_) => Some("bookmark".to_string()),
            V3HtmlLinkType::Chapter(_) => Some("chapter".to_string()),
            V3HtmlLinkType::Contents(_) => Some("contents".to_string()),
            V3HtmlLinkType::Copyright(_) => Some("copyright".to_string()),
            V3HtmlLinkType::Glossary(_) => Some("glossary".to_string()),
            V3HtmlLinkType::Help(_) => Some("help".to_string()),
            V3HtmlLinkType::Index(_) => Some("index".to_string()),
            V3HtmlLinkType::Next(_) => Some("next".to_string()),
            V3HtmlLinkType::Prev(_) => Some("prev".to_string()),
            V3HtmlLinkType::Section(_) => Some("section".to_string()),
            V3HtmlLinkType::Start(_) => Some("start".to_string()),
            V3HtmlLinkType::Stylesheet(_) => Some("stylesheet".to_string()),
            V3HtmlLinkType::Subsection(_) => Some("subsection".to_string()),
            V3HtmlLinkType::Null(_) => None,
        }
    }
}
impl MetaValue for V3HtmlLinkType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3HtmlLinkType::Alternate(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Appendix(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Bookmark(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Chapter(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Contents(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Copyright(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Glossary(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Help(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Index(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Next(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Prev(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Section(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Start(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Stylesheet(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Subsection(Some(e)) => e.get_field(field),
                V3HtmlLinkType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3HtmlLinkType::Alternate(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Appendix(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Bookmark(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Chapter(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Contents(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Copyright(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Glossary(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Help(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Index(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Next(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Prev(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Section(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Start(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Stylesheet(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Subsection(Some(e)) => e.get_field_mut(field),
                V3HtmlLinkType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3IdentifierReliability {
    #[doc = "Issued by System"]
    #[code = "ISS"]
    ISS(Option<Element>),
    #[doc = "Unverified by system"]
    #[code = "UNV"]
    UNV(Option<Element>),
    #[doc = "Verified by system"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3IdentifierReliability {
    fn default() -> Self {
        V3IdentifierReliability::Null(None)
    }
}
impl TryFrom<String> for V3IdentifierReliability {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ISS" => Ok(V3IdentifierReliability::ISS(None)),
            "UNV" => Ok(V3IdentifierReliability::UNV(None)),
            "VRF" => Ok(V3IdentifierReliability::VRF(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3IdentifierReliability {
    fn into(self) -> Option<String> {
        match self {
            V3IdentifierReliability::ISS(_) => Some("ISS".to_string()),
            V3IdentifierReliability::UNV(_) => Some("UNV".to_string()),
            V3IdentifierReliability::VRF(_) => Some("VRF".to_string()),
            V3IdentifierReliability::Null(_) => None,
        }
    }
}
impl MetaValue for V3IdentifierReliability {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3IdentifierReliability::ISS(Some(e)) => e.get_field(field),
                V3IdentifierReliability::UNV(Some(e)) => e.get_field(field),
                V3IdentifierReliability::VRF(Some(e)) => e.get_field(field),
                V3IdentifierReliability::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3IdentifierReliability::ISS(Some(e)) => e.get_field_mut(field),
                V3IdentifierReliability::UNV(Some(e)) => e.get_field_mut(field),
                V3IdentifierReliability::VRF(Some(e)) => e.get_field_mut(field),
                V3IdentifierReliability::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3IdentifierScope {
    #[doc = "Business Identifier"]
    #[code = "BUSN"]
    BUSN(Option<Element>),
    #[doc = "Object Identifier"]
    #[code = "OBJ"]
    OBJ(Option<Element>),
    #[doc = "Version Identifier"]
    #[code = "VER"]
    VER(Option<Element>),
    #[doc = "View Specific Identifier"]
    #[code = "VW"]
    VW(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3IdentifierScope {
    fn default() -> Self {
        V3IdentifierScope::Null(None)
    }
}
impl TryFrom<String> for V3IdentifierScope {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BUSN" => Ok(V3IdentifierScope::BUSN(None)),
            "OBJ" => Ok(V3IdentifierScope::OBJ(None)),
            "VER" => Ok(V3IdentifierScope::VER(None)),
            "VW" => Ok(V3IdentifierScope::VW(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3IdentifierScope {
    fn into(self) -> Option<String> {
        match self {
            V3IdentifierScope::BUSN(_) => Some("BUSN".to_string()),
            V3IdentifierScope::OBJ(_) => Some("OBJ".to_string()),
            V3IdentifierScope::VER(_) => Some("VER".to_string()),
            V3IdentifierScope::VW(_) => Some("VW".to_string()),
            V3IdentifierScope::Null(_) => None,
        }
    }
}
impl MetaValue for V3IdentifierScope {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3IdentifierScope::BUSN(Some(e)) => e.get_field(field),
                V3IdentifierScope::OBJ(Some(e)) => e.get_field(field),
                V3IdentifierScope::VER(Some(e)) => e.get_field(field),
                V3IdentifierScope::VW(Some(e)) => e.get_field(field),
                V3IdentifierScope::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3IdentifierScope::BUSN(Some(e)) => e.get_field_mut(field),
                V3IdentifierScope::OBJ(Some(e)) => e.get_field_mut(field),
                V3IdentifierScope::VER(Some(e)) => e.get_field_mut(field),
                V3IdentifierScope::VW(Some(e)) => e.get_field_mut(field),
                V3IdentifierScope::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3IntegrityCheckAlgorithm {
    #[doc = "secure hash algorithm - 1"]
    #[code = "SHA-1"]
    SHA1(Option<Element>),
    #[doc = "secure hash algorithm - 256"]
    #[code = "SHA-256"]
    SHA256(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3IntegrityCheckAlgorithm {
    fn default() -> Self {
        V3IntegrityCheckAlgorithm::Null(None)
    }
}
impl TryFrom<String> for V3IntegrityCheckAlgorithm {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "SHA-1" => Ok(V3IntegrityCheckAlgorithm::SHA1(None)),
            "SHA-256" => Ok(V3IntegrityCheckAlgorithm::SHA256(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3IntegrityCheckAlgorithm {
    fn into(self) -> Option<String> {
        match self {
            V3IntegrityCheckAlgorithm::SHA1(_) => Some("SHA-1".to_string()),
            V3IntegrityCheckAlgorithm::SHA256(_) => Some("SHA-256".to_string()),
            V3IntegrityCheckAlgorithm::Null(_) => None,
        }
    }
}
impl MetaValue for V3IntegrityCheckAlgorithm {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3IntegrityCheckAlgorithm::SHA1(Some(e)) => e.get_field(field),
                V3IntegrityCheckAlgorithm::SHA256(Some(e)) => e.get_field(field),
                V3IntegrityCheckAlgorithm::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3IntegrityCheckAlgorithm::SHA1(Some(e)) => e.get_field_mut(field),
                V3IntegrityCheckAlgorithm::SHA256(Some(e)) => e.get_field_mut(field),
                V3IntegrityCheckAlgorithm::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3LanguageAbilityMode {
    #[doc = "Expressed signed"]
    #[code = "ESGN"]
    ESGN(Option<Element>),
    #[doc = "Expressed spoken"]
    #[code = "ESP"]
    ESP(Option<Element>),
    #[doc = "Expressed written"]
    #[code = "EWR"]
    EWR(Option<Element>),
    #[doc = "Received signed"]
    #[code = "RSGN"]
    RSGN(Option<Element>),
    #[doc = "Received spoken"]
    #[code = "RSP"]
    RSP(Option<Element>),
    #[doc = "Received written"]
    #[code = "RWR"]
    RWR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3LanguageAbilityMode {
    fn default() -> Self {
        V3LanguageAbilityMode::Null(None)
    }
}
impl TryFrom<String> for V3LanguageAbilityMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ESGN" => Ok(V3LanguageAbilityMode::ESGN(None)),
            "ESP" => Ok(V3LanguageAbilityMode::ESP(None)),
            "EWR" => Ok(V3LanguageAbilityMode::EWR(None)),
            "RSGN" => Ok(V3LanguageAbilityMode::RSGN(None)),
            "RSP" => Ok(V3LanguageAbilityMode::RSP(None)),
            "RWR" => Ok(V3LanguageAbilityMode::RWR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3LanguageAbilityMode {
    fn into(self) -> Option<String> {
        match self {
            V3LanguageAbilityMode::ESGN(_) => Some("ESGN".to_string()),
            V3LanguageAbilityMode::ESP(_) => Some("ESP".to_string()),
            V3LanguageAbilityMode::EWR(_) => Some("EWR".to_string()),
            V3LanguageAbilityMode::RSGN(_) => Some("RSGN".to_string()),
            V3LanguageAbilityMode::RSP(_) => Some("RSP".to_string()),
            V3LanguageAbilityMode::RWR(_) => Some("RWR".to_string()),
            V3LanguageAbilityMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3LanguageAbilityMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3LanguageAbilityMode::ESGN(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::ESP(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::EWR(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::RSGN(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::RSP(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::RWR(Some(e)) => e.get_field(field),
                V3LanguageAbilityMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3LanguageAbilityMode::ESGN(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::ESP(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::EWR(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::RSGN(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::RSP(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::RWR(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3LanguageAbilityProficiency {
    #[doc = "Excellent"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "Fair"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "Good"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "Poor"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3LanguageAbilityProficiency {
    fn default() -> Self {
        V3LanguageAbilityProficiency::Null(None)
    }
}
impl TryFrom<String> for V3LanguageAbilityProficiency {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "E" => Ok(V3LanguageAbilityProficiency::E(None)),
            "F" => Ok(V3LanguageAbilityProficiency::F(None)),
            "G" => Ok(V3LanguageAbilityProficiency::G(None)),
            "P" => Ok(V3LanguageAbilityProficiency::P(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3LanguageAbilityProficiency {
    fn into(self) -> Option<String> {
        match self {
            V3LanguageAbilityProficiency::E(_) => Some("E".to_string()),
            V3LanguageAbilityProficiency::F(_) => Some("F".to_string()),
            V3LanguageAbilityProficiency::G(_) => Some("G".to_string()),
            V3LanguageAbilityProficiency::P(_) => Some("P".to_string()),
            V3LanguageAbilityProficiency::Null(_) => None,
        }
    }
}
impl MetaValue for V3LanguageAbilityProficiency {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3LanguageAbilityProficiency::E(Some(e)) => e.get_field(field),
                V3LanguageAbilityProficiency::F(Some(e)) => e.get_field(field),
                V3LanguageAbilityProficiency::G(Some(e)) => e.get_field(field),
                V3LanguageAbilityProficiency::P(Some(e)) => e.get_field(field),
                V3LanguageAbilityProficiency::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3LanguageAbilityProficiency::E(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityProficiency::F(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityProficiency::G(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityProficiency::P(Some(e)) => e.get_field_mut(field),
                V3LanguageAbilityProficiency::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3LivingArrangement {
    #[doc = "community shelter"]
    #[code = "CS"]
    CS(Option<Element>),
    #[doc = "Group Home"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "Independent Household"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "homeless"]
    #[code = "HL"]
    HL(Option<Element>),
    #[doc = "Institution"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Nomadic"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "Nursing Home"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "private residence"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "Retirement Community"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "supported living"]
    #[code = "SL"]
    SL(Option<Element>),
    #[doc = "Transient"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "Extended care facility"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3LivingArrangement {
    fn default() -> Self {
        V3LivingArrangement::Null(None)
    }
}
impl TryFrom<String> for V3LivingArrangement {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CS" => Ok(V3LivingArrangement::CS(None)),
            "G" => Ok(V3LivingArrangement::G(None)),
            "H" => Ok(V3LivingArrangement::H(None)),
            "HL" => Ok(V3LivingArrangement::HL(None)),
            "I" => Ok(V3LivingArrangement::I(None)),
            "M" => Ok(V3LivingArrangement::M(None)),
            "N" => Ok(V3LivingArrangement::N(None)),
            "PR" => Ok(V3LivingArrangement::PR(None)),
            "R" => Ok(V3LivingArrangement::R(None)),
            "SL" => Ok(V3LivingArrangement::SL(None)),
            "T" => Ok(V3LivingArrangement::T(None)),
            "X" => Ok(V3LivingArrangement::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3LivingArrangement {
    fn into(self) -> Option<String> {
        match self {
            V3LivingArrangement::CS(_) => Some("CS".to_string()),
            V3LivingArrangement::G(_) => Some("G".to_string()),
            V3LivingArrangement::H(_) => Some("H".to_string()),
            V3LivingArrangement::HL(_) => Some("HL".to_string()),
            V3LivingArrangement::I(_) => Some("I".to_string()),
            V3LivingArrangement::M(_) => Some("M".to_string()),
            V3LivingArrangement::N(_) => Some("N".to_string()),
            V3LivingArrangement::PR(_) => Some("PR".to_string()),
            V3LivingArrangement::R(_) => Some("R".to_string()),
            V3LivingArrangement::SL(_) => Some("SL".to_string()),
            V3LivingArrangement::T(_) => Some("T".to_string()),
            V3LivingArrangement::X(_) => Some("X".to_string()),
            V3LivingArrangement::Null(_) => None,
        }
    }
}
impl MetaValue for V3LivingArrangement {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3LivingArrangement::CS(Some(e)) => e.get_field(field),
                V3LivingArrangement::G(Some(e)) => e.get_field(field),
                V3LivingArrangement::H(Some(e)) => e.get_field(field),
                V3LivingArrangement::HL(Some(e)) => e.get_field(field),
                V3LivingArrangement::I(Some(e)) => e.get_field(field),
                V3LivingArrangement::M(Some(e)) => e.get_field(field),
                V3LivingArrangement::N(Some(e)) => e.get_field(field),
                V3LivingArrangement::PR(Some(e)) => e.get_field(field),
                V3LivingArrangement::R(Some(e)) => e.get_field(field),
                V3LivingArrangement::SL(Some(e)) => e.get_field(field),
                V3LivingArrangement::T(Some(e)) => e.get_field(field),
                V3LivingArrangement::X(Some(e)) => e.get_field(field),
                V3LivingArrangement::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3LivingArrangement::CS(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::G(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::H(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::HL(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::I(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::M(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::N(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::PR(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::R(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::SL(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::T(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::X(Some(e)) => e.get_field_mut(field),
                V3LivingArrangement::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3LocalMarkupIgnore {
    #[doc = "all"]
    #[code = "all"]
    All(Option<Element>),
    #[doc = "markup"]
    #[code = "markup"]
    Markup(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3LocalMarkupIgnore {
    fn default() -> Self {
        V3LocalMarkupIgnore::Null(None)
    }
}
impl TryFrom<String> for V3LocalMarkupIgnore {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all" => Ok(V3LocalMarkupIgnore::All(None)),
            "markup" => Ok(V3LocalMarkupIgnore::Markup(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3LocalMarkupIgnore {
    fn into(self) -> Option<String> {
        match self {
            V3LocalMarkupIgnore::All(_) => Some("all".to_string()),
            V3LocalMarkupIgnore::Markup(_) => Some("markup".to_string()),
            V3LocalMarkupIgnore::Null(_) => None,
        }
    }
}
impl MetaValue for V3LocalMarkupIgnore {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3LocalMarkupIgnore::All(Some(e)) => e.get_field(field),
                V3LocalMarkupIgnore::Markup(Some(e)) => e.get_field(field),
                V3LocalMarkupIgnore::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3LocalMarkupIgnore::All(Some(e)) => e.get_field_mut(field),
                V3LocalMarkupIgnore::Markup(Some(e)) => e.get_field_mut(field),
                V3LocalMarkupIgnore::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3LocalRemoteControlState {
    #[doc = "Local"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Remote"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3LocalRemoteControlState {
    fn default() -> Self {
        V3LocalRemoteControlState::Null(None)
    }
}
impl TryFrom<String> for V3LocalRemoteControlState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "L" => Ok(V3LocalRemoteControlState::L(None)),
            "R" => Ok(V3LocalRemoteControlState::R(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3LocalRemoteControlState {
    fn into(self) -> Option<String> {
        match self {
            V3LocalRemoteControlState::L(_) => Some("L".to_string()),
            V3LocalRemoteControlState::R(_) => Some("R".to_string()),
            V3LocalRemoteControlState::Null(_) => None,
        }
    }
}
impl MetaValue for V3LocalRemoteControlState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3LocalRemoteControlState::L(Some(e)) => e.get_field(field),
                V3LocalRemoteControlState::R(Some(e)) => e.get_field(field),
                V3LocalRemoteControlState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3LocalRemoteControlState::L(Some(e)) => e.get_field_mut(field),
                V3LocalRemoteControlState::R(Some(e)) => e.get_field_mut(field),
                V3LocalRemoteControlState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ManagedParticipationStatus {
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "completed"]
    #[code = "completed"]
    Completed(Option<Element>),
    #[doc = "normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "nullified"]
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[doc = "pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ManagedParticipationStatus {
    fn default() -> Self {
        V3ManagedParticipationStatus::Null(None)
    }
}
impl TryFrom<String> for V3ManagedParticipationStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(V3ManagedParticipationStatus::Active(None)),
            "cancelled" => Ok(V3ManagedParticipationStatus::Cancelled(None)),
            "completed" => Ok(V3ManagedParticipationStatus::Completed(None)),
            "normal" => Ok(V3ManagedParticipationStatus::Normal(None)),
            "nullified" => Ok(V3ManagedParticipationStatus::Nullified(None)),
            "pending" => Ok(V3ManagedParticipationStatus::Pending(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ManagedParticipationStatus {
    fn into(self) -> Option<String> {
        match self {
            V3ManagedParticipationStatus::Active(_) => Some("active".to_string()),
            V3ManagedParticipationStatus::Cancelled(_) => Some("cancelled".to_string()),
            V3ManagedParticipationStatus::Completed(_) => Some("completed".to_string()),
            V3ManagedParticipationStatus::Normal(_) => Some("normal".to_string()),
            V3ManagedParticipationStatus::Nullified(_) => Some("nullified".to_string()),
            V3ManagedParticipationStatus::Pending(_) => Some("pending".to_string()),
            V3ManagedParticipationStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3ManagedParticipationStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ManagedParticipationStatus::Active(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Cancelled(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Completed(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Normal(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Nullified(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Pending(Some(e)) => e.get_field(field),
                V3ManagedParticipationStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ManagedParticipationStatus::Active(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Completed(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Normal(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Nullified(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Pending(Some(e)) => e.get_field_mut(field),
                V3ManagedParticipationStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3MapRelationship {
    #[doc = "Broader Than"]
    #[code = "BT"]
    BT(Option<Element>),
    #[doc = "Exact"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "Narrower Than"]
    #[code = "NT"]
    NT(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3MapRelationship {
    fn default() -> Self {
        V3MapRelationship::Null(None)
    }
}
impl TryFrom<String> for V3MapRelationship {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BT" => Ok(V3MapRelationship::BT(None)),
            "E" => Ok(V3MapRelationship::E(None)),
            "NT" => Ok(V3MapRelationship::NT(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3MapRelationship {
    fn into(self) -> Option<String> {
        match self {
            V3MapRelationship::BT(_) => Some("BT".to_string()),
            V3MapRelationship::E(_) => Some("E".to_string()),
            V3MapRelationship::NT(_) => Some("NT".to_string()),
            V3MapRelationship::Null(_) => None,
        }
    }
}
impl MetaValue for V3MapRelationship {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3MapRelationship::BT(Some(e)) => e.get_field(field),
                V3MapRelationship::E(Some(e)) => e.get_field(field),
                V3MapRelationship::NT(Some(e)) => e.get_field(field),
                V3MapRelationship::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3MapRelationship::BT(Some(e)) => e.get_field_mut(field),
                V3MapRelationship::E(Some(e)) => e.get_field_mut(field),
                V3MapRelationship::NT(Some(e)) => e.get_field_mut(field),
                V3MapRelationship::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3MaritalStatus {
    #[doc = "Annulled"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Divorced"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Interlocutory"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Legally Separated"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Married"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "Polygamous"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "Never Married"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Domestic partner"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "unmarried"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "Widowed"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3MaritalStatus {
    fn default() -> Self {
        V3MaritalStatus::Null(None)
    }
}
impl TryFrom<String> for V3MaritalStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3MaritalStatus::A(None)),
            "D" => Ok(V3MaritalStatus::D(None)),
            "I" => Ok(V3MaritalStatus::I(None)),
            "L" => Ok(V3MaritalStatus::L(None)),
            "M" => Ok(V3MaritalStatus::M(None)),
            "P" => Ok(V3MaritalStatus::P(None)),
            "S" => Ok(V3MaritalStatus::S(None)),
            "T" => Ok(V3MaritalStatus::T(None)),
            "U" => Ok(V3MaritalStatus::U(None)),
            "W" => Ok(V3MaritalStatus::W(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3MaritalStatus {
    fn into(self) -> Option<String> {
        match self {
            V3MaritalStatus::A(_) => Some("A".to_string()),
            V3MaritalStatus::D(_) => Some("D".to_string()),
            V3MaritalStatus::I(_) => Some("I".to_string()),
            V3MaritalStatus::L(_) => Some("L".to_string()),
            V3MaritalStatus::M(_) => Some("M".to_string()),
            V3MaritalStatus::P(_) => Some("P".to_string()),
            V3MaritalStatus::S(_) => Some("S".to_string()),
            V3MaritalStatus::T(_) => Some("T".to_string()),
            V3MaritalStatus::U(_) => Some("U".to_string()),
            V3MaritalStatus::W(_) => Some("W".to_string()),
            V3MaritalStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3MaritalStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3MaritalStatus::A(Some(e)) => e.get_field(field),
                V3MaritalStatus::D(Some(e)) => e.get_field(field),
                V3MaritalStatus::I(Some(e)) => e.get_field(field),
                V3MaritalStatus::L(Some(e)) => e.get_field(field),
                V3MaritalStatus::M(Some(e)) => e.get_field(field),
                V3MaritalStatus::P(Some(e)) => e.get_field(field),
                V3MaritalStatus::S(Some(e)) => e.get_field(field),
                V3MaritalStatus::T(Some(e)) => e.get_field(field),
                V3MaritalStatus::U(Some(e)) => e.get_field(field),
                V3MaritalStatus::W(Some(e)) => e.get_field(field),
                V3MaritalStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3MaritalStatus::A(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::D(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::I(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::L(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::M(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::P(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::S(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::T(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::U(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::W(Some(e)) => e.get_field_mut(field),
                V3MaritalStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3MessageWaitingPriority {
    #[doc = "High"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "Low"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Medium"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3MessageWaitingPriority {
    fn default() -> Self {
        V3MessageWaitingPriority::Null(None)
    }
}
impl TryFrom<String> for V3MessageWaitingPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "H" => Ok(V3MessageWaitingPriority::H(None)),
            "L" => Ok(V3MessageWaitingPriority::L(None)),
            "M" => Ok(V3MessageWaitingPriority::M(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3MessageWaitingPriority {
    fn into(self) -> Option<String> {
        match self {
            V3MessageWaitingPriority::H(_) => Some("H".to_string()),
            V3MessageWaitingPriority::L(_) => Some("L".to_string()),
            V3MessageWaitingPriority::M(_) => Some("M".to_string()),
            V3MessageWaitingPriority::Null(_) => None,
        }
    }
}
impl MetaValue for V3MessageWaitingPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3MessageWaitingPriority::H(Some(e)) => e.get_field(field),
                V3MessageWaitingPriority::L(Some(e)) => e.get_field(field),
                V3MessageWaitingPriority::M(Some(e)) => e.get_field(field),
                V3MessageWaitingPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3MessageWaitingPriority::H(Some(e)) => e.get_field_mut(field),
                V3MessageWaitingPriority::L(Some(e)) => e.get_field_mut(field),
                V3MessageWaitingPriority::M(Some(e)) => e.get_field_mut(field),
                V3MessageWaitingPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ModifyIndicator {
    #[doc = "Modified subscription"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "New subscription"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ModifyIndicator {
    fn default() -> Self {
        V3ModifyIndicator::Null(None)
    }
}
impl TryFrom<String> for V3ModifyIndicator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "M" => Ok(V3ModifyIndicator::M(None)),
            "N" => Ok(V3ModifyIndicator::N(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ModifyIndicator {
    fn into(self) -> Option<String> {
        match self {
            V3ModifyIndicator::M(_) => Some("M".to_string()),
            V3ModifyIndicator::N(_) => Some("N".to_string()),
            V3ModifyIndicator::Null(_) => None,
        }
    }
}
impl MetaValue for V3ModifyIndicator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ModifyIndicator::M(Some(e)) => e.get_field(field),
                V3ModifyIndicator::N(Some(e)) => e.get_field(field),
                V3ModifyIndicator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ModifyIndicator::M(Some(e)) => e.get_field_mut(field),
                V3ModifyIndicator::N(Some(e)) => e.get_field_mut(field),
                V3ModifyIndicator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3NullFlavor {
    #[doc = "asked but unknown"]
    #[code = "ASKU"]
    ASKU(Option<Element>),
    #[doc = "derived"]
    #[code = "DER"]
    DER(Option<Element>),
    #[doc = "invalid"]
    #[code = "INV"]
    INV(Option<Element>),
    #[doc = "masked"]
    #[code = "MSK"]
    MSK(Option<Element>),
    #[doc = "not applicable"]
    #[code = "NA"]
    NA(Option<Element>),
    #[doc = "not asked"]
    #[code = "NASK"]
    NASK(Option<Element>),
    #[doc = "temporarily unavailable"]
    #[code = "NAV"]
    NAV(Option<Element>),
    #[doc = "Not available"]
    #[code = "NAVU"]
    NAVU(Option<Element>),
    #[doc = "NoInformation"]
    #[code = "NI"]
    NI(Option<Element>),
    #[doc = "negative infinity"]
    #[code = "NINF"]
    NINF(Option<Element>),
    #[doc = "not present"]
    #[code = "NP"]
    NP(Option<Element>),
    #[doc = "other"]
    #[code = "OTH"]
    OTH(Option<Element>),
    #[doc = "positive infinity"]
    #[code = "PINF"]
    PINF(Option<Element>),
    #[doc = "Sufficient Quantity"]
    #[code = "QS"]
    QS(Option<Element>),
    #[doc = "trace"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "un-encoded"]
    #[code = "UNC"]
    UNC(Option<Element>),
    #[doc = "unknown"]
    #[code = "UNK"]
    UNK(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3NullFlavor {
    fn default() -> Self {
        V3NullFlavor::Null(None)
    }
}
impl TryFrom<String> for V3NullFlavor {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ASKU" => Ok(V3NullFlavor::ASKU(None)),
            "DER" => Ok(V3NullFlavor::DER(None)),
            "INV" => Ok(V3NullFlavor::INV(None)),
            "MSK" => Ok(V3NullFlavor::MSK(None)),
            "NA" => Ok(V3NullFlavor::NA(None)),
            "NASK" => Ok(V3NullFlavor::NASK(None)),
            "NAV" => Ok(V3NullFlavor::NAV(None)),
            "NAVU" => Ok(V3NullFlavor::NAVU(None)),
            "NI" => Ok(V3NullFlavor::NI(None)),
            "NINF" => Ok(V3NullFlavor::NINF(None)),
            "NP" => Ok(V3NullFlavor::NP(None)),
            "OTH" => Ok(V3NullFlavor::OTH(None)),
            "PINF" => Ok(V3NullFlavor::PINF(None)),
            "QS" => Ok(V3NullFlavor::QS(None)),
            "TRC" => Ok(V3NullFlavor::TRC(None)),
            "UNC" => Ok(V3NullFlavor::UNC(None)),
            "UNK" => Ok(V3NullFlavor::UNK(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3NullFlavor {
    fn into(self) -> Option<String> {
        match self {
            V3NullFlavor::ASKU(_) => Some("ASKU".to_string()),
            V3NullFlavor::DER(_) => Some("DER".to_string()),
            V3NullFlavor::INV(_) => Some("INV".to_string()),
            V3NullFlavor::MSK(_) => Some("MSK".to_string()),
            V3NullFlavor::NA(_) => Some("NA".to_string()),
            V3NullFlavor::NASK(_) => Some("NASK".to_string()),
            V3NullFlavor::NAV(_) => Some("NAV".to_string()),
            V3NullFlavor::NAVU(_) => Some("NAVU".to_string()),
            V3NullFlavor::NI(_) => Some("NI".to_string()),
            V3NullFlavor::NINF(_) => Some("NINF".to_string()),
            V3NullFlavor::NP(_) => Some("NP".to_string()),
            V3NullFlavor::OTH(_) => Some("OTH".to_string()),
            V3NullFlavor::PINF(_) => Some("PINF".to_string()),
            V3NullFlavor::QS(_) => Some("QS".to_string()),
            V3NullFlavor::TRC(_) => Some("TRC".to_string()),
            V3NullFlavor::UNC(_) => Some("UNC".to_string()),
            V3NullFlavor::UNK(_) => Some("UNK".to_string()),
            V3NullFlavor::Null(_) => None,
        }
    }
}
impl MetaValue for V3NullFlavor {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3NullFlavor::ASKU(Some(e)) => e.get_field(field),
                V3NullFlavor::DER(Some(e)) => e.get_field(field),
                V3NullFlavor::INV(Some(e)) => e.get_field(field),
                V3NullFlavor::MSK(Some(e)) => e.get_field(field),
                V3NullFlavor::NA(Some(e)) => e.get_field(field),
                V3NullFlavor::NASK(Some(e)) => e.get_field(field),
                V3NullFlavor::NAV(Some(e)) => e.get_field(field),
                V3NullFlavor::NAVU(Some(e)) => e.get_field(field),
                V3NullFlavor::NI(Some(e)) => e.get_field(field),
                V3NullFlavor::NINF(Some(e)) => e.get_field(field),
                V3NullFlavor::NP(Some(e)) => e.get_field(field),
                V3NullFlavor::OTH(Some(e)) => e.get_field(field),
                V3NullFlavor::PINF(Some(e)) => e.get_field(field),
                V3NullFlavor::QS(Some(e)) => e.get_field(field),
                V3NullFlavor::TRC(Some(e)) => e.get_field(field),
                V3NullFlavor::UNC(Some(e)) => e.get_field(field),
                V3NullFlavor::UNK(Some(e)) => e.get_field(field),
                V3NullFlavor::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3NullFlavor::ASKU(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::DER(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::INV(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::MSK(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NA(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NASK(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NAV(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NAVU(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NI(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NINF(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::NP(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::OTH(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::PINF(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::QS(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::TRC(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::UNC(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::UNK(Some(e)) => e.get_field_mut(field),
                V3NullFlavor::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ObservationCategory {
    #[doc = "Exam"]
    #[code = "exam"]
    Exam(Option<Element>),
    #[doc = "Imaging"]
    #[code = "imaging"]
    Imaging(Option<Element>),
    #[doc = "Laboratory"]
    #[code = "laboratory"]
    Laboratory(Option<Element>),
    #[doc = "Procedure"]
    #[code = "procedure"]
    Procedure(Option<Element>),
    #[doc = "Social History"]
    #[code = "social-history"]
    SocialHistory(Option<Element>),
    #[doc = "Survey"]
    #[code = "survey"]
    Survey(Option<Element>),
    #[doc = "Therapy"]
    #[code = "therapy"]
    Therapy(Option<Element>),
    #[doc = "Vital Signs"]
    #[code = "vital-signs"]
    VitalSigns(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ObservationCategory {
    fn default() -> Self {
        V3ObservationCategory::Null(None)
    }
}
impl TryFrom<String> for V3ObservationCategory {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "exam" => Ok(V3ObservationCategory::Exam(None)),
            "imaging" => Ok(V3ObservationCategory::Imaging(None)),
            "laboratory" => Ok(V3ObservationCategory::Laboratory(None)),
            "procedure" => Ok(V3ObservationCategory::Procedure(None)),
            "social-history" => Ok(V3ObservationCategory::SocialHistory(None)),
            "survey" => Ok(V3ObservationCategory::Survey(None)),
            "therapy" => Ok(V3ObservationCategory::Therapy(None)),
            "vital-signs" => Ok(V3ObservationCategory::VitalSigns(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ObservationCategory {
    fn into(self) -> Option<String> {
        match self {
            V3ObservationCategory::Exam(_) => Some("exam".to_string()),
            V3ObservationCategory::Imaging(_) => Some("imaging".to_string()),
            V3ObservationCategory::Laboratory(_) => Some("laboratory".to_string()),
            V3ObservationCategory::Procedure(_) => Some("procedure".to_string()),
            V3ObservationCategory::SocialHistory(_) => Some("social-history".to_string()),
            V3ObservationCategory::Survey(_) => Some("survey".to_string()),
            V3ObservationCategory::Therapy(_) => Some("therapy".to_string()),
            V3ObservationCategory::VitalSigns(_) => Some("vital-signs".to_string()),
            V3ObservationCategory::Null(_) => None,
        }
    }
}
impl MetaValue for V3ObservationCategory {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ObservationCategory::Exam(Some(e)) => e.get_field(field),
                V3ObservationCategory::Imaging(Some(e)) => e.get_field(field),
                V3ObservationCategory::Laboratory(Some(e)) => e.get_field(field),
                V3ObservationCategory::Procedure(Some(e)) => e.get_field(field),
                V3ObservationCategory::SocialHistory(Some(e)) => e.get_field(field),
                V3ObservationCategory::Survey(Some(e)) => e.get_field(field),
                V3ObservationCategory::Therapy(Some(e)) => e.get_field(field),
                V3ObservationCategory::VitalSigns(Some(e)) => e.get_field(field),
                V3ObservationCategory::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ObservationCategory::Exam(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Imaging(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Laboratory(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Procedure(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::SocialHistory(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Survey(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Therapy(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::VitalSigns(Some(e)) => e.get_field_mut(field),
                V3ObservationCategory::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ObservationInterpretation {
    #[doc = "Off scale low"]
    #[code = "<"]
    Greater(Option<Element>),
    #[doc = "Off scale high"]
    #[code = ">"]
    Less(Option<Element>),
    #[doc = "Abnormal"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Critical abnormal"]
    #[code = "AA"]
    AA(Option<Element>),
    #[doc = "Anti-complementary substances present"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "Better"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "Carrier"]
    #[code = "CAR"]
    CAR(Option<Element>),
    #[doc = "Carrier"]
    #[code = "Carrier"]
    Carrier(Option<Element>),
    #[doc = "Significant change down"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Detected"]
    #[code = "DET"]
    DET(Option<Element>),
    #[doc = "Equivocal"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "outside threshold"]
    #[code = "EX"]
    EX(Option<Element>),
    #[doc = "Expected"]
    #[code = "EXP"]
    EXP(Option<Element>),
    #[doc = "High"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "Significantly high"]
    #[code = "H>"]
    HLess(Option<Element>),
    #[doc = "Critical high"]
    #[code = "HH"]
    HH(Option<Element>),
    #[doc = "Hold for Medical Review"]
    #[code = "HM"]
    HM(Option<Element>),
    #[doc = "Significantly high"]
    #[code = "HU"]
    HU(Option<Element>),
    #[doc = "above high threshold"]
    #[code = "HX"]
    HX(Option<Element>),
    #[doc = "Intermediate"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Insufficient evidence"]
    #[code = "IE"]
    IE(Option<Element>),
    #[doc = "Indeterminate"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "Low"]
    #[code = "L"]
    L(Option<Element>),
    #[doc = "Significantly low"]
    #[code = "L<"]
    LGreater(Option<Element>),
    #[doc = "Critical low"]
    #[code = "LL"]
    LL(Option<Element>),
    #[doc = "Significantly low"]
    #[code = "LU"]
    LU(Option<Element>),
    #[doc = "below low threshold"]
    #[code = "LX"]
    LX(Option<Element>),
    #[doc = "moderately susceptible"]
    #[code = "MS"]
    MS(Option<Element>),
    #[doc = "Normal"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "No CLSI defined breakpoint"]
    #[code = "NCL"]
    NCL(Option<Element>),
    #[doc = "Not detected"]
    #[code = "ND"]
    ND(Option<Element>),
    #[doc = "Negative"]
    #[code = "NEG"]
    NEG(Option<Element>),
    #[doc = "Non-reactive"]
    #[code = "NR"]
    NR(Option<Element>),
    #[doc = "Non-susceptible"]
    #[code = "NS"]
    NS(Option<Element>),
    #[doc = "Interpretation qualifiers in separate OBX segments"]
    #[code = "OBX"]
    OBX(Option<Element>),
    #[doc = "ObservationInterpretationDetection"]
    #[code = "ObservationInterpretationDetection"]
    ObservationInterpretationDetection(Option<Element>),
    #[doc = "ObservationInterpretationExpectation"]
    #[code = "ObservationInterpretationExpectation"]
    ObservationInterpretationExpectation(Option<Element>),
    #[doc = "Positive"]
    #[code = "POS"]
    POS(Option<Element>),
    #[doc = "Quality control failure"]
    #[code = "QCF"]
    QCF(Option<Element>),
    #[doc = "Resistant"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Reactive"]
    #[code = "RR"]
    RR(Option<Element>),
    #[doc = "ReactivityObservationInterpretation"]
    #[code = "ReactivityObservationInterpretation"]
    ReactivityObservationInterpretation(Option<Element>),
    #[doc = "Susceptible"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "Susceptible-dose dependent"]
    #[code = "SDD"]
    SDD(Option<Element>),
    #[doc = "Synergy - resistant"]
    #[code = "SYN-R"]
    SYNR(Option<Element>),
    #[doc = "Synergy - susceptible"]
    #[code = "SYN-S"]
    SYNS(Option<Element>),
    #[doc = "Cytotoxic substance present"]
    #[code = "TOX"]
    TOX(Option<Element>),
    #[doc = "Significant change up"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "Unexpected"]
    #[code = "UNE"]
    UNE(Option<Element>),
    #[doc = "very susceptible"]
    #[code = "VS"]
    VS(Option<Element>),
    #[doc = "Worse"]
    #[code = "W"]
    W(Option<Element>),
    #[doc = "Weakly reactive"]
    #[code = "WR"]
    WR(Option<Element>),
    #[doc = "GeneticObservationInterpretation"]
    #[code = "_GeneticObservationInterpretation"]
    _GeneticObservationInterpretation(Option<Element>),
    #[doc = "ObservationInterpretationChange"]
    #[code = "_ObservationInterpretationChange"]
    _ObservationInterpretationChange(Option<Element>),
    #[doc = "ObservationInterpretationExceptions"]
    #[code = "_ObservationInterpretationExceptions"]
    _ObservationInterpretationExceptions(Option<Element>),
    #[doc = "ObservationInterpretationNormality"]
    #[code = "_ObservationInterpretationNormality"]
    _ObservationInterpretationNormality(Option<Element>),
    #[doc = "ObservationInterpretationSusceptibility"]
    #[code = "_ObservationInterpretationSusceptibility"]
    _ObservationInterpretationSusceptibility(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ObservationInterpretation {
    fn default() -> Self {
        V3ObservationInterpretation::Null(None)
    }
}
impl TryFrom<String> for V3ObservationInterpretation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "<" => Ok(V3ObservationInterpretation::Greater(None)),
            ">" => Ok(V3ObservationInterpretation::Less(None)),
            "A" => Ok(V3ObservationInterpretation::A(None)),
            "AA" => Ok(V3ObservationInterpretation::AA(None)),
            "AC" => Ok(V3ObservationInterpretation::AC(None)),
            "B" => Ok(V3ObservationInterpretation::B(None)),
            "CAR" => Ok(V3ObservationInterpretation::CAR(None)),
            "Carrier" => Ok(V3ObservationInterpretation::Carrier(None)),
            "D" => Ok(V3ObservationInterpretation::D(None)),
            "DET" => Ok(V3ObservationInterpretation::DET(None)),
            "E" => Ok(V3ObservationInterpretation::E(None)),
            "EX" => Ok(V3ObservationInterpretation::EX(None)),
            "EXP" => Ok(V3ObservationInterpretation::EXP(None)),
            "H" => Ok(V3ObservationInterpretation::H(None)),
            "H>" => Ok(V3ObservationInterpretation::HLess(None)),
            "HH" => Ok(V3ObservationInterpretation::HH(None)),
            "HM" => Ok(V3ObservationInterpretation::HM(None)),
            "HU" => Ok(V3ObservationInterpretation::HU(None)),
            "HX" => Ok(V3ObservationInterpretation::HX(None)),
            "I" => Ok(V3ObservationInterpretation::I(None)),
            "IE" => Ok(V3ObservationInterpretation::IE(None)),
            "IND" => Ok(V3ObservationInterpretation::IND(None)),
            "L" => Ok(V3ObservationInterpretation::L(None)),
            "L<" => Ok(V3ObservationInterpretation::LGreater(None)),
            "LL" => Ok(V3ObservationInterpretation::LL(None)),
            "LU" => Ok(V3ObservationInterpretation::LU(None)),
            "LX" => Ok(V3ObservationInterpretation::LX(None)),
            "MS" => Ok(V3ObservationInterpretation::MS(None)),
            "N" => Ok(V3ObservationInterpretation::N(None)),
            "NCL" => Ok(V3ObservationInterpretation::NCL(None)),
            "ND" => Ok(V3ObservationInterpretation::ND(None)),
            "NEG" => Ok(V3ObservationInterpretation::NEG(None)),
            "NR" => Ok(V3ObservationInterpretation::NR(None)),
            "NS" => Ok(V3ObservationInterpretation::NS(None)),
            "OBX" => Ok(V3ObservationInterpretation::OBX(None)),
            "ObservationInterpretationDetection" => {
                Ok(V3ObservationInterpretation::ObservationInterpretationDetection(None))
            }
            "ObservationInterpretationExpectation" => {
                Ok(V3ObservationInterpretation::ObservationInterpretationExpectation(None))
            }
            "POS" => Ok(V3ObservationInterpretation::POS(None)),
            "QCF" => Ok(V3ObservationInterpretation::QCF(None)),
            "R" => Ok(V3ObservationInterpretation::R(None)),
            "RR" => Ok(V3ObservationInterpretation::RR(None)),
            "ReactivityObservationInterpretation" => {
                Ok(V3ObservationInterpretation::ReactivityObservationInterpretation(None))
            }
            "S" => Ok(V3ObservationInterpretation::S(None)),
            "SDD" => Ok(V3ObservationInterpretation::SDD(None)),
            "SYN-R" => Ok(V3ObservationInterpretation::SYNR(None)),
            "SYN-S" => Ok(V3ObservationInterpretation::SYNS(None)),
            "TOX" => Ok(V3ObservationInterpretation::TOX(None)),
            "U" => Ok(V3ObservationInterpretation::U(None)),
            "UNE" => Ok(V3ObservationInterpretation::UNE(None)),
            "VS" => Ok(V3ObservationInterpretation::VS(None)),
            "W" => Ok(V3ObservationInterpretation::W(None)),
            "WR" => Ok(V3ObservationInterpretation::WR(None)),
            "_GeneticObservationInterpretation" => {
                Ok(V3ObservationInterpretation::_GeneticObservationInterpretation(None))
            }
            "_ObservationInterpretationChange" => {
                Ok(V3ObservationInterpretation::_ObservationInterpretationChange(None))
            }
            "_ObservationInterpretationExceptions" => {
                Ok(V3ObservationInterpretation::_ObservationInterpretationExceptions(None))
            }
            "_ObservationInterpretationNormality" => {
                Ok(V3ObservationInterpretation::_ObservationInterpretationNormality(None))
            }
            "_ObservationInterpretationSusceptibility" => {
                Ok(V3ObservationInterpretation::_ObservationInterpretationSusceptibility(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ObservationInterpretation {
    fn into(self) -> Option<String> {
        match self {
            V3ObservationInterpretation::Greater(_) => Some("<".to_string()),
            V3ObservationInterpretation::Less(_) => Some(">".to_string()),
            V3ObservationInterpretation::A(_) => Some("A".to_string()),
            V3ObservationInterpretation::AA(_) => Some("AA".to_string()),
            V3ObservationInterpretation::AC(_) => Some("AC".to_string()),
            V3ObservationInterpretation::B(_) => Some("B".to_string()),
            V3ObservationInterpretation::CAR(_) => Some("CAR".to_string()),
            V3ObservationInterpretation::Carrier(_) => Some("Carrier".to_string()),
            V3ObservationInterpretation::D(_) => Some("D".to_string()),
            V3ObservationInterpretation::DET(_) => Some("DET".to_string()),
            V3ObservationInterpretation::E(_) => Some("E".to_string()),
            V3ObservationInterpretation::EX(_) => Some("EX".to_string()),
            V3ObservationInterpretation::EXP(_) => Some("EXP".to_string()),
            V3ObservationInterpretation::H(_) => Some("H".to_string()),
            V3ObservationInterpretation::HLess(_) => Some("H>".to_string()),
            V3ObservationInterpretation::HH(_) => Some("HH".to_string()),
            V3ObservationInterpretation::HM(_) => Some("HM".to_string()),
            V3ObservationInterpretation::HU(_) => Some("HU".to_string()),
            V3ObservationInterpretation::HX(_) => Some("HX".to_string()),
            V3ObservationInterpretation::I(_) => Some("I".to_string()),
            V3ObservationInterpretation::IE(_) => Some("IE".to_string()),
            V3ObservationInterpretation::IND(_) => Some("IND".to_string()),
            V3ObservationInterpretation::L(_) => Some("L".to_string()),
            V3ObservationInterpretation::LGreater(_) => Some("L<".to_string()),
            V3ObservationInterpretation::LL(_) => Some("LL".to_string()),
            V3ObservationInterpretation::LU(_) => Some("LU".to_string()),
            V3ObservationInterpretation::LX(_) => Some("LX".to_string()),
            V3ObservationInterpretation::MS(_) => Some("MS".to_string()),
            V3ObservationInterpretation::N(_) => Some("N".to_string()),
            V3ObservationInterpretation::NCL(_) => Some("NCL".to_string()),
            V3ObservationInterpretation::ND(_) => Some("ND".to_string()),
            V3ObservationInterpretation::NEG(_) => Some("NEG".to_string()),
            V3ObservationInterpretation::NR(_) => Some("NR".to_string()),
            V3ObservationInterpretation::NS(_) => Some("NS".to_string()),
            V3ObservationInterpretation::OBX(_) => Some("OBX".to_string()),
            V3ObservationInterpretation::ObservationInterpretationDetection(_) => {
                Some("ObservationInterpretationDetection".to_string())
            }
            V3ObservationInterpretation::ObservationInterpretationExpectation(_) => {
                Some("ObservationInterpretationExpectation".to_string())
            }
            V3ObservationInterpretation::POS(_) => Some("POS".to_string()),
            V3ObservationInterpretation::QCF(_) => Some("QCF".to_string()),
            V3ObservationInterpretation::R(_) => Some("R".to_string()),
            V3ObservationInterpretation::RR(_) => Some("RR".to_string()),
            V3ObservationInterpretation::ReactivityObservationInterpretation(_) => {
                Some("ReactivityObservationInterpretation".to_string())
            }
            V3ObservationInterpretation::S(_) => Some("S".to_string()),
            V3ObservationInterpretation::SDD(_) => Some("SDD".to_string()),
            V3ObservationInterpretation::SYNR(_) => Some("SYN-R".to_string()),
            V3ObservationInterpretation::SYNS(_) => Some("SYN-S".to_string()),
            V3ObservationInterpretation::TOX(_) => Some("TOX".to_string()),
            V3ObservationInterpretation::U(_) => Some("U".to_string()),
            V3ObservationInterpretation::UNE(_) => Some("UNE".to_string()),
            V3ObservationInterpretation::VS(_) => Some("VS".to_string()),
            V3ObservationInterpretation::W(_) => Some("W".to_string()),
            V3ObservationInterpretation::WR(_) => Some("WR".to_string()),
            V3ObservationInterpretation::_GeneticObservationInterpretation(_) => {
                Some("_GeneticObservationInterpretation".to_string())
            }
            V3ObservationInterpretation::_ObservationInterpretationChange(_) => {
                Some("_ObservationInterpretationChange".to_string())
            }
            V3ObservationInterpretation::_ObservationInterpretationExceptions(_) => {
                Some("_ObservationInterpretationExceptions".to_string())
            }
            V3ObservationInterpretation::_ObservationInterpretationNormality(_) => {
                Some("_ObservationInterpretationNormality".to_string())
            }
            V3ObservationInterpretation::_ObservationInterpretationSusceptibility(_) => {
                Some("_ObservationInterpretationSusceptibility".to_string())
            }
            V3ObservationInterpretation::Null(_) => None,
        }
    }
}
impl MetaValue for V3ObservationInterpretation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ObservationInterpretation::Greater(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::Less(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::A(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::AA(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::AC(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::B(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::CAR(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::Carrier(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::D(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::DET(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::E(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::EX(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::EXP(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::H(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::HLess(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::HH(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::HM(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::HU(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::HX(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::I(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::IE(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::IND(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::L(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::LGreater(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::LL(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::LU(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::LX(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::MS(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::N(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::NCL(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::ND(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::NEG(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::NR(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::NS(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::OBX(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::ObservationInterpretationDetection(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::ObservationInterpretationExpectation(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::POS(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::QCF(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::R(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::RR(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::ReactivityObservationInterpretation(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::S(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::SDD(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::SYNR(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::SYNS(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::TOX(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::U(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::UNE(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::VS(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::W(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::WR(Some(e)) => e.get_field(field),
                V3ObservationInterpretation::_GeneticObservationInterpretation(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationChange(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationExceptions(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationNormality(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationSusceptibility(Some(e)) => {
                    e.get_field(field)
                }
                V3ObservationInterpretation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ObservationInterpretation::Greater(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::Less(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::A(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::AA(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::AC(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::B(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::CAR(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::Carrier(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::D(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::DET(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::E(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::EX(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::EXP(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::H(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::HLess(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::HH(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::HM(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::HU(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::HX(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::I(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::IE(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::IND(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::L(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::LGreater(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::LL(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::LU(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::LX(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::MS(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::N(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::NCL(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::ND(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::NEG(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::NR(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::NS(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::OBX(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::ObservationInterpretationDetection(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::ObservationInterpretationExpectation(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::POS(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::QCF(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::R(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::RR(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::ReactivityObservationInterpretation(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::S(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::SDD(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::SYNR(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::SYNS(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::TOX(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::U(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::UNE(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::VS(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::W(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::WR(Some(e)) => e.get_field_mut(field),
                V3ObservationInterpretation::_GeneticObservationInterpretation(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationChange(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationExceptions(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationNormality(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::_ObservationInterpretationSusceptibility(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ObservationInterpretation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationFunction {
    #[doc = "admitting physician"]
    #[code = "ADMPHYS"]
    ADMPHYS(Option<Element>),
    #[doc = "anesthesist"]
    #[code = "ANEST"]
    ANEST(Option<Element>),
    #[doc = "anesthesia nurse"]
    #[code = "ANRS"]
    ANRS(Option<Element>),
    #[doc = "assembly software"]
    #[code = "ASSEMBLER"]
    ASSEMBLER(Option<Element>),
    #[doc = "attending physician"]
    #[code = "ATTPHYS"]
    ATTPHYS(Option<Element>),
    #[doc = "caregiver information receiver"]
    #[code = "AUCG"]
    AUCG(Option<Element>),
    #[doc = "consent overrider"]
    #[code = "AUCOV"]
    AUCOV(Option<Element>),
    #[doc = "emergency overrider"]
    #[code = "AUEMROV"]
    AUEMROV(Option<Element>),
    #[doc = "legitimate relationship information receiver"]
    #[code = "AULR"]
    AULR(Option<Element>),
    #[doc = "care team information receiver"]
    #[code = "AUTM"]
    AUTM(Option<Element>),
    #[doc = "work area information receiver"]
    #[code = "AUWA"]
    AUWA(Option<Element>),
    #[doc = "claims adjudication"]
    #[code = "CLMADJ"]
    CLMADJ(Option<Element>),
    #[doc = "composer software"]
    #[code = "COMPOSER"]
    COMPOSER(Option<Element>),
    #[doc = "discharging physician"]
    #[code = "DISPHYS"]
    DISPHYS(Option<Element>),
    #[doc = "enrollment broker"]
    #[code = "ENROLL"]
    ENROLL(Option<Element>),
    #[doc = "first assistant surgeon"]
    #[code = "FASST"]
    FASST(Option<Element>),
    #[doc = "ffs management"]
    #[code = "FFSMGT"]
    FFSMGT(Option<Element>),
    #[doc = "fully insured"]
    #[code = "FULINRD"]
    FULINRD(Option<Element>),
    #[doc = "legal guardian consent author"]
    #[code = "GRDCON"]
    GRDCON(Option<Element>),
    #[doc = "managed care management"]
    #[code = "MCMGT"]
    MCMGT(Option<Element>),
    #[doc = "midwife"]
    #[code = "MDWF"]
    MDWF(Option<Element>),
    #[doc = "nurse assistant"]
    #[code = "NASST"]
    NASST(Option<Element>),
    #[doc = "payor contracting"]
    #[code = "PAYORCNTR"]
    PAYORCNTR(Option<Element>),
    #[doc = "primary care physician"]
    #[code = "PCP"]
    PCP(Option<Element>),
    #[doc = "healthcare power of attorney consent author"]
    #[code = "POACON"]
    POACON(Option<Element>),
    #[doc = "personal representative consent author"]
    #[code = "PRCON"]
    PRCON(Option<Element>),
    #[doc = "primary surgeon"]
    #[code = "PRISURG"]
    PRISURG(Option<Element>),
    #[doc = "authorized provider masking author"]
    #[code = "PROMSK"]
    PROMSK(Option<Element>),
    #[doc = "provider management"]
    #[code = "PROVMGT"]
    PROVMGT(Option<Element>),
    #[doc = "reinsures"]
    #[code = "REINS"]
    REINS(Option<Element>),
    #[doc = "retrocessionaires"]
    #[code = "RETROCES"]
    RETROCES(Option<Element>),
    #[doc = "reviewer"]
    #[code = "REVIEWER"]
    REVIEWER(Option<Element>),
    #[doc = "rounding physician"]
    #[code = "RNDPHYS"]
    RNDPHYS(Option<Element>),
    #[doc = "second assistant surgeon"]
    #[code = "SASST"]
    SASST(Option<Element>),
    #[doc = "self insured"]
    #[code = "SELFINRD"]
    SELFINRD(Option<Element>),
    #[doc = "scrub nurse"]
    #[code = "SNRS"]
    SNRS(Option<Element>),
    #[doc = "subject of consent author"]
    #[code = "SUBCON"]
    SUBCON(Option<Element>),
    #[doc = "subcontracting risk"]
    #[code = "SUBCTRT"]
    SUBCTRT(Option<Element>),
    #[doc = "third assistant"]
    #[code = "TASST"]
    TASST(Option<Element>),
    #[doc = "utilization management"]
    #[code = "UMGT"]
    UMGT(Option<Element>),
    #[doc = "underwriting"]
    #[code = "UNDERWRTNG"]
    UNDERWRTNG(Option<Element>),
    #[doc = "AuthorizedParticipationFunction"]
    #[code = "_AuthorizedParticipationFunction"]
    _AuthorizedParticipationFunction(Option<Element>),
    #[doc = "AuthorizedReceiverParticipationFunction"]
    #[code = "_AuthorizedReceiverParticipationFunction"]
    _AuthorizedReceiverParticipationFunction(Option<Element>),
    #[doc = "ConsenterParticipationFunction"]
    #[code = "_ConsenterParticipationFunction"]
    _ConsenterParticipationFunction(Option<Element>),
    #[doc = "CoverageParticipationFunction"]
    #[code = "_CoverageParticipationFunction"]
    _CoverageParticipationFunction(Option<Element>),
    #[doc = "OverriderParticipationFunction"]
    #[code = "_OverriderParticipationFunction"]
    _OverriderParticipationFunction(Option<Element>),
    #[doc = "PayorParticipationFunction"]
    #[code = "_PayorParticipationFunction"]
    _PayorParticipationFunction(Option<Element>),
    #[doc = "SponsorParticipationFunction"]
    #[code = "_SponsorParticipationFunction"]
    _SponsorParticipationFunction(Option<Element>),
    #[doc = "UnderwriterParticipationFunction"]
    #[code = "_UnderwriterParticipationFunction"]
    _UnderwriterParticipationFunction(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationFunction {
    fn default() -> Self {
        V3ParticipationFunction::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationFunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADMPHYS" => Ok(V3ParticipationFunction::ADMPHYS(None)),
            "ANEST" => Ok(V3ParticipationFunction::ANEST(None)),
            "ANRS" => Ok(V3ParticipationFunction::ANRS(None)),
            "ASSEMBLER" => Ok(V3ParticipationFunction::ASSEMBLER(None)),
            "ATTPHYS" => Ok(V3ParticipationFunction::ATTPHYS(None)),
            "AUCG" => Ok(V3ParticipationFunction::AUCG(None)),
            "AUCOV" => Ok(V3ParticipationFunction::AUCOV(None)),
            "AUEMROV" => Ok(V3ParticipationFunction::AUEMROV(None)),
            "AULR" => Ok(V3ParticipationFunction::AULR(None)),
            "AUTM" => Ok(V3ParticipationFunction::AUTM(None)),
            "AUWA" => Ok(V3ParticipationFunction::AUWA(None)),
            "CLMADJ" => Ok(V3ParticipationFunction::CLMADJ(None)),
            "COMPOSER" => Ok(V3ParticipationFunction::COMPOSER(None)),
            "DISPHYS" => Ok(V3ParticipationFunction::DISPHYS(None)),
            "ENROLL" => Ok(V3ParticipationFunction::ENROLL(None)),
            "FASST" => Ok(V3ParticipationFunction::FASST(None)),
            "FFSMGT" => Ok(V3ParticipationFunction::FFSMGT(None)),
            "FULINRD" => Ok(V3ParticipationFunction::FULINRD(None)),
            "GRDCON" => Ok(V3ParticipationFunction::GRDCON(None)),
            "MCMGT" => Ok(V3ParticipationFunction::MCMGT(None)),
            "MDWF" => Ok(V3ParticipationFunction::MDWF(None)),
            "NASST" => Ok(V3ParticipationFunction::NASST(None)),
            "PAYORCNTR" => Ok(V3ParticipationFunction::PAYORCNTR(None)),
            "PCP" => Ok(V3ParticipationFunction::PCP(None)),
            "POACON" => Ok(V3ParticipationFunction::POACON(None)),
            "PRCON" => Ok(V3ParticipationFunction::PRCON(None)),
            "PRISURG" => Ok(V3ParticipationFunction::PRISURG(None)),
            "PROMSK" => Ok(V3ParticipationFunction::PROMSK(None)),
            "PROVMGT" => Ok(V3ParticipationFunction::PROVMGT(None)),
            "REINS" => Ok(V3ParticipationFunction::REINS(None)),
            "RETROCES" => Ok(V3ParticipationFunction::RETROCES(None)),
            "REVIEWER" => Ok(V3ParticipationFunction::REVIEWER(None)),
            "RNDPHYS" => Ok(V3ParticipationFunction::RNDPHYS(None)),
            "SASST" => Ok(V3ParticipationFunction::SASST(None)),
            "SELFINRD" => Ok(V3ParticipationFunction::SELFINRD(None)),
            "SNRS" => Ok(V3ParticipationFunction::SNRS(None)),
            "SUBCON" => Ok(V3ParticipationFunction::SUBCON(None)),
            "SUBCTRT" => Ok(V3ParticipationFunction::SUBCTRT(None)),
            "TASST" => Ok(V3ParticipationFunction::TASST(None)),
            "UMGT" => Ok(V3ParticipationFunction::UMGT(None)),
            "UNDERWRTNG" => Ok(V3ParticipationFunction::UNDERWRTNG(None)),
            "_AuthorizedParticipationFunction" => Ok(
                V3ParticipationFunction::_AuthorizedParticipationFunction(None),
            ),
            "_AuthorizedReceiverParticipationFunction" => {
                Ok(V3ParticipationFunction::_AuthorizedReceiverParticipationFunction(None))
            }
            "_ConsenterParticipationFunction" => Ok(
                V3ParticipationFunction::_ConsenterParticipationFunction(None),
            ),
            "_CoverageParticipationFunction" => Ok(
                V3ParticipationFunction::_CoverageParticipationFunction(None),
            ),
            "_OverriderParticipationFunction" => Ok(
                V3ParticipationFunction::_OverriderParticipationFunction(None),
            ),
            "_PayorParticipationFunction" => {
                Ok(V3ParticipationFunction::_PayorParticipationFunction(None))
            }
            "_SponsorParticipationFunction" => {
                Ok(V3ParticipationFunction::_SponsorParticipationFunction(None))
            }
            "_UnderwriterParticipationFunction" => Ok(
                V3ParticipationFunction::_UnderwriterParticipationFunction(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationFunction {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationFunction::ADMPHYS(_) => Some("ADMPHYS".to_string()),
            V3ParticipationFunction::ANEST(_) => Some("ANEST".to_string()),
            V3ParticipationFunction::ANRS(_) => Some("ANRS".to_string()),
            V3ParticipationFunction::ASSEMBLER(_) => Some("ASSEMBLER".to_string()),
            V3ParticipationFunction::ATTPHYS(_) => Some("ATTPHYS".to_string()),
            V3ParticipationFunction::AUCG(_) => Some("AUCG".to_string()),
            V3ParticipationFunction::AUCOV(_) => Some("AUCOV".to_string()),
            V3ParticipationFunction::AUEMROV(_) => Some("AUEMROV".to_string()),
            V3ParticipationFunction::AULR(_) => Some("AULR".to_string()),
            V3ParticipationFunction::AUTM(_) => Some("AUTM".to_string()),
            V3ParticipationFunction::AUWA(_) => Some("AUWA".to_string()),
            V3ParticipationFunction::CLMADJ(_) => Some("CLMADJ".to_string()),
            V3ParticipationFunction::COMPOSER(_) => Some("COMPOSER".to_string()),
            V3ParticipationFunction::DISPHYS(_) => Some("DISPHYS".to_string()),
            V3ParticipationFunction::ENROLL(_) => Some("ENROLL".to_string()),
            V3ParticipationFunction::FASST(_) => Some("FASST".to_string()),
            V3ParticipationFunction::FFSMGT(_) => Some("FFSMGT".to_string()),
            V3ParticipationFunction::FULINRD(_) => Some("FULINRD".to_string()),
            V3ParticipationFunction::GRDCON(_) => Some("GRDCON".to_string()),
            V3ParticipationFunction::MCMGT(_) => Some("MCMGT".to_string()),
            V3ParticipationFunction::MDWF(_) => Some("MDWF".to_string()),
            V3ParticipationFunction::NASST(_) => Some("NASST".to_string()),
            V3ParticipationFunction::PAYORCNTR(_) => Some("PAYORCNTR".to_string()),
            V3ParticipationFunction::PCP(_) => Some("PCP".to_string()),
            V3ParticipationFunction::POACON(_) => Some("POACON".to_string()),
            V3ParticipationFunction::PRCON(_) => Some("PRCON".to_string()),
            V3ParticipationFunction::PRISURG(_) => Some("PRISURG".to_string()),
            V3ParticipationFunction::PROMSK(_) => Some("PROMSK".to_string()),
            V3ParticipationFunction::PROVMGT(_) => Some("PROVMGT".to_string()),
            V3ParticipationFunction::REINS(_) => Some("REINS".to_string()),
            V3ParticipationFunction::RETROCES(_) => Some("RETROCES".to_string()),
            V3ParticipationFunction::REVIEWER(_) => Some("REVIEWER".to_string()),
            V3ParticipationFunction::RNDPHYS(_) => Some("RNDPHYS".to_string()),
            V3ParticipationFunction::SASST(_) => Some("SASST".to_string()),
            V3ParticipationFunction::SELFINRD(_) => Some("SELFINRD".to_string()),
            V3ParticipationFunction::SNRS(_) => Some("SNRS".to_string()),
            V3ParticipationFunction::SUBCON(_) => Some("SUBCON".to_string()),
            V3ParticipationFunction::SUBCTRT(_) => Some("SUBCTRT".to_string()),
            V3ParticipationFunction::TASST(_) => Some("TASST".to_string()),
            V3ParticipationFunction::UMGT(_) => Some("UMGT".to_string()),
            V3ParticipationFunction::UNDERWRTNG(_) => Some("UNDERWRTNG".to_string()),
            V3ParticipationFunction::_AuthorizedParticipationFunction(_) => {
                Some("_AuthorizedParticipationFunction".to_string())
            }
            V3ParticipationFunction::_AuthorizedReceiverParticipationFunction(_) => {
                Some("_AuthorizedReceiverParticipationFunction".to_string())
            }
            V3ParticipationFunction::_ConsenterParticipationFunction(_) => {
                Some("_ConsenterParticipationFunction".to_string())
            }
            V3ParticipationFunction::_CoverageParticipationFunction(_) => {
                Some("_CoverageParticipationFunction".to_string())
            }
            V3ParticipationFunction::_OverriderParticipationFunction(_) => {
                Some("_OverriderParticipationFunction".to_string())
            }
            V3ParticipationFunction::_PayorParticipationFunction(_) => {
                Some("_PayorParticipationFunction".to_string())
            }
            V3ParticipationFunction::_SponsorParticipationFunction(_) => {
                Some("_SponsorParticipationFunction".to_string())
            }
            V3ParticipationFunction::_UnderwriterParticipationFunction(_) => {
                Some("_UnderwriterParticipationFunction".to_string())
            }
            V3ParticipationFunction::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationFunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationFunction::ADMPHYS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::ANEST(Some(e)) => e.get_field(field),
                V3ParticipationFunction::ANRS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::ASSEMBLER(Some(e)) => e.get_field(field),
                V3ParticipationFunction::ATTPHYS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AUCG(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AUCOV(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AUEMROV(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AULR(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AUTM(Some(e)) => e.get_field(field),
                V3ParticipationFunction::AUWA(Some(e)) => e.get_field(field),
                V3ParticipationFunction::CLMADJ(Some(e)) => e.get_field(field),
                V3ParticipationFunction::COMPOSER(Some(e)) => e.get_field(field),
                V3ParticipationFunction::DISPHYS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::ENROLL(Some(e)) => e.get_field(field),
                V3ParticipationFunction::FASST(Some(e)) => e.get_field(field),
                V3ParticipationFunction::FFSMGT(Some(e)) => e.get_field(field),
                V3ParticipationFunction::FULINRD(Some(e)) => e.get_field(field),
                V3ParticipationFunction::GRDCON(Some(e)) => e.get_field(field),
                V3ParticipationFunction::MCMGT(Some(e)) => e.get_field(field),
                V3ParticipationFunction::MDWF(Some(e)) => e.get_field(field),
                V3ParticipationFunction::NASST(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PAYORCNTR(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PCP(Some(e)) => e.get_field(field),
                V3ParticipationFunction::POACON(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PRCON(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PRISURG(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PROMSK(Some(e)) => e.get_field(field),
                V3ParticipationFunction::PROVMGT(Some(e)) => e.get_field(field),
                V3ParticipationFunction::REINS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::RETROCES(Some(e)) => e.get_field(field),
                V3ParticipationFunction::REVIEWER(Some(e)) => e.get_field(field),
                V3ParticipationFunction::RNDPHYS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::SASST(Some(e)) => e.get_field(field),
                V3ParticipationFunction::SELFINRD(Some(e)) => e.get_field(field),
                V3ParticipationFunction::SNRS(Some(e)) => e.get_field(field),
                V3ParticipationFunction::SUBCON(Some(e)) => e.get_field(field),
                V3ParticipationFunction::SUBCTRT(Some(e)) => e.get_field(field),
                V3ParticipationFunction::TASST(Some(e)) => e.get_field(field),
                V3ParticipationFunction::UMGT(Some(e)) => e.get_field(field),
                V3ParticipationFunction::UNDERWRTNG(Some(e)) => e.get_field(field),
                V3ParticipationFunction::_AuthorizedParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_AuthorizedReceiverParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_ConsenterParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_CoverageParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_OverriderParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_PayorParticipationFunction(Some(e)) => e.get_field(field),
                V3ParticipationFunction::_SponsorParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::_UnderwriterParticipationFunction(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationFunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationFunction::ADMPHYS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::ANEST(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::ANRS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::ASSEMBLER(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::ATTPHYS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AUCG(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AUCOV(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AUEMROV(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AULR(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AUTM(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::AUWA(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::CLMADJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::COMPOSER(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::DISPHYS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::ENROLL(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::FASST(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::FFSMGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::FULINRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::GRDCON(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::MCMGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::MDWF(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::NASST(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PAYORCNTR(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::POACON(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PRCON(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PRISURG(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PROMSK(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::PROVMGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::REINS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::RETROCES(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::REVIEWER(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::RNDPHYS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::SASST(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::SELFINRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::SNRS(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::SUBCON(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::SUBCTRT(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::TASST(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::UMGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::UNDERWRTNG(Some(e)) => e.get_field_mut(field),
                V3ParticipationFunction::_AuthorizedParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_AuthorizedReceiverParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_ConsenterParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_CoverageParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_OverriderParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_PayorParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_SponsorParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::_UnderwriterParticipationFunction(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationFunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationIndirectTarget {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationIndirectTarget {
    fn default() -> Self {
        V3ParticipationIndirectTarget::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationIndirectTarget {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationIndirectTarget::ADM(None)),
            "ALY" => Ok(V3ParticipationIndirectTarget::ALY(None)),
            "ATND" => Ok(V3ParticipationIndirectTarget::ATND(None)),
            "AUT" => Ok(V3ParticipationIndirectTarget::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationIndirectTarget::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationIndirectTarget::BBY(None)),
            "BEN" => Ok(V3ParticipationIndirectTarget::BEN(None)),
            "CAGNT" => Ok(V3ParticipationIndirectTarget::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationIndirectTarget::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationIndirectTarget::CAT(None)),
            "CON" => Ok(V3ParticipationIndirectTarget::CON(None)),
            "COV" => Ok(V3ParticipationIndirectTarget::COV(None)),
            "CSM" => Ok(V3ParticipationIndirectTarget::CSM(None)),
            "CST" => Ok(V3ParticipationIndirectTarget::CST(None)),
            "DEV" => Ok(V3ParticipationIndirectTarget::DEV(None)),
            "DIR" => Ok(V3ParticipationIndirectTarget::DIR(None)),
            "DIS" => Ok(V3ParticipationIndirectTarget::DIS(None)),
            "DIST" => Ok(V3ParticipationIndirectTarget::DIST(None)),
            "DON" => Ok(V3ParticipationIndirectTarget::DON(None)),
            "DST" => Ok(V3ParticipationIndirectTarget::DST(None)),
            "ELOC" => Ok(V3ParticipationIndirectTarget::ELOC(None)),
            "ENT" => Ok(V3ParticipationIndirectTarget::ENT(None)),
            "ESC" => Ok(V3ParticipationIndirectTarget::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationIndirectTarget::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationIndirectTarget::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationIndirectTarget::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationIndirectTarget::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationIndirectTarget::GUAR(None)),
            "HLD" => Ok(V3ParticipationIndirectTarget::HLD(None)),
            "IND" => Ok(V3ParticipationIndirectTarget::IND(None)),
            "INF" => Ok(V3ParticipationIndirectTarget::INF(None)),
            "IRCP" => Ok(V3ParticipationIndirectTarget::IRCP(None)),
            "LA" => Ok(V3ParticipationIndirectTarget::LA(None)),
            "LOC" => Ok(V3ParticipationIndirectTarget::LOC(None)),
            "NOT" => Ok(V3ParticipationIndirectTarget::NOT(None)),
            "NRD" => Ok(V3ParticipationIndirectTarget::NRD(None)),
            "ORG" => Ok(V3ParticipationIndirectTarget::ORG(None)),
            "PART" => Ok(V3ParticipationIndirectTarget::PART(None)),
            "PPRF" => Ok(V3ParticipationIndirectTarget::PPRF(None)),
            "PRCP" => Ok(V3ParticipationIndirectTarget::PRCP(None)),
            "PRD" => Ok(V3ParticipationIndirectTarget::PRD(None)),
            "PRF" => Ok(V3ParticipationIndirectTarget::PRF(None)),
            "RCT" => Ok(V3ParticipationIndirectTarget::RCT(None)),
            "RCV" => Ok(V3ParticipationIndirectTarget::RCV(None)),
            "RDV" => Ok(V3ParticipationIndirectTarget::RDV(None)),
            "REF" => Ok(V3ParticipationIndirectTarget::REF(None)),
            "REFB" => Ok(V3ParticipationIndirectTarget::REFB(None)),
            "REFT" => Ok(V3ParticipationIndirectTarget::REFT(None)),
            "RESP" => Ok(V3ParticipationIndirectTarget::RESP(None)),
            "RML" => Ok(V3ParticipationIndirectTarget::RML(None)),
            "SBJ" => Ok(V3ParticipationIndirectTarget::SBJ(None)),
            "SPC" => Ok(V3ParticipationIndirectTarget::SPC(None)),
            "SPRF" => Ok(V3ParticipationIndirectTarget::SPRF(None)),
            "TPA" => Ok(V3ParticipationIndirectTarget::TPA(None)),
            "TRANS" => Ok(V3ParticipationIndirectTarget::TRANS(None)),
            "TRC" => Ok(V3ParticipationIndirectTarget::TRC(None)),
            "VIA" => Ok(V3ParticipationIndirectTarget::VIA(None)),
            "VRF" => Ok(V3ParticipationIndirectTarget::VRF(None)),
            "WIT" => Ok(V3ParticipationIndirectTarget::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationIndirectTarget::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationIndirectTarget::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationIndirectTarget {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationIndirectTarget::ADM(_) => Some("ADM".to_string()),
            V3ParticipationIndirectTarget::ALY(_) => Some("ALY".to_string()),
            V3ParticipationIndirectTarget::ATND(_) => Some("ATND".to_string()),
            V3ParticipationIndirectTarget::AUT(_) => Some("AUT".to_string()),
            V3ParticipationIndirectTarget::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationIndirectTarget::BBY(_) => Some("BBY".to_string()),
            V3ParticipationIndirectTarget::BEN(_) => Some("BEN".to_string()),
            V3ParticipationIndirectTarget::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationIndirectTarget::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationIndirectTarget::CAT(_) => Some("CAT".to_string()),
            V3ParticipationIndirectTarget::CON(_) => Some("CON".to_string()),
            V3ParticipationIndirectTarget::COV(_) => Some("COV".to_string()),
            V3ParticipationIndirectTarget::CSM(_) => Some("CSM".to_string()),
            V3ParticipationIndirectTarget::CST(_) => Some("CST".to_string()),
            V3ParticipationIndirectTarget::DEV(_) => Some("DEV".to_string()),
            V3ParticipationIndirectTarget::DIR(_) => Some("DIR".to_string()),
            V3ParticipationIndirectTarget::DIS(_) => Some("DIS".to_string()),
            V3ParticipationIndirectTarget::DIST(_) => Some("DIST".to_string()),
            V3ParticipationIndirectTarget::DON(_) => Some("DON".to_string()),
            V3ParticipationIndirectTarget::DST(_) => Some("DST".to_string()),
            V3ParticipationIndirectTarget::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationIndirectTarget::ENT(_) => Some("ENT".to_string()),
            V3ParticipationIndirectTarget::ESC(_) => Some("ESC".to_string()),
            V3ParticipationIndirectTarget::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationIndirectTarget::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationIndirectTarget::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationIndirectTarget::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationIndirectTarget::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationIndirectTarget::HLD(_) => Some("HLD".to_string()),
            V3ParticipationIndirectTarget::IND(_) => Some("IND".to_string()),
            V3ParticipationIndirectTarget::INF(_) => Some("INF".to_string()),
            V3ParticipationIndirectTarget::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationIndirectTarget::LA(_) => Some("LA".to_string()),
            V3ParticipationIndirectTarget::LOC(_) => Some("LOC".to_string()),
            V3ParticipationIndirectTarget::NOT(_) => Some("NOT".to_string()),
            V3ParticipationIndirectTarget::NRD(_) => Some("NRD".to_string()),
            V3ParticipationIndirectTarget::ORG(_) => Some("ORG".to_string()),
            V3ParticipationIndirectTarget::PART(_) => Some("PART".to_string()),
            V3ParticipationIndirectTarget::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationIndirectTarget::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationIndirectTarget::PRD(_) => Some("PRD".to_string()),
            V3ParticipationIndirectTarget::PRF(_) => Some("PRF".to_string()),
            V3ParticipationIndirectTarget::RCT(_) => Some("RCT".to_string()),
            V3ParticipationIndirectTarget::RCV(_) => Some("RCV".to_string()),
            V3ParticipationIndirectTarget::RDV(_) => Some("RDV".to_string()),
            V3ParticipationIndirectTarget::REF(_) => Some("REF".to_string()),
            V3ParticipationIndirectTarget::REFB(_) => Some("REFB".to_string()),
            V3ParticipationIndirectTarget::REFT(_) => Some("REFT".to_string()),
            V3ParticipationIndirectTarget::RESP(_) => Some("RESP".to_string()),
            V3ParticipationIndirectTarget::RML(_) => Some("RML".to_string()),
            V3ParticipationIndirectTarget::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationIndirectTarget::SPC(_) => Some("SPC".to_string()),
            V3ParticipationIndirectTarget::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationIndirectTarget::TPA(_) => Some("TPA".to_string()),
            V3ParticipationIndirectTarget::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationIndirectTarget::TRC(_) => Some("TRC".to_string()),
            V3ParticipationIndirectTarget::VIA(_) => Some("VIA".to_string()),
            V3ParticipationIndirectTarget::VRF(_) => Some("VRF".to_string()),
            V3ParticipationIndirectTarget::WIT(_) => Some("WIT".to_string()),
            V3ParticipationIndirectTarget::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationIndirectTarget::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationIndirectTarget::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationIndirectTarget {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationIndirectTarget::ADM(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ALY(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ATND(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::AUT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::BBY(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::BEN(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CAT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CON(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::COV(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CSM(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::CST(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DEV(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DIR(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DIS(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DIST(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DON(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::DST(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ENT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ESC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::HLD(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::IND(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::INF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::LA(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::LOC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::NOT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::NRD(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::ORG(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::PART(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::PRD(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::PRF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::RCT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::RCV(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::RDV(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::REF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::REFB(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::REFT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::RESP(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::RML(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::SPC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::TPA(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::TRC(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::VIA(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::VRF(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::WIT(Some(e)) => e.get_field(field),
                V3ParticipationIndirectTarget::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationIndirectTarget::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationIndirectTarget::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationIndirectTarget::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationIndirectTarget::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationIndirectTarget::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationIndirectTarget::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationInformationGenerator {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationInformationGenerator {
    fn default() -> Self {
        V3ParticipationInformationGenerator::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationInformationGenerator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationInformationGenerator::ADM(None)),
            "ALY" => Ok(V3ParticipationInformationGenerator::ALY(None)),
            "ATND" => Ok(V3ParticipationInformationGenerator::ATND(None)),
            "AUT" => Ok(V3ParticipationInformationGenerator::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationInformationGenerator::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationInformationGenerator::BBY(None)),
            "BEN" => Ok(V3ParticipationInformationGenerator::BEN(None)),
            "CAGNT" => Ok(V3ParticipationInformationGenerator::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationInformationGenerator::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationInformationGenerator::CAT(None)),
            "CON" => Ok(V3ParticipationInformationGenerator::CON(None)),
            "COV" => Ok(V3ParticipationInformationGenerator::COV(None)),
            "CSM" => Ok(V3ParticipationInformationGenerator::CSM(None)),
            "CST" => Ok(V3ParticipationInformationGenerator::CST(None)),
            "DEV" => Ok(V3ParticipationInformationGenerator::DEV(None)),
            "DIR" => Ok(V3ParticipationInformationGenerator::DIR(None)),
            "DIS" => Ok(V3ParticipationInformationGenerator::DIS(None)),
            "DIST" => Ok(V3ParticipationInformationGenerator::DIST(None)),
            "DON" => Ok(V3ParticipationInformationGenerator::DON(None)),
            "DST" => Ok(V3ParticipationInformationGenerator::DST(None)),
            "ELOC" => Ok(V3ParticipationInformationGenerator::ELOC(None)),
            "ENT" => Ok(V3ParticipationInformationGenerator::ENT(None)),
            "ESC" => Ok(V3ParticipationInformationGenerator::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationInformationGenerator::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationInformationGenerator::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationInformationGenerator::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationInformationGenerator::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationInformationGenerator::GUAR(None)),
            "HLD" => Ok(V3ParticipationInformationGenerator::HLD(None)),
            "IND" => Ok(V3ParticipationInformationGenerator::IND(None)),
            "INF" => Ok(V3ParticipationInformationGenerator::INF(None)),
            "IRCP" => Ok(V3ParticipationInformationGenerator::IRCP(None)),
            "LA" => Ok(V3ParticipationInformationGenerator::LA(None)),
            "LOC" => Ok(V3ParticipationInformationGenerator::LOC(None)),
            "NOT" => Ok(V3ParticipationInformationGenerator::NOT(None)),
            "NRD" => Ok(V3ParticipationInformationGenerator::NRD(None)),
            "ORG" => Ok(V3ParticipationInformationGenerator::ORG(None)),
            "PART" => Ok(V3ParticipationInformationGenerator::PART(None)),
            "PPRF" => Ok(V3ParticipationInformationGenerator::PPRF(None)),
            "PRCP" => Ok(V3ParticipationInformationGenerator::PRCP(None)),
            "PRD" => Ok(V3ParticipationInformationGenerator::PRD(None)),
            "PRF" => Ok(V3ParticipationInformationGenerator::PRF(None)),
            "RCT" => Ok(V3ParticipationInformationGenerator::RCT(None)),
            "RCV" => Ok(V3ParticipationInformationGenerator::RCV(None)),
            "RDV" => Ok(V3ParticipationInformationGenerator::RDV(None)),
            "REF" => Ok(V3ParticipationInformationGenerator::REF(None)),
            "REFB" => Ok(V3ParticipationInformationGenerator::REFB(None)),
            "REFT" => Ok(V3ParticipationInformationGenerator::REFT(None)),
            "RESP" => Ok(V3ParticipationInformationGenerator::RESP(None)),
            "RML" => Ok(V3ParticipationInformationGenerator::RML(None)),
            "SBJ" => Ok(V3ParticipationInformationGenerator::SBJ(None)),
            "SPC" => Ok(V3ParticipationInformationGenerator::SPC(None)),
            "SPRF" => Ok(V3ParticipationInformationGenerator::SPRF(None)),
            "TPA" => Ok(V3ParticipationInformationGenerator::TPA(None)),
            "TRANS" => Ok(V3ParticipationInformationGenerator::TRANS(None)),
            "TRC" => Ok(V3ParticipationInformationGenerator::TRC(None)),
            "VIA" => Ok(V3ParticipationInformationGenerator::VIA(None)),
            "VRF" => Ok(V3ParticipationInformationGenerator::VRF(None)),
            "WIT" => Ok(V3ParticipationInformationGenerator::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationInformationGenerator::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationInformationGenerator::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationInformationGenerator {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationInformationGenerator::ADM(_) => Some("ADM".to_string()),
            V3ParticipationInformationGenerator::ALY(_) => Some("ALY".to_string()),
            V3ParticipationInformationGenerator::ATND(_) => Some("ATND".to_string()),
            V3ParticipationInformationGenerator::AUT(_) => Some("AUT".to_string()),
            V3ParticipationInformationGenerator::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationInformationGenerator::BBY(_) => Some("BBY".to_string()),
            V3ParticipationInformationGenerator::BEN(_) => Some("BEN".to_string()),
            V3ParticipationInformationGenerator::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationInformationGenerator::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationInformationGenerator::CAT(_) => Some("CAT".to_string()),
            V3ParticipationInformationGenerator::CON(_) => Some("CON".to_string()),
            V3ParticipationInformationGenerator::COV(_) => Some("COV".to_string()),
            V3ParticipationInformationGenerator::CSM(_) => Some("CSM".to_string()),
            V3ParticipationInformationGenerator::CST(_) => Some("CST".to_string()),
            V3ParticipationInformationGenerator::DEV(_) => Some("DEV".to_string()),
            V3ParticipationInformationGenerator::DIR(_) => Some("DIR".to_string()),
            V3ParticipationInformationGenerator::DIS(_) => Some("DIS".to_string()),
            V3ParticipationInformationGenerator::DIST(_) => Some("DIST".to_string()),
            V3ParticipationInformationGenerator::DON(_) => Some("DON".to_string()),
            V3ParticipationInformationGenerator::DST(_) => Some("DST".to_string()),
            V3ParticipationInformationGenerator::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationInformationGenerator::ENT(_) => Some("ENT".to_string()),
            V3ParticipationInformationGenerator::ESC(_) => Some("ESC".to_string()),
            V3ParticipationInformationGenerator::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationInformationGenerator::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationInformationGenerator::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationInformationGenerator::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationInformationGenerator::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationInformationGenerator::HLD(_) => Some("HLD".to_string()),
            V3ParticipationInformationGenerator::IND(_) => Some("IND".to_string()),
            V3ParticipationInformationGenerator::INF(_) => Some("INF".to_string()),
            V3ParticipationInformationGenerator::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationInformationGenerator::LA(_) => Some("LA".to_string()),
            V3ParticipationInformationGenerator::LOC(_) => Some("LOC".to_string()),
            V3ParticipationInformationGenerator::NOT(_) => Some("NOT".to_string()),
            V3ParticipationInformationGenerator::NRD(_) => Some("NRD".to_string()),
            V3ParticipationInformationGenerator::ORG(_) => Some("ORG".to_string()),
            V3ParticipationInformationGenerator::PART(_) => Some("PART".to_string()),
            V3ParticipationInformationGenerator::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationInformationGenerator::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationInformationGenerator::PRD(_) => Some("PRD".to_string()),
            V3ParticipationInformationGenerator::PRF(_) => Some("PRF".to_string()),
            V3ParticipationInformationGenerator::RCT(_) => Some("RCT".to_string()),
            V3ParticipationInformationGenerator::RCV(_) => Some("RCV".to_string()),
            V3ParticipationInformationGenerator::RDV(_) => Some("RDV".to_string()),
            V3ParticipationInformationGenerator::REF(_) => Some("REF".to_string()),
            V3ParticipationInformationGenerator::REFB(_) => Some("REFB".to_string()),
            V3ParticipationInformationGenerator::REFT(_) => Some("REFT".to_string()),
            V3ParticipationInformationGenerator::RESP(_) => Some("RESP".to_string()),
            V3ParticipationInformationGenerator::RML(_) => Some("RML".to_string()),
            V3ParticipationInformationGenerator::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationInformationGenerator::SPC(_) => Some("SPC".to_string()),
            V3ParticipationInformationGenerator::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationInformationGenerator::TPA(_) => Some("TPA".to_string()),
            V3ParticipationInformationGenerator::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationInformationGenerator::TRC(_) => Some("TRC".to_string()),
            V3ParticipationInformationGenerator::VIA(_) => Some("VIA".to_string()),
            V3ParticipationInformationGenerator::VRF(_) => Some("VRF".to_string()),
            V3ParticipationInformationGenerator::WIT(_) => Some("WIT".to_string()),
            V3ParticipationInformationGenerator::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationInformationGenerator::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationInformationGenerator::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationInformationGenerator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationInformationGenerator::ADM(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ALY(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ATND(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::AUT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::BBY(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::BEN(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CAT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CON(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::COV(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CSM(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::CST(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DEV(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DIR(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DIS(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DIST(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DON(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::DST(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ENT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ESC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::HLD(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::IND(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::INF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::LA(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::LOC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::NOT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::NRD(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::ORG(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::PART(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::PRD(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::PRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::RCT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::RCV(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::RDV(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::REF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::REFB(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::REFT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::RESP(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::RML(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::SPC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::TPA(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::TRC(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::VIA(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::VRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::WIT(Some(e)) => e.get_field(field),
                V3ParticipationInformationGenerator::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationInformationGenerator::_ParticipationInformationGenerator(Some(
                    e,
                )) => e.get_field(field),
                V3ParticipationInformationGenerator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationInformationGenerator::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationInformationGenerator::_ParticipationInformationGenerator(Some(
                    e,
                )) => e.get_field_mut(field),
                V3ParticipationInformationGenerator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationInformationTranscriber {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationInformationTranscriber {
    fn default() -> Self {
        V3ParticipationInformationTranscriber::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationInformationTranscriber {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationInformationTranscriber::ADM(None)),
            "ALY" => Ok(V3ParticipationInformationTranscriber::ALY(None)),
            "ATND" => Ok(V3ParticipationInformationTranscriber::ATND(None)),
            "AUT" => Ok(V3ParticipationInformationTranscriber::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationInformationTranscriber::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationInformationTranscriber::BBY(None)),
            "BEN" => Ok(V3ParticipationInformationTranscriber::BEN(None)),
            "CAGNT" => Ok(V3ParticipationInformationTranscriber::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationInformationTranscriber::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationInformationTranscriber::CAT(None)),
            "CON" => Ok(V3ParticipationInformationTranscriber::CON(None)),
            "COV" => Ok(V3ParticipationInformationTranscriber::COV(None)),
            "CSM" => Ok(V3ParticipationInformationTranscriber::CSM(None)),
            "CST" => Ok(V3ParticipationInformationTranscriber::CST(None)),
            "DEV" => Ok(V3ParticipationInformationTranscriber::DEV(None)),
            "DIR" => Ok(V3ParticipationInformationTranscriber::DIR(None)),
            "DIS" => Ok(V3ParticipationInformationTranscriber::DIS(None)),
            "DIST" => Ok(V3ParticipationInformationTranscriber::DIST(None)),
            "DON" => Ok(V3ParticipationInformationTranscriber::DON(None)),
            "DST" => Ok(V3ParticipationInformationTranscriber::DST(None)),
            "ELOC" => Ok(V3ParticipationInformationTranscriber::ELOC(None)),
            "ENT" => Ok(V3ParticipationInformationTranscriber::ENT(None)),
            "ESC" => Ok(V3ParticipationInformationTranscriber::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationInformationTranscriber::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationInformationTranscriber::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationInformationTranscriber::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationInformationTranscriber::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationInformationTranscriber::GUAR(None)),
            "HLD" => Ok(V3ParticipationInformationTranscriber::HLD(None)),
            "IND" => Ok(V3ParticipationInformationTranscriber::IND(None)),
            "INF" => Ok(V3ParticipationInformationTranscriber::INF(None)),
            "IRCP" => Ok(V3ParticipationInformationTranscriber::IRCP(None)),
            "LA" => Ok(V3ParticipationInformationTranscriber::LA(None)),
            "LOC" => Ok(V3ParticipationInformationTranscriber::LOC(None)),
            "NOT" => Ok(V3ParticipationInformationTranscriber::NOT(None)),
            "NRD" => Ok(V3ParticipationInformationTranscriber::NRD(None)),
            "ORG" => Ok(V3ParticipationInformationTranscriber::ORG(None)),
            "PART" => Ok(V3ParticipationInformationTranscriber::PART(None)),
            "PPRF" => Ok(V3ParticipationInformationTranscriber::PPRF(None)),
            "PRCP" => Ok(V3ParticipationInformationTranscriber::PRCP(None)),
            "PRD" => Ok(V3ParticipationInformationTranscriber::PRD(None)),
            "PRF" => Ok(V3ParticipationInformationTranscriber::PRF(None)),
            "RCT" => Ok(V3ParticipationInformationTranscriber::RCT(None)),
            "RCV" => Ok(V3ParticipationInformationTranscriber::RCV(None)),
            "RDV" => Ok(V3ParticipationInformationTranscriber::RDV(None)),
            "REF" => Ok(V3ParticipationInformationTranscriber::REF(None)),
            "REFB" => Ok(V3ParticipationInformationTranscriber::REFB(None)),
            "REFT" => Ok(V3ParticipationInformationTranscriber::REFT(None)),
            "RESP" => Ok(V3ParticipationInformationTranscriber::RESP(None)),
            "RML" => Ok(V3ParticipationInformationTranscriber::RML(None)),
            "SBJ" => Ok(V3ParticipationInformationTranscriber::SBJ(None)),
            "SPC" => Ok(V3ParticipationInformationTranscriber::SPC(None)),
            "SPRF" => Ok(V3ParticipationInformationTranscriber::SPRF(None)),
            "TPA" => Ok(V3ParticipationInformationTranscriber::TPA(None)),
            "TRANS" => Ok(V3ParticipationInformationTranscriber::TRANS(None)),
            "TRC" => Ok(V3ParticipationInformationTranscriber::TRC(None)),
            "VIA" => Ok(V3ParticipationInformationTranscriber::VIA(None)),
            "VRF" => Ok(V3ParticipationInformationTranscriber::VRF(None)),
            "WIT" => Ok(V3ParticipationInformationTranscriber::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationInformationTranscriber::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationInformationTranscriber::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationInformationTranscriber {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationInformationTranscriber::ADM(_) => Some("ADM".to_string()),
            V3ParticipationInformationTranscriber::ALY(_) => Some("ALY".to_string()),
            V3ParticipationInformationTranscriber::ATND(_) => Some("ATND".to_string()),
            V3ParticipationInformationTranscriber::AUT(_) => Some("AUT".to_string()),
            V3ParticipationInformationTranscriber::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationInformationTranscriber::BBY(_) => Some("BBY".to_string()),
            V3ParticipationInformationTranscriber::BEN(_) => Some("BEN".to_string()),
            V3ParticipationInformationTranscriber::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationInformationTranscriber::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationInformationTranscriber::CAT(_) => Some("CAT".to_string()),
            V3ParticipationInformationTranscriber::CON(_) => Some("CON".to_string()),
            V3ParticipationInformationTranscriber::COV(_) => Some("COV".to_string()),
            V3ParticipationInformationTranscriber::CSM(_) => Some("CSM".to_string()),
            V3ParticipationInformationTranscriber::CST(_) => Some("CST".to_string()),
            V3ParticipationInformationTranscriber::DEV(_) => Some("DEV".to_string()),
            V3ParticipationInformationTranscriber::DIR(_) => Some("DIR".to_string()),
            V3ParticipationInformationTranscriber::DIS(_) => Some("DIS".to_string()),
            V3ParticipationInformationTranscriber::DIST(_) => Some("DIST".to_string()),
            V3ParticipationInformationTranscriber::DON(_) => Some("DON".to_string()),
            V3ParticipationInformationTranscriber::DST(_) => Some("DST".to_string()),
            V3ParticipationInformationTranscriber::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationInformationTranscriber::ENT(_) => Some("ENT".to_string()),
            V3ParticipationInformationTranscriber::ESC(_) => Some("ESC".to_string()),
            V3ParticipationInformationTranscriber::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationInformationTranscriber::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationInformationTranscriber::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationInformationTranscriber::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationInformationTranscriber::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationInformationTranscriber::HLD(_) => Some("HLD".to_string()),
            V3ParticipationInformationTranscriber::IND(_) => Some("IND".to_string()),
            V3ParticipationInformationTranscriber::INF(_) => Some("INF".to_string()),
            V3ParticipationInformationTranscriber::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationInformationTranscriber::LA(_) => Some("LA".to_string()),
            V3ParticipationInformationTranscriber::LOC(_) => Some("LOC".to_string()),
            V3ParticipationInformationTranscriber::NOT(_) => Some("NOT".to_string()),
            V3ParticipationInformationTranscriber::NRD(_) => Some("NRD".to_string()),
            V3ParticipationInformationTranscriber::ORG(_) => Some("ORG".to_string()),
            V3ParticipationInformationTranscriber::PART(_) => Some("PART".to_string()),
            V3ParticipationInformationTranscriber::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationInformationTranscriber::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationInformationTranscriber::PRD(_) => Some("PRD".to_string()),
            V3ParticipationInformationTranscriber::PRF(_) => Some("PRF".to_string()),
            V3ParticipationInformationTranscriber::RCT(_) => Some("RCT".to_string()),
            V3ParticipationInformationTranscriber::RCV(_) => Some("RCV".to_string()),
            V3ParticipationInformationTranscriber::RDV(_) => Some("RDV".to_string()),
            V3ParticipationInformationTranscriber::REF(_) => Some("REF".to_string()),
            V3ParticipationInformationTranscriber::REFB(_) => Some("REFB".to_string()),
            V3ParticipationInformationTranscriber::REFT(_) => Some("REFT".to_string()),
            V3ParticipationInformationTranscriber::RESP(_) => Some("RESP".to_string()),
            V3ParticipationInformationTranscriber::RML(_) => Some("RML".to_string()),
            V3ParticipationInformationTranscriber::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationInformationTranscriber::SPC(_) => Some("SPC".to_string()),
            V3ParticipationInformationTranscriber::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationInformationTranscriber::TPA(_) => Some("TPA".to_string()),
            V3ParticipationInformationTranscriber::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationInformationTranscriber::TRC(_) => Some("TRC".to_string()),
            V3ParticipationInformationTranscriber::VIA(_) => Some("VIA".to_string()),
            V3ParticipationInformationTranscriber::VRF(_) => Some("VRF".to_string()),
            V3ParticipationInformationTranscriber::WIT(_) => Some("WIT".to_string()),
            V3ParticipationInformationTranscriber::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationInformationTranscriber::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationInformationTranscriber::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationInformationTranscriber {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationInformationTranscriber::ADM(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ALY(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ATND(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::AUT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::BBY(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::BEN(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CAT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CON(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::COV(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CSM(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::CST(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DEV(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DIR(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DIS(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DIST(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DON(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::DST(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ENT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ESC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::HLD(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::IND(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::INF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::LA(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::LOC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::NOT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::NRD(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::ORG(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::PART(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::PRD(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::PRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::RCT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::RCV(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::RDV(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::REF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::REFB(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::REFT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::RESP(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::RML(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::SPC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::TPA(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::TRC(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::VIA(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::VRF(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::WIT(Some(e)) => e.get_field(field),
                V3ParticipationInformationTranscriber::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationInformationTranscriber::_ParticipationInformationGenerator(
                    Some(e),
                ) => e.get_field(field),
                V3ParticipationInformationTranscriber::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationInformationTranscriber::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationInformationTranscriber::_ParticipationInformationGenerator(
                    Some(e),
                ) => e.get_field_mut(field),
                V3ParticipationInformationTranscriber::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationMode {
    #[doc = "dictated"]
    #[code = "DICTATE"]
    DICTATE(Option<Element>),
    #[doc = "electronic data"]
    #[code = "ELECTRONIC"]
    ELECTRONIC(Option<Element>),
    #[doc = "email"]
    #[code = "EMAILWRIT"]
    EMAILWRIT(Option<Element>),
    #[doc = "face-to-face"]
    #[code = "FACE"]
    FACE(Option<Element>),
    #[doc = "telefax"]
    #[code = "FAXWRIT"]
    FAXWRIT(Option<Element>),
    #[doc = "handwritten"]
    #[code = "HANDWRIT"]
    HANDWRIT(Option<Element>),
    #[doc = "mail"]
    #[code = "MAILWRIT"]
    MAILWRIT(Option<Element>),
    #[doc = "online written"]
    #[code = "ONLINEWRIT"]
    ONLINEWRIT(Option<Element>),
    #[doc = "telephone"]
    #[code = "PHONE"]
    PHONE(Option<Element>),
    #[doc = "physical presence"]
    #[code = "PHYSICAL"]
    PHYSICAL(Option<Element>),
    #[doc = "remote presence"]
    #[code = "REMOTE"]
    REMOTE(Option<Element>),
    #[doc = "typewritten"]
    #[code = "TYPEWRIT"]
    TYPEWRIT(Option<Element>),
    #[doc = "verbal"]
    #[code = "VERBAL"]
    VERBAL(Option<Element>),
    #[doc = "videoconferencing"]
    #[code = "VIDEOCONF"]
    VIDEOCONF(Option<Element>),
    #[doc = "written"]
    #[code = "WRITTEN"]
    WRITTEN(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationMode {
    fn default() -> Self {
        V3ParticipationMode::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "DICTATE" => Ok(V3ParticipationMode::DICTATE(None)),
            "ELECTRONIC" => Ok(V3ParticipationMode::ELECTRONIC(None)),
            "EMAILWRIT" => Ok(V3ParticipationMode::EMAILWRIT(None)),
            "FACE" => Ok(V3ParticipationMode::FACE(None)),
            "FAXWRIT" => Ok(V3ParticipationMode::FAXWRIT(None)),
            "HANDWRIT" => Ok(V3ParticipationMode::HANDWRIT(None)),
            "MAILWRIT" => Ok(V3ParticipationMode::MAILWRIT(None)),
            "ONLINEWRIT" => Ok(V3ParticipationMode::ONLINEWRIT(None)),
            "PHONE" => Ok(V3ParticipationMode::PHONE(None)),
            "PHYSICAL" => Ok(V3ParticipationMode::PHYSICAL(None)),
            "REMOTE" => Ok(V3ParticipationMode::REMOTE(None)),
            "TYPEWRIT" => Ok(V3ParticipationMode::TYPEWRIT(None)),
            "VERBAL" => Ok(V3ParticipationMode::VERBAL(None)),
            "VIDEOCONF" => Ok(V3ParticipationMode::VIDEOCONF(None)),
            "WRITTEN" => Ok(V3ParticipationMode::WRITTEN(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationMode {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationMode::DICTATE(_) => Some("DICTATE".to_string()),
            V3ParticipationMode::ELECTRONIC(_) => Some("ELECTRONIC".to_string()),
            V3ParticipationMode::EMAILWRIT(_) => Some("EMAILWRIT".to_string()),
            V3ParticipationMode::FACE(_) => Some("FACE".to_string()),
            V3ParticipationMode::FAXWRIT(_) => Some("FAXWRIT".to_string()),
            V3ParticipationMode::HANDWRIT(_) => Some("HANDWRIT".to_string()),
            V3ParticipationMode::MAILWRIT(_) => Some("MAILWRIT".to_string()),
            V3ParticipationMode::ONLINEWRIT(_) => Some("ONLINEWRIT".to_string()),
            V3ParticipationMode::PHONE(_) => Some("PHONE".to_string()),
            V3ParticipationMode::PHYSICAL(_) => Some("PHYSICAL".to_string()),
            V3ParticipationMode::REMOTE(_) => Some("REMOTE".to_string()),
            V3ParticipationMode::TYPEWRIT(_) => Some("TYPEWRIT".to_string()),
            V3ParticipationMode::VERBAL(_) => Some("VERBAL".to_string()),
            V3ParticipationMode::VIDEOCONF(_) => Some("VIDEOCONF".to_string()),
            V3ParticipationMode::WRITTEN(_) => Some("WRITTEN".to_string()),
            V3ParticipationMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationMode::DICTATE(Some(e)) => e.get_field(field),
                V3ParticipationMode::ELECTRONIC(Some(e)) => e.get_field(field),
                V3ParticipationMode::EMAILWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::FACE(Some(e)) => e.get_field(field),
                V3ParticipationMode::FAXWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::HANDWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::MAILWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::ONLINEWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::PHONE(Some(e)) => e.get_field(field),
                V3ParticipationMode::PHYSICAL(Some(e)) => e.get_field(field),
                V3ParticipationMode::REMOTE(Some(e)) => e.get_field(field),
                V3ParticipationMode::TYPEWRIT(Some(e)) => e.get_field(field),
                V3ParticipationMode::VERBAL(Some(e)) => e.get_field(field),
                V3ParticipationMode::VIDEOCONF(Some(e)) => e.get_field(field),
                V3ParticipationMode::WRITTEN(Some(e)) => e.get_field(field),
                V3ParticipationMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationMode::DICTATE(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::ELECTRONIC(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::EMAILWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::FACE(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::FAXWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::HANDWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::MAILWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::ONLINEWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::PHONE(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::PHYSICAL(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::REMOTE(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::TYPEWRIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::VERBAL(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::VIDEOCONF(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::WRITTEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationPhysicalPerformer {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationPhysicalPerformer {
    fn default() -> Self {
        V3ParticipationPhysicalPerformer::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationPhysicalPerformer {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationPhysicalPerformer::ADM(None)),
            "ALY" => Ok(V3ParticipationPhysicalPerformer::ALY(None)),
            "ATND" => Ok(V3ParticipationPhysicalPerformer::ATND(None)),
            "AUT" => Ok(V3ParticipationPhysicalPerformer::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationPhysicalPerformer::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationPhysicalPerformer::BBY(None)),
            "BEN" => Ok(V3ParticipationPhysicalPerformer::BEN(None)),
            "CAGNT" => Ok(V3ParticipationPhysicalPerformer::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationPhysicalPerformer::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationPhysicalPerformer::CAT(None)),
            "CON" => Ok(V3ParticipationPhysicalPerformer::CON(None)),
            "COV" => Ok(V3ParticipationPhysicalPerformer::COV(None)),
            "CSM" => Ok(V3ParticipationPhysicalPerformer::CSM(None)),
            "CST" => Ok(V3ParticipationPhysicalPerformer::CST(None)),
            "DEV" => Ok(V3ParticipationPhysicalPerformer::DEV(None)),
            "DIR" => Ok(V3ParticipationPhysicalPerformer::DIR(None)),
            "DIS" => Ok(V3ParticipationPhysicalPerformer::DIS(None)),
            "DIST" => Ok(V3ParticipationPhysicalPerformer::DIST(None)),
            "DON" => Ok(V3ParticipationPhysicalPerformer::DON(None)),
            "DST" => Ok(V3ParticipationPhysicalPerformer::DST(None)),
            "ELOC" => Ok(V3ParticipationPhysicalPerformer::ELOC(None)),
            "ENT" => Ok(V3ParticipationPhysicalPerformer::ENT(None)),
            "ESC" => Ok(V3ParticipationPhysicalPerformer::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationPhysicalPerformer::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationPhysicalPerformer::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationPhysicalPerformer::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationPhysicalPerformer::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationPhysicalPerformer::GUAR(None)),
            "HLD" => Ok(V3ParticipationPhysicalPerformer::HLD(None)),
            "IND" => Ok(V3ParticipationPhysicalPerformer::IND(None)),
            "INF" => Ok(V3ParticipationPhysicalPerformer::INF(None)),
            "IRCP" => Ok(V3ParticipationPhysicalPerformer::IRCP(None)),
            "LA" => Ok(V3ParticipationPhysicalPerformer::LA(None)),
            "LOC" => Ok(V3ParticipationPhysicalPerformer::LOC(None)),
            "NOT" => Ok(V3ParticipationPhysicalPerformer::NOT(None)),
            "NRD" => Ok(V3ParticipationPhysicalPerformer::NRD(None)),
            "ORG" => Ok(V3ParticipationPhysicalPerformer::ORG(None)),
            "PART" => Ok(V3ParticipationPhysicalPerformer::PART(None)),
            "PPRF" => Ok(V3ParticipationPhysicalPerformer::PPRF(None)),
            "PRCP" => Ok(V3ParticipationPhysicalPerformer::PRCP(None)),
            "PRD" => Ok(V3ParticipationPhysicalPerformer::PRD(None)),
            "PRF" => Ok(V3ParticipationPhysicalPerformer::PRF(None)),
            "RCT" => Ok(V3ParticipationPhysicalPerformer::RCT(None)),
            "RCV" => Ok(V3ParticipationPhysicalPerformer::RCV(None)),
            "RDV" => Ok(V3ParticipationPhysicalPerformer::RDV(None)),
            "REF" => Ok(V3ParticipationPhysicalPerformer::REF(None)),
            "REFB" => Ok(V3ParticipationPhysicalPerformer::REFB(None)),
            "REFT" => Ok(V3ParticipationPhysicalPerformer::REFT(None)),
            "RESP" => Ok(V3ParticipationPhysicalPerformer::RESP(None)),
            "RML" => Ok(V3ParticipationPhysicalPerformer::RML(None)),
            "SBJ" => Ok(V3ParticipationPhysicalPerformer::SBJ(None)),
            "SPC" => Ok(V3ParticipationPhysicalPerformer::SPC(None)),
            "SPRF" => Ok(V3ParticipationPhysicalPerformer::SPRF(None)),
            "TPA" => Ok(V3ParticipationPhysicalPerformer::TPA(None)),
            "TRANS" => Ok(V3ParticipationPhysicalPerformer::TRANS(None)),
            "TRC" => Ok(V3ParticipationPhysicalPerformer::TRC(None)),
            "VIA" => Ok(V3ParticipationPhysicalPerformer::VIA(None)),
            "VRF" => Ok(V3ParticipationPhysicalPerformer::VRF(None)),
            "WIT" => Ok(V3ParticipationPhysicalPerformer::WIT(None)),
            "_ParticipationAncillary" => Ok(
                V3ParticipationPhysicalPerformer::_ParticipationAncillary(None),
            ),
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationPhysicalPerformer::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationPhysicalPerformer {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationPhysicalPerformer::ADM(_) => Some("ADM".to_string()),
            V3ParticipationPhysicalPerformer::ALY(_) => Some("ALY".to_string()),
            V3ParticipationPhysicalPerformer::ATND(_) => Some("ATND".to_string()),
            V3ParticipationPhysicalPerformer::AUT(_) => Some("AUT".to_string()),
            V3ParticipationPhysicalPerformer::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationPhysicalPerformer::BBY(_) => Some("BBY".to_string()),
            V3ParticipationPhysicalPerformer::BEN(_) => Some("BEN".to_string()),
            V3ParticipationPhysicalPerformer::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationPhysicalPerformer::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationPhysicalPerformer::CAT(_) => Some("CAT".to_string()),
            V3ParticipationPhysicalPerformer::CON(_) => Some("CON".to_string()),
            V3ParticipationPhysicalPerformer::COV(_) => Some("COV".to_string()),
            V3ParticipationPhysicalPerformer::CSM(_) => Some("CSM".to_string()),
            V3ParticipationPhysicalPerformer::CST(_) => Some("CST".to_string()),
            V3ParticipationPhysicalPerformer::DEV(_) => Some("DEV".to_string()),
            V3ParticipationPhysicalPerformer::DIR(_) => Some("DIR".to_string()),
            V3ParticipationPhysicalPerformer::DIS(_) => Some("DIS".to_string()),
            V3ParticipationPhysicalPerformer::DIST(_) => Some("DIST".to_string()),
            V3ParticipationPhysicalPerformer::DON(_) => Some("DON".to_string()),
            V3ParticipationPhysicalPerformer::DST(_) => Some("DST".to_string()),
            V3ParticipationPhysicalPerformer::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationPhysicalPerformer::ENT(_) => Some("ENT".to_string()),
            V3ParticipationPhysicalPerformer::ESC(_) => Some("ESC".to_string()),
            V3ParticipationPhysicalPerformer::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationPhysicalPerformer::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationPhysicalPerformer::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationPhysicalPerformer::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationPhysicalPerformer::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationPhysicalPerformer::HLD(_) => Some("HLD".to_string()),
            V3ParticipationPhysicalPerformer::IND(_) => Some("IND".to_string()),
            V3ParticipationPhysicalPerformer::INF(_) => Some("INF".to_string()),
            V3ParticipationPhysicalPerformer::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationPhysicalPerformer::LA(_) => Some("LA".to_string()),
            V3ParticipationPhysicalPerformer::LOC(_) => Some("LOC".to_string()),
            V3ParticipationPhysicalPerformer::NOT(_) => Some("NOT".to_string()),
            V3ParticipationPhysicalPerformer::NRD(_) => Some("NRD".to_string()),
            V3ParticipationPhysicalPerformer::ORG(_) => Some("ORG".to_string()),
            V3ParticipationPhysicalPerformer::PART(_) => Some("PART".to_string()),
            V3ParticipationPhysicalPerformer::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationPhysicalPerformer::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationPhysicalPerformer::PRD(_) => Some("PRD".to_string()),
            V3ParticipationPhysicalPerformer::PRF(_) => Some("PRF".to_string()),
            V3ParticipationPhysicalPerformer::RCT(_) => Some("RCT".to_string()),
            V3ParticipationPhysicalPerformer::RCV(_) => Some("RCV".to_string()),
            V3ParticipationPhysicalPerformer::RDV(_) => Some("RDV".to_string()),
            V3ParticipationPhysicalPerformer::REF(_) => Some("REF".to_string()),
            V3ParticipationPhysicalPerformer::REFB(_) => Some("REFB".to_string()),
            V3ParticipationPhysicalPerformer::REFT(_) => Some("REFT".to_string()),
            V3ParticipationPhysicalPerformer::RESP(_) => Some("RESP".to_string()),
            V3ParticipationPhysicalPerformer::RML(_) => Some("RML".to_string()),
            V3ParticipationPhysicalPerformer::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationPhysicalPerformer::SPC(_) => Some("SPC".to_string()),
            V3ParticipationPhysicalPerformer::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationPhysicalPerformer::TPA(_) => Some("TPA".to_string()),
            V3ParticipationPhysicalPerformer::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationPhysicalPerformer::TRC(_) => Some("TRC".to_string()),
            V3ParticipationPhysicalPerformer::VIA(_) => Some("VIA".to_string()),
            V3ParticipationPhysicalPerformer::VRF(_) => Some("VRF".to_string()),
            V3ParticipationPhysicalPerformer::WIT(_) => Some("WIT".to_string()),
            V3ParticipationPhysicalPerformer::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationPhysicalPerformer::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationPhysicalPerformer::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationPhysicalPerformer {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationPhysicalPerformer::ADM(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ALY(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ATND(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::AUT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::BBY(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::BEN(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CAT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CON(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::COV(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CSM(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::CST(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DEV(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DIR(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DIS(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DIST(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DON(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::DST(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ENT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ESC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::HLD(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::IND(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::INF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::LA(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::LOC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::NOT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::NRD(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::ORG(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::PART(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::PRD(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::PRF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::RCT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::RCV(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::RDV(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::REF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::REFB(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::REFT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::RESP(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::RML(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::SPC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::TPA(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::TRC(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::VIA(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::VRF(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::WIT(Some(e)) => e.get_field(field),
                V3ParticipationPhysicalPerformer::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationPhysicalPerformer::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationPhysicalPerformer::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationPhysicalPerformer::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationPhysicalPerformer::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationPhysicalPerformer::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationPhysicalPerformer::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationSignature {
    #[doc = "intended"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "signed"]
    #[code = "S"]
    S(Option<Element>),
    #[doc = "required"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationSignature {
    fn default() -> Self {
        V3ParticipationSignature::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationSignature {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "I" => Ok(V3ParticipationSignature::I(None)),
            "S" => Ok(V3ParticipationSignature::S(None)),
            "X" => Ok(V3ParticipationSignature::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationSignature {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationSignature::I(_) => Some("I".to_string()),
            V3ParticipationSignature::S(_) => Some("S".to_string()),
            V3ParticipationSignature::X(_) => Some("X".to_string()),
            V3ParticipationSignature::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationSignature {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationSignature::I(Some(e)) => e.get_field(field),
                V3ParticipationSignature::S(Some(e)) => e.get_field(field),
                V3ParticipationSignature::X(Some(e)) => e.get_field(field),
                V3ParticipationSignature::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationSignature::I(Some(e)) => e.get_field_mut(field),
                V3ParticipationSignature::S(Some(e)) => e.get_field_mut(field),
                V3ParticipationSignature::X(Some(e)) => e.get_field_mut(field),
                V3ParticipationSignature::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationTargetDirect {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationTargetDirect {
    fn default() -> Self {
        V3ParticipationTargetDirect::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationTargetDirect {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationTargetDirect::ADM(None)),
            "ALY" => Ok(V3ParticipationTargetDirect::ALY(None)),
            "ATND" => Ok(V3ParticipationTargetDirect::ATND(None)),
            "AUT" => Ok(V3ParticipationTargetDirect::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationTargetDirect::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationTargetDirect::BBY(None)),
            "BEN" => Ok(V3ParticipationTargetDirect::BEN(None)),
            "CAGNT" => Ok(V3ParticipationTargetDirect::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationTargetDirect::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationTargetDirect::CAT(None)),
            "CON" => Ok(V3ParticipationTargetDirect::CON(None)),
            "COV" => Ok(V3ParticipationTargetDirect::COV(None)),
            "CSM" => Ok(V3ParticipationTargetDirect::CSM(None)),
            "CST" => Ok(V3ParticipationTargetDirect::CST(None)),
            "DEV" => Ok(V3ParticipationTargetDirect::DEV(None)),
            "DIR" => Ok(V3ParticipationTargetDirect::DIR(None)),
            "DIS" => Ok(V3ParticipationTargetDirect::DIS(None)),
            "DIST" => Ok(V3ParticipationTargetDirect::DIST(None)),
            "DON" => Ok(V3ParticipationTargetDirect::DON(None)),
            "DST" => Ok(V3ParticipationTargetDirect::DST(None)),
            "ELOC" => Ok(V3ParticipationTargetDirect::ELOC(None)),
            "ENT" => Ok(V3ParticipationTargetDirect::ENT(None)),
            "ESC" => Ok(V3ParticipationTargetDirect::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationTargetDirect::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationTargetDirect::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationTargetDirect::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationTargetDirect::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationTargetDirect::GUAR(None)),
            "HLD" => Ok(V3ParticipationTargetDirect::HLD(None)),
            "IND" => Ok(V3ParticipationTargetDirect::IND(None)),
            "INF" => Ok(V3ParticipationTargetDirect::INF(None)),
            "IRCP" => Ok(V3ParticipationTargetDirect::IRCP(None)),
            "LA" => Ok(V3ParticipationTargetDirect::LA(None)),
            "LOC" => Ok(V3ParticipationTargetDirect::LOC(None)),
            "NOT" => Ok(V3ParticipationTargetDirect::NOT(None)),
            "NRD" => Ok(V3ParticipationTargetDirect::NRD(None)),
            "ORG" => Ok(V3ParticipationTargetDirect::ORG(None)),
            "PART" => Ok(V3ParticipationTargetDirect::PART(None)),
            "PPRF" => Ok(V3ParticipationTargetDirect::PPRF(None)),
            "PRCP" => Ok(V3ParticipationTargetDirect::PRCP(None)),
            "PRD" => Ok(V3ParticipationTargetDirect::PRD(None)),
            "PRF" => Ok(V3ParticipationTargetDirect::PRF(None)),
            "RCT" => Ok(V3ParticipationTargetDirect::RCT(None)),
            "RCV" => Ok(V3ParticipationTargetDirect::RCV(None)),
            "RDV" => Ok(V3ParticipationTargetDirect::RDV(None)),
            "REF" => Ok(V3ParticipationTargetDirect::REF(None)),
            "REFB" => Ok(V3ParticipationTargetDirect::REFB(None)),
            "REFT" => Ok(V3ParticipationTargetDirect::REFT(None)),
            "RESP" => Ok(V3ParticipationTargetDirect::RESP(None)),
            "RML" => Ok(V3ParticipationTargetDirect::RML(None)),
            "SBJ" => Ok(V3ParticipationTargetDirect::SBJ(None)),
            "SPC" => Ok(V3ParticipationTargetDirect::SPC(None)),
            "SPRF" => Ok(V3ParticipationTargetDirect::SPRF(None)),
            "TPA" => Ok(V3ParticipationTargetDirect::TPA(None)),
            "TRANS" => Ok(V3ParticipationTargetDirect::TRANS(None)),
            "TRC" => Ok(V3ParticipationTargetDirect::TRC(None)),
            "VIA" => Ok(V3ParticipationTargetDirect::VIA(None)),
            "VRF" => Ok(V3ParticipationTargetDirect::VRF(None)),
            "WIT" => Ok(V3ParticipationTargetDirect::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationTargetDirect::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationTargetDirect::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationTargetDirect {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationTargetDirect::ADM(_) => Some("ADM".to_string()),
            V3ParticipationTargetDirect::ALY(_) => Some("ALY".to_string()),
            V3ParticipationTargetDirect::ATND(_) => Some("ATND".to_string()),
            V3ParticipationTargetDirect::AUT(_) => Some("AUT".to_string()),
            V3ParticipationTargetDirect::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationTargetDirect::BBY(_) => Some("BBY".to_string()),
            V3ParticipationTargetDirect::BEN(_) => Some("BEN".to_string()),
            V3ParticipationTargetDirect::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationTargetDirect::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationTargetDirect::CAT(_) => Some("CAT".to_string()),
            V3ParticipationTargetDirect::CON(_) => Some("CON".to_string()),
            V3ParticipationTargetDirect::COV(_) => Some("COV".to_string()),
            V3ParticipationTargetDirect::CSM(_) => Some("CSM".to_string()),
            V3ParticipationTargetDirect::CST(_) => Some("CST".to_string()),
            V3ParticipationTargetDirect::DEV(_) => Some("DEV".to_string()),
            V3ParticipationTargetDirect::DIR(_) => Some("DIR".to_string()),
            V3ParticipationTargetDirect::DIS(_) => Some("DIS".to_string()),
            V3ParticipationTargetDirect::DIST(_) => Some("DIST".to_string()),
            V3ParticipationTargetDirect::DON(_) => Some("DON".to_string()),
            V3ParticipationTargetDirect::DST(_) => Some("DST".to_string()),
            V3ParticipationTargetDirect::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationTargetDirect::ENT(_) => Some("ENT".to_string()),
            V3ParticipationTargetDirect::ESC(_) => Some("ESC".to_string()),
            V3ParticipationTargetDirect::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationTargetDirect::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationTargetDirect::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationTargetDirect::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationTargetDirect::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationTargetDirect::HLD(_) => Some("HLD".to_string()),
            V3ParticipationTargetDirect::IND(_) => Some("IND".to_string()),
            V3ParticipationTargetDirect::INF(_) => Some("INF".to_string()),
            V3ParticipationTargetDirect::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationTargetDirect::LA(_) => Some("LA".to_string()),
            V3ParticipationTargetDirect::LOC(_) => Some("LOC".to_string()),
            V3ParticipationTargetDirect::NOT(_) => Some("NOT".to_string()),
            V3ParticipationTargetDirect::NRD(_) => Some("NRD".to_string()),
            V3ParticipationTargetDirect::ORG(_) => Some("ORG".to_string()),
            V3ParticipationTargetDirect::PART(_) => Some("PART".to_string()),
            V3ParticipationTargetDirect::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationTargetDirect::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationTargetDirect::PRD(_) => Some("PRD".to_string()),
            V3ParticipationTargetDirect::PRF(_) => Some("PRF".to_string()),
            V3ParticipationTargetDirect::RCT(_) => Some("RCT".to_string()),
            V3ParticipationTargetDirect::RCV(_) => Some("RCV".to_string()),
            V3ParticipationTargetDirect::RDV(_) => Some("RDV".to_string()),
            V3ParticipationTargetDirect::REF(_) => Some("REF".to_string()),
            V3ParticipationTargetDirect::REFB(_) => Some("REFB".to_string()),
            V3ParticipationTargetDirect::REFT(_) => Some("REFT".to_string()),
            V3ParticipationTargetDirect::RESP(_) => Some("RESP".to_string()),
            V3ParticipationTargetDirect::RML(_) => Some("RML".to_string()),
            V3ParticipationTargetDirect::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationTargetDirect::SPC(_) => Some("SPC".to_string()),
            V3ParticipationTargetDirect::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationTargetDirect::TPA(_) => Some("TPA".to_string()),
            V3ParticipationTargetDirect::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationTargetDirect::TRC(_) => Some("TRC".to_string()),
            V3ParticipationTargetDirect::VIA(_) => Some("VIA".to_string()),
            V3ParticipationTargetDirect::VRF(_) => Some("VRF".to_string()),
            V3ParticipationTargetDirect::WIT(_) => Some("WIT".to_string()),
            V3ParticipationTargetDirect::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationTargetDirect::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationTargetDirect::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationTargetDirect {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationTargetDirect::ADM(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ALY(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ATND(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::AUT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::BBY(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::BEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CAT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CON(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::COV(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CSM(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::CST(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DEV(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DIR(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DIS(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DIST(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DON(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::DST(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ENT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ESC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::HLD(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::IND(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::INF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::LA(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::LOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::NOT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::NRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::ORG(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::PART(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::PRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::PRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::RCT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::RCV(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::RDV(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::REF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::REFB(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::REFT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::RESP(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::RML(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::SPC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::TPA(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::TRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::VIA(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::VRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::WIT(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::_ParticipationAncillary(Some(e)) => e.get_field(field),
                V3ParticipationTargetDirect::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationTargetDirect::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationTargetDirect::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetDirect::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetDirect::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetDirect::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationTargetLocation {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationTargetLocation {
    fn default() -> Self {
        V3ParticipationTargetLocation::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationTargetLocation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationTargetLocation::ADM(None)),
            "ALY" => Ok(V3ParticipationTargetLocation::ALY(None)),
            "ATND" => Ok(V3ParticipationTargetLocation::ATND(None)),
            "AUT" => Ok(V3ParticipationTargetLocation::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationTargetLocation::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationTargetLocation::BBY(None)),
            "BEN" => Ok(V3ParticipationTargetLocation::BEN(None)),
            "CAGNT" => Ok(V3ParticipationTargetLocation::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationTargetLocation::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationTargetLocation::CAT(None)),
            "CON" => Ok(V3ParticipationTargetLocation::CON(None)),
            "COV" => Ok(V3ParticipationTargetLocation::COV(None)),
            "CSM" => Ok(V3ParticipationTargetLocation::CSM(None)),
            "CST" => Ok(V3ParticipationTargetLocation::CST(None)),
            "DEV" => Ok(V3ParticipationTargetLocation::DEV(None)),
            "DIR" => Ok(V3ParticipationTargetLocation::DIR(None)),
            "DIS" => Ok(V3ParticipationTargetLocation::DIS(None)),
            "DIST" => Ok(V3ParticipationTargetLocation::DIST(None)),
            "DON" => Ok(V3ParticipationTargetLocation::DON(None)),
            "DST" => Ok(V3ParticipationTargetLocation::DST(None)),
            "ELOC" => Ok(V3ParticipationTargetLocation::ELOC(None)),
            "ENT" => Ok(V3ParticipationTargetLocation::ENT(None)),
            "ESC" => Ok(V3ParticipationTargetLocation::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationTargetLocation::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationTargetLocation::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationTargetLocation::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationTargetLocation::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationTargetLocation::GUAR(None)),
            "HLD" => Ok(V3ParticipationTargetLocation::HLD(None)),
            "IND" => Ok(V3ParticipationTargetLocation::IND(None)),
            "INF" => Ok(V3ParticipationTargetLocation::INF(None)),
            "IRCP" => Ok(V3ParticipationTargetLocation::IRCP(None)),
            "LA" => Ok(V3ParticipationTargetLocation::LA(None)),
            "LOC" => Ok(V3ParticipationTargetLocation::LOC(None)),
            "NOT" => Ok(V3ParticipationTargetLocation::NOT(None)),
            "NRD" => Ok(V3ParticipationTargetLocation::NRD(None)),
            "ORG" => Ok(V3ParticipationTargetLocation::ORG(None)),
            "PART" => Ok(V3ParticipationTargetLocation::PART(None)),
            "PPRF" => Ok(V3ParticipationTargetLocation::PPRF(None)),
            "PRCP" => Ok(V3ParticipationTargetLocation::PRCP(None)),
            "PRD" => Ok(V3ParticipationTargetLocation::PRD(None)),
            "PRF" => Ok(V3ParticipationTargetLocation::PRF(None)),
            "RCT" => Ok(V3ParticipationTargetLocation::RCT(None)),
            "RCV" => Ok(V3ParticipationTargetLocation::RCV(None)),
            "RDV" => Ok(V3ParticipationTargetLocation::RDV(None)),
            "REF" => Ok(V3ParticipationTargetLocation::REF(None)),
            "REFB" => Ok(V3ParticipationTargetLocation::REFB(None)),
            "REFT" => Ok(V3ParticipationTargetLocation::REFT(None)),
            "RESP" => Ok(V3ParticipationTargetLocation::RESP(None)),
            "RML" => Ok(V3ParticipationTargetLocation::RML(None)),
            "SBJ" => Ok(V3ParticipationTargetLocation::SBJ(None)),
            "SPC" => Ok(V3ParticipationTargetLocation::SPC(None)),
            "SPRF" => Ok(V3ParticipationTargetLocation::SPRF(None)),
            "TPA" => Ok(V3ParticipationTargetLocation::TPA(None)),
            "TRANS" => Ok(V3ParticipationTargetLocation::TRANS(None)),
            "TRC" => Ok(V3ParticipationTargetLocation::TRC(None)),
            "VIA" => Ok(V3ParticipationTargetLocation::VIA(None)),
            "VRF" => Ok(V3ParticipationTargetLocation::VRF(None)),
            "WIT" => Ok(V3ParticipationTargetLocation::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationTargetLocation::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationTargetLocation::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationTargetLocation {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationTargetLocation::ADM(_) => Some("ADM".to_string()),
            V3ParticipationTargetLocation::ALY(_) => Some("ALY".to_string()),
            V3ParticipationTargetLocation::ATND(_) => Some("ATND".to_string()),
            V3ParticipationTargetLocation::AUT(_) => Some("AUT".to_string()),
            V3ParticipationTargetLocation::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationTargetLocation::BBY(_) => Some("BBY".to_string()),
            V3ParticipationTargetLocation::BEN(_) => Some("BEN".to_string()),
            V3ParticipationTargetLocation::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationTargetLocation::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationTargetLocation::CAT(_) => Some("CAT".to_string()),
            V3ParticipationTargetLocation::CON(_) => Some("CON".to_string()),
            V3ParticipationTargetLocation::COV(_) => Some("COV".to_string()),
            V3ParticipationTargetLocation::CSM(_) => Some("CSM".to_string()),
            V3ParticipationTargetLocation::CST(_) => Some("CST".to_string()),
            V3ParticipationTargetLocation::DEV(_) => Some("DEV".to_string()),
            V3ParticipationTargetLocation::DIR(_) => Some("DIR".to_string()),
            V3ParticipationTargetLocation::DIS(_) => Some("DIS".to_string()),
            V3ParticipationTargetLocation::DIST(_) => Some("DIST".to_string()),
            V3ParticipationTargetLocation::DON(_) => Some("DON".to_string()),
            V3ParticipationTargetLocation::DST(_) => Some("DST".to_string()),
            V3ParticipationTargetLocation::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationTargetLocation::ENT(_) => Some("ENT".to_string()),
            V3ParticipationTargetLocation::ESC(_) => Some("ESC".to_string()),
            V3ParticipationTargetLocation::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationTargetLocation::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationTargetLocation::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationTargetLocation::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationTargetLocation::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationTargetLocation::HLD(_) => Some("HLD".to_string()),
            V3ParticipationTargetLocation::IND(_) => Some("IND".to_string()),
            V3ParticipationTargetLocation::INF(_) => Some("INF".to_string()),
            V3ParticipationTargetLocation::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationTargetLocation::LA(_) => Some("LA".to_string()),
            V3ParticipationTargetLocation::LOC(_) => Some("LOC".to_string()),
            V3ParticipationTargetLocation::NOT(_) => Some("NOT".to_string()),
            V3ParticipationTargetLocation::NRD(_) => Some("NRD".to_string()),
            V3ParticipationTargetLocation::ORG(_) => Some("ORG".to_string()),
            V3ParticipationTargetLocation::PART(_) => Some("PART".to_string()),
            V3ParticipationTargetLocation::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationTargetLocation::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationTargetLocation::PRD(_) => Some("PRD".to_string()),
            V3ParticipationTargetLocation::PRF(_) => Some("PRF".to_string()),
            V3ParticipationTargetLocation::RCT(_) => Some("RCT".to_string()),
            V3ParticipationTargetLocation::RCV(_) => Some("RCV".to_string()),
            V3ParticipationTargetLocation::RDV(_) => Some("RDV".to_string()),
            V3ParticipationTargetLocation::REF(_) => Some("REF".to_string()),
            V3ParticipationTargetLocation::REFB(_) => Some("REFB".to_string()),
            V3ParticipationTargetLocation::REFT(_) => Some("REFT".to_string()),
            V3ParticipationTargetLocation::RESP(_) => Some("RESP".to_string()),
            V3ParticipationTargetLocation::RML(_) => Some("RML".to_string()),
            V3ParticipationTargetLocation::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationTargetLocation::SPC(_) => Some("SPC".to_string()),
            V3ParticipationTargetLocation::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationTargetLocation::TPA(_) => Some("TPA".to_string()),
            V3ParticipationTargetLocation::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationTargetLocation::TRC(_) => Some("TRC".to_string()),
            V3ParticipationTargetLocation::VIA(_) => Some("VIA".to_string()),
            V3ParticipationTargetLocation::VRF(_) => Some("VRF".to_string()),
            V3ParticipationTargetLocation::WIT(_) => Some("WIT".to_string()),
            V3ParticipationTargetLocation::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationTargetLocation::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationTargetLocation::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationTargetLocation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationTargetLocation::ADM(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ALY(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ATND(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::AUT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::BBY(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::BEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CAT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CON(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::COV(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CSM(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::CST(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DEV(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DIR(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DIS(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DIST(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DON(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::DST(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ENT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ESC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::HLD(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::IND(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::INF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::LA(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::LOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::NOT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::NRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::ORG(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::PART(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::PRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::PRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::RCT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::RCV(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::RDV(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::REF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::REFB(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::REFT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::RESP(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::RML(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::SPC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::TPA(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::TRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::VIA(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::VRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::WIT(Some(e)) => e.get_field(field),
                V3ParticipationTargetLocation::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationTargetLocation::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationTargetLocation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationTargetLocation::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetLocation::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetLocation::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetLocation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationTargetSubject {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationTargetSubject {
    fn default() -> Self {
        V3ParticipationTargetSubject::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationTargetSubject {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationTargetSubject::ADM(None)),
            "ALY" => Ok(V3ParticipationTargetSubject::ALY(None)),
            "ATND" => Ok(V3ParticipationTargetSubject::ATND(None)),
            "AUT" => Ok(V3ParticipationTargetSubject::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationTargetSubject::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationTargetSubject::BBY(None)),
            "BEN" => Ok(V3ParticipationTargetSubject::BEN(None)),
            "CAGNT" => Ok(V3ParticipationTargetSubject::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationTargetSubject::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationTargetSubject::CAT(None)),
            "CON" => Ok(V3ParticipationTargetSubject::CON(None)),
            "COV" => Ok(V3ParticipationTargetSubject::COV(None)),
            "CSM" => Ok(V3ParticipationTargetSubject::CSM(None)),
            "CST" => Ok(V3ParticipationTargetSubject::CST(None)),
            "DEV" => Ok(V3ParticipationTargetSubject::DEV(None)),
            "DIR" => Ok(V3ParticipationTargetSubject::DIR(None)),
            "DIS" => Ok(V3ParticipationTargetSubject::DIS(None)),
            "DIST" => Ok(V3ParticipationTargetSubject::DIST(None)),
            "DON" => Ok(V3ParticipationTargetSubject::DON(None)),
            "DST" => Ok(V3ParticipationTargetSubject::DST(None)),
            "ELOC" => Ok(V3ParticipationTargetSubject::ELOC(None)),
            "ENT" => Ok(V3ParticipationTargetSubject::ENT(None)),
            "ESC" => Ok(V3ParticipationTargetSubject::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationTargetSubject::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationTargetSubject::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationTargetSubject::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationTargetSubject::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationTargetSubject::GUAR(None)),
            "HLD" => Ok(V3ParticipationTargetSubject::HLD(None)),
            "IND" => Ok(V3ParticipationTargetSubject::IND(None)),
            "INF" => Ok(V3ParticipationTargetSubject::INF(None)),
            "IRCP" => Ok(V3ParticipationTargetSubject::IRCP(None)),
            "LA" => Ok(V3ParticipationTargetSubject::LA(None)),
            "LOC" => Ok(V3ParticipationTargetSubject::LOC(None)),
            "NOT" => Ok(V3ParticipationTargetSubject::NOT(None)),
            "NRD" => Ok(V3ParticipationTargetSubject::NRD(None)),
            "ORG" => Ok(V3ParticipationTargetSubject::ORG(None)),
            "PART" => Ok(V3ParticipationTargetSubject::PART(None)),
            "PPRF" => Ok(V3ParticipationTargetSubject::PPRF(None)),
            "PRCP" => Ok(V3ParticipationTargetSubject::PRCP(None)),
            "PRD" => Ok(V3ParticipationTargetSubject::PRD(None)),
            "PRF" => Ok(V3ParticipationTargetSubject::PRF(None)),
            "RCT" => Ok(V3ParticipationTargetSubject::RCT(None)),
            "RCV" => Ok(V3ParticipationTargetSubject::RCV(None)),
            "RDV" => Ok(V3ParticipationTargetSubject::RDV(None)),
            "REF" => Ok(V3ParticipationTargetSubject::REF(None)),
            "REFB" => Ok(V3ParticipationTargetSubject::REFB(None)),
            "REFT" => Ok(V3ParticipationTargetSubject::REFT(None)),
            "RESP" => Ok(V3ParticipationTargetSubject::RESP(None)),
            "RML" => Ok(V3ParticipationTargetSubject::RML(None)),
            "SBJ" => Ok(V3ParticipationTargetSubject::SBJ(None)),
            "SPC" => Ok(V3ParticipationTargetSubject::SPC(None)),
            "SPRF" => Ok(V3ParticipationTargetSubject::SPRF(None)),
            "TPA" => Ok(V3ParticipationTargetSubject::TPA(None)),
            "TRANS" => Ok(V3ParticipationTargetSubject::TRANS(None)),
            "TRC" => Ok(V3ParticipationTargetSubject::TRC(None)),
            "VIA" => Ok(V3ParticipationTargetSubject::VIA(None)),
            "VRF" => Ok(V3ParticipationTargetSubject::VRF(None)),
            "WIT" => Ok(V3ParticipationTargetSubject::WIT(None)),
            "_ParticipationAncillary" => {
                Ok(V3ParticipationTargetSubject::_ParticipationAncillary(None))
            }
            "_ParticipationInformationGenerator" => {
                Ok(V3ParticipationTargetSubject::_ParticipationInformationGenerator(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationTargetSubject {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationTargetSubject::ADM(_) => Some("ADM".to_string()),
            V3ParticipationTargetSubject::ALY(_) => Some("ALY".to_string()),
            V3ParticipationTargetSubject::ATND(_) => Some("ATND".to_string()),
            V3ParticipationTargetSubject::AUT(_) => Some("AUT".to_string()),
            V3ParticipationTargetSubject::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationTargetSubject::BBY(_) => Some("BBY".to_string()),
            V3ParticipationTargetSubject::BEN(_) => Some("BEN".to_string()),
            V3ParticipationTargetSubject::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationTargetSubject::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationTargetSubject::CAT(_) => Some("CAT".to_string()),
            V3ParticipationTargetSubject::CON(_) => Some("CON".to_string()),
            V3ParticipationTargetSubject::COV(_) => Some("COV".to_string()),
            V3ParticipationTargetSubject::CSM(_) => Some("CSM".to_string()),
            V3ParticipationTargetSubject::CST(_) => Some("CST".to_string()),
            V3ParticipationTargetSubject::DEV(_) => Some("DEV".to_string()),
            V3ParticipationTargetSubject::DIR(_) => Some("DIR".to_string()),
            V3ParticipationTargetSubject::DIS(_) => Some("DIS".to_string()),
            V3ParticipationTargetSubject::DIST(_) => Some("DIST".to_string()),
            V3ParticipationTargetSubject::DON(_) => Some("DON".to_string()),
            V3ParticipationTargetSubject::DST(_) => Some("DST".to_string()),
            V3ParticipationTargetSubject::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationTargetSubject::ENT(_) => Some("ENT".to_string()),
            V3ParticipationTargetSubject::ESC(_) => Some("ESC".to_string()),
            V3ParticipationTargetSubject::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationTargetSubject::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationTargetSubject::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationTargetSubject::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationTargetSubject::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationTargetSubject::HLD(_) => Some("HLD".to_string()),
            V3ParticipationTargetSubject::IND(_) => Some("IND".to_string()),
            V3ParticipationTargetSubject::INF(_) => Some("INF".to_string()),
            V3ParticipationTargetSubject::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationTargetSubject::LA(_) => Some("LA".to_string()),
            V3ParticipationTargetSubject::LOC(_) => Some("LOC".to_string()),
            V3ParticipationTargetSubject::NOT(_) => Some("NOT".to_string()),
            V3ParticipationTargetSubject::NRD(_) => Some("NRD".to_string()),
            V3ParticipationTargetSubject::ORG(_) => Some("ORG".to_string()),
            V3ParticipationTargetSubject::PART(_) => Some("PART".to_string()),
            V3ParticipationTargetSubject::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationTargetSubject::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationTargetSubject::PRD(_) => Some("PRD".to_string()),
            V3ParticipationTargetSubject::PRF(_) => Some("PRF".to_string()),
            V3ParticipationTargetSubject::RCT(_) => Some("RCT".to_string()),
            V3ParticipationTargetSubject::RCV(_) => Some("RCV".to_string()),
            V3ParticipationTargetSubject::RDV(_) => Some("RDV".to_string()),
            V3ParticipationTargetSubject::REF(_) => Some("REF".to_string()),
            V3ParticipationTargetSubject::REFB(_) => Some("REFB".to_string()),
            V3ParticipationTargetSubject::REFT(_) => Some("REFT".to_string()),
            V3ParticipationTargetSubject::RESP(_) => Some("RESP".to_string()),
            V3ParticipationTargetSubject::RML(_) => Some("RML".to_string()),
            V3ParticipationTargetSubject::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationTargetSubject::SPC(_) => Some("SPC".to_string()),
            V3ParticipationTargetSubject::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationTargetSubject::TPA(_) => Some("TPA".to_string()),
            V3ParticipationTargetSubject::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationTargetSubject::TRC(_) => Some("TRC".to_string()),
            V3ParticipationTargetSubject::VIA(_) => Some("VIA".to_string()),
            V3ParticipationTargetSubject::VRF(_) => Some("VRF".to_string()),
            V3ParticipationTargetSubject::WIT(_) => Some("WIT".to_string()),
            V3ParticipationTargetSubject::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationTargetSubject::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationTargetSubject::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationTargetSubject {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationTargetSubject::ADM(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ALY(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ATND(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::AUT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::BBY(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::BEN(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CAT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CON(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::COV(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CSM(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::CST(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DEV(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DIR(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DIS(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DIST(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DON(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::DST(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ENT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ESC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::HLD(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::IND(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::INF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::LA(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::LOC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::NOT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::NRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::ORG(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::PART(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::PRD(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::PRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::RCT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::RCV(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::RDV(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::REF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::REFB(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::REFT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::RESP(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::RML(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::SPC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::TPA(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::TRC(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::VIA(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::VRF(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::WIT(Some(e)) => e.get_field(field),
                V3ParticipationTargetSubject::_ParticipationAncillary(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationTargetSubject::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationTargetSubject::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationTargetSubject::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationTargetSubject::_ParticipationAncillary(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetSubject::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationTargetSubject::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationType {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationType {
    fn default() -> Self {
        V3ParticipationType::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationType::ADM(None)),
            "ALY" => Ok(V3ParticipationType::ALY(None)),
            "ATND" => Ok(V3ParticipationType::ATND(None)),
            "AUT" => Ok(V3ParticipationType::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationType::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationType::BBY(None)),
            "BEN" => Ok(V3ParticipationType::BEN(None)),
            "CAGNT" => Ok(V3ParticipationType::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationType::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationType::CAT(None)),
            "CON" => Ok(V3ParticipationType::CON(None)),
            "COV" => Ok(V3ParticipationType::COV(None)),
            "CSM" => Ok(V3ParticipationType::CSM(None)),
            "CST" => Ok(V3ParticipationType::CST(None)),
            "DEV" => Ok(V3ParticipationType::DEV(None)),
            "DIR" => Ok(V3ParticipationType::DIR(None)),
            "DIS" => Ok(V3ParticipationType::DIS(None)),
            "DIST" => Ok(V3ParticipationType::DIST(None)),
            "DON" => Ok(V3ParticipationType::DON(None)),
            "DST" => Ok(V3ParticipationType::DST(None)),
            "ELOC" => Ok(V3ParticipationType::ELOC(None)),
            "ENT" => Ok(V3ParticipationType::ENT(None)),
            "ESC" => Ok(V3ParticipationType::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationType::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationType::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationType::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationType::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationType::GUAR(None)),
            "HLD" => Ok(V3ParticipationType::HLD(None)),
            "IND" => Ok(V3ParticipationType::IND(None)),
            "INF" => Ok(V3ParticipationType::INF(None)),
            "IRCP" => Ok(V3ParticipationType::IRCP(None)),
            "LA" => Ok(V3ParticipationType::LA(None)),
            "LOC" => Ok(V3ParticipationType::LOC(None)),
            "NOT" => Ok(V3ParticipationType::NOT(None)),
            "NRD" => Ok(V3ParticipationType::NRD(None)),
            "ORG" => Ok(V3ParticipationType::ORG(None)),
            "PART" => Ok(V3ParticipationType::PART(None)),
            "PPRF" => Ok(V3ParticipationType::PPRF(None)),
            "PRCP" => Ok(V3ParticipationType::PRCP(None)),
            "PRD" => Ok(V3ParticipationType::PRD(None)),
            "PRF" => Ok(V3ParticipationType::PRF(None)),
            "RCT" => Ok(V3ParticipationType::RCT(None)),
            "RCV" => Ok(V3ParticipationType::RCV(None)),
            "RDV" => Ok(V3ParticipationType::RDV(None)),
            "REF" => Ok(V3ParticipationType::REF(None)),
            "REFB" => Ok(V3ParticipationType::REFB(None)),
            "REFT" => Ok(V3ParticipationType::REFT(None)),
            "RESP" => Ok(V3ParticipationType::RESP(None)),
            "RML" => Ok(V3ParticipationType::RML(None)),
            "SBJ" => Ok(V3ParticipationType::SBJ(None)),
            "SPC" => Ok(V3ParticipationType::SPC(None)),
            "SPRF" => Ok(V3ParticipationType::SPRF(None)),
            "TPA" => Ok(V3ParticipationType::TPA(None)),
            "TRANS" => Ok(V3ParticipationType::TRANS(None)),
            "TRC" => Ok(V3ParticipationType::TRC(None)),
            "VIA" => Ok(V3ParticipationType::VIA(None)),
            "VRF" => Ok(V3ParticipationType::VRF(None)),
            "WIT" => Ok(V3ParticipationType::WIT(None)),
            "_ParticipationAncillary" => Ok(V3ParticipationType::_ParticipationAncillary(None)),
            "_ParticipationInformationGenerator" => Ok(
                V3ParticipationType::_ParticipationInformationGenerator(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationType {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationType::ADM(_) => Some("ADM".to_string()),
            V3ParticipationType::ALY(_) => Some("ALY".to_string()),
            V3ParticipationType::ATND(_) => Some("ATND".to_string()),
            V3ParticipationType::AUT(_) => Some("AUT".to_string()),
            V3ParticipationType::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationType::BBY(_) => Some("BBY".to_string()),
            V3ParticipationType::BEN(_) => Some("BEN".to_string()),
            V3ParticipationType::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationType::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationType::CAT(_) => Some("CAT".to_string()),
            V3ParticipationType::CON(_) => Some("CON".to_string()),
            V3ParticipationType::COV(_) => Some("COV".to_string()),
            V3ParticipationType::CSM(_) => Some("CSM".to_string()),
            V3ParticipationType::CST(_) => Some("CST".to_string()),
            V3ParticipationType::DEV(_) => Some("DEV".to_string()),
            V3ParticipationType::DIR(_) => Some("DIR".to_string()),
            V3ParticipationType::DIS(_) => Some("DIS".to_string()),
            V3ParticipationType::DIST(_) => Some("DIST".to_string()),
            V3ParticipationType::DON(_) => Some("DON".to_string()),
            V3ParticipationType::DST(_) => Some("DST".to_string()),
            V3ParticipationType::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationType::ENT(_) => Some("ENT".to_string()),
            V3ParticipationType::ESC(_) => Some("ESC".to_string()),
            V3ParticipationType::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationType::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationType::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationType::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationType::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationType::HLD(_) => Some("HLD".to_string()),
            V3ParticipationType::IND(_) => Some("IND".to_string()),
            V3ParticipationType::INF(_) => Some("INF".to_string()),
            V3ParticipationType::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationType::LA(_) => Some("LA".to_string()),
            V3ParticipationType::LOC(_) => Some("LOC".to_string()),
            V3ParticipationType::NOT(_) => Some("NOT".to_string()),
            V3ParticipationType::NRD(_) => Some("NRD".to_string()),
            V3ParticipationType::ORG(_) => Some("ORG".to_string()),
            V3ParticipationType::PART(_) => Some("PART".to_string()),
            V3ParticipationType::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationType::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationType::PRD(_) => Some("PRD".to_string()),
            V3ParticipationType::PRF(_) => Some("PRF".to_string()),
            V3ParticipationType::RCT(_) => Some("RCT".to_string()),
            V3ParticipationType::RCV(_) => Some("RCV".to_string()),
            V3ParticipationType::RDV(_) => Some("RDV".to_string()),
            V3ParticipationType::REF(_) => Some("REF".to_string()),
            V3ParticipationType::REFB(_) => Some("REFB".to_string()),
            V3ParticipationType::REFT(_) => Some("REFT".to_string()),
            V3ParticipationType::RESP(_) => Some("RESP".to_string()),
            V3ParticipationType::RML(_) => Some("RML".to_string()),
            V3ParticipationType::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationType::SPC(_) => Some("SPC".to_string()),
            V3ParticipationType::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationType::TPA(_) => Some("TPA".to_string()),
            V3ParticipationType::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationType::TRC(_) => Some("TRC".to_string()),
            V3ParticipationType::VIA(_) => Some("VIA".to_string()),
            V3ParticipationType::VRF(_) => Some("VRF".to_string()),
            V3ParticipationType::WIT(_) => Some("WIT".to_string()),
            V3ParticipationType::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationType::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationType::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationType::ADM(Some(e)) => e.get_field(field),
                V3ParticipationType::ALY(Some(e)) => e.get_field(field),
                V3ParticipationType::ATND(Some(e)) => e.get_field(field),
                V3ParticipationType::AUT(Some(e)) => e.get_field(field),
                V3ParticipationType::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationType::BBY(Some(e)) => e.get_field(field),
                V3ParticipationType::BEN(Some(e)) => e.get_field(field),
                V3ParticipationType::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationType::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationType::CAT(Some(e)) => e.get_field(field),
                V3ParticipationType::CON(Some(e)) => e.get_field(field),
                V3ParticipationType::COV(Some(e)) => e.get_field(field),
                V3ParticipationType::CSM(Some(e)) => e.get_field(field),
                V3ParticipationType::CST(Some(e)) => e.get_field(field),
                V3ParticipationType::DEV(Some(e)) => e.get_field(field),
                V3ParticipationType::DIR(Some(e)) => e.get_field(field),
                V3ParticipationType::DIS(Some(e)) => e.get_field(field),
                V3ParticipationType::DIST(Some(e)) => e.get_field(field),
                V3ParticipationType::DON(Some(e)) => e.get_field(field),
                V3ParticipationType::DST(Some(e)) => e.get_field(field),
                V3ParticipationType::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationType::ENT(Some(e)) => e.get_field(field),
                V3ParticipationType::ESC(Some(e)) => e.get_field(field),
                V3ParticipationType::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationType::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationType::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationType::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationType::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationType::HLD(Some(e)) => e.get_field(field),
                V3ParticipationType::IND(Some(e)) => e.get_field(field),
                V3ParticipationType::INF(Some(e)) => e.get_field(field),
                V3ParticipationType::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationType::LA(Some(e)) => e.get_field(field),
                V3ParticipationType::LOC(Some(e)) => e.get_field(field),
                V3ParticipationType::NOT(Some(e)) => e.get_field(field),
                V3ParticipationType::NRD(Some(e)) => e.get_field(field),
                V3ParticipationType::ORG(Some(e)) => e.get_field(field),
                V3ParticipationType::PART(Some(e)) => e.get_field(field),
                V3ParticipationType::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationType::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationType::PRD(Some(e)) => e.get_field(field),
                V3ParticipationType::PRF(Some(e)) => e.get_field(field),
                V3ParticipationType::RCT(Some(e)) => e.get_field(field),
                V3ParticipationType::RCV(Some(e)) => e.get_field(field),
                V3ParticipationType::RDV(Some(e)) => e.get_field(field),
                V3ParticipationType::REF(Some(e)) => e.get_field(field),
                V3ParticipationType::REFB(Some(e)) => e.get_field(field),
                V3ParticipationType::REFT(Some(e)) => e.get_field(field),
                V3ParticipationType::RESP(Some(e)) => e.get_field(field),
                V3ParticipationType::RML(Some(e)) => e.get_field(field),
                V3ParticipationType::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationType::SPC(Some(e)) => e.get_field(field),
                V3ParticipationType::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationType::TPA(Some(e)) => e.get_field(field),
                V3ParticipationType::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationType::TRC(Some(e)) => e.get_field(field),
                V3ParticipationType::VIA(Some(e)) => e.get_field(field),
                V3ParticipationType::VRF(Some(e)) => e.get_field(field),
                V3ParticipationType::WIT(Some(e)) => e.get_field(field),
                V3ParticipationType::_ParticipationAncillary(Some(e)) => e.get_field(field),
                V3ParticipationType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationType::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::_ParticipationAncillary(Some(e)) => e.get_field_mut(field),
                V3ParticipationType::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ParticipationVerifier {
    #[doc = "admitter"]
    #[code = "ADM"]
    ADM(Option<Element>),
    #[doc = "analyte"]
    #[code = "ALY"]
    ALY(Option<Element>),
    #[doc = "attender"]
    #[code = "ATND"]
    ATND(Option<Element>),
    #[doc = "author (originator)"]
    #[code = "AUT"]
    AUT(Option<Element>),
    #[doc = "authenticator"]
    #[code = "AUTHEN"]
    AUTHEN(Option<Element>),
    #[doc = "baby"]
    #[code = "BBY"]
    BBY(Option<Element>),
    #[doc = "beneficiary"]
    #[code = "BEN"]
    BEN(Option<Element>),
    #[doc = "causative agent"]
    #[code = "CAGNT"]
    CAGNT(Option<Element>),
    #[doc = "callback contact"]
    #[code = "CALLBCK"]
    CALLBCK(Option<Element>),
    #[doc = "catalyst"]
    #[code = "CAT"]
    CAT(Option<Element>),
    #[doc = "consultant"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "coverage target"]
    #[code = "COV"]
    COV(Option<Element>),
    #[doc = "consumable"]
    #[code = "CSM"]
    CSM(Option<Element>),
    #[doc = "custodian"]
    #[code = "CST"]
    CST(Option<Element>),
    #[doc = "device"]
    #[code = "DEV"]
    DEV(Option<Element>),
    #[doc = "direct target"]
    #[code = "DIR"]
    DIR(Option<Element>),
    #[doc = "discharger"]
    #[code = "DIS"]
    DIS(Option<Element>),
    #[doc = "distributor"]
    #[code = "DIST"]
    DIST(Option<Element>),
    #[doc = "donor"]
    #[code = "DON"]
    DON(Option<Element>),
    #[doc = "destination"]
    #[code = "DST"]
    DST(Option<Element>),
    #[doc = "entry location"]
    #[code = "ELOC"]
    ELOC(Option<Element>),
    #[doc = "data entry person"]
    #[code = "ENT"]
    ENT(Option<Element>),
    #[doc = "escort"]
    #[code = "ESC"]
    ESC(Option<Element>),
    #[doc = "ExposureAgent"]
    #[code = "EXPAGNT"]
    EXPAGNT(Option<Element>),
    #[doc = "ExposureParticipation"]
    #[code = "EXPART"]
    EXPART(Option<Element>),
    #[doc = "ExposureTarget"]
    #[code = "EXPTRGT"]
    EXPTRGT(Option<Element>),
    #[doc = "ExposureSource"]
    #[code = "EXSRC"]
    EXSRC(Option<Element>),
    #[doc = "guarantor party"]
    #[code = "GUAR"]
    GUAR(Option<Element>),
    #[doc = "holder"]
    #[code = "HLD"]
    HLD(Option<Element>),
    #[doc = "indirect target"]
    #[code = "IND"]
    IND(Option<Element>),
    #[doc = "informant"]
    #[code = "INF"]
    INF(Option<Element>),
    #[doc = "information recipient"]
    #[code = "IRCP"]
    IRCP(Option<Element>),
    #[doc = "legal authenticator"]
    #[code = "LA"]
    LA(Option<Element>),
    #[doc = "location"]
    #[code = "LOC"]
    LOC(Option<Element>),
    #[doc = "ugent notification contact"]
    #[code = "NOT"]
    NOT(Option<Element>),
    #[doc = "non-reuseable device"]
    #[code = "NRD"]
    NRD(Option<Element>),
    #[doc = "origin"]
    #[code = "ORG"]
    ORG(Option<Element>),
    #[doc = "Participation"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "primary performer"]
    #[code = "PPRF"]
    PPRF(Option<Element>),
    #[doc = "primary information recipient"]
    #[code = "PRCP"]
    PRCP(Option<Element>),
    #[doc = "product"]
    #[code = "PRD"]
    PRD(Option<Element>),
    #[doc = "performer"]
    #[code = "PRF"]
    PRF(Option<Element>),
    #[doc = "record target"]
    #[code = "RCT"]
    RCT(Option<Element>),
    #[doc = "receiver"]
    #[code = "RCV"]
    RCV(Option<Element>),
    #[doc = "reusable device"]
    #[code = "RDV"]
    RDV(Option<Element>),
    #[doc = "referrer"]
    #[code = "REF"]
    REF(Option<Element>),
    #[doc = "Referred By"]
    #[code = "REFB"]
    REFB(Option<Element>),
    #[doc = "Referred to"]
    #[code = "REFT"]
    REFT(Option<Element>),
    #[doc = "responsible party"]
    #[code = "RESP"]
    RESP(Option<Element>),
    #[doc = "remote"]
    #[code = "RML"]
    RML(Option<Element>),
    #[doc = "subject"]
    #[code = "SBJ"]
    SBJ(Option<Element>),
    #[doc = "specimen"]
    #[code = "SPC"]
    SPC(Option<Element>),
    #[doc = "secondary performer"]
    #[code = "SPRF"]
    SPRF(Option<Element>),
    #[doc = "therapeutic agent"]
    #[code = "TPA"]
    TPA(Option<Element>),
    #[doc = "Transcriber"]
    #[code = "TRANS"]
    TRANS(Option<Element>),
    #[doc = "tracker"]
    #[code = "TRC"]
    TRC(Option<Element>),
    #[doc = "via"]
    #[code = "VIA"]
    VIA(Option<Element>),
    #[doc = "verifier"]
    #[code = "VRF"]
    VRF(Option<Element>),
    #[doc = "witness"]
    #[code = "WIT"]
    WIT(Option<Element>),
    #[doc = "ParticipationAncillary"]
    #[code = "_ParticipationAncillary"]
    _ParticipationAncillary(Option<Element>),
    #[doc = "ParticipationInformationGenerator"]
    #[code = "_ParticipationInformationGenerator"]
    _ParticipationInformationGenerator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ParticipationVerifier {
    fn default() -> Self {
        V3ParticipationVerifier::Null(None)
    }
}
impl TryFrom<String> for V3ParticipationVerifier {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ADM" => Ok(V3ParticipationVerifier::ADM(None)),
            "ALY" => Ok(V3ParticipationVerifier::ALY(None)),
            "ATND" => Ok(V3ParticipationVerifier::ATND(None)),
            "AUT" => Ok(V3ParticipationVerifier::AUT(None)),
            "AUTHEN" => Ok(V3ParticipationVerifier::AUTHEN(None)),
            "BBY" => Ok(V3ParticipationVerifier::BBY(None)),
            "BEN" => Ok(V3ParticipationVerifier::BEN(None)),
            "CAGNT" => Ok(V3ParticipationVerifier::CAGNT(None)),
            "CALLBCK" => Ok(V3ParticipationVerifier::CALLBCK(None)),
            "CAT" => Ok(V3ParticipationVerifier::CAT(None)),
            "CON" => Ok(V3ParticipationVerifier::CON(None)),
            "COV" => Ok(V3ParticipationVerifier::COV(None)),
            "CSM" => Ok(V3ParticipationVerifier::CSM(None)),
            "CST" => Ok(V3ParticipationVerifier::CST(None)),
            "DEV" => Ok(V3ParticipationVerifier::DEV(None)),
            "DIR" => Ok(V3ParticipationVerifier::DIR(None)),
            "DIS" => Ok(V3ParticipationVerifier::DIS(None)),
            "DIST" => Ok(V3ParticipationVerifier::DIST(None)),
            "DON" => Ok(V3ParticipationVerifier::DON(None)),
            "DST" => Ok(V3ParticipationVerifier::DST(None)),
            "ELOC" => Ok(V3ParticipationVerifier::ELOC(None)),
            "ENT" => Ok(V3ParticipationVerifier::ENT(None)),
            "ESC" => Ok(V3ParticipationVerifier::ESC(None)),
            "EXPAGNT" => Ok(V3ParticipationVerifier::EXPAGNT(None)),
            "EXPART" => Ok(V3ParticipationVerifier::EXPART(None)),
            "EXPTRGT" => Ok(V3ParticipationVerifier::EXPTRGT(None)),
            "EXSRC" => Ok(V3ParticipationVerifier::EXSRC(None)),
            "GUAR" => Ok(V3ParticipationVerifier::GUAR(None)),
            "HLD" => Ok(V3ParticipationVerifier::HLD(None)),
            "IND" => Ok(V3ParticipationVerifier::IND(None)),
            "INF" => Ok(V3ParticipationVerifier::INF(None)),
            "IRCP" => Ok(V3ParticipationVerifier::IRCP(None)),
            "LA" => Ok(V3ParticipationVerifier::LA(None)),
            "LOC" => Ok(V3ParticipationVerifier::LOC(None)),
            "NOT" => Ok(V3ParticipationVerifier::NOT(None)),
            "NRD" => Ok(V3ParticipationVerifier::NRD(None)),
            "ORG" => Ok(V3ParticipationVerifier::ORG(None)),
            "PART" => Ok(V3ParticipationVerifier::PART(None)),
            "PPRF" => Ok(V3ParticipationVerifier::PPRF(None)),
            "PRCP" => Ok(V3ParticipationVerifier::PRCP(None)),
            "PRD" => Ok(V3ParticipationVerifier::PRD(None)),
            "PRF" => Ok(V3ParticipationVerifier::PRF(None)),
            "RCT" => Ok(V3ParticipationVerifier::RCT(None)),
            "RCV" => Ok(V3ParticipationVerifier::RCV(None)),
            "RDV" => Ok(V3ParticipationVerifier::RDV(None)),
            "REF" => Ok(V3ParticipationVerifier::REF(None)),
            "REFB" => Ok(V3ParticipationVerifier::REFB(None)),
            "REFT" => Ok(V3ParticipationVerifier::REFT(None)),
            "RESP" => Ok(V3ParticipationVerifier::RESP(None)),
            "RML" => Ok(V3ParticipationVerifier::RML(None)),
            "SBJ" => Ok(V3ParticipationVerifier::SBJ(None)),
            "SPC" => Ok(V3ParticipationVerifier::SPC(None)),
            "SPRF" => Ok(V3ParticipationVerifier::SPRF(None)),
            "TPA" => Ok(V3ParticipationVerifier::TPA(None)),
            "TRANS" => Ok(V3ParticipationVerifier::TRANS(None)),
            "TRC" => Ok(V3ParticipationVerifier::TRC(None)),
            "VIA" => Ok(V3ParticipationVerifier::VIA(None)),
            "VRF" => Ok(V3ParticipationVerifier::VRF(None)),
            "WIT" => Ok(V3ParticipationVerifier::WIT(None)),
            "_ParticipationAncillary" => Ok(V3ParticipationVerifier::_ParticipationAncillary(None)),
            "_ParticipationInformationGenerator" => Ok(
                V3ParticipationVerifier::_ParticipationInformationGenerator(None),
            ),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ParticipationVerifier {
    fn into(self) -> Option<String> {
        match self {
            V3ParticipationVerifier::ADM(_) => Some("ADM".to_string()),
            V3ParticipationVerifier::ALY(_) => Some("ALY".to_string()),
            V3ParticipationVerifier::ATND(_) => Some("ATND".to_string()),
            V3ParticipationVerifier::AUT(_) => Some("AUT".to_string()),
            V3ParticipationVerifier::AUTHEN(_) => Some("AUTHEN".to_string()),
            V3ParticipationVerifier::BBY(_) => Some("BBY".to_string()),
            V3ParticipationVerifier::BEN(_) => Some("BEN".to_string()),
            V3ParticipationVerifier::CAGNT(_) => Some("CAGNT".to_string()),
            V3ParticipationVerifier::CALLBCK(_) => Some("CALLBCK".to_string()),
            V3ParticipationVerifier::CAT(_) => Some("CAT".to_string()),
            V3ParticipationVerifier::CON(_) => Some("CON".to_string()),
            V3ParticipationVerifier::COV(_) => Some("COV".to_string()),
            V3ParticipationVerifier::CSM(_) => Some("CSM".to_string()),
            V3ParticipationVerifier::CST(_) => Some("CST".to_string()),
            V3ParticipationVerifier::DEV(_) => Some("DEV".to_string()),
            V3ParticipationVerifier::DIR(_) => Some("DIR".to_string()),
            V3ParticipationVerifier::DIS(_) => Some("DIS".to_string()),
            V3ParticipationVerifier::DIST(_) => Some("DIST".to_string()),
            V3ParticipationVerifier::DON(_) => Some("DON".to_string()),
            V3ParticipationVerifier::DST(_) => Some("DST".to_string()),
            V3ParticipationVerifier::ELOC(_) => Some("ELOC".to_string()),
            V3ParticipationVerifier::ENT(_) => Some("ENT".to_string()),
            V3ParticipationVerifier::ESC(_) => Some("ESC".to_string()),
            V3ParticipationVerifier::EXPAGNT(_) => Some("EXPAGNT".to_string()),
            V3ParticipationVerifier::EXPART(_) => Some("EXPART".to_string()),
            V3ParticipationVerifier::EXPTRGT(_) => Some("EXPTRGT".to_string()),
            V3ParticipationVerifier::EXSRC(_) => Some("EXSRC".to_string()),
            V3ParticipationVerifier::GUAR(_) => Some("GUAR".to_string()),
            V3ParticipationVerifier::HLD(_) => Some("HLD".to_string()),
            V3ParticipationVerifier::IND(_) => Some("IND".to_string()),
            V3ParticipationVerifier::INF(_) => Some("INF".to_string()),
            V3ParticipationVerifier::IRCP(_) => Some("IRCP".to_string()),
            V3ParticipationVerifier::LA(_) => Some("LA".to_string()),
            V3ParticipationVerifier::LOC(_) => Some("LOC".to_string()),
            V3ParticipationVerifier::NOT(_) => Some("NOT".to_string()),
            V3ParticipationVerifier::NRD(_) => Some("NRD".to_string()),
            V3ParticipationVerifier::ORG(_) => Some("ORG".to_string()),
            V3ParticipationVerifier::PART(_) => Some("PART".to_string()),
            V3ParticipationVerifier::PPRF(_) => Some("PPRF".to_string()),
            V3ParticipationVerifier::PRCP(_) => Some("PRCP".to_string()),
            V3ParticipationVerifier::PRD(_) => Some("PRD".to_string()),
            V3ParticipationVerifier::PRF(_) => Some("PRF".to_string()),
            V3ParticipationVerifier::RCT(_) => Some("RCT".to_string()),
            V3ParticipationVerifier::RCV(_) => Some("RCV".to_string()),
            V3ParticipationVerifier::RDV(_) => Some("RDV".to_string()),
            V3ParticipationVerifier::REF(_) => Some("REF".to_string()),
            V3ParticipationVerifier::REFB(_) => Some("REFB".to_string()),
            V3ParticipationVerifier::REFT(_) => Some("REFT".to_string()),
            V3ParticipationVerifier::RESP(_) => Some("RESP".to_string()),
            V3ParticipationVerifier::RML(_) => Some("RML".to_string()),
            V3ParticipationVerifier::SBJ(_) => Some("SBJ".to_string()),
            V3ParticipationVerifier::SPC(_) => Some("SPC".to_string()),
            V3ParticipationVerifier::SPRF(_) => Some("SPRF".to_string()),
            V3ParticipationVerifier::TPA(_) => Some("TPA".to_string()),
            V3ParticipationVerifier::TRANS(_) => Some("TRANS".to_string()),
            V3ParticipationVerifier::TRC(_) => Some("TRC".to_string()),
            V3ParticipationVerifier::VIA(_) => Some("VIA".to_string()),
            V3ParticipationVerifier::VRF(_) => Some("VRF".to_string()),
            V3ParticipationVerifier::WIT(_) => Some("WIT".to_string()),
            V3ParticipationVerifier::_ParticipationAncillary(_) => {
                Some("_ParticipationAncillary".to_string())
            }
            V3ParticipationVerifier::_ParticipationInformationGenerator(_) => {
                Some("_ParticipationInformationGenerator".to_string())
            }
            V3ParticipationVerifier::Null(_) => None,
        }
    }
}
impl MetaValue for V3ParticipationVerifier {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ParticipationVerifier::ADM(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ALY(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ATND(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::AUT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::AUTHEN(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::BBY(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::BEN(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CAGNT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CALLBCK(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CAT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CON(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::COV(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CSM(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::CST(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DEV(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DIR(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DIS(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DIST(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DON(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::DST(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ELOC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ENT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ESC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::EXPAGNT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::EXPART(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::EXPTRGT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::EXSRC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::GUAR(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::HLD(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::IND(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::INF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::IRCP(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::LA(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::LOC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::NOT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::NRD(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::ORG(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::PART(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::PPRF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::PRCP(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::PRD(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::PRF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::RCT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::RCV(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::RDV(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::REF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::REFB(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::REFT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::RESP(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::RML(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::SBJ(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::SPC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::SPRF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::TPA(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::TRANS(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::TRC(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::VIA(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::VRF(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::WIT(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::_ParticipationAncillary(Some(e)) => e.get_field(field),
                V3ParticipationVerifier::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field(field)
                }
                V3ParticipationVerifier::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ParticipationVerifier::ADM(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ALY(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ATND(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::AUT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::AUTHEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::BBY(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::BEN(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CALLBCK(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CAT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CON(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::COV(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CSM(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::CST(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DEV(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DIR(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DIS(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DIST(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DON(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::DST(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ELOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ENT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ESC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::EXPAGNT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::EXPART(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::EXPTRGT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::EXSRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::GUAR(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::HLD(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::IND(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::INF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::IRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::LA(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::LOC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::NOT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::NRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::ORG(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::PART(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::PPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::PRCP(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::PRD(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::PRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::RCT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::RCV(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::RDV(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::REF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::REFB(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::REFT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::RESP(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::RML(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::SBJ(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::SPC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::SPRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::TPA(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::TRANS(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::TRC(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::VIA(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::VRF(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::WIT(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::_ParticipationAncillary(Some(e)) => e.get_field_mut(field),
                V3ParticipationVerifier::_ParticipationInformationGenerator(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3ParticipationVerifier::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3PatientImportance {
    #[doc = "Board Member"]
    #[code = "BM"]
    BM(Option<Element>),
    #[doc = "Physician Family Member"]
    #[code = "DFM"]
    DFM(Option<Element>),
    #[doc = "Staff Physician"]
    #[code = "DR"]
    DR(Option<Element>),
    #[doc = "Financial Donor"]
    #[code = "FD"]
    FD(Option<Element>),
    #[doc = "Foreign Dignitary"]
    #[code = "FOR"]
    FOR(Option<Element>),
    #[doc = "Government Dignitary"]
    #[code = "GOVT"]
    GOVT(Option<Element>),
    #[doc = "Staff Family Member"]
    #[code = "SFM"]
    SFM(Option<Element>),
    #[doc = "Staff Member"]
    #[code = "STF"]
    STF(Option<Element>),
    #[doc = "Very Important Person"]
    #[code = "VIP"]
    VIP(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3PatientImportance {
    fn default() -> Self {
        V3PatientImportance::Null(None)
    }
}
impl TryFrom<String> for V3PatientImportance {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BM" => Ok(V3PatientImportance::BM(None)),
            "DFM" => Ok(V3PatientImportance::DFM(None)),
            "DR" => Ok(V3PatientImportance::DR(None)),
            "FD" => Ok(V3PatientImportance::FD(None)),
            "FOR" => Ok(V3PatientImportance::FOR(None)),
            "GOVT" => Ok(V3PatientImportance::GOVT(None)),
            "SFM" => Ok(V3PatientImportance::SFM(None)),
            "STF" => Ok(V3PatientImportance::STF(None)),
            "VIP" => Ok(V3PatientImportance::VIP(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3PatientImportance {
    fn into(self) -> Option<String> {
        match self {
            V3PatientImportance::BM(_) => Some("BM".to_string()),
            V3PatientImportance::DFM(_) => Some("DFM".to_string()),
            V3PatientImportance::DR(_) => Some("DR".to_string()),
            V3PatientImportance::FD(_) => Some("FD".to_string()),
            V3PatientImportance::FOR(_) => Some("FOR".to_string()),
            V3PatientImportance::GOVT(_) => Some("GOVT".to_string()),
            V3PatientImportance::SFM(_) => Some("SFM".to_string()),
            V3PatientImportance::STF(_) => Some("STF".to_string()),
            V3PatientImportance::VIP(_) => Some("VIP".to_string()),
            V3PatientImportance::Null(_) => None,
        }
    }
}
impl MetaValue for V3PatientImportance {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3PatientImportance::BM(Some(e)) => e.get_field(field),
                V3PatientImportance::DFM(Some(e)) => e.get_field(field),
                V3PatientImportance::DR(Some(e)) => e.get_field(field),
                V3PatientImportance::FD(Some(e)) => e.get_field(field),
                V3PatientImportance::FOR(Some(e)) => e.get_field(field),
                V3PatientImportance::GOVT(Some(e)) => e.get_field(field),
                V3PatientImportance::SFM(Some(e)) => e.get_field(field),
                V3PatientImportance::STF(Some(e)) => e.get_field(field),
                V3PatientImportance::VIP(Some(e)) => e.get_field(field),
                V3PatientImportance::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3PatientImportance::BM(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::DFM(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::DR(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::FD(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::FOR(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::GOVT(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::SFM(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::STF(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::VIP(Some(e)) => e.get_field_mut(field),
                V3PatientImportance::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3PaymentTerms {
    #[doc = "Cash on Delivery"]
    #[code = "COD"]
    COD(Option<Element>),
    #[doc = "Net 30 days"]
    #[code = "N30"]
    N30(Option<Element>),
    #[doc = "Net 60 days"]
    #[code = "N60"]
    N60(Option<Element>),
    #[doc = "Net 90 days"]
    #[code = "N90"]
    N90(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3PaymentTerms {
    fn default() -> Self {
        V3PaymentTerms::Null(None)
    }
}
impl TryFrom<String> for V3PaymentTerms {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "COD" => Ok(V3PaymentTerms::COD(None)),
            "N30" => Ok(V3PaymentTerms::N30(None)),
            "N60" => Ok(V3PaymentTerms::N60(None)),
            "N90" => Ok(V3PaymentTerms::N90(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3PaymentTerms {
    fn into(self) -> Option<String> {
        match self {
            V3PaymentTerms::COD(_) => Some("COD".to_string()),
            V3PaymentTerms::N30(_) => Some("N30".to_string()),
            V3PaymentTerms::N60(_) => Some("N60".to_string()),
            V3PaymentTerms::N90(_) => Some("N90".to_string()),
            V3PaymentTerms::Null(_) => None,
        }
    }
}
impl MetaValue for V3PaymentTerms {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3PaymentTerms::COD(Some(e)) => e.get_field(field),
                V3PaymentTerms::N30(Some(e)) => e.get_field(field),
                V3PaymentTerms::N60(Some(e)) => e.get_field(field),
                V3PaymentTerms::N90(Some(e)) => e.get_field(field),
                V3PaymentTerms::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3PaymentTerms::COD(Some(e)) => e.get_field_mut(field),
                V3PaymentTerms::N30(Some(e)) => e.get_field_mut(field),
                V3PaymentTerms::N60(Some(e)) => e.get_field_mut(field),
                V3PaymentTerms::N90(Some(e)) => e.get_field_mut(field),
                V3PaymentTerms::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3PersonDisabilityType {
    #[doc = "Vision impaired"]
    #[code = "1"]
    V1(Option<Element>),
    #[doc = "Hearing impaired"]
    #[code = "2"]
    V2(Option<Element>),
    #[doc = "Speech impaired"]
    #[code = "3"]
    V3(Option<Element>),
    #[doc = "Mentally impaired"]
    #[code = "4"]
    V4(Option<Element>),
    #[doc = "Mobility impaired"]
    #[code = "5"]
    V5(Option<Element>),
    #[doc = "Requires crib"]
    #[code = "CB"]
    CB(Option<Element>),
    #[doc = "Requires crutches"]
    #[code = "CR"]
    CR(Option<Element>),
    #[doc = "Requires gurney"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "Requires wheelchair"]
    #[code = "WC"]
    WC(Option<Element>),
    #[doc = "Requires walker"]
    #[code = "WK"]
    WK(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3PersonDisabilityType {
    fn default() -> Self {
        V3PersonDisabilityType::Null(None)
    }
}
impl TryFrom<String> for V3PersonDisabilityType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1" => Ok(V3PersonDisabilityType::V1(None)),
            "2" => Ok(V3PersonDisabilityType::V2(None)),
            "3" => Ok(V3PersonDisabilityType::V3(None)),
            "4" => Ok(V3PersonDisabilityType::V4(None)),
            "5" => Ok(V3PersonDisabilityType::V5(None)),
            "CB" => Ok(V3PersonDisabilityType::CB(None)),
            "CR" => Ok(V3PersonDisabilityType::CR(None)),
            "G" => Ok(V3PersonDisabilityType::G(None)),
            "WC" => Ok(V3PersonDisabilityType::WC(None)),
            "WK" => Ok(V3PersonDisabilityType::WK(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3PersonDisabilityType {
    fn into(self) -> Option<String> {
        match self {
            V3PersonDisabilityType::V1(_) => Some("1".to_string()),
            V3PersonDisabilityType::V2(_) => Some("2".to_string()),
            V3PersonDisabilityType::V3(_) => Some("3".to_string()),
            V3PersonDisabilityType::V4(_) => Some("4".to_string()),
            V3PersonDisabilityType::V5(_) => Some("5".to_string()),
            V3PersonDisabilityType::CB(_) => Some("CB".to_string()),
            V3PersonDisabilityType::CR(_) => Some("CR".to_string()),
            V3PersonDisabilityType::G(_) => Some("G".to_string()),
            V3PersonDisabilityType::WC(_) => Some("WC".to_string()),
            V3PersonDisabilityType::WK(_) => Some("WK".to_string()),
            V3PersonDisabilityType::Null(_) => None,
        }
    }
}
impl MetaValue for V3PersonDisabilityType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3PersonDisabilityType::V1(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::V2(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::V3(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::V4(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::V5(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::CB(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::CR(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::G(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::WC(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::WK(Some(e)) => e.get_field(field),
                V3PersonDisabilityType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3PersonDisabilityType::V1(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::V2(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::V3(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::V4(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::V5(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::CB(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::CR(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::G(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::WC(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::WK(Some(e)) => e.get_field_mut(field),
                V3PersonDisabilityType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProbabilityDistributionType {
    #[doc = "beta"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "exponential"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "F"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "(gamma)"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "log-normal"]
    #[code = "LN"]
    LN(Option<Element>),
    #[doc = "normal (Gaussian)"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "T"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "uniform"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "chi square"]
    #[code = "X2"]
    X2(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProbabilityDistributionType {
    fn default() -> Self {
        V3ProbabilityDistributionType::Null(None)
    }
}
impl TryFrom<String> for V3ProbabilityDistributionType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(V3ProbabilityDistributionType::B(None)),
            "E" => Ok(V3ProbabilityDistributionType::E(None)),
            "F" => Ok(V3ProbabilityDistributionType::F(None)),
            "G" => Ok(V3ProbabilityDistributionType::G(None)),
            "LN" => Ok(V3ProbabilityDistributionType::LN(None)),
            "N" => Ok(V3ProbabilityDistributionType::N(None)),
            "T" => Ok(V3ProbabilityDistributionType::T(None)),
            "U" => Ok(V3ProbabilityDistributionType::U(None)),
            "X2" => Ok(V3ProbabilityDistributionType::X2(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProbabilityDistributionType {
    fn into(self) -> Option<String> {
        match self {
            V3ProbabilityDistributionType::B(_) => Some("B".to_string()),
            V3ProbabilityDistributionType::E(_) => Some("E".to_string()),
            V3ProbabilityDistributionType::F(_) => Some("F".to_string()),
            V3ProbabilityDistributionType::G(_) => Some("G".to_string()),
            V3ProbabilityDistributionType::LN(_) => Some("LN".to_string()),
            V3ProbabilityDistributionType::N(_) => Some("N".to_string()),
            V3ProbabilityDistributionType::T(_) => Some("T".to_string()),
            V3ProbabilityDistributionType::U(_) => Some("U".to_string()),
            V3ProbabilityDistributionType::X2(_) => Some("X2".to_string()),
            V3ProbabilityDistributionType::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProbabilityDistributionType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProbabilityDistributionType::B(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::E(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::F(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::G(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::LN(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::N(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::T(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::U(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::X2(Some(e)) => e.get_field(field),
                V3ProbabilityDistributionType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProbabilityDistributionType::B(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::E(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::F(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::G(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::LN(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::N(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::T(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::U(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::X2(Some(e)) => e.get_field_mut(field),
                V3ProbabilityDistributionType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProcessingID {
    #[doc = "Debugging"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Production"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "Training"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProcessingID {
    fn default() -> Self {
        V3ProcessingID::Null(None)
    }
}
impl TryFrom<String> for V3ProcessingID {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "D" => Ok(V3ProcessingID::D(None)),
            "P" => Ok(V3ProcessingID::P(None)),
            "T" => Ok(V3ProcessingID::T(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProcessingID {
    fn into(self) -> Option<String> {
        match self {
            V3ProcessingID::D(_) => Some("D".to_string()),
            V3ProcessingID::P(_) => Some("P".to_string()),
            V3ProcessingID::T(_) => Some("T".to_string()),
            V3ProcessingID::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProcessingID {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProcessingID::D(Some(e)) => e.get_field(field),
                V3ProcessingID::P(Some(e)) => e.get_field(field),
                V3ProcessingID::T(Some(e)) => e.get_field(field),
                V3ProcessingID::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProcessingID::D(Some(e)) => e.get_field_mut(field),
                V3ProcessingID::P(Some(e)) => e.get_field_mut(field),
                V3ProcessingID::T(Some(e)) => e.get_field_mut(field),
                V3ProcessingID::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProcessingMode {
    #[doc = "Archive"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Initial load"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "Restore from archive"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Current processing"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProcessingMode {
    fn default() -> Self {
        V3ProcessingMode::Null(None)
    }
}
impl TryFrom<String> for V3ProcessingMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3ProcessingMode::A(None)),
            "I" => Ok(V3ProcessingMode::I(None)),
            "R" => Ok(V3ProcessingMode::R(None)),
            "T" => Ok(V3ProcessingMode::T(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProcessingMode {
    fn into(self) -> Option<String> {
        match self {
            V3ProcessingMode::A(_) => Some("A".to_string()),
            V3ProcessingMode::I(_) => Some("I".to_string()),
            V3ProcessingMode::R(_) => Some("R".to_string()),
            V3ProcessingMode::T(_) => Some("T".to_string()),
            V3ProcessingMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProcessingMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProcessingMode::A(Some(e)) => e.get_field(field),
                V3ProcessingMode::I(Some(e)) => e.get_field(field),
                V3ProcessingMode::R(Some(e)) => e.get_field(field),
                V3ProcessingMode::T(Some(e)) => e.get_field(field),
                V3ProcessingMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProcessingMode::A(Some(e)) => e.get_field_mut(field),
                V3ProcessingMode::I(Some(e)) => e.get_field_mut(field),
                V3ProcessingMode::R(Some(e)) => e.get_field_mut(field),
                V3ProcessingMode::T(Some(e)) => e.get_field_mut(field),
                V3ProcessingMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProvenanceEventCurrentState {
    #[code = "AU"]
    AU(Option<Element>),
    #[code = "DI"]
    DI(Option<Element>),
    #[code = "DO"]
    DO(Option<Element>),
    #[code = "LA"]
    LA(Option<Element>),
    #[code = "UC"]
    UC(Option<Element>),
    #[code = "aborted"]
    Aborted(Option<Element>),
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[code = "completed"]
    Completed(Option<Element>),
    #[code = "new"]
    New(Option<Element>),
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[code = "obsolete"]
    Obsolete(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProvenanceEventCurrentState {
    fn default() -> Self {
        V3ProvenanceEventCurrentState::Null(None)
    }
}
impl TryFrom<String> for V3ProvenanceEventCurrentState {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AU" => Ok(V3ProvenanceEventCurrentState::AU(None)),
            "DI" => Ok(V3ProvenanceEventCurrentState::DI(None)),
            "DO" => Ok(V3ProvenanceEventCurrentState::DO(None)),
            "LA" => Ok(V3ProvenanceEventCurrentState::LA(None)),
            "UC" => Ok(V3ProvenanceEventCurrentState::UC(None)),
            "aborted" => Ok(V3ProvenanceEventCurrentState::Aborted(None)),
            "cancelled" => Ok(V3ProvenanceEventCurrentState::Cancelled(None)),
            "completed" => Ok(V3ProvenanceEventCurrentState::Completed(None)),
            "new" => Ok(V3ProvenanceEventCurrentState::New(None)),
            "nullified" => Ok(V3ProvenanceEventCurrentState::Nullified(None)),
            "obsolete" => Ok(V3ProvenanceEventCurrentState::Obsolete(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProvenanceEventCurrentState {
    fn into(self) -> Option<String> {
        match self {
            V3ProvenanceEventCurrentState::AU(_) => Some("AU".to_string()),
            V3ProvenanceEventCurrentState::DI(_) => Some("DI".to_string()),
            V3ProvenanceEventCurrentState::DO(_) => Some("DO".to_string()),
            V3ProvenanceEventCurrentState::LA(_) => Some("LA".to_string()),
            V3ProvenanceEventCurrentState::UC(_) => Some("UC".to_string()),
            V3ProvenanceEventCurrentState::Aborted(_) => Some("aborted".to_string()),
            V3ProvenanceEventCurrentState::Cancelled(_) => Some("cancelled".to_string()),
            V3ProvenanceEventCurrentState::Completed(_) => Some("completed".to_string()),
            V3ProvenanceEventCurrentState::New(_) => Some("new".to_string()),
            V3ProvenanceEventCurrentState::Nullified(_) => Some("nullified".to_string()),
            V3ProvenanceEventCurrentState::Obsolete(_) => Some("obsolete".to_string()),
            V3ProvenanceEventCurrentState::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProvenanceEventCurrentState {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProvenanceEventCurrentState::AU(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::DI(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::DO(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::LA(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::UC(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Aborted(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Cancelled(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Completed(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::New(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Nullified(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Obsolete(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentState::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProvenanceEventCurrentState::AU(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::DI(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::DO(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::LA(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::UC(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Aborted(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Cancelled(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Completed(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::New(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Nullified(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Obsolete(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentState::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProvenanceEventCurrentStateAS {
    #[code = "aborted"]
    Aborted(Option<Element>),
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[code = "completed"]
    Completed(Option<Element>),
    #[code = "new"]
    New(Option<Element>),
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[code = "obsolete"]
    Obsolete(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProvenanceEventCurrentStateAS {
    fn default() -> Self {
        V3ProvenanceEventCurrentStateAS::Null(None)
    }
}
impl TryFrom<String> for V3ProvenanceEventCurrentStateAS {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aborted" => Ok(V3ProvenanceEventCurrentStateAS::Aborted(None)),
            "cancelled" => Ok(V3ProvenanceEventCurrentStateAS::Cancelled(None)),
            "completed" => Ok(V3ProvenanceEventCurrentStateAS::Completed(None)),
            "new" => Ok(V3ProvenanceEventCurrentStateAS::New(None)),
            "nullified" => Ok(V3ProvenanceEventCurrentStateAS::Nullified(None)),
            "obsolete" => Ok(V3ProvenanceEventCurrentStateAS::Obsolete(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProvenanceEventCurrentStateAS {
    fn into(self) -> Option<String> {
        match self {
            V3ProvenanceEventCurrentStateAS::Aborted(_) => Some("aborted".to_string()),
            V3ProvenanceEventCurrentStateAS::Cancelled(_) => Some("cancelled".to_string()),
            V3ProvenanceEventCurrentStateAS::Completed(_) => Some("completed".to_string()),
            V3ProvenanceEventCurrentStateAS::New(_) => Some("new".to_string()),
            V3ProvenanceEventCurrentStateAS::Nullified(_) => Some("nullified".to_string()),
            V3ProvenanceEventCurrentStateAS::Obsolete(_) => Some("obsolete".to_string()),
            V3ProvenanceEventCurrentStateAS::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProvenanceEventCurrentStateAS {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProvenanceEventCurrentStateAS::Aborted(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::Cancelled(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::Completed(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::New(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::Nullified(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::Obsolete(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateAS::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProvenanceEventCurrentStateAS::Aborted(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::Cancelled(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::Completed(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::New(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::Nullified(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::Obsolete(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateAS::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ProvenanceEventCurrentStateDC {
    #[code = "AU"]
    AU(Option<Element>),
    #[code = "DI"]
    DI(Option<Element>),
    #[code = "DO"]
    DO(Option<Element>),
    #[code = "LA"]
    LA(Option<Element>),
    #[code = "UC"]
    UC(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ProvenanceEventCurrentStateDC {
    fn default() -> Self {
        V3ProvenanceEventCurrentStateDC::Null(None)
    }
}
impl TryFrom<String> for V3ProvenanceEventCurrentStateDC {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AU" => Ok(V3ProvenanceEventCurrentStateDC::AU(None)),
            "DI" => Ok(V3ProvenanceEventCurrentStateDC::DI(None)),
            "DO" => Ok(V3ProvenanceEventCurrentStateDC::DO(None)),
            "LA" => Ok(V3ProvenanceEventCurrentStateDC::LA(None)),
            "UC" => Ok(V3ProvenanceEventCurrentStateDC::UC(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ProvenanceEventCurrentStateDC {
    fn into(self) -> Option<String> {
        match self {
            V3ProvenanceEventCurrentStateDC::AU(_) => Some("AU".to_string()),
            V3ProvenanceEventCurrentStateDC::DI(_) => Some("DI".to_string()),
            V3ProvenanceEventCurrentStateDC::DO(_) => Some("DO".to_string()),
            V3ProvenanceEventCurrentStateDC::LA(_) => Some("LA".to_string()),
            V3ProvenanceEventCurrentStateDC::UC(_) => Some("UC".to_string()),
            V3ProvenanceEventCurrentStateDC::Null(_) => None,
        }
    }
}
impl MetaValue for V3ProvenanceEventCurrentStateDC {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ProvenanceEventCurrentStateDC::AU(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateDC::DI(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateDC::DO(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateDC::LA(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateDC::UC(Some(e)) => e.get_field(field),
                V3ProvenanceEventCurrentStateDC::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ProvenanceEventCurrentStateDC::AU(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateDC::DI(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateDC::DO(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateDC::LA(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateDC::UC(Some(e)) => e.get_field_mut(field),
                V3ProvenanceEventCurrentStateDC::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3QueryParameterValue {
    #[doc = "all dispenses"]
    #[code = "ALLDISP"]
    ALLDISP(Option<Element>),
    #[doc = "all orders"]
    #[code = "AO"]
    AO(Option<Element>),
    #[doc = "Completely dispensed"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "all"]
    #[code = "ISSFA"]
    ISSFA(Option<Element>),
    #[doc = "with issues"]
    #[code = "ISSFI"]
    ISSFI(Option<Element>),
    #[doc = "with unmanaged issues"]
    #[code = "ISSFU"]
    ISSFU(Option<Element>),
    #[doc = "last dispense"]
    #[code = "LASTDISP"]
    LASTDISP(Option<Element>),
    #[doc = "Never Dispensed"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "no dispense"]
    #[code = "NODISP"]
    NODISP(Option<Element>),
    #[doc = "orders without results"]
    #[code = "ONR"]
    ONR(Option<Element>),
    #[doc = "orders with results"]
    #[code = "OWR"]
    OWR(Option<Element>),
    #[doc = "Dispensed with remaining fills"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "dispense query filter code"]
    #[code = "_DispenseQueryFilterCode"]
    _DispenseQueryFilterCode(Option<Element>),
    #[doc = "_OrderFilterCode"]
    #[code = "_OrderFilterCode"]
    _OrderFilterCode(Option<Element>),
    #[doc = "Prescription Dispense Filter Code"]
    #[code = "_PrescriptionDispenseFilterCode"]
    _PrescriptionDispenseFilterCode(Option<Element>),
    #[doc = "QueryParameterValue"]
    #[code = "_QueryParameterValue"]
    _QueryParameterValue(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3QueryParameterValue {
    fn default() -> Self {
        V3QueryParameterValue::Null(None)
    }
}
impl TryFrom<String> for V3QueryParameterValue {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ALLDISP" => Ok(V3QueryParameterValue::ALLDISP(None)),
            "AO" => Ok(V3QueryParameterValue::AO(None)),
            "C" => Ok(V3QueryParameterValue::C(None)),
            "ISSFA" => Ok(V3QueryParameterValue::ISSFA(None)),
            "ISSFI" => Ok(V3QueryParameterValue::ISSFI(None)),
            "ISSFU" => Ok(V3QueryParameterValue::ISSFU(None)),
            "LASTDISP" => Ok(V3QueryParameterValue::LASTDISP(None)),
            "N" => Ok(V3QueryParameterValue::N(None)),
            "NODISP" => Ok(V3QueryParameterValue::NODISP(None)),
            "ONR" => Ok(V3QueryParameterValue::ONR(None)),
            "OWR" => Ok(V3QueryParameterValue::OWR(None)),
            "R" => Ok(V3QueryParameterValue::R(None)),
            "_DispenseQueryFilterCode" => Ok(V3QueryParameterValue::_DispenseQueryFilterCode(None)),
            "_OrderFilterCode" => Ok(V3QueryParameterValue::_OrderFilterCode(None)),
            "_PrescriptionDispenseFilterCode" => {
                Ok(V3QueryParameterValue::_PrescriptionDispenseFilterCode(None))
            }
            "_QueryParameterValue" => Ok(V3QueryParameterValue::_QueryParameterValue(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3QueryParameterValue {
    fn into(self) -> Option<String> {
        match self {
            V3QueryParameterValue::ALLDISP(_) => Some("ALLDISP".to_string()),
            V3QueryParameterValue::AO(_) => Some("AO".to_string()),
            V3QueryParameterValue::C(_) => Some("C".to_string()),
            V3QueryParameterValue::ISSFA(_) => Some("ISSFA".to_string()),
            V3QueryParameterValue::ISSFI(_) => Some("ISSFI".to_string()),
            V3QueryParameterValue::ISSFU(_) => Some("ISSFU".to_string()),
            V3QueryParameterValue::LASTDISP(_) => Some("LASTDISP".to_string()),
            V3QueryParameterValue::N(_) => Some("N".to_string()),
            V3QueryParameterValue::NODISP(_) => Some("NODISP".to_string()),
            V3QueryParameterValue::ONR(_) => Some("ONR".to_string()),
            V3QueryParameterValue::OWR(_) => Some("OWR".to_string()),
            V3QueryParameterValue::R(_) => Some("R".to_string()),
            V3QueryParameterValue::_DispenseQueryFilterCode(_) => {
                Some("_DispenseQueryFilterCode".to_string())
            }
            V3QueryParameterValue::_OrderFilterCode(_) => Some("_OrderFilterCode".to_string()),
            V3QueryParameterValue::_PrescriptionDispenseFilterCode(_) => {
                Some("_PrescriptionDispenseFilterCode".to_string())
            }
            V3QueryParameterValue::_QueryParameterValue(_) => {
                Some("_QueryParameterValue".to_string())
            }
            V3QueryParameterValue::Null(_) => None,
        }
    }
}
impl MetaValue for V3QueryParameterValue {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3QueryParameterValue::ALLDISP(Some(e)) => e.get_field(field),
                V3QueryParameterValue::AO(Some(e)) => e.get_field(field),
                V3QueryParameterValue::C(Some(e)) => e.get_field(field),
                V3QueryParameterValue::ISSFA(Some(e)) => e.get_field(field),
                V3QueryParameterValue::ISSFI(Some(e)) => e.get_field(field),
                V3QueryParameterValue::ISSFU(Some(e)) => e.get_field(field),
                V3QueryParameterValue::LASTDISP(Some(e)) => e.get_field(field),
                V3QueryParameterValue::N(Some(e)) => e.get_field(field),
                V3QueryParameterValue::NODISP(Some(e)) => e.get_field(field),
                V3QueryParameterValue::ONR(Some(e)) => e.get_field(field),
                V3QueryParameterValue::OWR(Some(e)) => e.get_field(field),
                V3QueryParameterValue::R(Some(e)) => e.get_field(field),
                V3QueryParameterValue::_DispenseQueryFilterCode(Some(e)) => e.get_field(field),
                V3QueryParameterValue::_OrderFilterCode(Some(e)) => e.get_field(field),
                V3QueryParameterValue::_PrescriptionDispenseFilterCode(Some(e)) => {
                    e.get_field(field)
                }
                V3QueryParameterValue::_QueryParameterValue(Some(e)) => e.get_field(field),
                V3QueryParameterValue::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3QueryParameterValue::ALLDISP(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::AO(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::C(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::ISSFA(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::ISSFI(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::ISSFU(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::LASTDISP(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::N(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::NODISP(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::ONR(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::OWR(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::R(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::_DispenseQueryFilterCode(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::_OrderFilterCode(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::_PrescriptionDispenseFilterCode(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3QueryParameterValue::_QueryParameterValue(Some(e)) => e.get_field_mut(field),
                V3QueryParameterValue::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3QueryPriority {
    #[doc = "Deferred"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "Immediate"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3QueryPriority {
    fn default() -> Self {
        V3QueryPriority::Null(None)
    }
}
impl TryFrom<String> for V3QueryPriority {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "D" => Ok(V3QueryPriority::D(None)),
            "I" => Ok(V3QueryPriority::I(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3QueryPriority {
    fn into(self) -> Option<String> {
        match self {
            V3QueryPriority::D(_) => Some("D".to_string()),
            V3QueryPriority::I(_) => Some("I".to_string()),
            V3QueryPriority::Null(_) => None,
        }
    }
}
impl MetaValue for V3QueryPriority {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3QueryPriority::D(Some(e)) => e.get_field(field),
                V3QueryPriority::I(Some(e)) => e.get_field(field),
                V3QueryPriority::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3QueryPriority::D(Some(e)) => e.get_field_mut(field),
                V3QueryPriority::I(Some(e)) => e.get_field_mut(field),
                V3QueryPriority::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3QueryRequestLimit {
    #[doc = "record"]
    #[code = "RD"]
    RD(Option<Element>),
    #[doc = "QueryRequestLimit"]
    #[code = "_QueryRequestLimit"]
    _QueryRequestLimit(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3QueryRequestLimit {
    fn default() -> Self {
        V3QueryRequestLimit::Null(None)
    }
}
impl TryFrom<String> for V3QueryRequestLimit {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "RD" => Ok(V3QueryRequestLimit::RD(None)),
            "_QueryRequestLimit" => Ok(V3QueryRequestLimit::_QueryRequestLimit(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3QueryRequestLimit {
    fn into(self) -> Option<String> {
        match self {
            V3QueryRequestLimit::RD(_) => Some("RD".to_string()),
            V3QueryRequestLimit::_QueryRequestLimit(_) => Some("_QueryRequestLimit".to_string()),
            V3QueryRequestLimit::Null(_) => None,
        }
    }
}
impl MetaValue for V3QueryRequestLimit {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3QueryRequestLimit::RD(Some(e)) => e.get_field(field),
                V3QueryRequestLimit::_QueryRequestLimit(Some(e)) => e.get_field(field),
                V3QueryRequestLimit::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3QueryRequestLimit::RD(Some(e)) => e.get_field_mut(field),
                V3QueryRequestLimit::_QueryRequestLimit(Some(e)) => e.get_field_mut(field),
                V3QueryRequestLimit::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3QueryResponse {
    #[doc = "ApplicationError"]
    #[code = "AE"]
    AE(Option<Element>),
    #[doc = "No data found"]
    #[code = "NF"]
    NF(Option<Element>),
    #[doc = "Data found"]
    #[code = "OK"]
    OK(Option<Element>),
    #[doc = "QueryParameterError"]
    #[code = "QE"]
    QE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3QueryResponse {
    fn default() -> Self {
        V3QueryResponse::Null(None)
    }
}
impl TryFrom<String> for V3QueryResponse {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AE" => Ok(V3QueryResponse::AE(None)),
            "NF" => Ok(V3QueryResponse::NF(None)),
            "OK" => Ok(V3QueryResponse::OK(None)),
            "QE" => Ok(V3QueryResponse::QE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3QueryResponse {
    fn into(self) -> Option<String> {
        match self {
            V3QueryResponse::AE(_) => Some("AE".to_string()),
            V3QueryResponse::NF(_) => Some("NF".to_string()),
            V3QueryResponse::OK(_) => Some("OK".to_string()),
            V3QueryResponse::QE(_) => Some("QE".to_string()),
            V3QueryResponse::Null(_) => None,
        }
    }
}
impl MetaValue for V3QueryResponse {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3QueryResponse::AE(Some(e)) => e.get_field(field),
                V3QueryResponse::NF(Some(e)) => e.get_field(field),
                V3QueryResponse::OK(Some(e)) => e.get_field(field),
                V3QueryResponse::QE(Some(e)) => e.get_field(field),
                V3QueryResponse::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3QueryResponse::AE(Some(e)) => e.get_field_mut(field),
                V3QueryResponse::NF(Some(e)) => e.get_field_mut(field),
                V3QueryResponse::OK(Some(e)) => e.get_field_mut(field),
                V3QueryResponse::QE(Some(e)) => e.get_field_mut(field),
                V3QueryResponse::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3QueryStatusCode {
    #[doc = "aborted"]
    #[code = "aborted"]
    Aborted(Option<Element>),
    #[doc = "deliveredResponse"]
    #[code = "deliveredResponse"]
    DeliveredResponse(Option<Element>),
    #[doc = "executing"]
    #[code = "executing"]
    Executing(Option<Element>),
    #[doc = "new"]
    #[code = "new"]
    New(Option<Element>),
    #[doc = "waitContinuedQueryResponse"]
    #[code = "waitContinuedQueryResponse"]
    WaitContinuedQueryResponse(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3QueryStatusCode {
    fn default() -> Self {
        V3QueryStatusCode::Null(None)
    }
}
impl TryFrom<String> for V3QueryStatusCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "aborted" => Ok(V3QueryStatusCode::Aborted(None)),
            "deliveredResponse" => Ok(V3QueryStatusCode::DeliveredResponse(None)),
            "executing" => Ok(V3QueryStatusCode::Executing(None)),
            "new" => Ok(V3QueryStatusCode::New(None)),
            "waitContinuedQueryResponse" => Ok(V3QueryStatusCode::WaitContinuedQueryResponse(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3QueryStatusCode {
    fn into(self) -> Option<String> {
        match self {
            V3QueryStatusCode::Aborted(_) => Some("aborted".to_string()),
            V3QueryStatusCode::DeliveredResponse(_) => Some("deliveredResponse".to_string()),
            V3QueryStatusCode::Executing(_) => Some("executing".to_string()),
            V3QueryStatusCode::New(_) => Some("new".to_string()),
            V3QueryStatusCode::WaitContinuedQueryResponse(_) => {
                Some("waitContinuedQueryResponse".to_string())
            }
            V3QueryStatusCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3QueryStatusCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3QueryStatusCode::Aborted(Some(e)) => e.get_field(field),
                V3QueryStatusCode::DeliveredResponse(Some(e)) => e.get_field(field),
                V3QueryStatusCode::Executing(Some(e)) => e.get_field(field),
                V3QueryStatusCode::New(Some(e)) => e.get_field(field),
                V3QueryStatusCode::WaitContinuedQueryResponse(Some(e)) => e.get_field(field),
                V3QueryStatusCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3QueryStatusCode::Aborted(Some(e)) => e.get_field_mut(field),
                V3QueryStatusCode::DeliveredResponse(Some(e)) => e.get_field_mut(field),
                V3QueryStatusCode::Executing(Some(e)) => e.get_field_mut(field),
                V3QueryStatusCode::New(Some(e)) => e.get_field_mut(field),
                V3QueryStatusCode::WaitContinuedQueryResponse(Some(e)) => e.get_field_mut(field),
                V3QueryStatusCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3RelationalOperator {
    #[doc = "Contains"]
    #[code = "CT"]
    CT(Option<Element>),
    #[doc = "Equal"]
    #[code = "EQ"]
    EQ(Option<Element>),
    #[doc = "Greater than or equal"]
    #[code = "GE"]
    GE(Option<Element>),
    #[doc = "Generic"]
    #[code = "GN"]
    GN(Option<Element>),
    #[doc = "Greater than"]
    #[code = "GT"]
    GT(Option<Element>),
    #[doc = "Less than or equal"]
    #[code = "LE"]
    LE(Option<Element>),
    #[doc = "Less than"]
    #[code = "LT"]
    LT(Option<Element>),
    #[doc = "Not Equal"]
    #[code = "NE"]
    NE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3RelationalOperator {
    fn default() -> Self {
        V3RelationalOperator::Null(None)
    }
}
impl TryFrom<String> for V3RelationalOperator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CT" => Ok(V3RelationalOperator::CT(None)),
            "EQ" => Ok(V3RelationalOperator::EQ(None)),
            "GE" => Ok(V3RelationalOperator::GE(None)),
            "GN" => Ok(V3RelationalOperator::GN(None)),
            "GT" => Ok(V3RelationalOperator::GT(None)),
            "LE" => Ok(V3RelationalOperator::LE(None)),
            "LT" => Ok(V3RelationalOperator::LT(None)),
            "NE" => Ok(V3RelationalOperator::NE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3RelationalOperator {
    fn into(self) -> Option<String> {
        match self {
            V3RelationalOperator::CT(_) => Some("CT".to_string()),
            V3RelationalOperator::EQ(_) => Some("EQ".to_string()),
            V3RelationalOperator::GE(_) => Some("GE".to_string()),
            V3RelationalOperator::GN(_) => Some("GN".to_string()),
            V3RelationalOperator::GT(_) => Some("GT".to_string()),
            V3RelationalOperator::LE(_) => Some("LE".to_string()),
            V3RelationalOperator::LT(_) => Some("LT".to_string()),
            V3RelationalOperator::NE(_) => Some("NE".to_string()),
            V3RelationalOperator::Null(_) => None,
        }
    }
}
impl MetaValue for V3RelationalOperator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3RelationalOperator::CT(Some(e)) => e.get_field(field),
                V3RelationalOperator::EQ(Some(e)) => e.get_field(field),
                V3RelationalOperator::GE(Some(e)) => e.get_field(field),
                V3RelationalOperator::GN(Some(e)) => e.get_field(field),
                V3RelationalOperator::GT(Some(e)) => e.get_field(field),
                V3RelationalOperator::LE(Some(e)) => e.get_field(field),
                V3RelationalOperator::LT(Some(e)) => e.get_field(field),
                V3RelationalOperator::NE(Some(e)) => e.get_field(field),
                V3RelationalOperator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3RelationalOperator::CT(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::EQ(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::GE(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::GN(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::GT(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::LE(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::LT(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::NE(Some(e)) => e.get_field_mut(field),
                V3RelationalOperator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3RelationshipConjunction {
    #[doc = "and"]
    #[code = "AND"]
    AND(Option<Element>),
    #[doc = "or"]
    #[code = "OR"]
    OR(Option<Element>),
    #[doc = "exclusive or"]
    #[code = "XOR"]
    XOR(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3RelationshipConjunction {
    fn default() -> Self {
        V3RelationshipConjunction::Null(None)
    }
}
impl TryFrom<String> for V3RelationshipConjunction {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AND" => Ok(V3RelationshipConjunction::AND(None)),
            "OR" => Ok(V3RelationshipConjunction::OR(None)),
            "XOR" => Ok(V3RelationshipConjunction::XOR(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3RelationshipConjunction {
    fn into(self) -> Option<String> {
        match self {
            V3RelationshipConjunction::AND(_) => Some("AND".to_string()),
            V3RelationshipConjunction::OR(_) => Some("OR".to_string()),
            V3RelationshipConjunction::XOR(_) => Some("XOR".to_string()),
            V3RelationshipConjunction::Null(_) => None,
        }
    }
}
impl MetaValue for V3RelationshipConjunction {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3RelationshipConjunction::AND(Some(e)) => e.get_field(field),
                V3RelationshipConjunction::OR(Some(e)) => e.get_field(field),
                V3RelationshipConjunction::XOR(Some(e)) => e.get_field(field),
                V3RelationshipConjunction::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3RelationshipConjunction::AND(Some(e)) => e.get_field_mut(field),
                V3RelationshipConjunction::OR(Some(e)) => e.get_field_mut(field),
                V3RelationshipConjunction::XOR(Some(e)) => e.get_field_mut(field),
                V3RelationshipConjunction::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ReligiousAffiliation {
    #[doc = "Adventist"]
    #[code = "1001"]
    V1001(Option<Element>),
    #[doc = "African Religions"]
    #[code = "1002"]
    V1002(Option<Element>),
    #[doc = "Afro-Caribbean Religions"]
    #[code = "1003"]
    V1003(Option<Element>),
    #[doc = "Agnosticism"]
    #[code = "1004"]
    V1004(Option<Element>),
    #[doc = "Anglican"]
    #[code = "1005"]
    V1005(Option<Element>),
    #[doc = "Animism"]
    #[code = "1006"]
    V1006(Option<Element>),
    #[doc = "Atheism"]
    #[code = "1007"]
    V1007(Option<Element>),
    #[doc = "Babi & Baha'I faiths"]
    #[code = "1008"]
    V1008(Option<Element>),
    #[doc = "Baptist"]
    #[code = "1009"]
    V1009(Option<Element>),
    #[doc = "Bon"]
    #[code = "1010"]
    V1010(Option<Element>),
    #[doc = "Cao Dai"]
    #[code = "1011"]
    V1011(Option<Element>),
    #[doc = "Celticism"]
    #[code = "1012"]
    V1012(Option<Element>),
    #[doc = "Christian (non-Catholic, non-specific)"]
    #[code = "1013"]
    V1013(Option<Element>),
    #[doc = "Confucianism"]
    #[code = "1014"]
    V1014(Option<Element>),
    #[doc = "Cyberculture Religions"]
    #[code = "1015"]
    V1015(Option<Element>),
    #[doc = "Divination"]
    #[code = "1016"]
    V1016(Option<Element>),
    #[doc = "Fourth Way"]
    #[code = "1017"]
    V1017(Option<Element>),
    #[doc = "Free Daism"]
    #[code = "1018"]
    V1018(Option<Element>),
    #[doc = "Gnosis"]
    #[code = "1019"]
    V1019(Option<Element>),
    #[doc = "Hinduism"]
    #[code = "1020"]
    V1020(Option<Element>),
    #[doc = "Humanism"]
    #[code = "1021"]
    V1021(Option<Element>),
    #[doc = "Independent"]
    #[code = "1022"]
    V1022(Option<Element>),
    #[doc = "Islam"]
    #[code = "1023"]
    V1023(Option<Element>),
    #[doc = "Jainism"]
    #[code = "1024"]
    V1024(Option<Element>),
    #[doc = "Jehovah's Witnesses"]
    #[code = "1025"]
    V1025(Option<Element>),
    #[doc = "Judaism"]
    #[code = "1026"]
    V1026(Option<Element>),
    #[doc = "Latter Day Saints"]
    #[code = "1027"]
    V1027(Option<Element>),
    #[doc = "Lutheran"]
    #[code = "1028"]
    V1028(Option<Element>),
    #[doc = "Mahayana"]
    #[code = "1029"]
    V1029(Option<Element>),
    #[doc = "Meditation"]
    #[code = "1030"]
    V1030(Option<Element>),
    #[doc = "Messianic Judaism"]
    #[code = "1031"]
    V1031(Option<Element>),
    #[doc = "Mitraism"]
    #[code = "1032"]
    V1032(Option<Element>),
    #[doc = "New Age"]
    #[code = "1033"]
    V1033(Option<Element>),
    #[doc = "non-Roman Catholic"]
    #[code = "1034"]
    V1034(Option<Element>),
    #[doc = "Occult"]
    #[code = "1035"]
    V1035(Option<Element>),
    #[doc = "Orthodox"]
    #[code = "1036"]
    V1036(Option<Element>),
    #[doc = "Paganism"]
    #[code = "1037"]
    V1037(Option<Element>),
    #[doc = "Pentecostal"]
    #[code = "1038"]
    V1038(Option<Element>),
    #[doc = "Process, The"]
    #[code = "1039"]
    V1039(Option<Element>),
    #[doc = "Reformed/Presbyterian"]
    #[code = "1040"]
    V1040(Option<Element>),
    #[doc = "Roman Catholic Church"]
    #[code = "1041"]
    V1041(Option<Element>),
    #[doc = "Satanism"]
    #[code = "1042"]
    V1042(Option<Element>),
    #[doc = "Scientology"]
    #[code = "1043"]
    V1043(Option<Element>),
    #[doc = "Shamanism"]
    #[code = "1044"]
    V1044(Option<Element>),
    #[doc = "Shiite (Islam)"]
    #[code = "1045"]
    V1045(Option<Element>),
    #[doc = "Shinto"]
    #[code = "1046"]
    V1046(Option<Element>),
    #[doc = "Sikism"]
    #[code = "1047"]
    V1047(Option<Element>),
    #[doc = "Spiritualism"]
    #[code = "1048"]
    V1048(Option<Element>),
    #[doc = "Sunni (Islam)"]
    #[code = "1049"]
    V1049(Option<Element>),
    #[doc = "Taoism"]
    #[code = "1050"]
    V1050(Option<Element>),
    #[doc = "Theravada"]
    #[code = "1051"]
    V1051(Option<Element>),
    #[doc = "Unitarian-Universalism"]
    #[code = "1052"]
    V1052(Option<Element>),
    #[doc = "Universal Life Church"]
    #[code = "1053"]
    V1053(Option<Element>),
    #[doc = "Vajrayana (Tibetan)"]
    #[code = "1054"]
    V1054(Option<Element>),
    #[doc = "Veda"]
    #[code = "1055"]
    V1055(Option<Element>),
    #[doc = "Voodoo"]
    #[code = "1056"]
    V1056(Option<Element>),
    #[doc = "Wicca"]
    #[code = "1057"]
    V1057(Option<Element>),
    #[doc = "Yaohushua"]
    #[code = "1058"]
    V1058(Option<Element>),
    #[doc = "Zen Buddhism"]
    #[code = "1059"]
    V1059(Option<Element>),
    #[doc = "Zoroastrianism"]
    #[code = "1060"]
    V1060(Option<Element>),
    #[doc = "Assembly of God"]
    #[code = "1061"]
    V1061(Option<Element>),
    #[doc = "Brethren"]
    #[code = "1062"]
    V1062(Option<Element>),
    #[doc = "Christian Scientist"]
    #[code = "1063"]
    V1063(Option<Element>),
    #[doc = "Church of Christ"]
    #[code = "1064"]
    V1064(Option<Element>),
    #[doc = "Church of God"]
    #[code = "1065"]
    V1065(Option<Element>),
    #[doc = "Congregational"]
    #[code = "1066"]
    V1066(Option<Element>),
    #[doc = "Disciples of Christ"]
    #[code = "1067"]
    V1067(Option<Element>),
    #[doc = "Eastern Orthodox"]
    #[code = "1068"]
    V1068(Option<Element>),
    #[doc = "Episcopalian"]
    #[code = "1069"]
    V1069(Option<Element>),
    #[doc = "Evangelical Covenant"]
    #[code = "1070"]
    V1070(Option<Element>),
    #[doc = "Friends"]
    #[code = "1071"]
    V1071(Option<Element>),
    #[doc = "Full Gospel"]
    #[code = "1072"]
    V1072(Option<Element>),
    #[doc = "Methodist"]
    #[code = "1073"]
    V1073(Option<Element>),
    #[doc = "Native American"]
    #[code = "1074"]
    V1074(Option<Element>),
    #[doc = "Nazarene"]
    #[code = "1075"]
    V1075(Option<Element>),
    #[doc = "Presbyterian"]
    #[code = "1076"]
    V1076(Option<Element>),
    #[doc = "Protestant"]
    #[code = "1077"]
    V1077(Option<Element>),
    #[doc = "Protestant, No Denomination"]
    #[code = "1078"]
    V1078(Option<Element>),
    #[doc = "Reformed"]
    #[code = "1079"]
    V1079(Option<Element>),
    #[doc = "Salvation Army"]
    #[code = "1080"]
    V1080(Option<Element>),
    #[doc = "Unitarian Universalist"]
    #[code = "1081"]
    V1081(Option<Element>),
    #[doc = "United Church of Christ"]
    #[code = "1082"]
    V1082(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ReligiousAffiliation {
    fn default() -> Self {
        V3ReligiousAffiliation::Null(None)
    }
}
impl TryFrom<String> for V3ReligiousAffiliation {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "1001" => Ok(V3ReligiousAffiliation::V1001(None)),
            "1002" => Ok(V3ReligiousAffiliation::V1002(None)),
            "1003" => Ok(V3ReligiousAffiliation::V1003(None)),
            "1004" => Ok(V3ReligiousAffiliation::V1004(None)),
            "1005" => Ok(V3ReligiousAffiliation::V1005(None)),
            "1006" => Ok(V3ReligiousAffiliation::V1006(None)),
            "1007" => Ok(V3ReligiousAffiliation::V1007(None)),
            "1008" => Ok(V3ReligiousAffiliation::V1008(None)),
            "1009" => Ok(V3ReligiousAffiliation::V1009(None)),
            "1010" => Ok(V3ReligiousAffiliation::V1010(None)),
            "1011" => Ok(V3ReligiousAffiliation::V1011(None)),
            "1012" => Ok(V3ReligiousAffiliation::V1012(None)),
            "1013" => Ok(V3ReligiousAffiliation::V1013(None)),
            "1014" => Ok(V3ReligiousAffiliation::V1014(None)),
            "1015" => Ok(V3ReligiousAffiliation::V1015(None)),
            "1016" => Ok(V3ReligiousAffiliation::V1016(None)),
            "1017" => Ok(V3ReligiousAffiliation::V1017(None)),
            "1018" => Ok(V3ReligiousAffiliation::V1018(None)),
            "1019" => Ok(V3ReligiousAffiliation::V1019(None)),
            "1020" => Ok(V3ReligiousAffiliation::V1020(None)),
            "1021" => Ok(V3ReligiousAffiliation::V1021(None)),
            "1022" => Ok(V3ReligiousAffiliation::V1022(None)),
            "1023" => Ok(V3ReligiousAffiliation::V1023(None)),
            "1024" => Ok(V3ReligiousAffiliation::V1024(None)),
            "1025" => Ok(V3ReligiousAffiliation::V1025(None)),
            "1026" => Ok(V3ReligiousAffiliation::V1026(None)),
            "1027" => Ok(V3ReligiousAffiliation::V1027(None)),
            "1028" => Ok(V3ReligiousAffiliation::V1028(None)),
            "1029" => Ok(V3ReligiousAffiliation::V1029(None)),
            "1030" => Ok(V3ReligiousAffiliation::V1030(None)),
            "1031" => Ok(V3ReligiousAffiliation::V1031(None)),
            "1032" => Ok(V3ReligiousAffiliation::V1032(None)),
            "1033" => Ok(V3ReligiousAffiliation::V1033(None)),
            "1034" => Ok(V3ReligiousAffiliation::V1034(None)),
            "1035" => Ok(V3ReligiousAffiliation::V1035(None)),
            "1036" => Ok(V3ReligiousAffiliation::V1036(None)),
            "1037" => Ok(V3ReligiousAffiliation::V1037(None)),
            "1038" => Ok(V3ReligiousAffiliation::V1038(None)),
            "1039" => Ok(V3ReligiousAffiliation::V1039(None)),
            "1040" => Ok(V3ReligiousAffiliation::V1040(None)),
            "1041" => Ok(V3ReligiousAffiliation::V1041(None)),
            "1042" => Ok(V3ReligiousAffiliation::V1042(None)),
            "1043" => Ok(V3ReligiousAffiliation::V1043(None)),
            "1044" => Ok(V3ReligiousAffiliation::V1044(None)),
            "1045" => Ok(V3ReligiousAffiliation::V1045(None)),
            "1046" => Ok(V3ReligiousAffiliation::V1046(None)),
            "1047" => Ok(V3ReligiousAffiliation::V1047(None)),
            "1048" => Ok(V3ReligiousAffiliation::V1048(None)),
            "1049" => Ok(V3ReligiousAffiliation::V1049(None)),
            "1050" => Ok(V3ReligiousAffiliation::V1050(None)),
            "1051" => Ok(V3ReligiousAffiliation::V1051(None)),
            "1052" => Ok(V3ReligiousAffiliation::V1052(None)),
            "1053" => Ok(V3ReligiousAffiliation::V1053(None)),
            "1054" => Ok(V3ReligiousAffiliation::V1054(None)),
            "1055" => Ok(V3ReligiousAffiliation::V1055(None)),
            "1056" => Ok(V3ReligiousAffiliation::V1056(None)),
            "1057" => Ok(V3ReligiousAffiliation::V1057(None)),
            "1058" => Ok(V3ReligiousAffiliation::V1058(None)),
            "1059" => Ok(V3ReligiousAffiliation::V1059(None)),
            "1060" => Ok(V3ReligiousAffiliation::V1060(None)),
            "1061" => Ok(V3ReligiousAffiliation::V1061(None)),
            "1062" => Ok(V3ReligiousAffiliation::V1062(None)),
            "1063" => Ok(V3ReligiousAffiliation::V1063(None)),
            "1064" => Ok(V3ReligiousAffiliation::V1064(None)),
            "1065" => Ok(V3ReligiousAffiliation::V1065(None)),
            "1066" => Ok(V3ReligiousAffiliation::V1066(None)),
            "1067" => Ok(V3ReligiousAffiliation::V1067(None)),
            "1068" => Ok(V3ReligiousAffiliation::V1068(None)),
            "1069" => Ok(V3ReligiousAffiliation::V1069(None)),
            "1070" => Ok(V3ReligiousAffiliation::V1070(None)),
            "1071" => Ok(V3ReligiousAffiliation::V1071(None)),
            "1072" => Ok(V3ReligiousAffiliation::V1072(None)),
            "1073" => Ok(V3ReligiousAffiliation::V1073(None)),
            "1074" => Ok(V3ReligiousAffiliation::V1074(None)),
            "1075" => Ok(V3ReligiousAffiliation::V1075(None)),
            "1076" => Ok(V3ReligiousAffiliation::V1076(None)),
            "1077" => Ok(V3ReligiousAffiliation::V1077(None)),
            "1078" => Ok(V3ReligiousAffiliation::V1078(None)),
            "1079" => Ok(V3ReligiousAffiliation::V1079(None)),
            "1080" => Ok(V3ReligiousAffiliation::V1080(None)),
            "1081" => Ok(V3ReligiousAffiliation::V1081(None)),
            "1082" => Ok(V3ReligiousAffiliation::V1082(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ReligiousAffiliation {
    fn into(self) -> Option<String> {
        match self {
            V3ReligiousAffiliation::V1001(_) => Some("1001".to_string()),
            V3ReligiousAffiliation::V1002(_) => Some("1002".to_string()),
            V3ReligiousAffiliation::V1003(_) => Some("1003".to_string()),
            V3ReligiousAffiliation::V1004(_) => Some("1004".to_string()),
            V3ReligiousAffiliation::V1005(_) => Some("1005".to_string()),
            V3ReligiousAffiliation::V1006(_) => Some("1006".to_string()),
            V3ReligiousAffiliation::V1007(_) => Some("1007".to_string()),
            V3ReligiousAffiliation::V1008(_) => Some("1008".to_string()),
            V3ReligiousAffiliation::V1009(_) => Some("1009".to_string()),
            V3ReligiousAffiliation::V1010(_) => Some("1010".to_string()),
            V3ReligiousAffiliation::V1011(_) => Some("1011".to_string()),
            V3ReligiousAffiliation::V1012(_) => Some("1012".to_string()),
            V3ReligiousAffiliation::V1013(_) => Some("1013".to_string()),
            V3ReligiousAffiliation::V1014(_) => Some("1014".to_string()),
            V3ReligiousAffiliation::V1015(_) => Some("1015".to_string()),
            V3ReligiousAffiliation::V1016(_) => Some("1016".to_string()),
            V3ReligiousAffiliation::V1017(_) => Some("1017".to_string()),
            V3ReligiousAffiliation::V1018(_) => Some("1018".to_string()),
            V3ReligiousAffiliation::V1019(_) => Some("1019".to_string()),
            V3ReligiousAffiliation::V1020(_) => Some("1020".to_string()),
            V3ReligiousAffiliation::V1021(_) => Some("1021".to_string()),
            V3ReligiousAffiliation::V1022(_) => Some("1022".to_string()),
            V3ReligiousAffiliation::V1023(_) => Some("1023".to_string()),
            V3ReligiousAffiliation::V1024(_) => Some("1024".to_string()),
            V3ReligiousAffiliation::V1025(_) => Some("1025".to_string()),
            V3ReligiousAffiliation::V1026(_) => Some("1026".to_string()),
            V3ReligiousAffiliation::V1027(_) => Some("1027".to_string()),
            V3ReligiousAffiliation::V1028(_) => Some("1028".to_string()),
            V3ReligiousAffiliation::V1029(_) => Some("1029".to_string()),
            V3ReligiousAffiliation::V1030(_) => Some("1030".to_string()),
            V3ReligiousAffiliation::V1031(_) => Some("1031".to_string()),
            V3ReligiousAffiliation::V1032(_) => Some("1032".to_string()),
            V3ReligiousAffiliation::V1033(_) => Some("1033".to_string()),
            V3ReligiousAffiliation::V1034(_) => Some("1034".to_string()),
            V3ReligiousAffiliation::V1035(_) => Some("1035".to_string()),
            V3ReligiousAffiliation::V1036(_) => Some("1036".to_string()),
            V3ReligiousAffiliation::V1037(_) => Some("1037".to_string()),
            V3ReligiousAffiliation::V1038(_) => Some("1038".to_string()),
            V3ReligiousAffiliation::V1039(_) => Some("1039".to_string()),
            V3ReligiousAffiliation::V1040(_) => Some("1040".to_string()),
            V3ReligiousAffiliation::V1041(_) => Some("1041".to_string()),
            V3ReligiousAffiliation::V1042(_) => Some("1042".to_string()),
            V3ReligiousAffiliation::V1043(_) => Some("1043".to_string()),
            V3ReligiousAffiliation::V1044(_) => Some("1044".to_string()),
            V3ReligiousAffiliation::V1045(_) => Some("1045".to_string()),
            V3ReligiousAffiliation::V1046(_) => Some("1046".to_string()),
            V3ReligiousAffiliation::V1047(_) => Some("1047".to_string()),
            V3ReligiousAffiliation::V1048(_) => Some("1048".to_string()),
            V3ReligiousAffiliation::V1049(_) => Some("1049".to_string()),
            V3ReligiousAffiliation::V1050(_) => Some("1050".to_string()),
            V3ReligiousAffiliation::V1051(_) => Some("1051".to_string()),
            V3ReligiousAffiliation::V1052(_) => Some("1052".to_string()),
            V3ReligiousAffiliation::V1053(_) => Some("1053".to_string()),
            V3ReligiousAffiliation::V1054(_) => Some("1054".to_string()),
            V3ReligiousAffiliation::V1055(_) => Some("1055".to_string()),
            V3ReligiousAffiliation::V1056(_) => Some("1056".to_string()),
            V3ReligiousAffiliation::V1057(_) => Some("1057".to_string()),
            V3ReligiousAffiliation::V1058(_) => Some("1058".to_string()),
            V3ReligiousAffiliation::V1059(_) => Some("1059".to_string()),
            V3ReligiousAffiliation::V1060(_) => Some("1060".to_string()),
            V3ReligiousAffiliation::V1061(_) => Some("1061".to_string()),
            V3ReligiousAffiliation::V1062(_) => Some("1062".to_string()),
            V3ReligiousAffiliation::V1063(_) => Some("1063".to_string()),
            V3ReligiousAffiliation::V1064(_) => Some("1064".to_string()),
            V3ReligiousAffiliation::V1065(_) => Some("1065".to_string()),
            V3ReligiousAffiliation::V1066(_) => Some("1066".to_string()),
            V3ReligiousAffiliation::V1067(_) => Some("1067".to_string()),
            V3ReligiousAffiliation::V1068(_) => Some("1068".to_string()),
            V3ReligiousAffiliation::V1069(_) => Some("1069".to_string()),
            V3ReligiousAffiliation::V1070(_) => Some("1070".to_string()),
            V3ReligiousAffiliation::V1071(_) => Some("1071".to_string()),
            V3ReligiousAffiliation::V1072(_) => Some("1072".to_string()),
            V3ReligiousAffiliation::V1073(_) => Some("1073".to_string()),
            V3ReligiousAffiliation::V1074(_) => Some("1074".to_string()),
            V3ReligiousAffiliation::V1075(_) => Some("1075".to_string()),
            V3ReligiousAffiliation::V1076(_) => Some("1076".to_string()),
            V3ReligiousAffiliation::V1077(_) => Some("1077".to_string()),
            V3ReligiousAffiliation::V1078(_) => Some("1078".to_string()),
            V3ReligiousAffiliation::V1079(_) => Some("1079".to_string()),
            V3ReligiousAffiliation::V1080(_) => Some("1080".to_string()),
            V3ReligiousAffiliation::V1081(_) => Some("1081".to_string()),
            V3ReligiousAffiliation::V1082(_) => Some("1082".to_string()),
            V3ReligiousAffiliation::Null(_) => None,
        }
    }
}
impl MetaValue for V3ReligiousAffiliation {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ReligiousAffiliation::V1001(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1002(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1003(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1004(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1005(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1006(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1007(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1008(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1009(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1010(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1011(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1012(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1013(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1014(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1015(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1016(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1017(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1018(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1019(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1020(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1021(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1022(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1023(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1024(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1025(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1026(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1027(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1028(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1029(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1030(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1031(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1032(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1033(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1034(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1035(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1036(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1037(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1038(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1039(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1040(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1041(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1042(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1043(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1044(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1045(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1046(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1047(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1048(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1049(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1050(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1051(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1052(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1053(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1054(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1055(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1056(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1057(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1058(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1059(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1060(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1061(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1062(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1063(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1064(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1065(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1066(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1067(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1068(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1069(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1070(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1071(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1072(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1073(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1074(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1075(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1076(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1077(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1078(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1079(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1080(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1081(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::V1082(Some(e)) => e.get_field(field),
                V3ReligiousAffiliation::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ReligiousAffiliation::V1001(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1002(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1003(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1004(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1005(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1006(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1007(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1008(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1009(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1010(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1011(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1012(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1013(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1014(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1015(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1016(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1017(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1018(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1019(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1020(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1021(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1022(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1023(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1024(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1025(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1026(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1027(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1028(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1029(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1030(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1031(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1032(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1033(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1034(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1035(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1036(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1037(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1038(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1039(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1040(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1041(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1042(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1043(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1044(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1045(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1046(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1047(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1048(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1049(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1050(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1051(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1052(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1053(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1054(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1055(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1056(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1057(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1058(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1059(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1060(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1061(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1062(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1063(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1064(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1065(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1066(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1067(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1068(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1069(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1070(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1071(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1072(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1073(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1074(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1075(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1076(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1077(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1078(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1079(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1080(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1081(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::V1082(Some(e)) => e.get_field_mut(field),
                V3ReligiousAffiliation::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ResponseLevel {
    #[doc = "completion"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "detail"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "exception"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "confirmation"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "message-control"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "modification"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "none"]
    #[code = "X"]
    X(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ResponseLevel {
    fn default() -> Self {
        V3ResponseLevel::Null(None)
    }
}
impl TryFrom<String> for V3ResponseLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "C" => Ok(V3ResponseLevel::C(None)),
            "D" => Ok(V3ResponseLevel::D(None)),
            "E" => Ok(V3ResponseLevel::E(None)),
            "F" => Ok(V3ResponseLevel::F(None)),
            "N" => Ok(V3ResponseLevel::N(None)),
            "R" => Ok(V3ResponseLevel::R(None)),
            "X" => Ok(V3ResponseLevel::X(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ResponseLevel {
    fn into(self) -> Option<String> {
        match self {
            V3ResponseLevel::C(_) => Some("C".to_string()),
            V3ResponseLevel::D(_) => Some("D".to_string()),
            V3ResponseLevel::E(_) => Some("E".to_string()),
            V3ResponseLevel::F(_) => Some("F".to_string()),
            V3ResponseLevel::N(_) => Some("N".to_string()),
            V3ResponseLevel::R(_) => Some("R".to_string()),
            V3ResponseLevel::X(_) => Some("X".to_string()),
            V3ResponseLevel::Null(_) => None,
        }
    }
}
impl MetaValue for V3ResponseLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ResponseLevel::C(Some(e)) => e.get_field(field),
                V3ResponseLevel::D(Some(e)) => e.get_field(field),
                V3ResponseLevel::E(Some(e)) => e.get_field(field),
                V3ResponseLevel::F(Some(e)) => e.get_field(field),
                V3ResponseLevel::N(Some(e)) => e.get_field(field),
                V3ResponseLevel::R(Some(e)) => e.get_field(field),
                V3ResponseLevel::X(Some(e)) => e.get_field(field),
                V3ResponseLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ResponseLevel::C(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::D(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::E(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::F(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::N(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::R(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::X(Some(e)) => e.get_field_mut(field),
                V3ResponseLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ResponseModality {
    #[doc = "Batch"]
    #[code = "B"]
    B(Option<Element>),
    #[doc = "Real Time"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "Bolus"]
    #[code = "T"]
    T(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ResponseModality {
    fn default() -> Self {
        V3ResponseModality::Null(None)
    }
}
impl TryFrom<String> for V3ResponseModality {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "B" => Ok(V3ResponseModality::B(None)),
            "R" => Ok(V3ResponseModality::R(None)),
            "T" => Ok(V3ResponseModality::T(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ResponseModality {
    fn into(self) -> Option<String> {
        match self {
            V3ResponseModality::B(_) => Some("B".to_string()),
            V3ResponseModality::R(_) => Some("R".to_string()),
            V3ResponseModality::T(_) => Some("T".to_string()),
            V3ResponseModality::Null(_) => None,
        }
    }
}
impl MetaValue for V3ResponseModality {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ResponseModality::B(Some(e)) => e.get_field(field),
                V3ResponseModality::R(Some(e)) => e.get_field(field),
                V3ResponseModality::T(Some(e)) => e.get_field(field),
                V3ResponseModality::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ResponseModality::B(Some(e)) => e.get_field_mut(field),
                V3ResponseModality::R(Some(e)) => e.get_field_mut(field),
                V3ResponseModality::T(Some(e)) => e.get_field_mut(field),
                V3ResponseModality::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3ResponseMode {
    #[doc = "deferred"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "immediate"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "queue"]
    #[code = "Q"]
    Q(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3ResponseMode {
    fn default() -> Self {
        V3ResponseMode::Null(None)
    }
}
impl TryFrom<String> for V3ResponseMode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "D" => Ok(V3ResponseMode::D(None)),
            "I" => Ok(V3ResponseMode::I(None)),
            "Q" => Ok(V3ResponseMode::Q(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3ResponseMode {
    fn into(self) -> Option<String> {
        match self {
            V3ResponseMode::D(_) => Some("D".to_string()),
            V3ResponseMode::I(_) => Some("I".to_string()),
            V3ResponseMode::Q(_) => Some("Q".to_string()),
            V3ResponseMode::Null(_) => None,
        }
    }
}
impl MetaValue for V3ResponseMode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3ResponseMode::D(Some(e)) => e.get_field(field),
                V3ResponseMode::I(Some(e)) => e.get_field(field),
                V3ResponseMode::Q(Some(e)) => e.get_field(field),
                V3ResponseMode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3ResponseMode::D(Some(e)) => e.get_field_mut(field),
                V3ResponseMode::I(Some(e)) => e.get_field_mut(field),
                V3ResponseMode::Q(Some(e)) => e.get_field_mut(field),
                V3ResponseMode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3RoleLinkStatus {
    #[doc = "active"]
    #[code = "ACTIVE"]
    ACTIVE(Option<Element>),
    #[doc = "cancelled"]
    #[code = "CANCELLED"]
    CANCELLED(Option<Element>),
    #[doc = "completed"]
    #[code = "COMPLETED"]
    COMPLETED(Option<Element>),
    #[doc = "normal"]
    #[code = "NORMAL"]
    NORMAL(Option<Element>),
    #[doc = "nullified"]
    #[code = "NULLIFIED"]
    NULLIFIED(Option<Element>),
    #[doc = "pending"]
    #[code = "PENDING"]
    PENDING(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3RoleLinkStatus {
    fn default() -> Self {
        V3RoleLinkStatus::Null(None)
    }
}
impl TryFrom<String> for V3RoleLinkStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "ACTIVE" => Ok(V3RoleLinkStatus::ACTIVE(None)),
            "CANCELLED" => Ok(V3RoleLinkStatus::CANCELLED(None)),
            "COMPLETED" => Ok(V3RoleLinkStatus::COMPLETED(None)),
            "NORMAL" => Ok(V3RoleLinkStatus::NORMAL(None)),
            "NULLIFIED" => Ok(V3RoleLinkStatus::NULLIFIED(None)),
            "PENDING" => Ok(V3RoleLinkStatus::PENDING(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3RoleLinkStatus {
    fn into(self) -> Option<String> {
        match self {
            V3RoleLinkStatus::ACTIVE(_) => Some("ACTIVE".to_string()),
            V3RoleLinkStatus::CANCELLED(_) => Some("CANCELLED".to_string()),
            V3RoleLinkStatus::COMPLETED(_) => Some("COMPLETED".to_string()),
            V3RoleLinkStatus::NORMAL(_) => Some("NORMAL".to_string()),
            V3RoleLinkStatus::NULLIFIED(_) => Some("NULLIFIED".to_string()),
            V3RoleLinkStatus::PENDING(_) => Some("PENDING".to_string()),
            V3RoleLinkStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3RoleLinkStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3RoleLinkStatus::ACTIVE(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::CANCELLED(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::COMPLETED(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::NORMAL(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::NULLIFIED(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::PENDING(Some(e)) => e.get_field(field),
                V3RoleLinkStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3RoleLinkStatus::ACTIVE(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::CANCELLED(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::COMPLETED(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::NORMAL(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::NULLIFIED(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::PENDING(Some(e)) => e.get_field_mut(field),
                V3RoleLinkStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3RoleLinkType {
    #[doc = "is backup for"]
    #[code = "BACKUP"]
    BACKUP(Option<Element>),
    #[doc = "has contact"]
    #[code = "CONT"]
    CONT(Option<Element>),
    #[doc = "has direct authority over"]
    #[code = "DIRAUTH"]
    DIRAUTH(Option<Element>),
    #[doc = "Identification"]
    #[code = "IDENT"]
    IDENT(Option<Element>),
    #[doc = "has indirect authority over"]
    #[code = "INDAUTH"]
    INDAUTH(Option<Element>),
    #[doc = "has part"]
    #[code = "PART"]
    PART(Option<Element>),
    #[doc = "related"]
    #[code = "REL"]
    REL(Option<Element>),
    #[doc = "replaces"]
    #[code = "REPL"]
    REPL(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3RoleLinkType {
    fn default() -> Self {
        V3RoleLinkType::Null(None)
    }
}
impl TryFrom<String> for V3RoleLinkType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BACKUP" => Ok(V3RoleLinkType::BACKUP(None)),
            "CONT" => Ok(V3RoleLinkType::CONT(None)),
            "DIRAUTH" => Ok(V3RoleLinkType::DIRAUTH(None)),
            "IDENT" => Ok(V3RoleLinkType::IDENT(None)),
            "INDAUTH" => Ok(V3RoleLinkType::INDAUTH(None)),
            "PART" => Ok(V3RoleLinkType::PART(None)),
            "REL" => Ok(V3RoleLinkType::REL(None)),
            "REPL" => Ok(V3RoleLinkType::REPL(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3RoleLinkType {
    fn into(self) -> Option<String> {
        match self {
            V3RoleLinkType::BACKUP(_) => Some("BACKUP".to_string()),
            V3RoleLinkType::CONT(_) => Some("CONT".to_string()),
            V3RoleLinkType::DIRAUTH(_) => Some("DIRAUTH".to_string()),
            V3RoleLinkType::IDENT(_) => Some("IDENT".to_string()),
            V3RoleLinkType::INDAUTH(_) => Some("INDAUTH".to_string()),
            V3RoleLinkType::PART(_) => Some("PART".to_string()),
            V3RoleLinkType::REL(_) => Some("REL".to_string()),
            V3RoleLinkType::REPL(_) => Some("REPL".to_string()),
            V3RoleLinkType::Null(_) => None,
        }
    }
}
impl MetaValue for V3RoleLinkType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3RoleLinkType::BACKUP(Some(e)) => e.get_field(field),
                V3RoleLinkType::CONT(Some(e)) => e.get_field(field),
                V3RoleLinkType::DIRAUTH(Some(e)) => e.get_field(field),
                V3RoleLinkType::IDENT(Some(e)) => e.get_field(field),
                V3RoleLinkType::INDAUTH(Some(e)) => e.get_field(field),
                V3RoleLinkType::PART(Some(e)) => e.get_field(field),
                V3RoleLinkType::REL(Some(e)) => e.get_field(field),
                V3RoleLinkType::REPL(Some(e)) => e.get_field(field),
                V3RoleLinkType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3RoleLinkType::BACKUP(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::CONT(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::DIRAUTH(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::IDENT(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::INDAUTH(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::PART(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::REL(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::REPL(Some(e)) => e.get_field_mut(field),
                V3RoleLinkType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3RoleStatus {
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "cancelled"]
    #[code = "cancelled"]
    Cancelled(Option<Element>),
    #[doc = "normal"]
    #[code = "normal"]
    Normal(Option<Element>),
    #[doc = "nullified"]
    #[code = "nullified"]
    Nullified(Option<Element>),
    #[doc = "pending"]
    #[code = "pending"]
    Pending(Option<Element>),
    #[doc = "suspended"]
    #[code = "suspended"]
    Suspended(Option<Element>),
    #[doc = "terminated"]
    #[code = "terminated"]
    Terminated(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3RoleStatus {
    fn default() -> Self {
        V3RoleStatus::Null(None)
    }
}
impl TryFrom<String> for V3RoleStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(V3RoleStatus::Active(None)),
            "cancelled" => Ok(V3RoleStatus::Cancelled(None)),
            "normal" => Ok(V3RoleStatus::Normal(None)),
            "nullified" => Ok(V3RoleStatus::Nullified(None)),
            "pending" => Ok(V3RoleStatus::Pending(None)),
            "suspended" => Ok(V3RoleStatus::Suspended(None)),
            "terminated" => Ok(V3RoleStatus::Terminated(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3RoleStatus {
    fn into(self) -> Option<String> {
        match self {
            V3RoleStatus::Active(_) => Some("active".to_string()),
            V3RoleStatus::Cancelled(_) => Some("cancelled".to_string()),
            V3RoleStatus::Normal(_) => Some("normal".to_string()),
            V3RoleStatus::Nullified(_) => Some("nullified".to_string()),
            V3RoleStatus::Pending(_) => Some("pending".to_string()),
            V3RoleStatus::Suspended(_) => Some("suspended".to_string()),
            V3RoleStatus::Terminated(_) => Some("terminated".to_string()),
            V3RoleStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3RoleStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3RoleStatus::Active(Some(e)) => e.get_field(field),
                V3RoleStatus::Cancelled(Some(e)) => e.get_field(field),
                V3RoleStatus::Normal(Some(e)) => e.get_field(field),
                V3RoleStatus::Nullified(Some(e)) => e.get_field(field),
                V3RoleStatus::Pending(Some(e)) => e.get_field(field),
                V3RoleStatus::Suspended(Some(e)) => e.get_field(field),
                V3RoleStatus::Terminated(Some(e)) => e.get_field(field),
                V3RoleStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3RoleStatus::Active(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Cancelled(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Normal(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Nullified(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Pending(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Suspended(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Terminated(Some(e)) => e.get_field_mut(field),
                V3RoleStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Sequencing {
    #[doc = "Ascending"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "Descending"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "None"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Sequencing {
    fn default() -> Self {
        V3Sequencing::Null(None)
    }
}
impl TryFrom<String> for V3Sequencing {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3Sequencing::A(None)),
            "D" => Ok(V3Sequencing::D(None)),
            "N" => Ok(V3Sequencing::N(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Sequencing {
    fn into(self) -> Option<String> {
        match self {
            V3Sequencing::A(_) => Some("A".to_string()),
            V3Sequencing::D(_) => Some("D".to_string()),
            V3Sequencing::N(_) => Some("N".to_string()),
            V3Sequencing::Null(_) => None,
        }
    }
}
impl MetaValue for V3Sequencing {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Sequencing::A(Some(e)) => e.get_field(field),
                V3Sequencing::D(Some(e)) => e.get_field(field),
                V3Sequencing::N(Some(e)) => e.get_field(field),
                V3Sequencing::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Sequencing::A(Some(e)) => e.get_field_mut(field),
                V3Sequencing::D(Some(e)) => e.get_field_mut(field),
                V3Sequencing::N(Some(e)) => e.get_field_mut(field),
                V3Sequencing::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3SetOperator {
    #[doc = "intersect"]
    #[code = "A"]
    A(Option<Element>),
    #[doc = "exclude"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "convex hull"]
    #[code = "H"]
    H(Option<Element>),
    #[doc = "include"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "periodic hull"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "ValueSetOperator"]
    #[code = "_ValueSetOperator"]
    _ValueSetOperator(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3SetOperator {
    fn default() -> Self {
        V3SetOperator::Null(None)
    }
}
impl TryFrom<String> for V3SetOperator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "A" => Ok(V3SetOperator::A(None)),
            "E" => Ok(V3SetOperator::E(None)),
            "H" => Ok(V3SetOperator::H(None)),
            "I" => Ok(V3SetOperator::I(None)),
            "P" => Ok(V3SetOperator::P(None)),
            "_ValueSetOperator" => Ok(V3SetOperator::_ValueSetOperator(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3SetOperator {
    fn into(self) -> Option<String> {
        match self {
            V3SetOperator::A(_) => Some("A".to_string()),
            V3SetOperator::E(_) => Some("E".to_string()),
            V3SetOperator::H(_) => Some("H".to_string()),
            V3SetOperator::I(_) => Some("I".to_string()),
            V3SetOperator::P(_) => Some("P".to_string()),
            V3SetOperator::_ValueSetOperator(_) => Some("_ValueSetOperator".to_string()),
            V3SetOperator::Null(_) => None,
        }
    }
}
impl MetaValue for V3SetOperator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3SetOperator::A(Some(e)) => e.get_field(field),
                V3SetOperator::E(Some(e)) => e.get_field(field),
                V3SetOperator::H(Some(e)) => e.get_field(field),
                V3SetOperator::I(Some(e)) => e.get_field(field),
                V3SetOperator::P(Some(e)) => e.get_field(field),
                V3SetOperator::_ValueSetOperator(Some(e)) => e.get_field(field),
                V3SetOperator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3SetOperator::A(Some(e)) => e.get_field_mut(field),
                V3SetOperator::E(Some(e)) => e.get_field_mut(field),
                V3SetOperator::H(Some(e)) => e.get_field_mut(field),
                V3SetOperator::I(Some(e)) => e.get_field_mut(field),
                V3SetOperator::P(Some(e)) => e.get_field_mut(field),
                V3SetOperator::_ValueSetOperator(Some(e)) => e.get_field_mut(field),
                V3SetOperator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3SubstitutionCondition {
    #[doc = "Confirm first"]
    #[code = "CONFIRM"]
    CONFIRM(Option<Element>),
    #[doc = "No substitution"]
    #[code = "NOSUB"]
    NOSUB(Option<Element>),
    #[doc = "Notify first"]
    #[code = "NOTIFY"]
    NOTIFY(Option<Element>),
    #[doc = "Unconditional"]
    #[code = "UNCOND"]
    UNCOND(Option<Element>),
    #[doc = "Conditional"]
    #[code = "_Conditional"]
    _Conditional(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3SubstitutionCondition {
    fn default() -> Self {
        V3SubstitutionCondition::Null(None)
    }
}
impl TryFrom<String> for V3SubstitutionCondition {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CONFIRM" => Ok(V3SubstitutionCondition::CONFIRM(None)),
            "NOSUB" => Ok(V3SubstitutionCondition::NOSUB(None)),
            "NOTIFY" => Ok(V3SubstitutionCondition::NOTIFY(None)),
            "UNCOND" => Ok(V3SubstitutionCondition::UNCOND(None)),
            "_Conditional" => Ok(V3SubstitutionCondition::_Conditional(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3SubstitutionCondition {
    fn into(self) -> Option<String> {
        match self {
            V3SubstitutionCondition::CONFIRM(_) => Some("CONFIRM".to_string()),
            V3SubstitutionCondition::NOSUB(_) => Some("NOSUB".to_string()),
            V3SubstitutionCondition::NOTIFY(_) => Some("NOTIFY".to_string()),
            V3SubstitutionCondition::UNCOND(_) => Some("UNCOND".to_string()),
            V3SubstitutionCondition::_Conditional(_) => Some("_Conditional".to_string()),
            V3SubstitutionCondition::Null(_) => None,
        }
    }
}
impl MetaValue for V3SubstitutionCondition {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3SubstitutionCondition::CONFIRM(Some(e)) => e.get_field(field),
                V3SubstitutionCondition::NOSUB(Some(e)) => e.get_field(field),
                V3SubstitutionCondition::NOTIFY(Some(e)) => e.get_field(field),
                V3SubstitutionCondition::UNCOND(Some(e)) => e.get_field(field),
                V3SubstitutionCondition::_Conditional(Some(e)) => e.get_field(field),
                V3SubstitutionCondition::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3SubstitutionCondition::CONFIRM(Some(e)) => e.get_field_mut(field),
                V3SubstitutionCondition::NOSUB(Some(e)) => e.get_field_mut(field),
                V3SubstitutionCondition::NOTIFY(Some(e)) => e.get_field_mut(field),
                V3SubstitutionCondition::UNCOND(Some(e)) => e.get_field_mut(field),
                V3SubstitutionCondition::_Conditional(Some(e)) => e.get_field_mut(field),
                V3SubstitutionCondition::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TableCellHorizontalAlign {
    #[doc = "center"]
    #[code = "center"]
    Center(Option<Element>),
    #[doc = "char"]
    #[code = "char"]
    Char(Option<Element>),
    #[doc = "justify"]
    #[code = "justify"]
    Justify(Option<Element>),
    #[doc = "left"]
    #[code = "left"]
    Left(Option<Element>),
    #[doc = "right"]
    #[code = "right"]
    Right(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TableCellHorizontalAlign {
    fn default() -> Self {
        V3TableCellHorizontalAlign::Null(None)
    }
}
impl TryFrom<String> for V3TableCellHorizontalAlign {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "center" => Ok(V3TableCellHorizontalAlign::Center(None)),
            "char" => Ok(V3TableCellHorizontalAlign::Char(None)),
            "justify" => Ok(V3TableCellHorizontalAlign::Justify(None)),
            "left" => Ok(V3TableCellHorizontalAlign::Left(None)),
            "right" => Ok(V3TableCellHorizontalAlign::Right(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TableCellHorizontalAlign {
    fn into(self) -> Option<String> {
        match self {
            V3TableCellHorizontalAlign::Center(_) => Some("center".to_string()),
            V3TableCellHorizontalAlign::Char(_) => Some("char".to_string()),
            V3TableCellHorizontalAlign::Justify(_) => Some("justify".to_string()),
            V3TableCellHorizontalAlign::Left(_) => Some("left".to_string()),
            V3TableCellHorizontalAlign::Right(_) => Some("right".to_string()),
            V3TableCellHorizontalAlign::Null(_) => None,
        }
    }
}
impl MetaValue for V3TableCellHorizontalAlign {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TableCellHorizontalAlign::Center(Some(e)) => e.get_field(field),
                V3TableCellHorizontalAlign::Char(Some(e)) => e.get_field(field),
                V3TableCellHorizontalAlign::Justify(Some(e)) => e.get_field(field),
                V3TableCellHorizontalAlign::Left(Some(e)) => e.get_field(field),
                V3TableCellHorizontalAlign::Right(Some(e)) => e.get_field(field),
                V3TableCellHorizontalAlign::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TableCellHorizontalAlign::Center(Some(e)) => e.get_field_mut(field),
                V3TableCellHorizontalAlign::Char(Some(e)) => e.get_field_mut(field),
                V3TableCellHorizontalAlign::Justify(Some(e)) => e.get_field_mut(field),
                V3TableCellHorizontalAlign::Left(Some(e)) => e.get_field_mut(field),
                V3TableCellHorizontalAlign::Right(Some(e)) => e.get_field_mut(field),
                V3TableCellHorizontalAlign::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TableCellScope {
    #[doc = "col"]
    #[code = "col"]
    Col(Option<Element>),
    #[doc = "colgroup"]
    #[code = "colgroup"]
    Colgroup(Option<Element>),
    #[doc = "row"]
    #[code = "row"]
    Row(Option<Element>),
    #[doc = "rowgroup"]
    #[code = "rowgroup"]
    Rowgroup(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TableCellScope {
    fn default() -> Self {
        V3TableCellScope::Null(None)
    }
}
impl TryFrom<String> for V3TableCellScope {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "col" => Ok(V3TableCellScope::Col(None)),
            "colgroup" => Ok(V3TableCellScope::Colgroup(None)),
            "row" => Ok(V3TableCellScope::Row(None)),
            "rowgroup" => Ok(V3TableCellScope::Rowgroup(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TableCellScope {
    fn into(self) -> Option<String> {
        match self {
            V3TableCellScope::Col(_) => Some("col".to_string()),
            V3TableCellScope::Colgroup(_) => Some("colgroup".to_string()),
            V3TableCellScope::Row(_) => Some("row".to_string()),
            V3TableCellScope::Rowgroup(_) => Some("rowgroup".to_string()),
            V3TableCellScope::Null(_) => None,
        }
    }
}
impl MetaValue for V3TableCellScope {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TableCellScope::Col(Some(e)) => e.get_field(field),
                V3TableCellScope::Colgroup(Some(e)) => e.get_field(field),
                V3TableCellScope::Row(Some(e)) => e.get_field(field),
                V3TableCellScope::Rowgroup(Some(e)) => e.get_field(field),
                V3TableCellScope::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TableCellScope::Col(Some(e)) => e.get_field_mut(field),
                V3TableCellScope::Colgroup(Some(e)) => e.get_field_mut(field),
                V3TableCellScope::Row(Some(e)) => e.get_field_mut(field),
                V3TableCellScope::Rowgroup(Some(e)) => e.get_field_mut(field),
                V3TableCellScope::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TableCellVerticalAlign {
    #[doc = "baseline"]
    #[code = "baseline"]
    Baseline(Option<Element>),
    #[doc = "bottom"]
    #[code = "bottom"]
    Bottom(Option<Element>),
    #[doc = "middle"]
    #[code = "middle"]
    Middle(Option<Element>),
    #[doc = "top"]
    #[code = "top"]
    Top(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TableCellVerticalAlign {
    fn default() -> Self {
        V3TableCellVerticalAlign::Null(None)
    }
}
impl TryFrom<String> for V3TableCellVerticalAlign {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "baseline" => Ok(V3TableCellVerticalAlign::Baseline(None)),
            "bottom" => Ok(V3TableCellVerticalAlign::Bottom(None)),
            "middle" => Ok(V3TableCellVerticalAlign::Middle(None)),
            "top" => Ok(V3TableCellVerticalAlign::Top(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TableCellVerticalAlign {
    fn into(self) -> Option<String> {
        match self {
            V3TableCellVerticalAlign::Baseline(_) => Some("baseline".to_string()),
            V3TableCellVerticalAlign::Bottom(_) => Some("bottom".to_string()),
            V3TableCellVerticalAlign::Middle(_) => Some("middle".to_string()),
            V3TableCellVerticalAlign::Top(_) => Some("top".to_string()),
            V3TableCellVerticalAlign::Null(_) => None,
        }
    }
}
impl MetaValue for V3TableCellVerticalAlign {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TableCellVerticalAlign::Baseline(Some(e)) => e.get_field(field),
                V3TableCellVerticalAlign::Bottom(Some(e)) => e.get_field(field),
                V3TableCellVerticalAlign::Middle(Some(e)) => e.get_field(field),
                V3TableCellVerticalAlign::Top(Some(e)) => e.get_field(field),
                V3TableCellVerticalAlign::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TableCellVerticalAlign::Baseline(Some(e)) => e.get_field_mut(field),
                V3TableCellVerticalAlign::Bottom(Some(e)) => e.get_field_mut(field),
                V3TableCellVerticalAlign::Middle(Some(e)) => e.get_field_mut(field),
                V3TableCellVerticalAlign::Top(Some(e)) => e.get_field_mut(field),
                V3TableCellVerticalAlign::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TableFrame {
    #[doc = "above"]
    #[code = "above"]
    Above(Option<Element>),
    #[doc = "below"]
    #[code = "below"]
    Below(Option<Element>),
    #[doc = "border"]
    #[code = "border"]
    Border(Option<Element>),
    #[doc = "box"]
    #[code = "box"]
    Box(Option<Element>),
    #[doc = "hsides"]
    #[code = "hsides"]
    Hsides(Option<Element>),
    #[doc = "lhs"]
    #[code = "lhs"]
    Lhs(Option<Element>),
    #[doc = "rhs"]
    #[code = "rhs"]
    Rhs(Option<Element>),
    #[doc = "void"]
    #[code = "void"]
    Void(Option<Element>),
    #[doc = "vsides"]
    #[code = "vsides"]
    Vsides(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TableFrame {
    fn default() -> Self {
        V3TableFrame::Null(None)
    }
}
impl TryFrom<String> for V3TableFrame {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "above" => Ok(V3TableFrame::Above(None)),
            "below" => Ok(V3TableFrame::Below(None)),
            "border" => Ok(V3TableFrame::Border(None)),
            "box" => Ok(V3TableFrame::Box(None)),
            "hsides" => Ok(V3TableFrame::Hsides(None)),
            "lhs" => Ok(V3TableFrame::Lhs(None)),
            "rhs" => Ok(V3TableFrame::Rhs(None)),
            "void" => Ok(V3TableFrame::Void(None)),
            "vsides" => Ok(V3TableFrame::Vsides(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TableFrame {
    fn into(self) -> Option<String> {
        match self {
            V3TableFrame::Above(_) => Some("above".to_string()),
            V3TableFrame::Below(_) => Some("below".to_string()),
            V3TableFrame::Border(_) => Some("border".to_string()),
            V3TableFrame::Box(_) => Some("box".to_string()),
            V3TableFrame::Hsides(_) => Some("hsides".to_string()),
            V3TableFrame::Lhs(_) => Some("lhs".to_string()),
            V3TableFrame::Rhs(_) => Some("rhs".to_string()),
            V3TableFrame::Void(_) => Some("void".to_string()),
            V3TableFrame::Vsides(_) => Some("vsides".to_string()),
            V3TableFrame::Null(_) => None,
        }
    }
}
impl MetaValue for V3TableFrame {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TableFrame::Above(Some(e)) => e.get_field(field),
                V3TableFrame::Below(Some(e)) => e.get_field(field),
                V3TableFrame::Border(Some(e)) => e.get_field(field),
                V3TableFrame::Box(Some(e)) => e.get_field(field),
                V3TableFrame::Hsides(Some(e)) => e.get_field(field),
                V3TableFrame::Lhs(Some(e)) => e.get_field(field),
                V3TableFrame::Rhs(Some(e)) => e.get_field(field),
                V3TableFrame::Void(Some(e)) => e.get_field(field),
                V3TableFrame::Vsides(Some(e)) => e.get_field(field),
                V3TableFrame::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TableFrame::Above(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Below(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Border(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Box(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Hsides(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Lhs(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Rhs(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Void(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Vsides(Some(e)) => e.get_field_mut(field),
                V3TableFrame::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TableRules {
    #[doc = "all"]
    #[code = "all"]
    All(Option<Element>),
    #[doc = "cols"]
    #[code = "cols"]
    Cols(Option<Element>),
    #[doc = "groups"]
    #[code = "groups"]
    Groups(Option<Element>),
    #[doc = "none"]
    #[code = "none"]
    None(Option<Element>),
    #[doc = "rows"]
    #[code = "rows"]
    Rows(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TableRules {
    fn default() -> Self {
        V3TableRules::Null(None)
    }
}
impl TryFrom<String> for V3TableRules {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all" => Ok(V3TableRules::All(None)),
            "cols" => Ok(V3TableRules::Cols(None)),
            "groups" => Ok(V3TableRules::Groups(None)),
            "none" => Ok(V3TableRules::None(None)),
            "rows" => Ok(V3TableRules::Rows(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TableRules {
    fn into(self) -> Option<String> {
        match self {
            V3TableRules::All(_) => Some("all".to_string()),
            V3TableRules::Cols(_) => Some("cols".to_string()),
            V3TableRules::Groups(_) => Some("groups".to_string()),
            V3TableRules::None(_) => Some("none".to_string()),
            V3TableRules::Rows(_) => Some("rows".to_string()),
            V3TableRules::Null(_) => None,
        }
    }
}
impl MetaValue for V3TableRules {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TableRules::All(Some(e)) => e.get_field(field),
                V3TableRules::Cols(Some(e)) => e.get_field(field),
                V3TableRules::Groups(Some(e)) => e.get_field(field),
                V3TableRules::None(Some(e)) => e.get_field(field),
                V3TableRules::Rows(Some(e)) => e.get_field(field),
                V3TableRules::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TableRules::All(Some(e)) => e.get_field_mut(field),
                V3TableRules::Cols(Some(e)) => e.get_field_mut(field),
                V3TableRules::Groups(Some(e)) => e.get_field_mut(field),
                V3TableRules::None(Some(e)) => e.get_field_mut(field),
                V3TableRules::Rows(Some(e)) => e.get_field_mut(field),
                V3TableRules::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TargetAwareness {
    #[doc = "denying"]
    #[code = "D"]
    D(Option<Element>),
    #[doc = "full awareness"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "incapable"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "marginal"]
    #[code = "M"]
    M(Option<Element>),
    #[doc = "partial"]
    #[code = "P"]
    P(Option<Element>),
    #[doc = "uninformed"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TargetAwareness {
    fn default() -> Self {
        V3TargetAwareness::Null(None)
    }
}
impl TryFrom<String> for V3TargetAwareness {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "D" => Ok(V3TargetAwareness::D(None)),
            "F" => Ok(V3TargetAwareness::F(None)),
            "I" => Ok(V3TargetAwareness::I(None)),
            "M" => Ok(V3TargetAwareness::M(None)),
            "P" => Ok(V3TargetAwareness::P(None)),
            "U" => Ok(V3TargetAwareness::U(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TargetAwareness {
    fn into(self) -> Option<String> {
        match self {
            V3TargetAwareness::D(_) => Some("D".to_string()),
            V3TargetAwareness::F(_) => Some("F".to_string()),
            V3TargetAwareness::I(_) => Some("I".to_string()),
            V3TargetAwareness::M(_) => Some("M".to_string()),
            V3TargetAwareness::P(_) => Some("P".to_string()),
            V3TargetAwareness::U(_) => Some("U".to_string()),
            V3TargetAwareness::Null(_) => None,
        }
    }
}
impl MetaValue for V3TargetAwareness {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TargetAwareness::D(Some(e)) => e.get_field(field),
                V3TargetAwareness::F(Some(e)) => e.get_field(field),
                V3TargetAwareness::I(Some(e)) => e.get_field(field),
                V3TargetAwareness::M(Some(e)) => e.get_field(field),
                V3TargetAwareness::P(Some(e)) => e.get_field(field),
                V3TargetAwareness::U(Some(e)) => e.get_field(field),
                V3TargetAwareness::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TargetAwareness::D(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::F(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::I(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::M(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::P(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::U(Some(e)) => e.get_field_mut(field),
                V3TargetAwareness::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TelecommunicationCapabilities {
    #[doc = "data"]
    #[code = "data"]
    Data(Option<Element>),
    #[doc = "fax"]
    #[code = "fax"]
    Fax(Option<Element>),
    #[doc = "sms"]
    #[code = "sms"]
    Sms(Option<Element>),
    #[doc = "text"]
    #[code = "tty"]
    Tty(Option<Element>),
    #[doc = "voice"]
    #[code = "voice"]
    Voice(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TelecommunicationCapabilities {
    fn default() -> Self {
        V3TelecommunicationCapabilities::Null(None)
    }
}
impl TryFrom<String> for V3TelecommunicationCapabilities {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "data" => Ok(V3TelecommunicationCapabilities::Data(None)),
            "fax" => Ok(V3TelecommunicationCapabilities::Fax(None)),
            "sms" => Ok(V3TelecommunicationCapabilities::Sms(None)),
            "tty" => Ok(V3TelecommunicationCapabilities::Tty(None)),
            "voice" => Ok(V3TelecommunicationCapabilities::Voice(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TelecommunicationCapabilities {
    fn into(self) -> Option<String> {
        match self {
            V3TelecommunicationCapabilities::Data(_) => Some("data".to_string()),
            V3TelecommunicationCapabilities::Fax(_) => Some("fax".to_string()),
            V3TelecommunicationCapabilities::Sms(_) => Some("sms".to_string()),
            V3TelecommunicationCapabilities::Tty(_) => Some("tty".to_string()),
            V3TelecommunicationCapabilities::Voice(_) => Some("voice".to_string()),
            V3TelecommunicationCapabilities::Null(_) => None,
        }
    }
}
impl MetaValue for V3TelecommunicationCapabilities {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TelecommunicationCapabilities::Data(Some(e)) => e.get_field(field),
                V3TelecommunicationCapabilities::Fax(Some(e)) => e.get_field(field),
                V3TelecommunicationCapabilities::Sms(Some(e)) => e.get_field(field),
                V3TelecommunicationCapabilities::Tty(Some(e)) => e.get_field(field),
                V3TelecommunicationCapabilities::Voice(Some(e)) => e.get_field(field),
                V3TelecommunicationCapabilities::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TelecommunicationCapabilities::Data(Some(e)) => e.get_field_mut(field),
                V3TelecommunicationCapabilities::Fax(Some(e)) => e.get_field_mut(field),
                V3TelecommunicationCapabilities::Sms(Some(e)) => e.get_field_mut(field),
                V3TelecommunicationCapabilities::Tty(Some(e)) => e.get_field_mut(field),
                V3TelecommunicationCapabilities::Voice(Some(e)) => e.get_field_mut(field),
                V3TelecommunicationCapabilities::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TimingEvent {
    #[doc = "AC"]
    #[code = "AC"]
    AC(Option<Element>),
    #[doc = "ACD"]
    #[code = "ACD"]
    ACD(Option<Element>),
    #[doc = "ACM"]
    #[code = "ACM"]
    ACM(Option<Element>),
    #[doc = "ACV"]
    #[code = "ACV"]
    ACV(Option<Element>),
    #[doc = "C"]
    #[code = "C"]
    C(Option<Element>),
    #[doc = "CD"]
    #[code = "CD"]
    CD(Option<Element>),
    #[doc = "CM"]
    #[code = "CM"]
    CM(Option<Element>),
    #[doc = "CV"]
    #[code = "CV"]
    CV(Option<Element>),
    #[doc = "HS"]
    #[code = "HS"]
    HS(Option<Element>),
    #[doc = "IC"]
    #[code = "IC"]
    IC(Option<Element>),
    #[doc = "ICD"]
    #[code = "ICD"]
    ICD(Option<Element>),
    #[doc = "ICM"]
    #[code = "ICM"]
    ICM(Option<Element>),
    #[doc = "ICV"]
    #[code = "ICV"]
    ICV(Option<Element>),
    #[doc = "PC"]
    #[code = "PC"]
    PC(Option<Element>),
    #[doc = "PCD"]
    #[code = "PCD"]
    PCD(Option<Element>),
    #[doc = "PCM"]
    #[code = "PCM"]
    PCM(Option<Element>),
    #[doc = "PCV"]
    #[code = "PCV"]
    PCV(Option<Element>),
    #[doc = "WAKE"]
    #[code = "WAKE"]
    WAKE(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TimingEvent {
    fn default() -> Self {
        V3TimingEvent::Null(None)
    }
}
impl TryFrom<String> for V3TimingEvent {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AC" => Ok(V3TimingEvent::AC(None)),
            "ACD" => Ok(V3TimingEvent::ACD(None)),
            "ACM" => Ok(V3TimingEvent::ACM(None)),
            "ACV" => Ok(V3TimingEvent::ACV(None)),
            "C" => Ok(V3TimingEvent::C(None)),
            "CD" => Ok(V3TimingEvent::CD(None)),
            "CM" => Ok(V3TimingEvent::CM(None)),
            "CV" => Ok(V3TimingEvent::CV(None)),
            "HS" => Ok(V3TimingEvent::HS(None)),
            "IC" => Ok(V3TimingEvent::IC(None)),
            "ICD" => Ok(V3TimingEvent::ICD(None)),
            "ICM" => Ok(V3TimingEvent::ICM(None)),
            "ICV" => Ok(V3TimingEvent::ICV(None)),
            "PC" => Ok(V3TimingEvent::PC(None)),
            "PCD" => Ok(V3TimingEvent::PCD(None)),
            "PCM" => Ok(V3TimingEvent::PCM(None)),
            "PCV" => Ok(V3TimingEvent::PCV(None)),
            "WAKE" => Ok(V3TimingEvent::WAKE(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TimingEvent {
    fn into(self) -> Option<String> {
        match self {
            V3TimingEvent::AC(_) => Some("AC".to_string()),
            V3TimingEvent::ACD(_) => Some("ACD".to_string()),
            V3TimingEvent::ACM(_) => Some("ACM".to_string()),
            V3TimingEvent::ACV(_) => Some("ACV".to_string()),
            V3TimingEvent::C(_) => Some("C".to_string()),
            V3TimingEvent::CD(_) => Some("CD".to_string()),
            V3TimingEvent::CM(_) => Some("CM".to_string()),
            V3TimingEvent::CV(_) => Some("CV".to_string()),
            V3TimingEvent::HS(_) => Some("HS".to_string()),
            V3TimingEvent::IC(_) => Some("IC".to_string()),
            V3TimingEvent::ICD(_) => Some("ICD".to_string()),
            V3TimingEvent::ICM(_) => Some("ICM".to_string()),
            V3TimingEvent::ICV(_) => Some("ICV".to_string()),
            V3TimingEvent::PC(_) => Some("PC".to_string()),
            V3TimingEvent::PCD(_) => Some("PCD".to_string()),
            V3TimingEvent::PCM(_) => Some("PCM".to_string()),
            V3TimingEvent::PCV(_) => Some("PCV".to_string()),
            V3TimingEvent::WAKE(_) => Some("WAKE".to_string()),
            V3TimingEvent::Null(_) => None,
        }
    }
}
impl MetaValue for V3TimingEvent {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TimingEvent::AC(Some(e)) => e.get_field(field),
                V3TimingEvent::ACD(Some(e)) => e.get_field(field),
                V3TimingEvent::ACM(Some(e)) => e.get_field(field),
                V3TimingEvent::ACV(Some(e)) => e.get_field(field),
                V3TimingEvent::C(Some(e)) => e.get_field(field),
                V3TimingEvent::CD(Some(e)) => e.get_field(field),
                V3TimingEvent::CM(Some(e)) => e.get_field(field),
                V3TimingEvent::CV(Some(e)) => e.get_field(field),
                V3TimingEvent::HS(Some(e)) => e.get_field(field),
                V3TimingEvent::IC(Some(e)) => e.get_field(field),
                V3TimingEvent::ICD(Some(e)) => e.get_field(field),
                V3TimingEvent::ICM(Some(e)) => e.get_field(field),
                V3TimingEvent::ICV(Some(e)) => e.get_field(field),
                V3TimingEvent::PC(Some(e)) => e.get_field(field),
                V3TimingEvent::PCD(Some(e)) => e.get_field(field),
                V3TimingEvent::PCM(Some(e)) => e.get_field(field),
                V3TimingEvent::PCV(Some(e)) => e.get_field(field),
                V3TimingEvent::WAKE(Some(e)) => e.get_field(field),
                V3TimingEvent::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TimingEvent::AC(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ACD(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ACM(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ACV(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::C(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::CD(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::CM(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::CV(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::HS(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::IC(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ICD(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ICM(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::ICV(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::PC(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::PCD(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::PCM(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::PCV(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::WAKE(Some(e)) => e.get_field_mut(field),
                V3TimingEvent::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TransmissionRelationshipTypeCode {
    #[doc = "sequence"]
    #[code = "SEQL"]
    SEQL(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TransmissionRelationshipTypeCode {
    fn default() -> Self {
        V3TransmissionRelationshipTypeCode::Null(None)
    }
}
impl TryFrom<String> for V3TransmissionRelationshipTypeCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "SEQL" => Ok(V3TransmissionRelationshipTypeCode::SEQL(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TransmissionRelationshipTypeCode {
    fn into(self) -> Option<String> {
        match self {
            V3TransmissionRelationshipTypeCode::SEQL(_) => Some("SEQL".to_string()),
            V3TransmissionRelationshipTypeCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3TransmissionRelationshipTypeCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TransmissionRelationshipTypeCode::SEQL(Some(e)) => e.get_field(field),
                V3TransmissionRelationshipTypeCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TransmissionRelationshipTypeCode::SEQL(Some(e)) => e.get_field_mut(field),
                V3TransmissionRelationshipTypeCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3VaccineManufacturer {
    #[doc = "Abbott Laboratories (includes Ross Products Division)"]
    #[code = "AB"]
    AB(Option<Element>),
    #[doc = "Adams Laboratories"]
    #[code = "AD"]
    AD(Option<Element>),
    #[doc = "Alpha Therapeutic Corporation"]
    #[code = "ALP"]
    ALP(Option<Element>),
    #[doc = "Armour [Inactive - use CEN]"]
    #[code = "AR"]
    AR(Option<Element>),
    #[doc = "Aviron"]
    #[code = "AVI"]
    AVI(Option<Element>),
    #[doc = "Baxter Healthcare Corporation"]
    #[code = "BA"]
    BA(Option<Element>),
    #[doc = "Bayer Corporation (includes Miles, Inc. and Cutter Laboratories)"]
    #[code = "BAY"]
    BAY(Option<Element>),
    #[doc = "Berna Products [Inactive - use BPC]"]
    #[code = "BP"]
    BP(Option<Element>),
    #[doc = "Berna Products Corporation (includes Swiss Serum and Vaccine Institute Berne)"]
    #[code = "BPC"]
    BPC(Option<Element>),
    #[doc = "Centeon L.L.C. (includes Armour Pharmaceutical Company)"]
    #[code = "CEN"]
    CEN(Option<Element>),
    #[doc = "Chiron Corporation"]
    #[code = "CHI"]
    CHI(Option<Element>),
    #[doc = "Connaught [Inactive - use PMC]"]
    #[code = "CON"]
    CON(Option<Element>),
    #[doc = "Evans Medical Limited (an affiliate of Medeva Pharmaceuticals, Inc.)"]
    #[code = "EVN"]
    EVN(Option<Element>),
    #[doc = "Greer Laboratories, Inc."]
    #[code = "GRE"]
    GRE(Option<Element>),
    #[doc = "Immuno International AG"]
    #[code = "IAG"]
    IAG(Option<Element>),
    #[doc = "Merieux [Inactive - use PMC]"]
    #[code = "IM"]
    IM(Option<Element>),
    #[doc = "Immuno-U.S., Inc."]
    #[code = "IUS"]
    IUS(Option<Element>),
    #[doc = "The Research Foundation for Microbial Diseases of Osaka University (BIKEN)"]
    #[code = "JPN"]
    JPN(Option<Element>),
    #[doc = "Korea Green Cross Corporation"]
    #[code = "KGC"]
    KGC(Option<Element>),
    #[doc = "Lederle [Inactive - use WAL]"]
    #[code = "LED"]
    LED(Option<Element>),
    #[doc = "Massachusetts Public Health Biologic Laboratories"]
    #[code = "MA"]
    MA(Option<Element>),
    #[doc = "MedImmune, Inc."]
    #[code = "MED"]
    MED(Option<Element>),
    #[doc = "Miles [Inactive - use BAY]"]
    #[code = "MIL"]
    MIL(Option<Element>),
    #[doc = "Bioport Corporation (formerly Michigan Biologic Products Institute)"]
    #[code = "MIP"]
    MIP(Option<Element>),
    #[doc = "Merck and Co., Inc."]
    #[code = "MSD"]
    MSD(Option<Element>),
    #[doc = "NABI (formerly North American Biologicals, Inc.)"]
    #[code = "NAB"]
    NAB(Option<Element>),
    #[doc = "North American Vaccine, Inc."]
    #[code = "NAV"]
    NAV(Option<Element>),
    #[doc = "Novartis Pharmaceutical Corporation (includes Ciba-Geigy Limited and Sandoz Limited)"]
    #[code = "NOV"]
    NOV(Option<Element>),
    #[doc = "New York Blood Center"]
    #[code = "NYB"]
    NYB(Option<Element>),
    #[doc = "Ortho Diagnostic Systems, Inc."]
    #[code = "ORT"]
    ORT(Option<Element>),
    #[doc = "Organon Teknika Corporation"]
    #[code = "OTC"]
    OTC(Option<Element>),
    #[doc = "Parkedale Pharmaceuticals (formerly Parke-Davis)"]
    #[code = "PD"]
    PD(Option<Element>),
    #[doc = "Aventis Pasteur Inc. (formerly Pasteur Merieux Connaught; includes Connaught Laboratories and Pasteur Merieux)"]
    #[code = "PMC"]
    PMC(Option<Element>),
    #[doc = "Praxis Biologics [Inactive - use WAL]"]
    #[code = "PRX"]
    PRX(Option<Element>),
    #[doc = "Sclavo, Inc."]
    #[code = "SCL"]
    SCL(Option<Element>),
    #[doc = "Swiss Serum and Vaccine Inst. [Inactive - use BPC]"]
    #[code = "SI"]
    SI(Option<Element>),
    #[doc = "SmithKline Beecham"]
    #[code = "SKB"]
    SKB(Option<Element>),
    #[doc = "United States Army Medical Research and Materiel Command"]
    #[code = "USA"]
    USA(Option<Element>),
    #[doc = "Wyeth-Ayerst [Inactive - use WAL]"]
    #[code = "WA"]
    WA(Option<Element>),
    #[doc = "Wyeth-Ayerst (includes Wyeth-Lederle Vaccines and Pediatrics, Wyeth Laboratories, Lederle Laboratories, and Praxis Biologics)"]
    #[code = "WAL"]
    WAL(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3VaccineManufacturer {
    fn default() -> Self {
        V3VaccineManufacturer::Null(None)
    }
}
impl TryFrom<String> for V3VaccineManufacturer {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AB" => Ok(V3VaccineManufacturer::AB(None)),
            "AD" => Ok(V3VaccineManufacturer::AD(None)),
            "ALP" => Ok(V3VaccineManufacturer::ALP(None)),
            "AR" => Ok(V3VaccineManufacturer::AR(None)),
            "AVI" => Ok(V3VaccineManufacturer::AVI(None)),
            "BA" => Ok(V3VaccineManufacturer::BA(None)),
            "BAY" => Ok(V3VaccineManufacturer::BAY(None)),
            "BP" => Ok(V3VaccineManufacturer::BP(None)),
            "BPC" => Ok(V3VaccineManufacturer::BPC(None)),
            "CEN" => Ok(V3VaccineManufacturer::CEN(None)),
            "CHI" => Ok(V3VaccineManufacturer::CHI(None)),
            "CON" => Ok(V3VaccineManufacturer::CON(None)),
            "EVN" => Ok(V3VaccineManufacturer::EVN(None)),
            "GRE" => Ok(V3VaccineManufacturer::GRE(None)),
            "IAG" => Ok(V3VaccineManufacturer::IAG(None)),
            "IM" => Ok(V3VaccineManufacturer::IM(None)),
            "IUS" => Ok(V3VaccineManufacturer::IUS(None)),
            "JPN" => Ok(V3VaccineManufacturer::JPN(None)),
            "KGC" => Ok(V3VaccineManufacturer::KGC(None)),
            "LED" => Ok(V3VaccineManufacturer::LED(None)),
            "MA" => Ok(V3VaccineManufacturer::MA(None)),
            "MED" => Ok(V3VaccineManufacturer::MED(None)),
            "MIL" => Ok(V3VaccineManufacturer::MIL(None)),
            "MIP" => Ok(V3VaccineManufacturer::MIP(None)),
            "MSD" => Ok(V3VaccineManufacturer::MSD(None)),
            "NAB" => Ok(V3VaccineManufacturer::NAB(None)),
            "NAV" => Ok(V3VaccineManufacturer::NAV(None)),
            "NOV" => Ok(V3VaccineManufacturer::NOV(None)),
            "NYB" => Ok(V3VaccineManufacturer::NYB(None)),
            "ORT" => Ok(V3VaccineManufacturer::ORT(None)),
            "OTC" => Ok(V3VaccineManufacturer::OTC(None)),
            "PD" => Ok(V3VaccineManufacturer::PD(None)),
            "PMC" => Ok(V3VaccineManufacturer::PMC(None)),
            "PRX" => Ok(V3VaccineManufacturer::PRX(None)),
            "SCL" => Ok(V3VaccineManufacturer::SCL(None)),
            "SI" => Ok(V3VaccineManufacturer::SI(None)),
            "SKB" => Ok(V3VaccineManufacturer::SKB(None)),
            "USA" => Ok(V3VaccineManufacturer::USA(None)),
            "WA" => Ok(V3VaccineManufacturer::WA(None)),
            "WAL" => Ok(V3VaccineManufacturer::WAL(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3VaccineManufacturer {
    fn into(self) -> Option<String> {
        match self {
            V3VaccineManufacturer::AB(_) => Some("AB".to_string()),
            V3VaccineManufacturer::AD(_) => Some("AD".to_string()),
            V3VaccineManufacturer::ALP(_) => Some("ALP".to_string()),
            V3VaccineManufacturer::AR(_) => Some("AR".to_string()),
            V3VaccineManufacturer::AVI(_) => Some("AVI".to_string()),
            V3VaccineManufacturer::BA(_) => Some("BA".to_string()),
            V3VaccineManufacturer::BAY(_) => Some("BAY".to_string()),
            V3VaccineManufacturer::BP(_) => Some("BP".to_string()),
            V3VaccineManufacturer::BPC(_) => Some("BPC".to_string()),
            V3VaccineManufacturer::CEN(_) => Some("CEN".to_string()),
            V3VaccineManufacturer::CHI(_) => Some("CHI".to_string()),
            V3VaccineManufacturer::CON(_) => Some("CON".to_string()),
            V3VaccineManufacturer::EVN(_) => Some("EVN".to_string()),
            V3VaccineManufacturer::GRE(_) => Some("GRE".to_string()),
            V3VaccineManufacturer::IAG(_) => Some("IAG".to_string()),
            V3VaccineManufacturer::IM(_) => Some("IM".to_string()),
            V3VaccineManufacturer::IUS(_) => Some("IUS".to_string()),
            V3VaccineManufacturer::JPN(_) => Some("JPN".to_string()),
            V3VaccineManufacturer::KGC(_) => Some("KGC".to_string()),
            V3VaccineManufacturer::LED(_) => Some("LED".to_string()),
            V3VaccineManufacturer::MA(_) => Some("MA".to_string()),
            V3VaccineManufacturer::MED(_) => Some("MED".to_string()),
            V3VaccineManufacturer::MIL(_) => Some("MIL".to_string()),
            V3VaccineManufacturer::MIP(_) => Some("MIP".to_string()),
            V3VaccineManufacturer::MSD(_) => Some("MSD".to_string()),
            V3VaccineManufacturer::NAB(_) => Some("NAB".to_string()),
            V3VaccineManufacturer::NAV(_) => Some("NAV".to_string()),
            V3VaccineManufacturer::NOV(_) => Some("NOV".to_string()),
            V3VaccineManufacturer::NYB(_) => Some("NYB".to_string()),
            V3VaccineManufacturer::ORT(_) => Some("ORT".to_string()),
            V3VaccineManufacturer::OTC(_) => Some("OTC".to_string()),
            V3VaccineManufacturer::PD(_) => Some("PD".to_string()),
            V3VaccineManufacturer::PMC(_) => Some("PMC".to_string()),
            V3VaccineManufacturer::PRX(_) => Some("PRX".to_string()),
            V3VaccineManufacturer::SCL(_) => Some("SCL".to_string()),
            V3VaccineManufacturer::SI(_) => Some("SI".to_string()),
            V3VaccineManufacturer::SKB(_) => Some("SKB".to_string()),
            V3VaccineManufacturer::USA(_) => Some("USA".to_string()),
            V3VaccineManufacturer::WA(_) => Some("WA".to_string()),
            V3VaccineManufacturer::WAL(_) => Some("WAL".to_string()),
            V3VaccineManufacturer::Null(_) => None,
        }
    }
}
impl MetaValue for V3VaccineManufacturer {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3VaccineManufacturer::AB(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::AD(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::ALP(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::AR(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::AVI(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::BA(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::BAY(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::BP(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::BPC(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::CEN(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::CHI(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::CON(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::EVN(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::GRE(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::IAG(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::IM(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::IUS(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::JPN(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::KGC(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::LED(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::MA(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::MED(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::MIL(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::MIP(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::MSD(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::NAB(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::NAV(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::NOV(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::NYB(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::ORT(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::OTC(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::PD(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::PMC(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::PRX(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::SCL(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::SI(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::SKB(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::USA(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::WA(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::WAL(Some(e)) => e.get_field(field),
                V3VaccineManufacturer::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3VaccineManufacturer::AB(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::AD(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::ALP(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::AR(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::AVI(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::BA(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::BAY(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::BP(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::BPC(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::CEN(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::CHI(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::CON(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::EVN(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::GRE(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::IAG(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::IM(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::IUS(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::JPN(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::KGC(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::LED(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::MA(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::MED(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::MIL(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::MIP(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::MSD(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::NAB(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::NAV(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::NOV(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::NYB(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::ORT(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::OTC(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::PD(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::PMC(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::PRX(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::SCL(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::SI(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::SKB(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::USA(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::WA(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::WAL(Some(e)) => e.get_field_mut(field),
                V3VaccineManufacturer::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3WorkClassificationODH {
    #[doc = "Paid work, Armed Forces"]
    #[code = "PWAF"]
    PWAF(Option<Element>),
    #[doc = "Paid work, national government, not armed forces"]
    #[code = "PWFG"]
    PWFG(Option<Element>),
    #[doc = "Paid work, local government, not armed forces"]
    #[code = "PWLG"]
    PWLG(Option<Element>),
    #[doc = "Paid non-governmental work, not self-employed"]
    #[code = "PWNSE"]
    PWNSE(Option<Element>),
    #[doc = "Paid work, self-employed"]
    #[code = "PWSE"]
    PWSE(Option<Element>),
    #[doc = "Paid work, state government, not armed forces"]
    #[code = "PWSG"]
    PWSG(Option<Element>),
    #[doc = "Unpaid non-governmental work, not self-employed"]
    #[code = "UWNSE"]
    UWNSE(Option<Element>),
    #[doc = "Unpaid work, self-employed"]
    #[code = "UWSE"]
    UWSE(Option<Element>),
    #[doc = "Voluntary work"]
    #[code = "VW"]
    VW(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3WorkClassificationODH {
    fn default() -> Self {
        V3WorkClassificationODH::Null(None)
    }
}
impl TryFrom<String> for V3WorkClassificationODH {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "PWAF" => Ok(V3WorkClassificationODH::PWAF(None)),
            "PWFG" => Ok(V3WorkClassificationODH::PWFG(None)),
            "PWLG" => Ok(V3WorkClassificationODH::PWLG(None)),
            "PWNSE" => Ok(V3WorkClassificationODH::PWNSE(None)),
            "PWSE" => Ok(V3WorkClassificationODH::PWSE(None)),
            "PWSG" => Ok(V3WorkClassificationODH::PWSG(None)),
            "UWNSE" => Ok(V3WorkClassificationODH::UWNSE(None)),
            "UWSE" => Ok(V3WorkClassificationODH::UWSE(None)),
            "VW" => Ok(V3WorkClassificationODH::VW(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3WorkClassificationODH {
    fn into(self) -> Option<String> {
        match self {
            V3WorkClassificationODH::PWAF(_) => Some("PWAF".to_string()),
            V3WorkClassificationODH::PWFG(_) => Some("PWFG".to_string()),
            V3WorkClassificationODH::PWLG(_) => Some("PWLG".to_string()),
            V3WorkClassificationODH::PWNSE(_) => Some("PWNSE".to_string()),
            V3WorkClassificationODH::PWSE(_) => Some("PWSE".to_string()),
            V3WorkClassificationODH::PWSG(_) => Some("PWSG".to_string()),
            V3WorkClassificationODH::UWNSE(_) => Some("UWNSE".to_string()),
            V3WorkClassificationODH::UWSE(_) => Some("UWSE".to_string()),
            V3WorkClassificationODH::VW(_) => Some("VW".to_string()),
            V3WorkClassificationODH::Null(_) => None,
        }
    }
}
impl MetaValue for V3WorkClassificationODH {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3WorkClassificationODH::PWAF(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::PWFG(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::PWLG(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::PWNSE(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::PWSE(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::PWSG(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::UWNSE(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::UWSE(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::VW(Some(e)) => e.get_field(field),
                V3WorkClassificationODH::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3WorkClassificationODH::PWAF(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::PWFG(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::PWLG(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::PWNSE(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::PWSE(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::PWSG(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::UWNSE(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::UWSE(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::VW(Some(e)) => e.get_field_mut(field),
                V3WorkClassificationODH::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7ApprovalStatus {
    #[doc = "affiliate ballot - DSTU"]
    #[code = "affd"]
    Affd(Option<Element>),
    #[doc = "affiliate ballot - informative"]
    #[code = "affi"]
    Affi(Option<Element>),
    #[doc = "affiliate ballot - normative"]
    #[code = "affn"]
    Affn(Option<Element>),
    #[doc = "approved affiliate DSTU"]
    #[code = "appad"]
    Appad(Option<Element>),
    #[doc = "approved affiliate informative"]
    #[code = "appai"]
    Appai(Option<Element>),
    #[doc = "approved affiliate normative"]
    #[code = "appan"]
    Appan(Option<Element>),
    #[doc = "approved DSTU"]
    #[code = "appd"]
    Appd(Option<Element>),
    #[doc = "approved informative"]
    #[code = "appi"]
    Appi(Option<Element>),
    #[doc = "approved normative"]
    #[code = "appn"]
    Appn(Option<Element>),
    #[doc = "committee ballot - informative"]
    #[code = "comi"]
    Comi(Option<Element>),
    #[doc = "committee ballot - normative"]
    #[code = "comn"]
    Comn(Option<Element>),
    #[doc = "draft"]
    #[code = "draft"]
    Draft(Option<Element>),
    #[doc = "localized adaptation"]
    #[code = "loc"]
    Loc(Option<Element>),
    #[doc = "membership ballot - DSTU"]
    #[code = "memd"]
    Memd(Option<Element>),
    #[doc = "membership ballot - informative"]
    #[code = "memi"]
    Memi(Option<Element>),
    #[doc = "membership ballot - normative"]
    #[code = "memn"]
    Memn(Option<Element>),
    #[doc = "non-standard - available for use"]
    #[code = "ns"]
    Ns(Option<Element>),
    #[doc = "proposal"]
    #[code = "prop"]
    Prop(Option<Element>),
    #[doc = "reference"]
    #[code = "ref"]
    Ref(Option<Element>),
    #[doc = "withdrawn"]
    #[code = "wd"]
    Wd(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7ApprovalStatus {
    fn default() -> Self {
        V3Hl7ApprovalStatus::Null(None)
    }
}
impl TryFrom<String> for V3Hl7ApprovalStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "affd" => Ok(V3Hl7ApprovalStatus::Affd(None)),
            "affi" => Ok(V3Hl7ApprovalStatus::Affi(None)),
            "affn" => Ok(V3Hl7ApprovalStatus::Affn(None)),
            "appad" => Ok(V3Hl7ApprovalStatus::Appad(None)),
            "appai" => Ok(V3Hl7ApprovalStatus::Appai(None)),
            "appan" => Ok(V3Hl7ApprovalStatus::Appan(None)),
            "appd" => Ok(V3Hl7ApprovalStatus::Appd(None)),
            "appi" => Ok(V3Hl7ApprovalStatus::Appi(None)),
            "appn" => Ok(V3Hl7ApprovalStatus::Appn(None)),
            "comi" => Ok(V3Hl7ApprovalStatus::Comi(None)),
            "comn" => Ok(V3Hl7ApprovalStatus::Comn(None)),
            "draft" => Ok(V3Hl7ApprovalStatus::Draft(None)),
            "loc" => Ok(V3Hl7ApprovalStatus::Loc(None)),
            "memd" => Ok(V3Hl7ApprovalStatus::Memd(None)),
            "memi" => Ok(V3Hl7ApprovalStatus::Memi(None)),
            "memn" => Ok(V3Hl7ApprovalStatus::Memn(None)),
            "ns" => Ok(V3Hl7ApprovalStatus::Ns(None)),
            "prop" => Ok(V3Hl7ApprovalStatus::Prop(None)),
            "ref" => Ok(V3Hl7ApprovalStatus::Ref(None)),
            "wd" => Ok(V3Hl7ApprovalStatus::Wd(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7ApprovalStatus {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7ApprovalStatus::Affd(_) => Some("affd".to_string()),
            V3Hl7ApprovalStatus::Affi(_) => Some("affi".to_string()),
            V3Hl7ApprovalStatus::Affn(_) => Some("affn".to_string()),
            V3Hl7ApprovalStatus::Appad(_) => Some("appad".to_string()),
            V3Hl7ApprovalStatus::Appai(_) => Some("appai".to_string()),
            V3Hl7ApprovalStatus::Appan(_) => Some("appan".to_string()),
            V3Hl7ApprovalStatus::Appd(_) => Some("appd".to_string()),
            V3Hl7ApprovalStatus::Appi(_) => Some("appi".to_string()),
            V3Hl7ApprovalStatus::Appn(_) => Some("appn".to_string()),
            V3Hl7ApprovalStatus::Comi(_) => Some("comi".to_string()),
            V3Hl7ApprovalStatus::Comn(_) => Some("comn".to_string()),
            V3Hl7ApprovalStatus::Draft(_) => Some("draft".to_string()),
            V3Hl7ApprovalStatus::Loc(_) => Some("loc".to_string()),
            V3Hl7ApprovalStatus::Memd(_) => Some("memd".to_string()),
            V3Hl7ApprovalStatus::Memi(_) => Some("memi".to_string()),
            V3Hl7ApprovalStatus::Memn(_) => Some("memn".to_string()),
            V3Hl7ApprovalStatus::Ns(_) => Some("ns".to_string()),
            V3Hl7ApprovalStatus::Prop(_) => Some("prop".to_string()),
            V3Hl7ApprovalStatus::Ref(_) => Some("ref".to_string()),
            V3Hl7ApprovalStatus::Wd(_) => Some("wd".to_string()),
            V3Hl7ApprovalStatus::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7ApprovalStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7ApprovalStatus::Affd(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Affi(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Affn(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appad(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appai(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appan(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appd(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appi(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Appn(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Comi(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Comn(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Draft(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Loc(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Memd(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Memi(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Memn(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Ns(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Prop(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Ref(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Wd(Some(e)) => e.get_field(field),
                V3Hl7ApprovalStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7ApprovalStatus::Affd(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Affi(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Affn(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appad(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appai(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appan(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appd(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appi(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Appn(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Comi(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Comn(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Draft(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Loc(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Memd(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Memi(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Memn(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Ns(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Prop(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Ref(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Wd(Some(e)) => e.get_field_mut(field),
                V3Hl7ApprovalStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7CMETAttribution {
    #[doc = "contact"]
    #[code = "contact"]
    Contact(Option<Element>),
    #[doc = "identified"]
    #[code = "identified"]
    Identified(Option<Element>),
    #[doc = "identified-confirmable"]
    #[code = "identified-confirmable"]
    IdentifiedConfirmable(Option<Element>),
    #[doc = "identified-informational"]
    #[code = "identified-informational"]
    IdentifiedInformational(Option<Element>),
    #[doc = "informational"]
    #[code = "informational"]
    Informational(Option<Element>),
    #[doc = "minimal"]
    #[code = "minimal"]
    Minimal(Option<Element>),
    #[doc = "universal"]
    #[code = "universal"]
    Universal(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7CMETAttribution {
    fn default() -> Self {
        V3Hl7CMETAttribution::Null(None)
    }
}
impl TryFrom<String> for V3Hl7CMETAttribution {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "contact" => Ok(V3Hl7CMETAttribution::Contact(None)),
            "identified" => Ok(V3Hl7CMETAttribution::Identified(None)),
            "identified-confirmable" => Ok(V3Hl7CMETAttribution::IdentifiedConfirmable(None)),
            "identified-informational" => Ok(V3Hl7CMETAttribution::IdentifiedInformational(None)),
            "informational" => Ok(V3Hl7CMETAttribution::Informational(None)),
            "minimal" => Ok(V3Hl7CMETAttribution::Minimal(None)),
            "universal" => Ok(V3Hl7CMETAttribution::Universal(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7CMETAttribution {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7CMETAttribution::Contact(_) => Some("contact".to_string()),
            V3Hl7CMETAttribution::Identified(_) => Some("identified".to_string()),
            V3Hl7CMETAttribution::IdentifiedConfirmable(_) => {
                Some("identified-confirmable".to_string())
            }
            V3Hl7CMETAttribution::IdentifiedInformational(_) => {
                Some("identified-informational".to_string())
            }
            V3Hl7CMETAttribution::Informational(_) => Some("informational".to_string()),
            V3Hl7CMETAttribution::Minimal(_) => Some("minimal".to_string()),
            V3Hl7CMETAttribution::Universal(_) => Some("universal".to_string()),
            V3Hl7CMETAttribution::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7CMETAttribution {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7CMETAttribution::Contact(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::Identified(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::IdentifiedConfirmable(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::IdentifiedInformational(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::Informational(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::Minimal(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::Universal(Some(e)) => e.get_field(field),
                V3Hl7CMETAttribution::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7CMETAttribution::Contact(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::Identified(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::IdentifiedConfirmable(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::IdentifiedInformational(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::Informational(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::Minimal(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::Universal(Some(e)) => e.get_field_mut(field),
                V3Hl7CMETAttribution::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7ITSType {
    #[doc = "universal modeling language"]
    #[code = "UML"]
    UML(Option<Element>),
    #[doc = "extensible markup language"]
    #[code = "XML"]
    XML(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7ITSType {
    fn default() -> Self {
        V3Hl7ITSType::Null(None)
    }
}
impl TryFrom<String> for V3Hl7ITSType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "UML" => Ok(V3Hl7ITSType::UML(None)),
            "XML" => Ok(V3Hl7ITSType::XML(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7ITSType {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7ITSType::UML(_) => Some("UML".to_string()),
            V3Hl7ITSType::XML(_) => Some("XML".to_string()),
            V3Hl7ITSType::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7ITSType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7ITSType::UML(Some(e)) => e.get_field(field),
                V3Hl7ITSType::XML(Some(e)) => e.get_field(field),
                V3Hl7ITSType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7ITSType::UML(Some(e)) => e.get_field_mut(field),
                V3Hl7ITSType::XML(Some(e)) => e.get_field_mut(field),
                V3Hl7ITSType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7ITSVersionCode {
    #[doc = "XMLV1PR1"]
    #[code = "XMLV1PR1"]
    XMLV1PR1(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7ITSVersionCode {
    fn default() -> Self {
        V3Hl7ITSVersionCode::Null(None)
    }
}
impl TryFrom<String> for V3Hl7ITSVersionCode {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "XMLV1PR1" => Ok(V3Hl7ITSVersionCode::XMLV1PR1(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7ITSVersionCode {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7ITSVersionCode::XMLV1PR1(_) => Some("XMLV1PR1".to_string()),
            V3Hl7ITSVersionCode::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7ITSVersionCode {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7ITSVersionCode::XMLV1PR1(Some(e)) => e.get_field(field),
                V3Hl7ITSVersionCode::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7ITSVersionCode::XMLV1PR1(Some(e)) => e.get_field_mut(field),
                V3Hl7ITSVersionCode::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7PublishingDomain {
    #[doc = "accounting & billing"]
    #[code = "AB"]
    AB(Option<Element>),
    #[doc = "trigger event control act infrastructure"]
    #[code = "AI"]
    AI(Option<Element>),
    #[doc = "artificial listing for test purposes - faux Domain for testing"]
    #[code = "AL"]
    AL(Option<Element>),
    #[doc = "blood tissue and organ"]
    #[code = "BB"]
    BB(Option<Element>),
    #[doc = "clinical document architecture"]
    #[code = "CD"]
    CD(Option<Element>),
    #[doc = "clinical genomics"]
    #[code = "CG"]
    CG(Option<Element>),
    #[doc = "transmission infrastructure"]
    #[code = "CI"]
    CI(Option<Element>),
    #[doc = "coverage"]
    #[code = "CO"]
    CO(Option<Element>),
    #[doc = "common product model"]
    #[code = "CP"]
    CP(Option<Element>),
    #[doc = "claims and reimbursement"]
    #[code = "CR"]
    CR(Option<Element>),
    #[doc = "clinical statement"]
    #[code = "CS"]
    CS(Option<Element>),
    #[doc = "common types"]
    #[code = "CT"]
    CT(Option<Element>),
    #[doc = "dummy domain"]
    #[code = "DD"]
    DD(Option<Element>),
    #[doc = "diagnostic imaging"]
    #[code = "DI"]
    DI(Option<Element>),
    #[doc = "decision support"]
    #[code = "DS"]
    DS(Option<Element>),
    #[doc = "emergency medical services"]
    #[code = "EM"]
    EM(Option<Element>),
    #[doc = "imaging integration"]
    #[code = "II"]
    II(Option<Element>),
    #[doc = "immunization"]
    #[code = "IZ"]
    IZ(Option<Element>),
    #[doc = "laboratory"]
    #[code = "LB"]
    LB(Option<Element>),
    #[doc = "medication"]
    #[code = "ME"]
    ME(Option<Element>),
    #[doc = "masterfile infrastructure"]
    #[code = "MI"]
    MI(Option<Element>),
    #[doc = "materials management"]
    #[code = "MM"]
    MM(Option<Element>),
    #[doc = "medical records"]
    #[code = "MR"]
    MR(Option<Element>),
    #[doc = "shared messages"]
    #[code = "MT"]
    MT(Option<Element>),
    #[doc = "observations"]
    #[code = "OB"]
    OB(Option<Element>),
    #[doc = "orders & observations"]
    #[code = "OO"]
    OO(Option<Element>),
    #[doc = "orders"]
    #[code = "OR"]
    OR(Option<Element>),
    #[doc = "patient administration"]
    #[code = "PA"]
    PA(Option<Element>),
    #[doc = "care provision"]
    #[code = "PC"]
    PC(Option<Element>),
    #[doc = "public health"]
    #[code = "PH"]
    PH(Option<Element>),
    #[doc = "personnel management"]
    #[code = "PM"]
    PM(Option<Element>),
    #[doc = "query infrastructure"]
    #[code = "QI"]
    QI(Option<Element>),
    #[doc = "quality measures"]
    #[code = "QM"]
    QM(Option<Element>),
    #[doc = "registries"]
    #[code = "RG"]
    RG(Option<Element>),
    #[doc = "informative public health"]
    #[code = "RI"]
    RI(Option<Element>),
    #[doc = "regulated products"]
    #[code = "RP"]
    RP(Option<Element>),
    #[doc = "public health reporting"]
    #[code = "RR"]
    RR(Option<Element>),
    #[doc = "regulated studies"]
    #[code = "RT"]
    RT(Option<Element>),
    #[doc = "pharmacy"]
    #[code = "RX"]
    RX(Option<Element>),
    #[doc = "scheduling"]
    #[code = "SC"]
    SC(Option<Element>),
    #[doc = "specimen"]
    #[code = "SP"]
    SP(Option<Element>),
    #[doc = "therapeutic devices"]
    #[code = "TD"]
    TD(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7PublishingDomain {
    fn default() -> Self {
        V3Hl7PublishingDomain::Null(None)
    }
}
impl TryFrom<String> for V3Hl7PublishingDomain {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AB" => Ok(V3Hl7PublishingDomain::AB(None)),
            "AI" => Ok(V3Hl7PublishingDomain::AI(None)),
            "AL" => Ok(V3Hl7PublishingDomain::AL(None)),
            "BB" => Ok(V3Hl7PublishingDomain::BB(None)),
            "CD" => Ok(V3Hl7PublishingDomain::CD(None)),
            "CG" => Ok(V3Hl7PublishingDomain::CG(None)),
            "CI" => Ok(V3Hl7PublishingDomain::CI(None)),
            "CO" => Ok(V3Hl7PublishingDomain::CO(None)),
            "CP" => Ok(V3Hl7PublishingDomain::CP(None)),
            "CR" => Ok(V3Hl7PublishingDomain::CR(None)),
            "CS" => Ok(V3Hl7PublishingDomain::CS(None)),
            "CT" => Ok(V3Hl7PublishingDomain::CT(None)),
            "DD" => Ok(V3Hl7PublishingDomain::DD(None)),
            "DI" => Ok(V3Hl7PublishingDomain::DI(None)),
            "DS" => Ok(V3Hl7PublishingDomain::DS(None)),
            "EM" => Ok(V3Hl7PublishingDomain::EM(None)),
            "II" => Ok(V3Hl7PublishingDomain::II(None)),
            "IZ" => Ok(V3Hl7PublishingDomain::IZ(None)),
            "LB" => Ok(V3Hl7PublishingDomain::LB(None)),
            "ME" => Ok(V3Hl7PublishingDomain::ME(None)),
            "MI" => Ok(V3Hl7PublishingDomain::MI(None)),
            "MM" => Ok(V3Hl7PublishingDomain::MM(None)),
            "MR" => Ok(V3Hl7PublishingDomain::MR(None)),
            "MT" => Ok(V3Hl7PublishingDomain::MT(None)),
            "OB" => Ok(V3Hl7PublishingDomain::OB(None)),
            "OO" => Ok(V3Hl7PublishingDomain::OO(None)),
            "OR" => Ok(V3Hl7PublishingDomain::OR(None)),
            "PA" => Ok(V3Hl7PublishingDomain::PA(None)),
            "PC" => Ok(V3Hl7PublishingDomain::PC(None)),
            "PH" => Ok(V3Hl7PublishingDomain::PH(None)),
            "PM" => Ok(V3Hl7PublishingDomain::PM(None)),
            "QI" => Ok(V3Hl7PublishingDomain::QI(None)),
            "QM" => Ok(V3Hl7PublishingDomain::QM(None)),
            "RG" => Ok(V3Hl7PublishingDomain::RG(None)),
            "RI" => Ok(V3Hl7PublishingDomain::RI(None)),
            "RP" => Ok(V3Hl7PublishingDomain::RP(None)),
            "RR" => Ok(V3Hl7PublishingDomain::RR(None)),
            "RT" => Ok(V3Hl7PublishingDomain::RT(None)),
            "RX" => Ok(V3Hl7PublishingDomain::RX(None)),
            "SC" => Ok(V3Hl7PublishingDomain::SC(None)),
            "SP" => Ok(V3Hl7PublishingDomain::SP(None)),
            "TD" => Ok(V3Hl7PublishingDomain::TD(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7PublishingDomain {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7PublishingDomain::AB(_) => Some("AB".to_string()),
            V3Hl7PublishingDomain::AI(_) => Some("AI".to_string()),
            V3Hl7PublishingDomain::AL(_) => Some("AL".to_string()),
            V3Hl7PublishingDomain::BB(_) => Some("BB".to_string()),
            V3Hl7PublishingDomain::CD(_) => Some("CD".to_string()),
            V3Hl7PublishingDomain::CG(_) => Some("CG".to_string()),
            V3Hl7PublishingDomain::CI(_) => Some("CI".to_string()),
            V3Hl7PublishingDomain::CO(_) => Some("CO".to_string()),
            V3Hl7PublishingDomain::CP(_) => Some("CP".to_string()),
            V3Hl7PublishingDomain::CR(_) => Some("CR".to_string()),
            V3Hl7PublishingDomain::CS(_) => Some("CS".to_string()),
            V3Hl7PublishingDomain::CT(_) => Some("CT".to_string()),
            V3Hl7PublishingDomain::DD(_) => Some("DD".to_string()),
            V3Hl7PublishingDomain::DI(_) => Some("DI".to_string()),
            V3Hl7PublishingDomain::DS(_) => Some("DS".to_string()),
            V3Hl7PublishingDomain::EM(_) => Some("EM".to_string()),
            V3Hl7PublishingDomain::II(_) => Some("II".to_string()),
            V3Hl7PublishingDomain::IZ(_) => Some("IZ".to_string()),
            V3Hl7PublishingDomain::LB(_) => Some("LB".to_string()),
            V3Hl7PublishingDomain::ME(_) => Some("ME".to_string()),
            V3Hl7PublishingDomain::MI(_) => Some("MI".to_string()),
            V3Hl7PublishingDomain::MM(_) => Some("MM".to_string()),
            V3Hl7PublishingDomain::MR(_) => Some("MR".to_string()),
            V3Hl7PublishingDomain::MT(_) => Some("MT".to_string()),
            V3Hl7PublishingDomain::OB(_) => Some("OB".to_string()),
            V3Hl7PublishingDomain::OO(_) => Some("OO".to_string()),
            V3Hl7PublishingDomain::OR(_) => Some("OR".to_string()),
            V3Hl7PublishingDomain::PA(_) => Some("PA".to_string()),
            V3Hl7PublishingDomain::PC(_) => Some("PC".to_string()),
            V3Hl7PublishingDomain::PH(_) => Some("PH".to_string()),
            V3Hl7PublishingDomain::PM(_) => Some("PM".to_string()),
            V3Hl7PublishingDomain::QI(_) => Some("QI".to_string()),
            V3Hl7PublishingDomain::QM(_) => Some("QM".to_string()),
            V3Hl7PublishingDomain::RG(_) => Some("RG".to_string()),
            V3Hl7PublishingDomain::RI(_) => Some("RI".to_string()),
            V3Hl7PublishingDomain::RP(_) => Some("RP".to_string()),
            V3Hl7PublishingDomain::RR(_) => Some("RR".to_string()),
            V3Hl7PublishingDomain::RT(_) => Some("RT".to_string()),
            V3Hl7PublishingDomain::RX(_) => Some("RX".to_string()),
            V3Hl7PublishingDomain::SC(_) => Some("SC".to_string()),
            V3Hl7PublishingDomain::SP(_) => Some("SP".to_string()),
            V3Hl7PublishingDomain::TD(_) => Some("TD".to_string()),
            V3Hl7PublishingDomain::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7PublishingDomain {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7PublishingDomain::AB(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::AI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::AL(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::BB(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CD(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CG(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CO(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CP(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CR(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CS(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::CT(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::DD(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::DI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::DS(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::EM(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::II(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::IZ(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::LB(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::ME(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::MI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::MM(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::MR(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::MT(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::OB(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::OO(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::OR(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::PA(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::PC(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::PH(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::PM(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::QI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::QM(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RG(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RI(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RP(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RR(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RT(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::RX(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::SC(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::SP(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::TD(Some(e)) => e.get_field(field),
                V3Hl7PublishingDomain::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7PublishingDomain::AB(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::AI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::AL(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::BB(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CD(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CG(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CO(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CP(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CR(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CS(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::CT(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::DD(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::DI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::DS(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::EM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::II(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::IZ(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::LB(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::ME(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::MI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::MM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::MR(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::MT(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::OB(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::OO(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::OR(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::PA(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::PC(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::PH(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::PM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::QI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::QM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RG(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RP(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RR(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RT(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::RX(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::SC(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::SP(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::TD(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingDomain::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7PublishingSection {
    #[doc = "administrative management"]
    #[code = "AM"]
    AM(Option<Element>),
    #[doc = "health and clinical management"]
    #[code = "HM"]
    HM(Option<Element>),
    #[doc = "infrastructure management"]
    #[code = "IM"]
    IM(Option<Element>),
    #[doc = "unknown"]
    #[code = "UU"]
    UU(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7PublishingSection {
    fn default() -> Self {
        V3Hl7PublishingSection::Null(None)
    }
}
impl TryFrom<String> for V3Hl7PublishingSection {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AM" => Ok(V3Hl7PublishingSection::AM(None)),
            "HM" => Ok(V3Hl7PublishingSection::HM(None)),
            "IM" => Ok(V3Hl7PublishingSection::IM(None)),
            "UU" => Ok(V3Hl7PublishingSection::UU(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7PublishingSection {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7PublishingSection::AM(_) => Some("AM".to_string()),
            V3Hl7PublishingSection::HM(_) => Some("HM".to_string()),
            V3Hl7PublishingSection::IM(_) => Some("IM".to_string()),
            V3Hl7PublishingSection::UU(_) => Some("UU".to_string()),
            V3Hl7PublishingSection::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7PublishingSection {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7PublishingSection::AM(Some(e)) => e.get_field(field),
                V3Hl7PublishingSection::HM(Some(e)) => e.get_field(field),
                V3Hl7PublishingSection::IM(Some(e)) => e.get_field(field),
                V3Hl7PublishingSection::UU(Some(e)) => e.get_field(field),
                V3Hl7PublishingSection::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7PublishingSection::AM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSection::HM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSection::IM(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSection::UU(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSection::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7PublishingSubSection {
    #[doc = "common"]
    #[code = "CO"]
    CO(Option<Element>),
    #[doc = "financial information"]
    #[code = "FI"]
    FI(Option<Element>),
    #[doc = "message control"]
    #[code = "MC"]
    MC(Option<Element>),
    #[doc = "master file"]
    #[code = "MF"]
    MF(Option<Element>),
    #[doc = "operations"]
    #[code = "PO"]
    PO(Option<Element>),
    #[doc = "practice"]
    #[code = "PR"]
    PR(Option<Element>),
    #[doc = "query"]
    #[code = "QU"]
    QU(Option<Element>),
    #[doc = "records"]
    #[code = "RC"]
    RC(Option<Element>),
    #[doc = "reasoning"]
    #[code = "RE"]
    RE(Option<Element>),
    #[doc = "unknown"]
    #[code = "UU"]
    UU(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7PublishingSubSection {
    fn default() -> Self {
        V3Hl7PublishingSubSection::Null(None)
    }
}
impl TryFrom<String> for V3Hl7PublishingSubSection {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "CO" => Ok(V3Hl7PublishingSubSection::CO(None)),
            "FI" => Ok(V3Hl7PublishingSubSection::FI(None)),
            "MC" => Ok(V3Hl7PublishingSubSection::MC(None)),
            "MF" => Ok(V3Hl7PublishingSubSection::MF(None)),
            "PO" => Ok(V3Hl7PublishingSubSection::PO(None)),
            "PR" => Ok(V3Hl7PublishingSubSection::PR(None)),
            "QU" => Ok(V3Hl7PublishingSubSection::QU(None)),
            "RC" => Ok(V3Hl7PublishingSubSection::RC(None)),
            "RE" => Ok(V3Hl7PublishingSubSection::RE(None)),
            "UU" => Ok(V3Hl7PublishingSubSection::UU(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7PublishingSubSection {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7PublishingSubSection::CO(_) => Some("CO".to_string()),
            V3Hl7PublishingSubSection::FI(_) => Some("FI".to_string()),
            V3Hl7PublishingSubSection::MC(_) => Some("MC".to_string()),
            V3Hl7PublishingSubSection::MF(_) => Some("MF".to_string()),
            V3Hl7PublishingSubSection::PO(_) => Some("PO".to_string()),
            V3Hl7PublishingSubSection::PR(_) => Some("PR".to_string()),
            V3Hl7PublishingSubSection::QU(_) => Some("QU".to_string()),
            V3Hl7PublishingSubSection::RC(_) => Some("RC".to_string()),
            V3Hl7PublishingSubSection::RE(_) => Some("RE".to_string()),
            V3Hl7PublishingSubSection::UU(_) => Some("UU".to_string()),
            V3Hl7PublishingSubSection::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7PublishingSubSection {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7PublishingSubSection::CO(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::FI(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::MC(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::MF(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::PO(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::PR(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::QU(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::RC(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::RE(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::UU(Some(e)) => e.get_field(field),
                V3Hl7PublishingSubSection::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7PublishingSubSection::CO(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::FI(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::MC(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::MF(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::PO(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::PR(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::QU(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::RC(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::RE(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::UU(Some(e)) => e.get_field_mut(field),
                V3Hl7PublishingSubSection::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7Realm {
    #[doc = "Argentina"]
    #[code = "AR"]
    AR(Option<Element>),
    #[doc = "Austria"]
    #[code = "AT"]
    AT(Option<Element>),
    #[doc = "Australia"]
    #[code = "AU"]
    AU(Option<Element>),
    #[doc = "Affiliate Realms"]
    #[code = "AffiliateRealms"]
    AffiliateRealms(Option<Element>),
    #[doc = "Brazil"]
    #[code = "BR"]
    BR(Option<Element>),
    #[doc = "binding realms"]
    #[code = "BindingRealms"]
    BindingRealms(Option<Element>),
    #[doc = "Unclassified Realm"]
    #[code = "C1"]
    C1(Option<Element>),
    #[doc = "Canada"]
    #[code = "CA"]
    CA(Option<Element>),
    #[doc = "Switzerland"]
    #[code = "CH"]
    CH(Option<Element>),
    #[doc = "Chile"]
    #[code = "CL"]
    CL(Option<Element>),
    #[doc = "China"]
    #[code = "CN"]
    CN(Option<Element>),
    #[doc = "Columbia"]
    #[code = "CO"]
    CO(Option<Element>),
    #[doc = "Czech Republic"]
    #[code = "CZ"]
    CZ(Option<Element>),
    #[doc = "Germany"]
    #[code = "DE"]
    DE(Option<Element>),
    #[doc = "Denmark"]
    #[code = "DK"]
    DK(Option<Element>),
    #[doc = "Spain"]
    #[code = "ES"]
    ES(Option<Element>),
    #[doc = "Finland"]
    #[code = "FI"]
    FI(Option<Element>),
    #[doc = "France"]
    #[code = "FR"]
    FR(Option<Element>),
    #[doc = "Great Britain"]
    #[code = "GB"]
    GB(Option<Element>),
    #[doc = "Greece"]
    #[code = "GR"]
    GR(Option<Element>),
    #[doc = "Croatia"]
    #[code = "HR"]
    HR(Option<Element>),
    #[doc = "Ireland"]
    #[code = "IE"]
    IE(Option<Element>),
    #[doc = "India"]
    #[code = "IN"]
    IN(Option<Element>),
    #[doc = "Italy"]
    #[code = "IT"]
    IT(Option<Element>),
    #[doc = "Japan"]
    #[code = "JP"]
    JP(Option<Element>),
    #[doc = "Korea"]
    #[code = "KR"]
    KR(Option<Element>),
    #[doc = "Lithuania"]
    #[code = "LT"]
    LT(Option<Element>),
    #[doc = "Mexico"]
    #[code = "MX"]
    MX(Option<Element>),
    #[doc = "The Netherlands"]
    #[code = "NL"]
    NL(Option<Element>),
    #[doc = "New Zealand"]
    #[code = "NZ"]
    NZ(Option<Element>),
    #[doc = "namespace realms"]
    #[code = "NamespaceRealms"]
    NamespaceRealms(Option<Element>),
    #[doc = "Representative Realm"]
    #[code = "R1"]
    R1(Option<Element>),
    #[doc = "Romania"]
    #[code = "RO"]
    RO(Option<Element>),
    #[doc = "Russian Federation"]
    #[code = "RU"]
    RU(Option<Element>),
    #[doc = "Sweden"]
    #[code = "SE"]
    SE(Option<Element>),
    #[doc = "Singapore"]
    #[code = "SG"]
    SG(Option<Element>),
    #[doc = "Southern Africa"]
    #[code = "SOA"]
    SOA(Option<Element>),
    #[doc = "Turkey"]
    #[code = "TR"]
    TR(Option<Element>),
    #[doc = "Taiwan"]
    #[code = "TW"]
    TW(Option<Element>),
    #[doc = "United Kingdom"]
    #[code = "UK"]
    UK(Option<Element>),
    #[doc = "United States of America"]
    #[code = "US"]
    US(Option<Element>),
    #[doc = "Universal"]
    #[code = "UV"]
    UV(Option<Element>),
    #[doc = "Uruguay"]
    #[code = "UY"]
    UY(Option<Element>),
    #[doc = "Example Realm"]
    #[code = "X1"]
    X1(Option<Element>),
    #[doc = "Localized Version"]
    #[code = "ZZ"]
    ZZ(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7Realm {
    fn default() -> Self {
        V3Hl7Realm::Null(None)
    }
}
impl TryFrom<String> for V3Hl7Realm {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "AR" => Ok(V3Hl7Realm::AR(None)),
            "AT" => Ok(V3Hl7Realm::AT(None)),
            "AU" => Ok(V3Hl7Realm::AU(None)),
            "AffiliateRealms" => Ok(V3Hl7Realm::AffiliateRealms(None)),
            "BR" => Ok(V3Hl7Realm::BR(None)),
            "BindingRealms" => Ok(V3Hl7Realm::BindingRealms(None)),
            "C1" => Ok(V3Hl7Realm::C1(None)),
            "CA" => Ok(V3Hl7Realm::CA(None)),
            "CH" => Ok(V3Hl7Realm::CH(None)),
            "CL" => Ok(V3Hl7Realm::CL(None)),
            "CN" => Ok(V3Hl7Realm::CN(None)),
            "CO" => Ok(V3Hl7Realm::CO(None)),
            "CZ" => Ok(V3Hl7Realm::CZ(None)),
            "DE" => Ok(V3Hl7Realm::DE(None)),
            "DK" => Ok(V3Hl7Realm::DK(None)),
            "ES" => Ok(V3Hl7Realm::ES(None)),
            "FI" => Ok(V3Hl7Realm::FI(None)),
            "FR" => Ok(V3Hl7Realm::FR(None)),
            "GB" => Ok(V3Hl7Realm::GB(None)),
            "GR" => Ok(V3Hl7Realm::GR(None)),
            "HR" => Ok(V3Hl7Realm::HR(None)),
            "IE" => Ok(V3Hl7Realm::IE(None)),
            "IN" => Ok(V3Hl7Realm::IN(None)),
            "IT" => Ok(V3Hl7Realm::IT(None)),
            "JP" => Ok(V3Hl7Realm::JP(None)),
            "KR" => Ok(V3Hl7Realm::KR(None)),
            "LT" => Ok(V3Hl7Realm::LT(None)),
            "MX" => Ok(V3Hl7Realm::MX(None)),
            "NL" => Ok(V3Hl7Realm::NL(None)),
            "NZ" => Ok(V3Hl7Realm::NZ(None)),
            "NamespaceRealms" => Ok(V3Hl7Realm::NamespaceRealms(None)),
            "R1" => Ok(V3Hl7Realm::R1(None)),
            "RO" => Ok(V3Hl7Realm::RO(None)),
            "RU" => Ok(V3Hl7Realm::RU(None)),
            "SE" => Ok(V3Hl7Realm::SE(None)),
            "SG" => Ok(V3Hl7Realm::SG(None)),
            "SOA" => Ok(V3Hl7Realm::SOA(None)),
            "TR" => Ok(V3Hl7Realm::TR(None)),
            "TW" => Ok(V3Hl7Realm::TW(None)),
            "UK" => Ok(V3Hl7Realm::UK(None)),
            "US" => Ok(V3Hl7Realm::US(None)),
            "UV" => Ok(V3Hl7Realm::UV(None)),
            "UY" => Ok(V3Hl7Realm::UY(None)),
            "X1" => Ok(V3Hl7Realm::X1(None)),
            "ZZ" => Ok(V3Hl7Realm::ZZ(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7Realm {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7Realm::AR(_) => Some("AR".to_string()),
            V3Hl7Realm::AT(_) => Some("AT".to_string()),
            V3Hl7Realm::AU(_) => Some("AU".to_string()),
            V3Hl7Realm::AffiliateRealms(_) => Some("AffiliateRealms".to_string()),
            V3Hl7Realm::BR(_) => Some("BR".to_string()),
            V3Hl7Realm::BindingRealms(_) => Some("BindingRealms".to_string()),
            V3Hl7Realm::C1(_) => Some("C1".to_string()),
            V3Hl7Realm::CA(_) => Some("CA".to_string()),
            V3Hl7Realm::CH(_) => Some("CH".to_string()),
            V3Hl7Realm::CL(_) => Some("CL".to_string()),
            V3Hl7Realm::CN(_) => Some("CN".to_string()),
            V3Hl7Realm::CO(_) => Some("CO".to_string()),
            V3Hl7Realm::CZ(_) => Some("CZ".to_string()),
            V3Hl7Realm::DE(_) => Some("DE".to_string()),
            V3Hl7Realm::DK(_) => Some("DK".to_string()),
            V3Hl7Realm::ES(_) => Some("ES".to_string()),
            V3Hl7Realm::FI(_) => Some("FI".to_string()),
            V3Hl7Realm::FR(_) => Some("FR".to_string()),
            V3Hl7Realm::GB(_) => Some("GB".to_string()),
            V3Hl7Realm::GR(_) => Some("GR".to_string()),
            V3Hl7Realm::HR(_) => Some("HR".to_string()),
            V3Hl7Realm::IE(_) => Some("IE".to_string()),
            V3Hl7Realm::IN(_) => Some("IN".to_string()),
            V3Hl7Realm::IT(_) => Some("IT".to_string()),
            V3Hl7Realm::JP(_) => Some("JP".to_string()),
            V3Hl7Realm::KR(_) => Some("KR".to_string()),
            V3Hl7Realm::LT(_) => Some("LT".to_string()),
            V3Hl7Realm::MX(_) => Some("MX".to_string()),
            V3Hl7Realm::NL(_) => Some("NL".to_string()),
            V3Hl7Realm::NZ(_) => Some("NZ".to_string()),
            V3Hl7Realm::NamespaceRealms(_) => Some("NamespaceRealms".to_string()),
            V3Hl7Realm::R1(_) => Some("R1".to_string()),
            V3Hl7Realm::RO(_) => Some("RO".to_string()),
            V3Hl7Realm::RU(_) => Some("RU".to_string()),
            V3Hl7Realm::SE(_) => Some("SE".to_string()),
            V3Hl7Realm::SG(_) => Some("SG".to_string()),
            V3Hl7Realm::SOA(_) => Some("SOA".to_string()),
            V3Hl7Realm::TR(_) => Some("TR".to_string()),
            V3Hl7Realm::TW(_) => Some("TW".to_string()),
            V3Hl7Realm::UK(_) => Some("UK".to_string()),
            V3Hl7Realm::US(_) => Some("US".to_string()),
            V3Hl7Realm::UV(_) => Some("UV".to_string()),
            V3Hl7Realm::UY(_) => Some("UY".to_string()),
            V3Hl7Realm::X1(_) => Some("X1".to_string()),
            V3Hl7Realm::ZZ(_) => Some("ZZ".to_string()),
            V3Hl7Realm::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7Realm {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7Realm::AR(Some(e)) => e.get_field(field),
                V3Hl7Realm::AT(Some(e)) => e.get_field(field),
                V3Hl7Realm::AU(Some(e)) => e.get_field(field),
                V3Hl7Realm::AffiliateRealms(Some(e)) => e.get_field(field),
                V3Hl7Realm::BR(Some(e)) => e.get_field(field),
                V3Hl7Realm::BindingRealms(Some(e)) => e.get_field(field),
                V3Hl7Realm::C1(Some(e)) => e.get_field(field),
                V3Hl7Realm::CA(Some(e)) => e.get_field(field),
                V3Hl7Realm::CH(Some(e)) => e.get_field(field),
                V3Hl7Realm::CL(Some(e)) => e.get_field(field),
                V3Hl7Realm::CN(Some(e)) => e.get_field(field),
                V3Hl7Realm::CO(Some(e)) => e.get_field(field),
                V3Hl7Realm::CZ(Some(e)) => e.get_field(field),
                V3Hl7Realm::DE(Some(e)) => e.get_field(field),
                V3Hl7Realm::DK(Some(e)) => e.get_field(field),
                V3Hl7Realm::ES(Some(e)) => e.get_field(field),
                V3Hl7Realm::FI(Some(e)) => e.get_field(field),
                V3Hl7Realm::FR(Some(e)) => e.get_field(field),
                V3Hl7Realm::GB(Some(e)) => e.get_field(field),
                V3Hl7Realm::GR(Some(e)) => e.get_field(field),
                V3Hl7Realm::HR(Some(e)) => e.get_field(field),
                V3Hl7Realm::IE(Some(e)) => e.get_field(field),
                V3Hl7Realm::IN(Some(e)) => e.get_field(field),
                V3Hl7Realm::IT(Some(e)) => e.get_field(field),
                V3Hl7Realm::JP(Some(e)) => e.get_field(field),
                V3Hl7Realm::KR(Some(e)) => e.get_field(field),
                V3Hl7Realm::LT(Some(e)) => e.get_field(field),
                V3Hl7Realm::MX(Some(e)) => e.get_field(field),
                V3Hl7Realm::NL(Some(e)) => e.get_field(field),
                V3Hl7Realm::NZ(Some(e)) => e.get_field(field),
                V3Hl7Realm::NamespaceRealms(Some(e)) => e.get_field(field),
                V3Hl7Realm::R1(Some(e)) => e.get_field(field),
                V3Hl7Realm::RO(Some(e)) => e.get_field(field),
                V3Hl7Realm::RU(Some(e)) => e.get_field(field),
                V3Hl7Realm::SE(Some(e)) => e.get_field(field),
                V3Hl7Realm::SG(Some(e)) => e.get_field(field),
                V3Hl7Realm::SOA(Some(e)) => e.get_field(field),
                V3Hl7Realm::TR(Some(e)) => e.get_field(field),
                V3Hl7Realm::TW(Some(e)) => e.get_field(field),
                V3Hl7Realm::UK(Some(e)) => e.get_field(field),
                V3Hl7Realm::US(Some(e)) => e.get_field(field),
                V3Hl7Realm::UV(Some(e)) => e.get_field(field),
                V3Hl7Realm::UY(Some(e)) => e.get_field(field),
                V3Hl7Realm::X1(Some(e)) => e.get_field(field),
                V3Hl7Realm::ZZ(Some(e)) => e.get_field(field),
                V3Hl7Realm::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7Realm::AR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::AT(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::AU(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::AffiliateRealms(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::BR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::BindingRealms(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::C1(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CA(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CH(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CL(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CN(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CO(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::CZ(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::DE(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::DK(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::ES(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::FI(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::FR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::GB(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::GR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::HR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::IE(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::IN(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::IT(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::JP(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::KR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::LT(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::MX(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::NL(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::NZ(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::NamespaceRealms(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::R1(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::RO(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::RU(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::SE(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::SG(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::SOA(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::TR(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::TW(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::UK(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::US(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::UV(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::UY(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::X1(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::ZZ(Some(e)) => e.get_field_mut(field),
                V3Hl7Realm::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7V3Conformance {
    #[doc = "ignored"]
    #[code = "I"]
    I(Option<Element>),
    #[doc = "not permitted"]
    #[code = "NP"]
    NP(Option<Element>),
    #[doc = "required"]
    #[code = "R"]
    R(Option<Element>),
    #[doc = "required for consumer"]
    #[code = "RC"]
    RC(Option<Element>),
    #[doc = "required for initiator"]
    #[code = "RI"]
    RI(Option<Element>),
    #[doc = "undetermined"]
    #[code = "U"]
    U(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7V3Conformance {
    fn default() -> Self {
        V3Hl7V3Conformance::Null(None)
    }
}
impl TryFrom<String> for V3Hl7V3Conformance {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "I" => Ok(V3Hl7V3Conformance::I(None)),
            "NP" => Ok(V3Hl7V3Conformance::NP(None)),
            "R" => Ok(V3Hl7V3Conformance::R(None)),
            "RC" => Ok(V3Hl7V3Conformance::RC(None)),
            "RI" => Ok(V3Hl7V3Conformance::RI(None)),
            "U" => Ok(V3Hl7V3Conformance::U(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7V3Conformance {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7V3Conformance::I(_) => Some("I".to_string()),
            V3Hl7V3Conformance::NP(_) => Some("NP".to_string()),
            V3Hl7V3Conformance::R(_) => Some("R".to_string()),
            V3Hl7V3Conformance::RC(_) => Some("RC".to_string()),
            V3Hl7V3Conformance::RI(_) => Some("RI".to_string()),
            V3Hl7V3Conformance::U(_) => Some("U".to_string()),
            V3Hl7V3Conformance::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7V3Conformance {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7V3Conformance::I(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::NP(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::R(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::RC(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::RI(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::U(Some(e)) => e.get_field(field),
                V3Hl7V3Conformance::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7V3Conformance::I(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::NP(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::R(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::RC(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::RI(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::U(Some(e)) => e.get_field_mut(field),
                V3Hl7V3Conformance::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3Hl7VoteResolution {
    #[doc = "affirmative-deferred"]
    #[code = "affdef"]
    Affdef(Option<Element>),
    #[doc = "affirmative-incorporated"]
    #[code = "affi"]
    Affi(Option<Element>),
    #[doc = "affirmative resolution"]
    #[code = "affirmativeResolution"]
    AffirmativeResolution(Option<Element>),
    #[doc = "affirmative-rejected"]
    #[code = "affr"]
    Affr(Option<Element>),
    #[doc = "negative resolution"]
    #[code = "negativeResolution"]
    NegativeResolution(Option<Element>),
    #[doc = "non-substantive proposed"]
    #[code = "nonsubp"]
    Nonsubp(Option<Element>),
    #[doc = "non-substantive voted"]
    #[code = "nonsubv"]
    Nonsubv(Option<Element>),
    #[doc = "not related proposed"]
    #[code = "notrelp"]
    Notrelp(Option<Element>),
    #[doc = "not related voted"]
    #[code = "notrelv"]
    Notrelv(Option<Element>),
    #[doc = "previously considered"]
    #[code = "prevcons"]
    Prevcons(Option<Element>),
    #[doc = "retracted"]
    #[code = "retract"]
    Retract(Option<Element>),
    #[doc = "unresolved"]
    #[code = "unresolved"]
    Unresolved(Option<Element>),
    #[doc = "withdrawn"]
    #[code = "withdraw"]
    Withdraw(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3Hl7VoteResolution {
    fn default() -> Self {
        V3Hl7VoteResolution::Null(None)
    }
}
impl TryFrom<String> for V3Hl7VoteResolution {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "affdef" => Ok(V3Hl7VoteResolution::Affdef(None)),
            "affi" => Ok(V3Hl7VoteResolution::Affi(None)),
            "affirmativeResolution" => Ok(V3Hl7VoteResolution::AffirmativeResolution(None)),
            "affr" => Ok(V3Hl7VoteResolution::Affr(None)),
            "negativeResolution" => Ok(V3Hl7VoteResolution::NegativeResolution(None)),
            "nonsubp" => Ok(V3Hl7VoteResolution::Nonsubp(None)),
            "nonsubv" => Ok(V3Hl7VoteResolution::Nonsubv(None)),
            "notrelp" => Ok(V3Hl7VoteResolution::Notrelp(None)),
            "notrelv" => Ok(V3Hl7VoteResolution::Notrelv(None)),
            "prevcons" => Ok(V3Hl7VoteResolution::Prevcons(None)),
            "retract" => Ok(V3Hl7VoteResolution::Retract(None)),
            "unresolved" => Ok(V3Hl7VoteResolution::Unresolved(None)),
            "withdraw" => Ok(V3Hl7VoteResolution::Withdraw(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3Hl7VoteResolution {
    fn into(self) -> Option<String> {
        match self {
            V3Hl7VoteResolution::Affdef(_) => Some("affdef".to_string()),
            V3Hl7VoteResolution::Affi(_) => Some("affi".to_string()),
            V3Hl7VoteResolution::AffirmativeResolution(_) => {
                Some("affirmativeResolution".to_string())
            }
            V3Hl7VoteResolution::Affr(_) => Some("affr".to_string()),
            V3Hl7VoteResolution::NegativeResolution(_) => Some("negativeResolution".to_string()),
            V3Hl7VoteResolution::Nonsubp(_) => Some("nonsubp".to_string()),
            V3Hl7VoteResolution::Nonsubv(_) => Some("nonsubv".to_string()),
            V3Hl7VoteResolution::Notrelp(_) => Some("notrelp".to_string()),
            V3Hl7VoteResolution::Notrelv(_) => Some("notrelv".to_string()),
            V3Hl7VoteResolution::Prevcons(_) => Some("prevcons".to_string()),
            V3Hl7VoteResolution::Retract(_) => Some("retract".to_string()),
            V3Hl7VoteResolution::Unresolved(_) => Some("unresolved".to_string()),
            V3Hl7VoteResolution::Withdraw(_) => Some("withdraw".to_string()),
            V3Hl7VoteResolution::Null(_) => None,
        }
    }
}
impl MetaValue for V3Hl7VoteResolution {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3Hl7VoteResolution::Affdef(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Affi(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::AffirmativeResolution(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Affr(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::NegativeResolution(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Nonsubp(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Nonsubv(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Notrelp(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Notrelv(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Prevcons(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Retract(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Unresolved(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Withdraw(Some(e)) => e.get_field(field),
                V3Hl7VoteResolution::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3Hl7VoteResolution::Affdef(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Affi(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::AffirmativeResolution(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Affr(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::NegativeResolution(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Nonsubp(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Nonsubv(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Notrelp(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Notrelv(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Prevcons(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Retract(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Unresolved(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Withdraw(Some(e)) => e.get_field_mut(field),
                V3Hl7VoteResolution::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3StyleType {
    #[doc = "Arabic"]
    #[code = "Arabic"]
    Arabic(Option<Element>),
    #[doc = "Big Alpha"]
    #[code = "BigAlpha"]
    BigAlpha(Option<Element>),
    #[doc = "Big Roman"]
    #[code = "BigRoman"]
    BigRoman(Option<Element>),
    #[doc = "Bottom Rule"]
    #[code = "Botrule"]
    Botrule(Option<Element>),
    #[doc = "Circle"]
    #[code = "Circle"]
    Circle(Option<Element>),
    #[doc = "Disc"]
    #[code = "Disc"]
    Disc(Option<Element>),
    #[doc = "Little Alpha"]
    #[code = "LittleAlpha"]
    LittleAlpha(Option<Element>),
    #[doc = "Little Roman"]
    #[code = "LittleRoman"]
    LittleRoman(Option<Element>),
    #[doc = "Left-sided rule"]
    #[code = "Lrule"]
    Lrule(Option<Element>),
    #[doc = "Right-sided rule"]
    #[code = "Rrule"]
    Rrule(Option<Element>),
    #[doc = "Square"]
    #[code = "Square"]
    Square(Option<Element>),
    #[doc = "Top Rule"]
    #[code = "Toprule"]
    Toprule(Option<Element>),
    #[doc = "Font Style"]
    #[code = "_FontStyle"]
    _FontStyle(Option<Element>),
    #[doc = "List Style"]
    #[code = "_ListStyle"]
    _ListStyle(Option<Element>),
    #[doc = "Ordered List Style"]
    #[code = "_OrderedListStyle"]
    _OrderedListStyle(Option<Element>),
    #[doc = "Table Rule Style"]
    #[code = "_TableRuleStyle"]
    _TableRuleStyle(Option<Element>),
    #[doc = "Unordered List Style"]
    #[code = "_UnorderedListStyle"]
    _UnorderedListStyle(Option<Element>),
    #[doc = "Bold Font"]
    #[code = "bold"]
    Bold(Option<Element>),
    #[doc = "Emphasised Font"]
    #[code = "emphasis"]
    Emphasis(Option<Element>),
    #[doc = "Italics Font"]
    #[code = "italics"]
    Italics(Option<Element>),
    #[doc = "Underline Font"]
    #[code = "underline"]
    Underline(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3StyleType {
    fn default() -> Self {
        V3StyleType::Null(None)
    }
}
impl TryFrom<String> for V3StyleType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "Arabic" => Ok(V3StyleType::Arabic(None)),
            "BigAlpha" => Ok(V3StyleType::BigAlpha(None)),
            "BigRoman" => Ok(V3StyleType::BigRoman(None)),
            "Botrule" => Ok(V3StyleType::Botrule(None)),
            "Circle" => Ok(V3StyleType::Circle(None)),
            "Disc" => Ok(V3StyleType::Disc(None)),
            "LittleAlpha" => Ok(V3StyleType::LittleAlpha(None)),
            "LittleRoman" => Ok(V3StyleType::LittleRoman(None)),
            "Lrule" => Ok(V3StyleType::Lrule(None)),
            "Rrule" => Ok(V3StyleType::Rrule(None)),
            "Square" => Ok(V3StyleType::Square(None)),
            "Toprule" => Ok(V3StyleType::Toprule(None)),
            "_FontStyle" => Ok(V3StyleType::_FontStyle(None)),
            "_ListStyle" => Ok(V3StyleType::_ListStyle(None)),
            "_OrderedListStyle" => Ok(V3StyleType::_OrderedListStyle(None)),
            "_TableRuleStyle" => Ok(V3StyleType::_TableRuleStyle(None)),
            "_UnorderedListStyle" => Ok(V3StyleType::_UnorderedListStyle(None)),
            "bold" => Ok(V3StyleType::Bold(None)),
            "emphasis" => Ok(V3StyleType::Emphasis(None)),
            "italics" => Ok(V3StyleType::Italics(None)),
            "underline" => Ok(V3StyleType::Underline(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3StyleType {
    fn into(self) -> Option<String> {
        match self {
            V3StyleType::Arabic(_) => Some("Arabic".to_string()),
            V3StyleType::BigAlpha(_) => Some("BigAlpha".to_string()),
            V3StyleType::BigRoman(_) => Some("BigRoman".to_string()),
            V3StyleType::Botrule(_) => Some("Botrule".to_string()),
            V3StyleType::Circle(_) => Some("Circle".to_string()),
            V3StyleType::Disc(_) => Some("Disc".to_string()),
            V3StyleType::LittleAlpha(_) => Some("LittleAlpha".to_string()),
            V3StyleType::LittleRoman(_) => Some("LittleRoman".to_string()),
            V3StyleType::Lrule(_) => Some("Lrule".to_string()),
            V3StyleType::Rrule(_) => Some("Rrule".to_string()),
            V3StyleType::Square(_) => Some("Square".to_string()),
            V3StyleType::Toprule(_) => Some("Toprule".to_string()),
            V3StyleType::_FontStyle(_) => Some("_FontStyle".to_string()),
            V3StyleType::_ListStyle(_) => Some("_ListStyle".to_string()),
            V3StyleType::_OrderedListStyle(_) => Some("_OrderedListStyle".to_string()),
            V3StyleType::_TableRuleStyle(_) => Some("_TableRuleStyle".to_string()),
            V3StyleType::_UnorderedListStyle(_) => Some("_UnorderedListStyle".to_string()),
            V3StyleType::Bold(_) => Some("bold".to_string()),
            V3StyleType::Emphasis(_) => Some("emphasis".to_string()),
            V3StyleType::Italics(_) => Some("italics".to_string()),
            V3StyleType::Underline(_) => Some("underline".to_string()),
            V3StyleType::Null(_) => None,
        }
    }
}
impl MetaValue for V3StyleType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3StyleType::Arabic(Some(e)) => e.get_field(field),
                V3StyleType::BigAlpha(Some(e)) => e.get_field(field),
                V3StyleType::BigRoman(Some(e)) => e.get_field(field),
                V3StyleType::Botrule(Some(e)) => e.get_field(field),
                V3StyleType::Circle(Some(e)) => e.get_field(field),
                V3StyleType::Disc(Some(e)) => e.get_field(field),
                V3StyleType::LittleAlpha(Some(e)) => e.get_field(field),
                V3StyleType::LittleRoman(Some(e)) => e.get_field(field),
                V3StyleType::Lrule(Some(e)) => e.get_field(field),
                V3StyleType::Rrule(Some(e)) => e.get_field(field),
                V3StyleType::Square(Some(e)) => e.get_field(field),
                V3StyleType::Toprule(Some(e)) => e.get_field(field),
                V3StyleType::_FontStyle(Some(e)) => e.get_field(field),
                V3StyleType::_ListStyle(Some(e)) => e.get_field(field),
                V3StyleType::_OrderedListStyle(Some(e)) => e.get_field(field),
                V3StyleType::_TableRuleStyle(Some(e)) => e.get_field(field),
                V3StyleType::_UnorderedListStyle(Some(e)) => e.get_field(field),
                V3StyleType::Bold(Some(e)) => e.get_field(field),
                V3StyleType::Emphasis(Some(e)) => e.get_field(field),
                V3StyleType::Italics(Some(e)) => e.get_field(field),
                V3StyleType::Underline(Some(e)) => e.get_field(field),
                V3StyleType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3StyleType::Arabic(Some(e)) => e.get_field_mut(field),
                V3StyleType::BigAlpha(Some(e)) => e.get_field_mut(field),
                V3StyleType::BigRoman(Some(e)) => e.get_field_mut(field),
                V3StyleType::Botrule(Some(e)) => e.get_field_mut(field),
                V3StyleType::Circle(Some(e)) => e.get_field_mut(field),
                V3StyleType::Disc(Some(e)) => e.get_field_mut(field),
                V3StyleType::LittleAlpha(Some(e)) => e.get_field_mut(field),
                V3StyleType::LittleRoman(Some(e)) => e.get_field_mut(field),
                V3StyleType::Lrule(Some(e)) => e.get_field_mut(field),
                V3StyleType::Rrule(Some(e)) => e.get_field_mut(field),
                V3StyleType::Square(Some(e)) => e.get_field_mut(field),
                V3StyleType::Toprule(Some(e)) => e.get_field_mut(field),
                V3StyleType::_FontStyle(Some(e)) => e.get_field_mut(field),
                V3StyleType::_ListStyle(Some(e)) => e.get_field_mut(field),
                V3StyleType::_OrderedListStyle(Some(e)) => e.get_field_mut(field),
                V3StyleType::_TableRuleStyle(Some(e)) => e.get_field_mut(field),
                V3StyleType::_UnorderedListStyle(Some(e)) => e.get_field_mut(field),
                V3StyleType::Bold(Some(e)) => e.get_field_mut(field),
                V3StyleType::Emphasis(Some(e)) => e.get_field_mut(field),
                V3StyleType::Italics(Some(e)) => e.get_field_mut(field),
                V3StyleType::Underline(Some(e)) => e.get_field_mut(field),
                V3StyleType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3SubstanceAdminSubstitution {
    #[doc = "brand composition"]
    #[code = "BC"]
    BC(Option<Element>),
    #[doc = "equivalent"]
    #[code = "E"]
    E(Option<Element>),
    #[doc = "equivalent composition"]
    #[code = "EC"]
    EC(Option<Element>),
    #[doc = "formulary"]
    #[code = "F"]
    F(Option<Element>),
    #[doc = "generic composition"]
    #[code = "G"]
    G(Option<Element>),
    #[doc = "none"]
    #[code = "N"]
    N(Option<Element>),
    #[doc = "therapeutic brand"]
    #[code = "TB"]
    TB(Option<Element>),
    #[doc = "therapeutic alternative"]
    #[code = "TE"]
    TE(Option<Element>),
    #[doc = "therapeutic generic"]
    #[code = "TG"]
    TG(Option<Element>),
    #[doc = "ActSubstanceAdminSubstitutionCode"]
    #[code = "_ActSubstanceAdminSubstitutionCode"]
    _ActSubstanceAdminSubstitutionCode(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3SubstanceAdminSubstitution {
    fn default() -> Self {
        V3SubstanceAdminSubstitution::Null(None)
    }
}
impl TryFrom<String> for V3SubstanceAdminSubstitution {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "BC" => Ok(V3SubstanceAdminSubstitution::BC(None)),
            "E" => Ok(V3SubstanceAdminSubstitution::E(None)),
            "EC" => Ok(V3SubstanceAdminSubstitution::EC(None)),
            "F" => Ok(V3SubstanceAdminSubstitution::F(None)),
            "G" => Ok(V3SubstanceAdminSubstitution::G(None)),
            "N" => Ok(V3SubstanceAdminSubstitution::N(None)),
            "TB" => Ok(V3SubstanceAdminSubstitution::TB(None)),
            "TE" => Ok(V3SubstanceAdminSubstitution::TE(None)),
            "TG" => Ok(V3SubstanceAdminSubstitution::TG(None)),
            "_ActSubstanceAdminSubstitutionCode" => {
                Ok(V3SubstanceAdminSubstitution::_ActSubstanceAdminSubstitutionCode(None))
            }
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3SubstanceAdminSubstitution {
    fn into(self) -> Option<String> {
        match self {
            V3SubstanceAdminSubstitution::BC(_) => Some("BC".to_string()),
            V3SubstanceAdminSubstitution::E(_) => Some("E".to_string()),
            V3SubstanceAdminSubstitution::EC(_) => Some("EC".to_string()),
            V3SubstanceAdminSubstitution::F(_) => Some("F".to_string()),
            V3SubstanceAdminSubstitution::G(_) => Some("G".to_string()),
            V3SubstanceAdminSubstitution::N(_) => Some("N".to_string()),
            V3SubstanceAdminSubstitution::TB(_) => Some("TB".to_string()),
            V3SubstanceAdminSubstitution::TE(_) => Some("TE".to_string()),
            V3SubstanceAdminSubstitution::TG(_) => Some("TG".to_string()),
            V3SubstanceAdminSubstitution::_ActSubstanceAdminSubstitutionCode(_) => {
                Some("_ActSubstanceAdminSubstitutionCode".to_string())
            }
            V3SubstanceAdminSubstitution::Null(_) => None,
        }
    }
}
impl MetaValue for V3SubstanceAdminSubstitution {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3SubstanceAdminSubstitution::BC(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::E(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::EC(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::F(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::G(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::N(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::TB(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::TE(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::TG(Some(e)) => e.get_field(field),
                V3SubstanceAdminSubstitution::_ActSubstanceAdminSubstitutionCode(Some(e)) => {
                    e.get_field(field)
                }
                V3SubstanceAdminSubstitution::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3SubstanceAdminSubstitution::BC(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::E(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::EC(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::F(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::G(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::N(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::TB(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::TE(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::TG(Some(e)) => e.get_field_mut(field),
                V3SubstanceAdminSubstitution::_ActSubstanceAdminSubstitutionCode(Some(e)) => {
                    e.get_field_mut(field)
                }
                V3SubstanceAdminSubstitution::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3TriggerEventID {
    #[doc = "Result Status"]
    #[code = "POLB_TE004000UV"]
    POLB_TE004000UV(Option<Element>),
    #[doc = "Result Confirm"]
    #[code = "POLB_TE004001UV"]
    POLB_TE004001UV(Option<Element>),
    #[doc = "Result Reject"]
    #[code = "POLB_TE004002UV"]
    POLB_TE004002UV(Option<Element>),
    #[doc = "Result Tracking"]
    #[code = "POLB_TE004007UV"]
    POLB_TE004007UV(Option<Element>),
    #[doc = "Result in Progress"]
    #[code = "POLB_TE004100UV"]
    POLB_TE004100UV(Option<Element>),
    #[doc = "Result Activate"]
    #[code = "POLB_TE004102UV"]
    POLB_TE004102UV(Option<Element>),
    #[doc = "Result Complete with Fulfillment"]
    #[code = "POLB_TE004200UV"]
    POLB_TE004200UV(Option<Element>),
    #[doc = "Result Corrected"]
    #[code = "POLB_TE004201UV"]
    POLB_TE004201UV(Option<Element>),
    #[doc = "Result Complete"]
    #[code = "POLB_TE004202UV"]
    POLB_TE004202UV(Option<Element>),
    #[doc = "Result Abort"]
    #[code = "POLB_TE004301UV"]
    POLB_TE004301UV(Option<Element>),
    #[doc = "Result Nullify"]
    #[code = "POLB_TE004500UV"]
    POLB_TE004500UV(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3TriggerEventID {
    fn default() -> Self {
        V3TriggerEventID::Null(None)
    }
}
impl TryFrom<String> for V3TriggerEventID {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "POLB_TE004000UV" => Ok(V3TriggerEventID::POLB_TE004000UV(None)),
            "POLB_TE004001UV" => Ok(V3TriggerEventID::POLB_TE004001UV(None)),
            "POLB_TE004002UV" => Ok(V3TriggerEventID::POLB_TE004002UV(None)),
            "POLB_TE004007UV" => Ok(V3TriggerEventID::POLB_TE004007UV(None)),
            "POLB_TE004100UV" => Ok(V3TriggerEventID::POLB_TE004100UV(None)),
            "POLB_TE004102UV" => Ok(V3TriggerEventID::POLB_TE004102UV(None)),
            "POLB_TE004200UV" => Ok(V3TriggerEventID::POLB_TE004200UV(None)),
            "POLB_TE004201UV" => Ok(V3TriggerEventID::POLB_TE004201UV(None)),
            "POLB_TE004202UV" => Ok(V3TriggerEventID::POLB_TE004202UV(None)),
            "POLB_TE004301UV" => Ok(V3TriggerEventID::POLB_TE004301UV(None)),
            "POLB_TE004500UV" => Ok(V3TriggerEventID::POLB_TE004500UV(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3TriggerEventID {
    fn into(self) -> Option<String> {
        match self {
            V3TriggerEventID::POLB_TE004000UV(_) => Some("POLB_TE004000UV".to_string()),
            V3TriggerEventID::POLB_TE004001UV(_) => Some("POLB_TE004001UV".to_string()),
            V3TriggerEventID::POLB_TE004002UV(_) => Some("POLB_TE004002UV".to_string()),
            V3TriggerEventID::POLB_TE004007UV(_) => Some("POLB_TE004007UV".to_string()),
            V3TriggerEventID::POLB_TE004100UV(_) => Some("POLB_TE004100UV".to_string()),
            V3TriggerEventID::POLB_TE004102UV(_) => Some("POLB_TE004102UV".to_string()),
            V3TriggerEventID::POLB_TE004200UV(_) => Some("POLB_TE004200UV".to_string()),
            V3TriggerEventID::POLB_TE004201UV(_) => Some("POLB_TE004201UV".to_string()),
            V3TriggerEventID::POLB_TE004202UV(_) => Some("POLB_TE004202UV".to_string()),
            V3TriggerEventID::POLB_TE004301UV(_) => Some("POLB_TE004301UV".to_string()),
            V3TriggerEventID::POLB_TE004500UV(_) => Some("POLB_TE004500UV".to_string()),
            V3TriggerEventID::Null(_) => None,
        }
    }
}
impl MetaValue for V3TriggerEventID {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3TriggerEventID::POLB_TE004000UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004001UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004002UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004007UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004100UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004102UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004200UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004201UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004202UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004301UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::POLB_TE004500UV(Some(e)) => e.get_field(field),
                V3TriggerEventID::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3TriggerEventID::POLB_TE004000UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004001UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004002UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004007UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004100UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004102UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004200UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004201UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004202UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004301UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::POLB_TE004500UV(Some(e)) => e.get_field_mut(field),
                V3TriggerEventID::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum V3XBasicConfidentialityKind {
    #[code = "N"]
    N(Option<Element>),
    #[code = "R"]
    R(Option<Element>),
    #[code = "V"]
    V(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for V3XBasicConfidentialityKind {
    fn default() -> Self {
        V3XBasicConfidentialityKind::Null(None)
    }
}
impl TryFrom<String> for V3XBasicConfidentialityKind {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "N" => Ok(V3XBasicConfidentialityKind::N(None)),
            "R" => Ok(V3XBasicConfidentialityKind::R(None)),
            "V" => Ok(V3XBasicConfidentialityKind::V(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &V3XBasicConfidentialityKind {
    fn into(self) -> Option<String> {
        match self {
            V3XBasicConfidentialityKind::N(_) => Some("N".to_string()),
            V3XBasicConfidentialityKind::R(_) => Some("R".to_string()),
            V3XBasicConfidentialityKind::V(_) => Some("V".to_string()),
            V3XBasicConfidentialityKind::Null(_) => None,
        }
    }
}
impl MetaValue for V3XBasicConfidentialityKind {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                V3XBasicConfidentialityKind::N(Some(e)) => e.get_field(field),
                V3XBasicConfidentialityKind::R(Some(e)) => e.get_field(field),
                V3XBasicConfidentialityKind::V(Some(e)) => e.get_field(field),
                V3XBasicConfidentialityKind::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                V3XBasicConfidentialityKind::N(Some(e)) => e.get_field_mut(field),
                V3XBasicConfidentialityKind::R(Some(e)) => e.get_field_mut(field),
                V3XBasicConfidentialityKind::V(Some(e)) => e.get_field_mut(field),
                V3XBasicConfidentialityKind::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyAttributeOperationTypes {
    #[doc = "Read"]
    #[code = "read"]
    Read(Option<Element>),
    #[doc = "Search by system"]
    #[code = "search-system"]
    SearchSystem(Option<Element>),
    #[doc = "Search by type"]
    #[code = "search-type"]
    SearchType(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyAttributeOperationTypes {
    fn default() -> Self {
        AccessPolicyAttributeOperationTypes::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyAttributeOperationTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "read" => Ok(AccessPolicyAttributeOperationTypes::Read(None)),
            "search-system" => Ok(AccessPolicyAttributeOperationTypes::SearchSystem(None)),
            "search-type" => Ok(AccessPolicyAttributeOperationTypes::SearchType(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyAttributeOperationTypes {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyAttributeOperationTypes::Read(_) => Some("read".to_string()),
            AccessPolicyAttributeOperationTypes::SearchSystem(_) => {
                Some("search-system".to_string())
            }
            AccessPolicyAttributeOperationTypes::SearchType(_) => Some("search-type".to_string()),
            AccessPolicyAttributeOperationTypes::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyAttributeOperationTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyAttributeOperationTypes::Read(Some(e)) => e.get_field(field),
                AccessPolicyAttributeOperationTypes::SearchSystem(Some(e)) => e.get_field(field),
                AccessPolicyAttributeOperationTypes::SearchType(Some(e)) => e.get_field(field),
                AccessPolicyAttributeOperationTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyAttributeOperationTypes::Read(Some(e)) => e.get_field_mut(field),
                AccessPolicyAttributeOperationTypes::SearchSystem(Some(e)) => {
                    e.get_field_mut(field)
                }
                AccessPolicyAttributeOperationTypes::SearchType(Some(e)) => e.get_field_mut(field),
                AccessPolicyAttributeOperationTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyv2Engine {
    #[doc = "Full Access"]
    #[code = "full-access"]
    FullAccess(Option<Element>),
    #[doc = "Rule Engine"]
    #[code = "rule-engine"]
    RuleEngine(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyv2Engine {
    fn default() -> Self {
        AccessPolicyv2Engine::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyv2Engine {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "full-access" => Ok(AccessPolicyv2Engine::FullAccess(None)),
            "rule-engine" => Ok(AccessPolicyv2Engine::RuleEngine(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyv2Engine {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyv2Engine::FullAccess(_) => Some("full-access".to_string()),
            AccessPolicyv2Engine::RuleEngine(_) => Some("rule-engine".to_string()),
            AccessPolicyv2Engine::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyv2Engine {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyv2Engine::FullAccess(Some(e)) => e.get_field(field),
                AccessPolicyv2Engine::RuleEngine(Some(e)) => e.get_field(field),
                AccessPolicyv2Engine::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyv2Engine::FullAccess(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2Engine::RuleEngine(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2Engine::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyFhirApiLevel {
    #[doc = "Instance"]
    #[code = "instance"]
    Instance(Option<Element>),
    #[doc = "System"]
    #[code = "system"]
    System(Option<Element>),
    #[doc = "Type"]
    #[code = "type"]
    Type(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyFhirApiLevel {
    fn default() -> Self {
        AccessPolicyFhirApiLevel::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyFhirApiLevel {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "instance" => Ok(AccessPolicyFhirApiLevel::Instance(None)),
            "system" => Ok(AccessPolicyFhirApiLevel::System(None)),
            "type" => Ok(AccessPolicyFhirApiLevel::Type(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyFhirApiLevel {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyFhirApiLevel::Instance(_) => Some("instance".to_string()),
            AccessPolicyFhirApiLevel::System(_) => Some("system".to_string()),
            AccessPolicyFhirApiLevel::Type(_) => Some("type".to_string()),
            AccessPolicyFhirApiLevel::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyFhirApiLevel {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyFhirApiLevel::Instance(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiLevel::System(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiLevel::Type(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiLevel::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyFhirApiLevel::Instance(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiLevel::System(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiLevel::Type(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiLevel::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyFhirApiMethods {
    #[doc = "Batch"]
    #[code = "batch"]
    Batch(Option<Element>),
    #[doc = "Capabilities"]
    #[code = "capabilities"]
    Capabilities(Option<Element>),
    #[doc = "create"]
    #[code = "create"]
    Create(Option<Element>),
    #[doc = "Delete"]
    #[code = "delete"]
    Delete(Option<Element>),
    #[doc = "History"]
    #[code = "history"]
    History(Option<Element>),
    #[doc = "Invoke"]
    #[code = "invoke"]
    Invoke(Option<Element>),
    #[doc = "Patch"]
    #[code = "patch"]
    Patch(Option<Element>),
    #[doc = "Read"]
    #[code = "read"]
    Read(Option<Element>),
    #[doc = "Search"]
    #[code = "search"]
    Search(Option<Element>),
    #[doc = "Transaction"]
    #[code = "transaction"]
    Transaction(Option<Element>),
    #[doc = "Update"]
    #[code = "update"]
    Update(Option<Element>),
    #[doc = "Version read"]
    #[code = "vread"]
    Vread(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyFhirApiMethods {
    fn default() -> Self {
        AccessPolicyFhirApiMethods::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyFhirApiMethods {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "batch" => Ok(AccessPolicyFhirApiMethods::Batch(None)),
            "capabilities" => Ok(AccessPolicyFhirApiMethods::Capabilities(None)),
            "create" => Ok(AccessPolicyFhirApiMethods::Create(None)),
            "delete" => Ok(AccessPolicyFhirApiMethods::Delete(None)),
            "history" => Ok(AccessPolicyFhirApiMethods::History(None)),
            "invoke" => Ok(AccessPolicyFhirApiMethods::Invoke(None)),
            "patch" => Ok(AccessPolicyFhirApiMethods::Patch(None)),
            "read" => Ok(AccessPolicyFhirApiMethods::Read(None)),
            "search" => Ok(AccessPolicyFhirApiMethods::Search(None)),
            "transaction" => Ok(AccessPolicyFhirApiMethods::Transaction(None)),
            "update" => Ok(AccessPolicyFhirApiMethods::Update(None)),
            "vread" => Ok(AccessPolicyFhirApiMethods::Vread(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyFhirApiMethods {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyFhirApiMethods::Batch(_) => Some("batch".to_string()),
            AccessPolicyFhirApiMethods::Capabilities(_) => Some("capabilities".to_string()),
            AccessPolicyFhirApiMethods::Create(_) => Some("create".to_string()),
            AccessPolicyFhirApiMethods::Delete(_) => Some("delete".to_string()),
            AccessPolicyFhirApiMethods::History(_) => Some("history".to_string()),
            AccessPolicyFhirApiMethods::Invoke(_) => Some("invoke".to_string()),
            AccessPolicyFhirApiMethods::Patch(_) => Some("patch".to_string()),
            AccessPolicyFhirApiMethods::Read(_) => Some("read".to_string()),
            AccessPolicyFhirApiMethods::Search(_) => Some("search".to_string()),
            AccessPolicyFhirApiMethods::Transaction(_) => Some("transaction".to_string()),
            AccessPolicyFhirApiMethods::Update(_) => Some("update".to_string()),
            AccessPolicyFhirApiMethods::Vread(_) => Some("vread".to_string()),
            AccessPolicyFhirApiMethods::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyFhirApiMethods {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyFhirApiMethods::Batch(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Capabilities(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Create(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Delete(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::History(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Invoke(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Patch(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Read(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Search(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Transaction(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Update(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Vread(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiMethods::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyFhirApiMethods::Batch(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Capabilities(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Create(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Delete(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::History(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Invoke(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Patch(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Read(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Search(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Transaction(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Update(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Vread(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiMethods::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyFhirApiParameter {
    #[doc = "Id"]
    #[code = "id"]
    Id(Option<Element>),
    #[doc = "Resource Type"]
    #[code = "resourceType"]
    ResourceType(Option<Element>),
    #[doc = "Version Id"]
    #[code = "versionId"]
    VersionId(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyFhirApiParameter {
    fn default() -> Self {
        AccessPolicyFhirApiParameter::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyFhirApiParameter {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "id" => Ok(AccessPolicyFhirApiParameter::Id(None)),
            "resourceType" => Ok(AccessPolicyFhirApiParameter::ResourceType(None)),
            "versionId" => Ok(AccessPolicyFhirApiParameter::VersionId(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyFhirApiParameter {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyFhirApiParameter::Id(_) => Some("id".to_string()),
            AccessPolicyFhirApiParameter::ResourceType(_) => Some("resourceType".to_string()),
            AccessPolicyFhirApiParameter::VersionId(_) => Some("versionId".to_string()),
            AccessPolicyFhirApiParameter::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyFhirApiParameter {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyFhirApiParameter::Id(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiParameter::ResourceType(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiParameter::VersionId(Some(e)) => e.get_field(field),
                AccessPolicyFhirApiParameter::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyFhirApiParameter::Id(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiParameter::ResourceType(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiParameter::VersionId(Some(e)) => e.get_field_mut(field),
                AccessPolicyFhirApiParameter::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyType {
    #[doc = "FHIR Rest"]
    #[code = "fhir-rest"]
    FhirRest(Option<Element>),
    #[doc = "Full Access"]
    #[code = "full-access"]
    FullAccess(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyType {
    fn default() -> Self {
        AccessPolicyType::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "fhir-rest" => Ok(AccessPolicyType::FhirRest(None)),
            "full-access" => Ok(AccessPolicyType::FullAccess(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyType {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyType::FhirRest(_) => Some("fhir-rest".to_string()),
            AccessPolicyType::FullAccess(_) => Some("full-access".to_string()),
            AccessPolicyType::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyType::FhirRest(Some(e)) => e.get_field(field),
                AccessPolicyType::FullAccess(Some(e)) => e.get_field(field),
                AccessPolicyType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyType::FhirRest(Some(e)) => e.get_field_mut(field),
                AccessPolicyType::FullAccess(Some(e)) => e.get_field_mut(field),
                AccessPolicyType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyv2CombineBehavior {
    #[doc = "All Of"]
    #[code = "all-of"]
    AllOf(Option<Element>),
    #[doc = "Any"]
    #[code = "any"]
    Any(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyv2CombineBehavior {
    fn default() -> Self {
        AccessPolicyv2CombineBehavior::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyv2CombineBehavior {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "all-of" => Ok(AccessPolicyv2CombineBehavior::AllOf(None)),
            "any" => Ok(AccessPolicyv2CombineBehavior::Any(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyv2CombineBehavior {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyv2CombineBehavior::AllOf(_) => Some("all-of".to_string()),
            AccessPolicyv2CombineBehavior::Any(_) => Some("any".to_string()),
            AccessPolicyv2CombineBehavior::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyv2CombineBehavior {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyv2CombineBehavior::AllOf(Some(e)) => e.get_field(field),
                AccessPolicyv2CombineBehavior::Any(Some(e)) => e.get_field(field),
                AccessPolicyv2CombineBehavior::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyv2CombineBehavior::AllOf(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2CombineBehavior::Any(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2CombineBehavior::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyv2RuleConditionOperator {
    #[doc = "!="]
    #[code = "!="]
    NotEqual(Option<Element>),
    #[doc = "="]
    #[code = "="]
    Equal(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyv2RuleConditionOperator {
    fn default() -> Self {
        AccessPolicyv2RuleConditionOperator::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyv2RuleConditionOperator {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "!=" => Ok(AccessPolicyv2RuleConditionOperator::NotEqual(None)),
            "=" => Ok(AccessPolicyv2RuleConditionOperator::Equal(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyv2RuleConditionOperator {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyv2RuleConditionOperator::NotEqual(_) => Some("!=".to_string()),
            AccessPolicyv2RuleConditionOperator::Equal(_) => Some("=".to_string()),
            AccessPolicyv2RuleConditionOperator::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyv2RuleConditionOperator {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyv2RuleConditionOperator::NotEqual(Some(e)) => e.get_field(field),
                AccessPolicyv2RuleConditionOperator::Equal(Some(e)) => e.get_field(field),
                AccessPolicyv2RuleConditionOperator::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyv2RuleConditionOperator::NotEqual(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2RuleConditionOperator::Equal(Some(e)) => e.get_field_mut(field),
                AccessPolicyv2RuleConditionOperator::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum AccessPolicyRuleEffect {
    #[doc = "Deny"]
    #[code = "deny"]
    Deny(Option<Element>),
    #[doc = "Permit"]
    #[code = "permit"]
    Permit(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for AccessPolicyRuleEffect {
    fn default() -> Self {
        AccessPolicyRuleEffect::Null(None)
    }
}
impl TryFrom<String> for AccessPolicyRuleEffect {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "deny" => Ok(AccessPolicyRuleEffect::Deny(None)),
            "permit" => Ok(AccessPolicyRuleEffect::Permit(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &AccessPolicyRuleEffect {
    fn into(self) -> Option<String> {
        match self {
            AccessPolicyRuleEffect::Deny(_) => Some("deny".to_string()),
            AccessPolicyRuleEffect::Permit(_) => Some("permit".to_string()),
            AccessPolicyRuleEffect::Null(_) => None,
        }
    }
}
impl MetaValue for AccessPolicyRuleEffect {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                AccessPolicyRuleEffect::Deny(Some(e)) => e.get_field(field),
                AccessPolicyRuleEffect::Permit(Some(e)) => e.get_field(field),
                AccessPolicyRuleEffect::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                AccessPolicyRuleEffect::Deny(Some(e)) => e.get_field_mut(field),
                AccessPolicyRuleEffect::Permit(Some(e)) => e.get_field_mut(field),
                AccessPolicyRuleEffect::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClientapplicationGrantType {
    #[doc = "Authorization Code"]
    #[code = "authorization_code"]
    Authorization_code(Option<Element>),
    #[doc = "Basic Authentication"]
    #[code = "basic_auth"]
    Basic_auth(Option<Element>),
    #[doc = "Client Credentials"]
    #[code = "client_credentials"]
    Client_credentials(Option<Element>),
    #[doc = "Refresh Token"]
    #[code = "refresh_token"]
    Refresh_token(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClientapplicationGrantType {
    fn default() -> Self {
        ClientapplicationGrantType::Null(None)
    }
}
impl TryFrom<String> for ClientapplicationGrantType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "authorization_code" => Ok(ClientapplicationGrantType::Authorization_code(None)),
            "basic_auth" => Ok(ClientapplicationGrantType::Basic_auth(None)),
            "client_credentials" => Ok(ClientapplicationGrantType::Client_credentials(None)),
            "refresh_token" => Ok(ClientapplicationGrantType::Refresh_token(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClientapplicationGrantType {
    fn into(self) -> Option<String> {
        match self {
            ClientapplicationGrantType::Authorization_code(_) => {
                Some("authorization_code".to_string())
            }
            ClientapplicationGrantType::Basic_auth(_) => Some("basic_auth".to_string()),
            ClientapplicationGrantType::Client_credentials(_) => {
                Some("client_credentials".to_string())
            }
            ClientapplicationGrantType::Refresh_token(_) => Some("refresh_token".to_string()),
            ClientapplicationGrantType::Null(_) => None,
        }
    }
}
impl MetaValue for ClientapplicationGrantType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClientapplicationGrantType::Authorization_code(Some(e)) => e.get_field(field),
                ClientapplicationGrantType::Basic_auth(Some(e)) => e.get_field(field),
                ClientapplicationGrantType::Client_credentials(Some(e)) => e.get_field(field),
                ClientapplicationGrantType::Refresh_token(Some(e)) => e.get_field(field),
                ClientapplicationGrantType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClientapplicationGrantType::Authorization_code(Some(e)) => e.get_field_mut(field),
                ClientapplicationGrantType::Basic_auth(Some(e)) => e.get_field_mut(field),
                ClientapplicationGrantType::Client_credentials(Some(e)) => e.get_field_mut(field),
                ClientapplicationGrantType::Refresh_token(Some(e)) => e.get_field_mut(field),
                ClientapplicationGrantType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum ClientapplicationResponseTypes {
    #[doc = "code"]
    #[code = "code"]
    Code(Option<Element>),
    #[doc = "token"]
    #[code = "token"]
    Token(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for ClientapplicationResponseTypes {
    fn default() -> Self {
        ClientapplicationResponseTypes::Null(None)
    }
}
impl TryFrom<String> for ClientapplicationResponseTypes {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "code" => Ok(ClientapplicationResponseTypes::Code(None)),
            "token" => Ok(ClientapplicationResponseTypes::Token(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &ClientapplicationResponseTypes {
    fn into(self) -> Option<String> {
        match self {
            ClientapplicationResponseTypes::Code(_) => Some("code".to_string()),
            ClientapplicationResponseTypes::Token(_) => Some("token".to_string()),
            ClientapplicationResponseTypes::Null(_) => None,
        }
    }
}
impl MetaValue for ClientapplicationResponseTypes {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                ClientapplicationResponseTypes::Code(Some(e)) => e.get_field(field),
                ClientapplicationResponseTypes::Token(Some(e)) => e.get_field(field),
                ClientapplicationResponseTypes::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                ClientapplicationResponseTypes::Code(Some(e)) => e.get_field_mut(field),
                ClientapplicationResponseTypes::Token(Some(e)) => e.get_field_mut(field),
                ClientapplicationResponseTypes::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentityProviderAccessType {
    #[doc = "oidc"]
    #[code = "oidc"]
    Oidc(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentityProviderAccessType {
    fn default() -> Self {
        IdentityProviderAccessType::Null(None)
    }
}
impl TryFrom<String> for IdentityProviderAccessType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "oidc" => Ok(IdentityProviderAccessType::Oidc(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentityProviderAccessType {
    fn into(self) -> Option<String> {
        match self {
            IdentityProviderAccessType::Oidc(_) => Some("oidc".to_string()),
            IdentityProviderAccessType::Null(_) => None,
        }
    }
}
impl MetaValue for IdentityProviderAccessType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentityProviderAccessType::Oidc(Some(e)) => e.get_field(field),
                IdentityProviderAccessType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentityProviderAccessType::Oidc(Some(e)) => e.get_field_mut(field),
                IdentityProviderAccessType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentityProviderPkceChallengeMethod {
    #[doc = "S256"]
    #[code = "S256"]
    S256(Option<Element>),
    #[doc = "plain"]
    #[code = "plain"]
    Plain(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentityProviderPkceChallengeMethod {
    fn default() -> Self {
        IdentityProviderPkceChallengeMethod::Null(None)
    }
}
impl TryFrom<String> for IdentityProviderPkceChallengeMethod {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "S256" => Ok(IdentityProviderPkceChallengeMethod::S256(None)),
            "plain" => Ok(IdentityProviderPkceChallengeMethod::Plain(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentityProviderPkceChallengeMethod {
    fn into(self) -> Option<String> {
        match self {
            IdentityProviderPkceChallengeMethod::S256(_) => Some("S256".to_string()),
            IdentityProviderPkceChallengeMethod::Plain(_) => Some("plain".to_string()),
            IdentityProviderPkceChallengeMethod::Null(_) => None,
        }
    }
}
impl MetaValue for IdentityProviderPkceChallengeMethod {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentityProviderPkceChallengeMethod::S256(Some(e)) => e.get_field(field),
                IdentityProviderPkceChallengeMethod::Plain(Some(e)) => e.get_field(field),
                IdentityProviderPkceChallengeMethod::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentityProviderPkceChallengeMethod::S256(Some(e)) => e.get_field_mut(field),
                IdentityProviderPkceChallengeMethod::Plain(Some(e)) => e.get_field_mut(field),
                IdentityProviderPkceChallengeMethod::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum IdentityProviderStatus {
    #[doc = "active"]
    #[code = "active"]
    Active(Option<Element>),
    #[doc = "disabled"]
    #[code = "disabled"]
    Disabled(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for IdentityProviderStatus {
    fn default() -> Self {
        IdentityProviderStatus::Null(None)
    }
}
impl TryFrom<String> for IdentityProviderStatus {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "active" => Ok(IdentityProviderStatus::Active(None)),
            "disabled" => Ok(IdentityProviderStatus::Disabled(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &IdentityProviderStatus {
    fn into(self) -> Option<String> {
        match self {
            IdentityProviderStatus::Active(_) => Some("active".to_string()),
            IdentityProviderStatus::Disabled(_) => Some("disabled".to_string()),
            IdentityProviderStatus::Null(_) => None,
        }
    }
}
impl MetaValue for IdentityProviderStatus {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                IdentityProviderStatus::Active(Some(e)) => e.get_field(field),
                IdentityProviderStatus::Disabled(Some(e)) => e.get_field(field),
                IdentityProviderStatus::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                IdentityProviderStatus::Active(Some(e)) => e.get_field_mut(field),
                IdentityProviderStatus::Disabled(Some(e)) => e.get_field_mut(field),
                IdentityProviderStatus::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MembershipRole {
    #[doc = "Super Admin"]
    #[code = "admin"]
    Admin(Option<Element>),
    #[doc = "Member"]
    #[code = "member"]
    Member(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MembershipRole {
    fn default() -> Self {
        MembershipRole::Null(None)
    }
}
impl TryFrom<String> for MembershipRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "admin" => Ok(MembershipRole::Admin(None)),
            "member" => Ok(MembershipRole::Member(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MembershipRole {
    fn into(self) -> Option<String> {
        match self {
            MembershipRole::Admin(_) => Some("admin".to_string()),
            MembershipRole::Member(_) => Some("member".to_string()),
            MembershipRole::Null(_) => None,
        }
    }
}
impl MetaValue for MembershipRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MembershipRole::Admin(Some(e)) => e.get_field(field),
                MembershipRole::Member(Some(e)) => e.get_field(field),
                MembershipRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MembershipRole::Admin(Some(e)) => e.get_field_mut(field),
                MembershipRole::Member(Some(e)) => e.get_field_mut(field),
                MembershipRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum MessageBrokerType {
    #[doc = "Kafka"]
    #[code = "kafka"]
    Kafka(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for MessageBrokerType {
    fn default() -> Self {
        MessageBrokerType::Null(None)
    }
}
impl TryFrom<String> for MessageBrokerType {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "kafka" => Ok(MessageBrokerType::Kafka(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &MessageBrokerType {
    fn into(self) -> Option<String> {
        match self {
            MessageBrokerType::Kafka(_) => Some("kafka".to_string()),
            MessageBrokerType::Null(_) => None,
        }
    }
}
impl MetaValue for MessageBrokerType {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                MessageBrokerType::Kafka(Some(e)) => e.get_field(field),
                MessageBrokerType::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                MessageBrokerType::Kafka(Some(e)) => e.get_field_mut(field),
                MessageBrokerType::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum SupportedFhirVersion {
    #[doc = "R4"]
    #[code = "r4"]
    R4(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for SupportedFhirVersion {
    fn default() -> Self {
        SupportedFhirVersion::Null(None)
    }
}
impl TryFrom<String> for SupportedFhirVersion {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "r4" => Ok(SupportedFhirVersion::R4(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &SupportedFhirVersion {
    fn into(self) -> Option<String> {
        match self {
            SupportedFhirVersion::R4(_) => Some("r4".to_string()),
            SupportedFhirVersion::Null(_) => None,
        }
    }
}
impl MetaValue for SupportedFhirVersion {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                SupportedFhirVersion::R4(Some(e)) => e.get_field(field),
                SupportedFhirVersion::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                SupportedFhirVersion::R4(Some(e)) => e.get_field_mut(field),
                SupportedFhirVersion::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}
#[derive(Debug, Clone, FHIRJSONSerialize, FHIRJSONDeserialize)]
#[fhir_serialize_type = "valueset"]
pub enum UserRole {
    #[doc = "Super Admin"]
    #[code = "admin"]
    Admin(Option<Element>),
    #[doc = "Member"]
    #[code = "member"]
    Member(Option<Element>),
    #[doc = "Owner"]
    #[code = "owner"]
    Owner(Option<Element>),
    #[doc = "If value is missing and just the element is present."]
    Null(Option<Element>),
}
impl Default for UserRole {
    fn default() -> Self {
        UserRole::Null(None)
    }
}
impl TryFrom<String> for UserRole {
    type Error = String;
    fn try_from(value: String) -> Result<Self, String> {
        match value.as_str() {
            "admin" => Ok(UserRole::Admin(None)),
            "member" => Ok(UserRole::Member(None)),
            "owner" => Ok(UserRole::Owner(None)),
            _ => Err(format!("Unknown code '{}'", value)),
        }
    }
}
impl Into<Option<String>> for &UserRole {
    fn into(self) -> Option<String> {
        match self {
            UserRole::Admin(_) => Some("admin".to_string()),
            UserRole::Member(_) => Some("member".to_string()),
            UserRole::Owner(_) => Some("owner".to_string()),
            UserRole::Null(_) => None,
        }
    }
}
impl MetaValue for UserRole {
    fn fields(&self) -> Vec<&'static str> {
        vec!["value", "id", "extension"]
    }
    fn get_field<'a>(&'a self, field: &str) -> Option<&'a dyn MetaValue> {
        match field {
            "value" => {
                let code_value: Option<String> = self.into();
                if let Some(code_value) = code_value {
                    let v = Box::new(code_value);
                    let code_ref: &'a String = Box::leak(v);
                    Some(code_ref)
                } else {
                    None
                }
            }
            _ => match self {
                UserRole::Admin(Some(e)) => e.get_field(field),
                UserRole::Member(Some(e)) => e.get_field(field),
                UserRole::Owner(Some(e)) => e.get_field(field),
                UserRole::Null(Some(e)) => e.get_field(field),
                _ => None,
            },
        }
    }
    fn get_field_mut<'a>(&'a mut self, field: &str) -> Option<&'a mut dyn MetaValue> {
        match field {
            "value" => None,
            _ => match self {
                UserRole::Admin(Some(e)) => e.get_field_mut(field),
                UserRole::Member(Some(e)) => e.get_field_mut(field),
                UserRole::Owner(Some(e)) => e.get_field_mut(field),
                UserRole::Null(Some(e)) => e.get_field_mut(field),
                _ => None,
            },
        }
    }
    fn get_index<'a>(&'a self, _index: usize) -> Option<&'a dyn MetaValue> {
        None
    }
    fn get_index_mut<'a>(&'a mut self, _index: usize) -> Option<&'a mut dyn MetaValue> {
        None
    }
    fn flatten(&self) -> Vec<&dyn MetaValue> {
        vec![self]
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn typename(&self) -> &'static str {
        "FHIRCode"
    }
}

// --- Generated file with edits ---
// Generated code had duplicate structs that required manual deletion.
// For now leaving code in place to avoid regenerating until fixed upstream.
//
// Allowing irrefultable_let_patterns other clippy lints were auto generated.
#![allow(irrefutable_let_patterns)]
#![allow(clippy::redundant_closure_call)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::clone_on_copy)]

#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "Optional annotations for the client. The client can use annotations to inform how objects are used or displayed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Optional annotations for the client. The client can use annotations to inform how objects are used or displayed\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"audience\": {"]
#[doc = "      \"description\": \"Describes who the intended audience of this object or data is.\\n\\nIt can include multiple entries to indicate content useful for multiple audiences (e.g., `[\\\"user\\\", \\\"assistant\\\"]`).\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Role\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"lastModified\": {"]
#[doc = "      \"description\": \"The moment the resource was last modified, as an ISO 8601 formatted string.\\n\\nShould be an ISO 8601 formatted string (e.g., \\\"2025-01-12T15:00:58Z\\\").\\n\\nExamples: last activity timestamp in an open file, timestamp when the resource\\nwas attached, etc.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"priority\": {"]
#[doc = "      \"description\": \"Describes how important this data is for operating the server.\\n\\nA value of 1 means \\\"most important,\\\" and indicates that the data is\\neffectively required, while 0 means \\\"least important,\\\" and indicates that\\nthe data is entirely optional.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"maximum\": 1.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Annotations {
    #[doc = "Describes who the intended audience of this object or data is.\n\nIt can include multiple entries to indicate content useful for multiple audiences (e.g., `[\"user\", \"assistant\"]`)."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub audience: ::std::vec::Vec<Role>,
    #[doc = "The moment the resource was last modified, as an ISO 8601 formatted string.\n\nShould be an ISO 8601 formatted string (e.g., \"2025-01-12T15:00:58Z\").\n\nExamples: last activity timestamp in an open file, timestamp when the resource\nwas attached, etc."]
    #[serde(
        rename = "lastModified",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub last_modified: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub priority: ::std::option::Option<f64>,
}
impl ::std::convert::From<&Annotations> for Annotations {
    fn from(value: &Annotations) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Annotations {
    fn default() -> Self {
        Self {
            audience: Default::default(),
            last_modified: Default::default(),
            priority: Default::default(),
        }
    }
}
impl Annotations {
    pub fn builder() -> builder::Annotations {
        Default::default()
    }
}
#[doc = "Audio provided to or from an LLM."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Audio provided to or from an LLM.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data\","]
#[doc = "    \"mimeType\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"The base64-encoded audio data.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"byte\""]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of the audio. Different providers may support different audio types.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"audio\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AudioContent {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[doc = "The base64-encoded audio data."]
    pub data: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<AudioContentMeta>,
    #[doc = "The MIME type of the audio. Different providers may support different audio types."]
    #[serde(rename = "mimeType")]
    pub mime_type: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&AudioContent> for AudioContent {
    fn from(value: &AudioContent) -> Self {
        value.clone()
    }
}
impl AudioContent {
    pub fn builder() -> builder::AudioContent {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AudioContentMeta {}
impl ::std::convert::From<&AudioContentMeta> for AudioContentMeta {
    fn from(value: &AudioContentMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AudioContentMeta {
    fn default() -> Self {
        Self {}
    }
}
impl AudioContentMeta {
    pub fn builder() -> builder::AudioContentMeta {
        Default::default()
    }
}
#[doc = "Base interface for metadata with name (identifier) and title (display name) properties."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Base interface for metadata with name (identifier) and title (display name) properties.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BaseMetadata {
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BaseMetadata> for BaseMetadata {
    fn from(value: &BaseMetadata) -> Self {
        value.clone()
    }
}
impl BaseMetadata {
    pub fn builder() -> builder::BaseMetadata {
        Default::default()
    }
}
#[doc = "`BlobResourceContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"blob\","]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"blob\": {"]
#[doc = "      \"description\": \"A base64-encoded string representing the binary data of the item.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"byte\""]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of this resource, if known.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of this resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BlobResourceContents {
    #[doc = "A base64-encoded string representing the binary data of the item."]
    pub blob: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<BlobResourceContentsMeta>,
    #[doc = "The MIME type of this resource, if known."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "The URI of this resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&BlobResourceContents> for BlobResourceContents {
    fn from(value: &BlobResourceContents) -> Self {
        value.clone()
    }
}
impl BlobResourceContents {
    pub fn builder() -> builder::BlobResourceContents {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlobResourceContentsMeta {}
impl ::std::convert::From<&BlobResourceContentsMeta> for BlobResourceContentsMeta {
    fn from(value: &BlobResourceContentsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BlobResourceContentsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl BlobResourceContentsMeta {
    pub fn builder() -> builder::BlobResourceContentsMeta {
        Default::default()
    }
}
#[doc = "`BooleanSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BooleanSchema {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&BooleanSchema> for BooleanSchema {
    fn from(value: &BooleanSchema) -> Self {
        value.clone()
    }
}
impl BooleanSchema {
    pub fn builder() -> builder::BooleanSchema {
        Default::default()
    }
}
#[doc = "Used by the client to invoke a tool provided by the server."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Used by the client to invoke a tool provided by the server.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tools/call\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/CallToolRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CallToolRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: CallToolRequestParams,
}
impl ::std::convert::From<&CallToolRequest> for CallToolRequest {
    fn from(value: &CallToolRequest) -> Self {
        value.clone()
    }
}
impl CallToolRequest {
    pub fn builder() -> builder::CallToolRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `tools/call` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `tools/call` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"description\": \"Arguments to use for the tool call.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting task-augmented execution for this request.\\nThe request will return a CreateTaskResult immediately, and the actual result can be\\nretrieved later via tasks/result.\\n\\nTask augmentation is subject to capability negotiation - receivers MUST declare support\\nfor task augmentation of specific request types in their capabilities.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskMetadata\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CallToolRequestParams {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub arguments: ::std::option::Option<CallToolRequestParamsArguments>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CallToolRequestParamsMeta>,
    #[doc = "The name of the tool."]
    pub name: ::std::string::String,
    #[doc = "If specified, the caller is requesting task-augmented execution for this request.\nThe request will return a CreateTaskResult immediately, and the actual result can be\nretrieved later via tasks/result.\n\nTask augmentation is subject to capability negotiation - receivers MUST declare support\nfor task augmentation of specific request types in their capabilities."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub task: ::std::option::Option<TaskMetadata>,
}
impl ::std::convert::From<&CallToolRequestParams> for CallToolRequestParams {
    fn from(value: &CallToolRequestParams) -> Self {
        value.clone()
    }
}
impl CallToolRequestParams {
    pub fn builder() -> builder::CallToolRequestParams {
        Default::default()
    }
}
#[doc = "Arguments to use for the tool call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Arguments to use for the tool call.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CallToolRequestParamsArguments {}
impl ::std::convert::From<&CallToolRequestParamsArguments> for CallToolRequestParamsArguments {
    fn from(value: &CallToolRequestParamsArguments) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CallToolRequestParamsArguments {
    fn default() -> Self {
        Self {}
    }
}
impl CallToolRequestParamsArguments {
    pub fn builder() -> builder::CallToolRequestParamsArguments {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CallToolRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&CallToolRequestParamsMeta> for CallToolRequestParamsMeta {
    fn from(value: &CallToolRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CallToolRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl CallToolRequestParamsMeta {
    pub fn builder() -> builder::CallToolRequestParamsMeta {
        Default::default()
    }
}
#[doc = "The server's response to a tool call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a tool call.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"content\": {"]
#[doc = "      \"description\": \"A list of content objects that represent the unstructured result of the tool call.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/ContentBlock\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"isError\": {"]
#[doc = "      \"description\": \"Whether the tool call ended in an error.\\n\\nIf not set, this is assumed to be false (the call was successful).\\n\\nAny errors that originate from the tool SHOULD be reported inside the result\\nobject, with `isError` set to true, _not_ as an MCP protocol-level error\\nresponse. Otherwise, the LLM would not be able to see that an error occurred\\nand self-correct.\\n\\nHowever, any errors in _finding_ the tool, an error indicating that the\\nserver does not support tool calls, or any other exceptional conditions,\\nshould be reported as an MCP error response.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"structuredContent\": {"]
#[doc = "      \"description\": \"An optional JSON object that represents the structured result of the tool call.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CallToolResult {
    #[doc = "A list of content objects that represent the unstructured result of the tool call."]
    pub content: ::std::vec::Vec<ContentBlock>,
    #[doc = "Whether the tool call ended in an error.\n\nIf not set, this is assumed to be false (the call was successful).\n\nAny errors that originate from the tool SHOULD be reported inside the result\nobject, with `isError` set to true, _not_ as an MCP protocol-level error\nresponse. Otherwise, the LLM would not be able to see that an error occurred\nand self-correct.\n\nHowever, any errors in _finding_ the tool, an error indicating that the\nserver does not support tool calls, or any other exceptional conditions,\nshould be reported as an MCP error response."]
    #[serde(
        rename = "isError",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_error: ::std::option::Option<bool>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CallToolResultMeta>,
    #[serde(
        rename = "structuredContent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub structured_content: ::std::option::Option<CallToolResultStructuredContent>,
}
impl ::std::convert::From<&CallToolResult> for CallToolResult {
    fn from(value: &CallToolResult) -> Self {
        value.clone()
    }
}
impl CallToolResult {
    pub fn builder() -> builder::CallToolResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CallToolResultMeta {}
impl ::std::convert::From<&CallToolResultMeta> for CallToolResultMeta {
    fn from(value: &CallToolResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CallToolResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl CallToolResultMeta {
    pub fn builder() -> builder::CallToolResultMeta {
        Default::default()
    }
}
#[doc = "An optional JSON object that represents the structured result of the tool call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional JSON object that represents the structured result of the tool call.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CallToolResultStructuredContent {}
impl ::std::convert::From<&CallToolResultStructuredContent> for CallToolResultStructuredContent {
    fn from(value: &CallToolResultStructuredContent) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CallToolResultStructuredContent {
    fn default() -> Self {
        Self {}
    }
}
impl CallToolResultStructuredContent {
    pub fn builder() -> builder::CallToolResultStructuredContent {
        Default::default()
    }
}
#[doc = "A request to cancel a task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request to cancel a task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tasks/cancel\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"taskId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"taskId\": {"]
#[doc = "          \"description\": \"The task identifier to cancel.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelTaskRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: CancelTaskRequestParams,
}
impl ::std::convert::From<&CancelTaskRequest> for CancelTaskRequest {
    fn from(value: &CancelTaskRequest) -> Self {
        value.clone()
    }
}
impl CancelTaskRequest {
    pub fn builder() -> builder::CancelTaskRequest {
        Default::default()
    }
}
#[doc = "`CancelTaskRequestParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"taskId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"taskId\": {"]
#[doc = "      \"description\": \"The task identifier to cancel.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelTaskRequestParams {
    #[doc = "The task identifier to cancel."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
}
impl ::std::convert::From<&CancelTaskRequestParams> for CancelTaskRequestParams {
    fn from(value: &CancelTaskRequestParams) -> Self {
        value.clone()
    }
}
impl CancelTaskRequestParams {
    pub fn builder() -> builder::CancelTaskRequestParams {
        Default::default()
    }
}
#[doc = "`CancelTaskResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The response to a tasks/cancel request.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Result\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Task\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum CancelTaskResult {}
impl ::std::convert::From<&Self> for CancelTaskResult {
    fn from(value: &CancelTaskResult) -> Self {
        value.clone()
    }
}
#[doc = "This notification can be sent by either side to indicate that it is cancelling a previously-issued request.\n\nThe request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\n\nThis notification indicates that the result will be unused, so any associated processing SHOULD cease.\n\nA client MUST NOT attempt to cancel its `initialize` request.\n\nFor task cancellation, use the `tasks/cancel` request instead of this notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This notification can be sent by either side to indicate that it is cancelling a previously-issued request.\\n\\nThe request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\\n\\nThis notification indicates that the result will be unused, so any associated processing SHOULD cease.\\n\\nA client MUST NOT attempt to cancel its `initialize` request.\\n\\nFor task cancellation, use the `tasks/cancel` request instead of this notification.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/cancelled\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/CancelledNotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelledNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: CancelledNotificationParams,
}
impl ::std::convert::From<&CancelledNotification> for CancelledNotification {
    fn from(value: &CancelledNotification) -> Self {
        value.clone()
    }
}
impl CancelledNotification {
    pub fn builder() -> builder::CancelledNotification {
        Default::default()
    }
}
#[doc = "Parameters for a `notifications/cancelled` notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `notifications/cancelled` notification.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"description\": \"An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"requestId\": {"]
#[doc = "      \"description\": \"The ID of the request to cancel.\\n\\nThis MUST correspond to the ID of a request previously issued in the same direction.\\nThis MUST be provided for cancelling non-task requests.\\nThis MUST NOT be used for cancelling tasks (use the `tasks/cancel` request instead).\","]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CancelledNotificationParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CancelledNotificationParamsMeta>,
    #[doc = "An optional string describing the reason for the cancellation. This MAY be logged or presented to the user."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub reason: ::std::option::Option<::std::string::String>,
    #[doc = "The ID of the request to cancel.\n\nThis MUST correspond to the ID of a request previously issued in the same direction.\nThis MUST be provided for cancelling non-task requests.\nThis MUST NOT be used for cancelling tasks (use the `tasks/cancel` request instead)."]
    #[serde(
        rename = "requestId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub request_id: ::std::option::Option<RequestId>,
}
impl ::std::convert::From<&CancelledNotificationParams> for CancelledNotificationParams {
    fn from(value: &CancelledNotificationParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CancelledNotificationParams {
    fn default() -> Self {
        Self {
            meta: Default::default(),
            reason: Default::default(),
            request_id: Default::default(),
        }
    }
}
impl CancelledNotificationParams {
    pub fn builder() -> builder::CancelledNotificationParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CancelledNotificationParamsMeta {}
impl ::std::convert::From<&CancelledNotificationParamsMeta> for CancelledNotificationParamsMeta {
    fn from(value: &CancelledNotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CancelledNotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl CancelledNotificationParamsMeta {
    pub fn builder() -> builder::CancelledNotificationParamsMeta {
        Default::default()
    }
}
#[doc = "Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"elicitation\": {"]
#[doc = "      \"description\": \"Present if the client supports elicitation from the server.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"form\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"experimental\": {"]
#[doc = "      \"description\": \"Experimental, non-standard capabilities that the client supports.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"additionalProperties\": true"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"roots\": {"]
#[doc = "      \"description\": \"Present if the client supports listing roots.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"listChanged\": {"]
#[doc = "          \"description\": \"Whether the client supports notifications for changes to the roots list.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"sampling\": {"]
#[doc = "      \"description\": \"Present if the client supports sampling from an LLM.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"context\": {"]
#[doc = "          \"description\": \"Whether the client supports context inclusion via includeContext parameter.\\nIf not declared, servers SHOULD only use `includeContext: \\\"none\\\"` (or omit it).\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"tools\": {"]
#[doc = "          \"description\": \"Whether the client supports tool use via tools and toolChoice parameters.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"tasks\": {"]
#[doc = "      \"description\": \"Present if the client supports task-augmented requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"cancel\": {"]
#[doc = "          \"description\": \"Whether this client supports tasks/cancel.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"list\": {"]
#[doc = "          \"description\": \"Whether this client supports tasks/list.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"requests\": {"]
#[doc = "          \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"elicitation\": {"]
#[doc = "              \"description\": \"Task support for elicitation-related requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"create\": {"]
#[doc = "                  \"description\": \"Whether the client supports task-augmented elicitation/create requests.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"sampling\": {"]
#[doc = "              \"description\": \"Task support for sampling-related requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"createMessage\": {"]
#[doc = "                  \"description\": \"Whether the client supports task-augmented sampling/createMessage requests.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilities {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub elicitation: ::std::option::Option<ClientCapabilitiesElicitation>,
    #[doc = "Experimental, non-standard capabilities that the client supports."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub experimental: ::std::collections::HashMap<
        ::std::string::String,
        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub roots: ::std::option::Option<ClientCapabilitiesRoots>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sampling: ::std::option::Option<ClientCapabilitiesSampling>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tasks: ::std::option::Option<ClientCapabilitiesTasks>,
}
impl ::std::convert::From<&ClientCapabilities> for ClientCapabilities {
    fn from(value: &ClientCapabilities) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilities {
    fn default() -> Self {
        Self {
            elicitation: Default::default(),
            experimental: Default::default(),
            roots: Default::default(),
            sampling: Default::default(),
            tasks: Default::default(),
        }
    }
}
impl ClientCapabilities {
    pub fn builder() -> builder::ClientCapabilities {
        Default::default()
    }
}
#[doc = "Present if the client supports elicitation from the server."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the client supports elicitation from the server.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"form\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesElicitation {
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub form: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub url: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&ClientCapabilitiesElicitation> for ClientCapabilitiesElicitation {
    fn from(value: &ClientCapabilitiesElicitation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesElicitation {
    fn default() -> Self {
        Self {
            form: Default::default(),
            url: Default::default(),
        }
    }
}
impl ClientCapabilitiesElicitation {
    pub fn builder() -> builder::ClientCapabilitiesElicitation {
        Default::default()
    }
}
#[doc = "Present if the client supports listing roots."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the client supports listing roots.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"listChanged\": {"]
#[doc = "      \"description\": \"Whether the client supports notifications for changes to the roots list.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesRoots {
    #[doc = "Whether the client supports notifications for changes to the roots list."]
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub list_changed: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ClientCapabilitiesRoots> for ClientCapabilitiesRoots {
    fn from(value: &ClientCapabilitiesRoots) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesRoots {
    fn default() -> Self {
        Self {
            list_changed: Default::default(),
        }
    }
}
impl ClientCapabilitiesRoots {
    pub fn builder() -> builder::ClientCapabilitiesRoots {
        Default::default()
    }
}
#[doc = "Present if the client supports sampling from an LLM."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the client supports sampling from an LLM.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"context\": {"]
#[doc = "      \"description\": \"Whether the client supports context inclusion via includeContext parameter.\\nIf not declared, servers SHOULD only use `includeContext: \\\"none\\\"` (or omit it).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"tools\": {"]
#[doc = "      \"description\": \"Whether the client supports tool use via tools and toolChoice parameters.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesSampling {
    #[doc = "Whether the client supports context inclusion via includeContext parameter.\nIf not declared, servers SHOULD only use `includeContext: \"none\"` (or omit it)."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub context: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Whether the client supports tool use via tools and toolChoice parameters."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub tools: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&ClientCapabilitiesSampling> for ClientCapabilitiesSampling {
    fn from(value: &ClientCapabilitiesSampling) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesSampling {
    fn default() -> Self {
        Self {
            context: Default::default(),
            tools: Default::default(),
        }
    }
}
impl ClientCapabilitiesSampling {
    pub fn builder() -> builder::ClientCapabilitiesSampling {
        Default::default()
    }
}
#[doc = "Present if the client supports task-augmented requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the client supports task-augmented requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"cancel\": {"]
#[doc = "      \"description\": \"Whether this client supports tasks/cancel.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"list\": {"]
#[doc = "      \"description\": \"Whether this client supports tasks/list.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"requests\": {"]
#[doc = "      \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"elicitation\": {"]
#[doc = "          \"description\": \"Task support for elicitation-related requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"create\": {"]
#[doc = "              \"description\": \"Whether the client supports task-augmented elicitation/create requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"sampling\": {"]
#[doc = "          \"description\": \"Task support for sampling-related requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"createMessage\": {"]
#[doc = "              \"description\": \"Whether the client supports task-augmented sampling/createMessage requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesTasks {
    #[doc = "Whether this client supports tasks/cancel."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub cancel: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Whether this client supports tasks/list."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub list: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requests: ::std::option::Option<ClientCapabilitiesTasksRequests>,
}
impl ::std::convert::From<&ClientCapabilitiesTasks> for ClientCapabilitiesTasks {
    fn from(value: &ClientCapabilitiesTasks) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesTasks {
    fn default() -> Self {
        Self {
            cancel: Default::default(),
            list: Default::default(),
            requests: Default::default(),
        }
    }
}
impl ClientCapabilitiesTasks {
    pub fn builder() -> builder::ClientCapabilitiesTasks {
        Default::default()
    }
}
#[doc = "Specifies which request types can be augmented with tasks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"elicitation\": {"]
#[doc = "      \"description\": \"Task support for elicitation-related requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"create\": {"]
#[doc = "          \"description\": \"Whether the client supports task-augmented elicitation/create requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"sampling\": {"]
#[doc = "      \"description\": \"Task support for sampling-related requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"createMessage\": {"]
#[doc = "          \"description\": \"Whether the client supports task-augmented sampling/createMessage requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesTasksRequests {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub elicitation: ::std::option::Option<ClientCapabilitiesTasksRequestsElicitation>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sampling: ::std::option::Option<ClientCapabilitiesTasksRequestsSampling>,
}
impl ::std::convert::From<&ClientCapabilitiesTasksRequests> for ClientCapabilitiesTasksRequests {
    fn from(value: &ClientCapabilitiesTasksRequests) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesTasksRequests {
    fn default() -> Self {
        Self {
            elicitation: Default::default(),
            sampling: Default::default(),
        }
    }
}
impl ClientCapabilitiesTasksRequests {
    pub fn builder() -> builder::ClientCapabilitiesTasksRequests {
        Default::default()
    }
}
#[doc = "Task support for elicitation-related requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Task support for elicitation-related requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"create\": {"]
#[doc = "      \"description\": \"Whether the client supports task-augmented elicitation/create requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesTasksRequestsElicitation {
    #[doc = "Whether the client supports task-augmented elicitation/create requests."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub create: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&ClientCapabilitiesTasksRequestsElicitation>
    for ClientCapabilitiesTasksRequestsElicitation
{
    fn from(value: &ClientCapabilitiesTasksRequestsElicitation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesTasksRequestsElicitation {
    fn default() -> Self {
        Self {
            create: Default::default(),
        }
    }
}
impl ClientCapabilitiesTasksRequestsElicitation {
    pub fn builder() -> builder::ClientCapabilitiesTasksRequestsElicitation {
        Default::default()
    }
}
#[doc = "Task support for sampling-related requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Task support for sampling-related requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"createMessage\": {"]
#[doc = "      \"description\": \"Whether the client supports task-augmented sampling/createMessage requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientCapabilitiesTasksRequestsSampling {
    #[doc = "Whether the client supports task-augmented sampling/createMessage requests."]
    #[serde(
        rename = "createMessage",
        default,
        skip_serializing_if = "::serde_json::Map::is_empty"
    )]
    pub create_message: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&ClientCapabilitiesTasksRequestsSampling>
    for ClientCapabilitiesTasksRequestsSampling
{
    fn from(value: &ClientCapabilitiesTasksRequestsSampling) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientCapabilitiesTasksRequestsSampling {
    fn default() -> Self {
        Self {
            create_message: Default::default(),
        }
    }
}
impl ClientCapabilitiesTasksRequestsSampling {
    pub fn builder() -> builder::ClientCapabilitiesTasksRequestsSampling {
        Default::default()
    }
}
#[doc = "`ClientNotification`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CancelledNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/InitializedNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ProgressNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TaskStatusNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/RootsListChangedNotification\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ClientNotification {
    CancelledNotification(CancelledNotification),
    InitializedNotification(InitializedNotification),
    ProgressNotification(ProgressNotification),
    TaskStatusNotification(TaskStatusNotification),
    RootsListChangedNotification(RootsListChangedNotification),
}
impl ::std::convert::From<&Self> for ClientNotification {
    fn from(value: &ClientNotification) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CancelledNotification> for ClientNotification {
    fn from(value: CancelledNotification) -> Self {
        Self::CancelledNotification(value)
    }
}
impl ::std::convert::From<InitializedNotification> for ClientNotification {
    fn from(value: InitializedNotification) -> Self {
        Self::InitializedNotification(value)
    }
}
impl ::std::convert::From<ProgressNotification> for ClientNotification {
    fn from(value: ProgressNotification) -> Self {
        Self::ProgressNotification(value)
    }
}
impl ::std::convert::From<TaskStatusNotification> for ClientNotification {
    fn from(value: TaskStatusNotification) -> Self {
        Self::TaskStatusNotification(value)
    }
}
impl ::std::convert::From<RootsListChangedNotification> for ClientNotification {
    fn from(value: RootsListChangedNotification) -> Self {
        Self::RootsListChangedNotification(value)
    }
}
#[doc = "`ClientRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/InitializeRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/PingRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListResourcesRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListResourceTemplatesRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ReadResourceRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/SubscribeRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UnsubscribeRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListPromptsRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetPromptRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListToolsRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CallToolRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskPayloadRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CancelTaskRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListTasksRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/SetLevelRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CompleteRequest\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ClientRequest {
    InitializeRequest(InitializeRequest),
    PingRequest(PingRequest),
    ListResourcesRequest(ListResourcesRequest),
    ListResourceTemplatesRequest(ListResourceTemplatesRequest),
    ReadResourceRequest(ReadResourceRequest),
    SubscribeRequest(SubscribeRequest),
    UnsubscribeRequest(UnsubscribeRequest),
    ListPromptsRequest(ListPromptsRequest),
    GetPromptRequest(GetPromptRequest),
    ListToolsRequest(ListToolsRequest),
    CallToolRequest(CallToolRequest),
    GetTaskRequest(GetTaskRequest),
    GetTaskPayloadRequest(GetTaskPayloadRequest),
    CancelTaskRequest(CancelTaskRequest),
    ListTasksRequest(ListTasksRequest),
    SetLevelRequest(SetLevelRequest),
    CompleteRequest(CompleteRequest),
}
impl ::std::convert::From<&Self> for ClientRequest {
    fn from(value: &ClientRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<InitializeRequest> for ClientRequest {
    fn from(value: InitializeRequest) -> Self {
        Self::InitializeRequest(value)
    }
}
impl ::std::convert::From<PingRequest> for ClientRequest {
    fn from(value: PingRequest) -> Self {
        Self::PingRequest(value)
    }
}
impl ::std::convert::From<ListResourcesRequest> for ClientRequest {
    fn from(value: ListResourcesRequest) -> Self {
        Self::ListResourcesRequest(value)
    }
}
impl ::std::convert::From<ListResourceTemplatesRequest> for ClientRequest {
    fn from(value: ListResourceTemplatesRequest) -> Self {
        Self::ListResourceTemplatesRequest(value)
    }
}
impl ::std::convert::From<ReadResourceRequest> for ClientRequest {
    fn from(value: ReadResourceRequest) -> Self {
        Self::ReadResourceRequest(value)
    }
}
impl ::std::convert::From<SubscribeRequest> for ClientRequest {
    fn from(value: SubscribeRequest) -> Self {
        Self::SubscribeRequest(value)
    }
}
impl ::std::convert::From<UnsubscribeRequest> for ClientRequest {
    fn from(value: UnsubscribeRequest) -> Self {
        Self::UnsubscribeRequest(value)
    }
}
impl ::std::convert::From<ListPromptsRequest> for ClientRequest {
    fn from(value: ListPromptsRequest) -> Self {
        Self::ListPromptsRequest(value)
    }
}
impl ::std::convert::From<GetPromptRequest> for ClientRequest {
    fn from(value: GetPromptRequest) -> Self {
        Self::GetPromptRequest(value)
    }
}
impl ::std::convert::From<ListToolsRequest> for ClientRequest {
    fn from(value: ListToolsRequest) -> Self {
        Self::ListToolsRequest(value)
    }
}
impl ::std::convert::From<CallToolRequest> for ClientRequest {
    fn from(value: CallToolRequest) -> Self {
        Self::CallToolRequest(value)
    }
}
impl ::std::convert::From<GetTaskRequest> for ClientRequest {
    fn from(value: GetTaskRequest) -> Self {
        Self::GetTaskRequest(value)
    }
}
impl ::std::convert::From<GetTaskPayloadRequest> for ClientRequest {
    fn from(value: GetTaskPayloadRequest) -> Self {
        Self::GetTaskPayloadRequest(value)
    }
}
impl ::std::convert::From<CancelTaskRequest> for ClientRequest {
    fn from(value: CancelTaskRequest) -> Self {
        Self::CancelTaskRequest(value)
    }
}
impl ::std::convert::From<ListTasksRequest> for ClientRequest {
    fn from(value: ListTasksRequest) -> Self {
        Self::ListTasksRequest(value)
    }
}
impl ::std::convert::From<SetLevelRequest> for ClientRequest {
    fn from(value: SetLevelRequest) -> Self {
        Self::SetLevelRequest(value)
    }
}
impl ::std::convert::From<CompleteRequest> for ClientRequest {
    fn from(value: CompleteRequest) -> Self {
        Self::CompleteRequest(value)
    }
}
#[doc = "`ClientResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Result\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The response to a tasks/get request.\","]
#[doc = "      \"$ref\": \"#/$defs/GetTaskResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskPayloadResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The response to a tasks/cancel request.\","]
#[doc = "      \"$ref\": \"#/$defs/CancelTaskResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListTasksResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CreateMessageResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListRootsResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitResult\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ClientResult {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<Result>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<GetTaskResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_2: ::std::option::Option<GetTaskPayloadResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_3: ::std::option::Option<CancelTaskResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_4: ::std::option::Option<ListTasksResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_5: ::std::option::Option<CreateMessageResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_6: ::std::option::Option<ListRootsResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_7: ::std::option::Option<ElicitResult>,
}
impl ::std::convert::From<&ClientResult> for ClientResult {
    fn from(value: &ClientResult) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ClientResult {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
            subtype_2: Default::default(),
            subtype_3: Default::default(),
            subtype_4: Default::default(),
            subtype_5: Default::default(),
            subtype_6: Default::default(),
            subtype_7: Default::default(),
        }
    }
}
impl ClientResult {
    pub fn builder() -> builder::ClientResult {
        Default::default()
    }
}
#[doc = "A request from the client to the server, to ask for completion options."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request from the client to the server, to ask for completion options.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"completion/complete\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/CompleteRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: CompleteRequestParams,
}
impl ::std::convert::From<&CompleteRequest> for CompleteRequest {
    fn from(value: &CompleteRequest) -> Self {
        value.clone()
    }
}
impl CompleteRequest {
    pub fn builder() -> builder::CompleteRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `completion/complete` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `completion/complete` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"argument\","]
#[doc = "    \"ref\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"argument\": {"]
#[doc = "      \"description\": \"The argument's information\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"description\": \"The name of the argument\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"value\": {"]
#[doc = "          \"description\": \"The value of the argument to use for completion matching.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"context\": {"]
#[doc = "      \"description\": \"Additional, optional context for completions\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"arguments\": {"]
#[doc = "          \"description\": \"Previously-resolved variables in a URI template or prompt.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"ref\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/PromptReference\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ResourceTemplateReference\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteRequestParams {
    pub argument: CompleteRequestParamsArgument,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub context: ::std::option::Option<CompleteRequestParamsContext>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CompleteRequestParamsMeta>,
    #[serde(rename = "ref")]
    pub ref_: CompleteRequestParamsRef,
}
impl ::std::convert::From<&CompleteRequestParams> for CompleteRequestParams {
    fn from(value: &CompleteRequestParams) -> Self {
        value.clone()
    }
}
impl CompleteRequestParams {
    pub fn builder() -> builder::CompleteRequestParams {
        Default::default()
    }
}
#[doc = "The argument's information"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The argument's information\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the argument\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"description\": \"The value of the argument to use for completion matching.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteRequestParamsArgument {
    #[doc = "The name of the argument"]
    pub name: ::std::string::String,
    #[doc = "The value of the argument to use for completion matching."]
    pub value: ::std::string::String,
}
impl ::std::convert::From<&CompleteRequestParamsArgument> for CompleteRequestParamsArgument {
    fn from(value: &CompleteRequestParamsArgument) -> Self {
        value.clone()
    }
}
impl CompleteRequestParamsArgument {
    pub fn builder() -> builder::CompleteRequestParamsArgument {
        Default::default()
    }
}
#[doc = "Additional, optional context for completions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Additional, optional context for completions\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"description\": \"Previously-resolved variables in a URI template or prompt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteRequestParamsContext {
    #[doc = "Previously-resolved variables in a URI template or prompt."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub arguments: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
}
impl ::std::convert::From<&CompleteRequestParamsContext> for CompleteRequestParamsContext {
    fn from(value: &CompleteRequestParamsContext) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CompleteRequestParamsContext {
    fn default() -> Self {
        Self {
            arguments: Default::default(),
        }
    }
}
impl CompleteRequestParamsContext {
    pub fn builder() -> builder::CompleteRequestParamsContext {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CompleteRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&CompleteRequestParamsMeta> for CompleteRequestParamsMeta {
    fn from(value: &CompleteRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CompleteRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl CompleteRequestParamsMeta {
    pub fn builder() -> builder::CompleteRequestParamsMeta {
        Default::default()
    }
}
#[doc = "`CompleteRequestParamsRef`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/PromptReference\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ResourceTemplateReference\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CompleteRequestParamsRef {
    PromptReference(PromptReference),
    ResourceTemplateReference(ResourceTemplateReference),
}
impl ::std::convert::From<&Self> for CompleteRequestParamsRef {
    fn from(value: &CompleteRequestParamsRef) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PromptReference> for CompleteRequestParamsRef {
    fn from(value: PromptReference) -> Self {
        Self::PromptReference(value)
    }
}
impl ::std::convert::From<ResourceTemplateReference> for CompleteRequestParamsRef {
    fn from(value: ResourceTemplateReference) -> Self {
        Self::ResourceTemplateReference(value)
    }
}
#[doc = "The server's response to a completion/complete request"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a completion/complete request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"completion\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"completion\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"values\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hasMore\": {"]
#[doc = "          \"description\": \"Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"total\": {"]
#[doc = "          \"description\": \"The total number of completion options available. This can exceed the number of values actually sent in the response.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"values\": {"]
#[doc = "          \"description\": \"An array of completion values. Must not exceed 100 items.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteResult {
    pub completion: CompleteResultCompletion,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CompleteResultMeta>,
}
impl ::std::convert::From<&CompleteResult> for CompleteResult {
    fn from(value: &CompleteResult) -> Self {
        value.clone()
    }
}
impl CompleteResult {
    pub fn builder() -> builder::CompleteResult {
        Default::default()
    }
}
#[doc = "`CompleteResultCompletion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"values\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hasMore\": {"]
#[doc = "      \"description\": \"Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"total\": {"]
#[doc = "      \"description\": \"The total number of completion options available. This can exceed the number of values actually sent in the response.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"description\": \"An array of completion values. Must not exceed 100 items.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CompleteResultCompletion {
    #[doc = "Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown."]
    #[serde(
        rename = "hasMore",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_more: ::std::option::Option<bool>,
    #[doc = "The total number of completion options available. This can exceed the number of values actually sent in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub total: ::std::option::Option<i64>,
    #[doc = "An array of completion values. Must not exceed 100 items."]
    pub values: ::std::vec::Vec<::std::string::String>,
}
impl ::std::convert::From<&CompleteResultCompletion> for CompleteResultCompletion {
    fn from(value: &CompleteResultCompletion) -> Self {
        value.clone()
    }
}
impl CompleteResultCompletion {
    pub fn builder() -> builder::CompleteResultCompletion {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CompleteResultMeta {}
impl ::std::convert::From<&CompleteResultMeta> for CompleteResultMeta {
    fn from(value: &CompleteResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CompleteResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl CompleteResultMeta {
    pub fn builder() -> builder::CompleteResultMeta {
        Default::default()
    }
}
#[doc = "`ContentBlock`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ResourceLink\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/EmbeddedResource\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContentBlock {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ResourceLink(ResourceLink),
    EmbeddedResource(EmbeddedResource),
}
impl ::std::convert::From<&Self> for ContentBlock {
    fn from(value: &ContentBlock) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextContent> for ContentBlock {
    fn from(value: TextContent) -> Self {
        Self::TextContent(value)
    }
}
impl ::std::convert::From<ImageContent> for ContentBlock {
    fn from(value: ImageContent) -> Self {
        Self::ImageContent(value)
    }
}
impl ::std::convert::From<AudioContent> for ContentBlock {
    fn from(value: AudioContent) -> Self {
        Self::AudioContent(value)
    }
}
impl ::std::convert::From<ResourceLink> for ContentBlock {
    fn from(value: ResourceLink) -> Self {
        Self::ResourceLink(value)
    }
}
impl ::std::convert::From<EmbeddedResource> for ContentBlock {
    fn from(value: EmbeddedResource) -> Self {
        Self::EmbeddedResource(value)
    }
}
#[doc = "A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"sampling/createMessage\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/CreateMessageRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CreateMessageRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: CreateMessageRequestParams,
}
impl ::std::convert::From<&CreateMessageRequest> for CreateMessageRequest {
    fn from(value: &CreateMessageRequest) -> Self {
        value.clone()
    }
}
impl CreateMessageRequest {
    pub fn builder() -> builder::CreateMessageRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `sampling/createMessage` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `sampling/createMessage` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"maxTokens\","]
#[doc = "    \"messages\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"includeContext\": {"]
#[doc = "      \"description\": \"A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.\\nThe client MAY ignore this request.\\n\\nDefault is \\\"none\\\". Values \\\"thisServer\\\" and \\\"allServers\\\" are soft-deprecated. Servers SHOULD only use these values if the client\\ndeclares ClientCapabilities.sampling.context. These values may be removed in future spec releases.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"allServers\","]
#[doc = "        \"none\","]
#[doc = "        \"thisServer\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxTokens\": {"]
#[doc = "      \"description\": \"The requested maximum number of tokens to sample (to prevent runaway completions).\\n\\nThe client MAY choose to sample fewer tokens than the requested maximum.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"messages\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/SamplingMessage\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"description\": \"Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"modelPreferences\": {"]
#[doc = "      \"description\": \"The server's preferences for which model to select. The client MAY ignore these preferences.\","]
#[doc = "      \"$ref\": \"#/$defs/ModelPreferences\""]
#[doc = "    },"]
#[doc = "    \"stopSequences\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"systemPrompt\": {"]
#[doc = "      \"description\": \"An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting task-augmented execution for this request.\\nThe request will return a CreateTaskResult immediately, and the actual result can be\\nretrieved later via tasks/result.\\n\\nTask augmentation is subject to capability negotiation - receivers MUST declare support\\nfor task augmentation of specific request types in their capabilities.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskMetadata\""]
#[doc = "    },"]
#[doc = "    \"temperature\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"toolChoice\": {"]
#[doc = "      \"description\": \"Controls how the model uses tools.\\nThe client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.\\nDefault is `{ mode: \\\"auto\\\" }`.\","]
#[doc = "      \"$ref\": \"#/$defs/ToolChoice\""]
#[doc = "    },"]
#[doc = "    \"tools\": {"]
#[doc = "      \"description\": \"Tools that the model may use during generation.\\nThe client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Tool\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CreateMessageRequestParams {
    #[doc = "A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.\nThe client MAY ignore this request.\n\nDefault is \"none\". Values \"thisServer\" and \"allServers\" are soft-deprecated. Servers SHOULD only use these values if the client\ndeclares ClientCapabilities.sampling.context. These values may be removed in future spec releases."]
    #[serde(
        rename = "includeContext",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub include_context: ::std::option::Option<CreateMessageRequestParamsIncludeContext>,
    #[doc = "The requested maximum number of tokens to sample (to prevent runaway completions).\n\nThe client MAY choose to sample fewer tokens than the requested maximum."]
    #[serde(rename = "maxTokens")]
    pub max_tokens: i64,
    pub messages: ::std::vec::Vec<SamplingMessage>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CreateMessageRequestParamsMeta>,
    #[doc = "Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The server's preferences for which model to select. The client MAY ignore these preferences."]
    #[serde(
        rename = "modelPreferences",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub model_preferences: ::std::option::Option<ModelPreferences>,
    #[serde(
        rename = "stopSequences",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub stop_sequences: ::std::vec::Vec<::std::string::String>,
    #[doc = "An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt."]
    #[serde(
        rename = "systemPrompt",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub system_prompt: ::std::option::Option<::std::string::String>,
    #[doc = "If specified, the caller is requesting task-augmented execution for this request.\nThe request will return a CreateTaskResult immediately, and the actual result can be\nretrieved later via tasks/result.\n\nTask augmentation is subject to capability negotiation - receivers MUST declare support\nfor task augmentation of specific request types in their capabilities."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub task: ::std::option::Option<TaskMetadata>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub temperature: ::std::option::Option<f64>,
    #[doc = "Controls how the model uses tools.\nThe client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.\nDefault is `{ mode: \"auto\" }`."]
    #[serde(
        rename = "toolChoice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tool_choice: ::std::option::Option<ToolChoice>,
    #[doc = "Tools that the model may use during generation.\nThe client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub tools: ::std::vec::Vec<Tool>,
}
impl ::std::convert::From<&CreateMessageRequestParams> for CreateMessageRequestParams {
    fn from(value: &CreateMessageRequestParams) -> Self {
        value.clone()
    }
}
impl CreateMessageRequestParams {
    pub fn builder() -> builder::CreateMessageRequestParams {
        Default::default()
    }
}
#[doc = "A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.\nThe client MAY ignore this request.\n\nDefault is \"none\". Values \"thisServer\" and \"allServers\" are soft-deprecated. Servers SHOULD only use these values if the client\ndeclares ClientCapabilities.sampling.context. These values may be removed in future spec releases."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.\\nThe client MAY ignore this request.\\n\\nDefault is \\\"none\\\". Values \\\"thisServer\\\" and \\\"allServers\\\" are soft-deprecated. Servers SHOULD only use these values if the client\\ndeclares ClientCapabilities.sampling.context. These values may be removed in future spec releases.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"allServers\","]
#[doc = "    \"none\","]
#[doc = "    \"thisServer\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CreateMessageRequestParamsIncludeContext {
    #[serde(rename = "allServers")]
    AllServers,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "thisServer")]
    ThisServer,
}
impl ::std::convert::From<&Self> for CreateMessageRequestParamsIncludeContext {
    fn from(value: &CreateMessageRequestParamsIncludeContext) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CreateMessageRequestParamsIncludeContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllServers => write!(f, "allServers"),
            Self::None => write!(f, "none"),
            Self::ThisServer => write!(f, "thisServer"),
        }
    }
}
impl ::std::str::FromStr for CreateMessageRequestParamsIncludeContext {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "allServers" => Ok(Self::AllServers),
            "none" => Ok(Self::None),
            "thisServer" => Ok(Self::ThisServer),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CreateMessageRequestParamsIncludeContext {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CreateMessageRequestParamsIncludeContext {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CreateMessageRequestParamsIncludeContext {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CreateMessageRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&CreateMessageRequestParamsMeta> for CreateMessageRequestParamsMeta {
    fn from(value: &CreateMessageRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CreateMessageRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl CreateMessageRequestParamsMeta {
    pub fn builder() -> builder::CreateMessageRequestParamsMeta {
        Default::default()
    }
}
#[doc = "The client's response to a sampling/createMessage request from the server.\nThe client should inform the user before returning the sampled message, to allow them\nto inspect the response (human in the loop) and decide whether to allow the server to see it."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The client's response to a sampling/createMessage request from the server.\\nThe client should inform the user before returning the sampled message, to allow them\\nto inspect the response (human in the loop) and decide whether to allow the server to see it.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\","]
#[doc = "    \"model\","]
#[doc = "    \"role\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"content\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/TextContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ToolUseContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ToolResultContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/$defs/SamplingMessageContentBlock\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"model\": {"]
#[doc = "      \"description\": \"The name of the model that generated the message.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"$ref\": \"#/$defs/Role\""]
#[doc = "    },"]
#[doc = "    \"stopReason\": {"]
#[doc = "      \"description\": \"The reason why sampling stopped, if known.\\n\\nStandard values:\\n- \\\"endTurn\\\": Natural end of the assistant's turn\\n- \\\"stopSequence\\\": A stop sequence was encountered\\n- \\\"maxTokens\\\": Maximum token limit was reached\\n- \\\"toolUse\\\": The model wants to use one or more tools\\n\\nThis field is an open string to allow for provider-specific stop reasons.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CreateMessageResult {
    pub content: CreateMessageResultContent,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CreateMessageResultMeta>,
    #[doc = "The name of the model that generated the message."]
    pub model: ::std::string::String,
    pub role: Role,
    #[doc = "The reason why sampling stopped, if known.\n\nStandard values:\n- \"endTurn\": Natural end of the assistant's turn\n- \"stopSequence\": A stop sequence was encountered\n- \"maxTokens\": Maximum token limit was reached\n- \"toolUse\": The model wants to use one or more tools\n\nThis field is an open string to allow for provider-specific stop reasons."]
    #[serde(
        rename = "stopReason",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stop_reason: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&CreateMessageResult> for CreateMessageResult {
    fn from(value: &CreateMessageResult) -> Self {
        value.clone()
    }
}
impl CreateMessageResult {
    pub fn builder() -> builder::CreateMessageResult {
        Default::default()
    }
}
#[doc = "`CreateMessageResultContent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolUseContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolResultContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/SamplingMessageContentBlock\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CreateMessageResultContent {
    Variant0(TextContent),
    Variant1(ImageContent),
    Variant2(AudioContent),
    Variant3(ToolUseContent),
    Variant4(ToolResultContent),
    Variant5(::std::vec::Vec<SamplingMessageContentBlock>),
}
impl ::std::convert::From<&Self> for CreateMessageResultContent {
    fn from(value: &CreateMessageResultContent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextContent> for CreateMessageResultContent {
    fn from(value: TextContent) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ImageContent> for CreateMessageResultContent {
    fn from(value: ImageContent) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AudioContent> for CreateMessageResultContent {
    fn from(value: AudioContent) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ToolUseContent> for CreateMessageResultContent {
    fn from(value: ToolUseContent) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<ToolResultContent> for CreateMessageResultContent {
    fn from(value: ToolResultContent) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<SamplingMessageContentBlock>>
    for CreateMessageResultContent
{
    fn from(value: ::std::vec::Vec<SamplingMessageContentBlock>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CreateMessageResultMeta {}
impl ::std::convert::From<&CreateMessageResultMeta> for CreateMessageResultMeta {
    fn from(value: &CreateMessageResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CreateMessageResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl CreateMessageResultMeta {
    pub fn builder() -> builder::CreateMessageResultMeta {
        Default::default()
    }
}
#[doc = "A response to a task-augmented request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A response to a task-augmented request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"task\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"$ref\": \"#/$defs/Task\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CreateTaskResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<CreateTaskResultMeta>,
    pub task: Task,
}
impl ::std::convert::From<&CreateTaskResult> for CreateTaskResult {
    fn from(value: &CreateTaskResult) -> Self {
        value.clone()
    }
}
impl CreateTaskResult {
    pub fn builder() -> builder::CreateTaskResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CreateTaskResultMeta {}
impl ::std::convert::From<&CreateTaskResultMeta> for CreateTaskResultMeta {
    fn from(value: &CreateTaskResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CreateTaskResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl CreateTaskResultMeta {
    pub fn builder() -> builder::CreateTaskResultMeta {
        Default::default()
    }
}
#[doc = "An opaque token used to represent a cursor for pagination."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An opaque token used to represent a cursor for pagination.\","]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Cursor(pub ::std::string::String);
impl ::std::ops::Deref for Cursor {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Cursor> for ::std::string::String {
    fn from(value: Cursor) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Cursor> for Cursor {
    fn from(value: &Cursor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Cursor {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Cursor {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Cursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "A request from the server to elicit additional information from the user via the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request from the server to elicit additional information from the user via the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"elicitation/create\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: ElicitRequestParams,
}
impl ::std::convert::From<&ElicitRequest> for ElicitRequest {
    fn from(value: &ElicitRequest) -> Self {
        value.clone()
    }
}
impl ElicitRequest {
    pub fn builder() -> builder::ElicitRequest {
        Default::default()
    }
}
#[doc = "The parameters for a request to elicit non-sensitive information from the user via a form in the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The parameters for a request to elicit non-sensitive information from the user via a form in the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"message\","]
#[doc = "    \"requestedSchema\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"The message to present to the user describing what information is being requested.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The elicitation mode.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"form\""]
#[doc = "    },"]
#[doc = "    \"requestedSchema\": {"]
#[doc = "      \"description\": \"A restricted subset of JSON Schema.\\nOnly top-level properties are allowed, without nesting.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"properties\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"$schema\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/PrimitiveSchemaDefinition\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"required\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting task-augmented execution for this request.\\nThe request will return a CreateTaskResult immediately, and the actual result can be\\nretrieved later via tasks/result.\\n\\nTask augmentation is subject to capability negotiation - receivers MUST declare support\\nfor task augmentation of specific request types in their capabilities.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskMetadata\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitRequestFormParams {
    #[doc = "The message to present to the user describing what information is being requested."]
    pub message: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ElicitRequestFormParamsMeta>,
    #[doc = "The elicitation mode."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<::std::string::String>,
    #[serde(rename = "requestedSchema")]
    pub requested_schema: ElicitRequestFormParamsRequestedSchema,
    #[doc = "If specified, the caller is requesting task-augmented execution for this request.\nThe request will return a CreateTaskResult immediately, and the actual result can be\nretrieved later via tasks/result.\n\nTask augmentation is subject to capability negotiation - receivers MUST declare support\nfor task augmentation of specific request types in their capabilities."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub task: ::std::option::Option<TaskMetadata>,
}
impl ::std::convert::From<&ElicitRequestFormParams> for ElicitRequestFormParams {
    fn from(value: &ElicitRequestFormParams) -> Self {
        value.clone()
    }
}
impl ElicitRequestFormParams {
    pub fn builder() -> builder::ElicitRequestFormParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ElicitRequestFormParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&ElicitRequestFormParamsMeta> for ElicitRequestFormParamsMeta {
    fn from(value: &ElicitRequestFormParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ElicitRequestFormParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl ElicitRequestFormParamsMeta {
    pub fn builder() -> builder::ElicitRequestFormParamsMeta {
        Default::default()
    }
}
#[doc = "A restricted subset of JSON Schema.\nOnly top-level properties are allowed, without nesting."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A restricted subset of JSON Schema.\\nOnly top-level properties are allowed, without nesting.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"properties\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"$schema\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"properties\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/PrimitiveSchemaDefinition\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"required\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"object\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitRequestFormParamsRequestedSchema {
    pub properties: ::std::collections::HashMap<::std::string::String, PrimitiveSchemaDefinition>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub required: ::std::vec::Vec<::std::string::String>,
    #[serde(
        rename = "$schema",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub schema: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ElicitRequestFormParamsRequestedSchema>
    for ElicitRequestFormParamsRequestedSchema
{
    fn from(value: &ElicitRequestFormParamsRequestedSchema) -> Self {
        value.clone()
    }
}
impl ElicitRequestFormParamsRequestedSchema {
    pub fn builder() -> builder::ElicitRequestFormParamsRequestedSchema {
        Default::default()
    }
}
#[doc = "The parameters for a request to elicit additional information from the user via the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The parameters for a request to elicit additional information from the user via the client.\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitRequestURLParams\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitRequestFormParams\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ElicitRequestParams {
    UrlParams(ElicitRequestUrlParams),
    FormParams(ElicitRequestFormParams),
}
impl ::std::convert::From<&Self> for ElicitRequestParams {
    fn from(value: &ElicitRequestParams) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ElicitRequestUrlParams> for ElicitRequestParams {
    fn from(value: ElicitRequestUrlParams) -> Self {
        Self::UrlParams(value)
    }
}
impl ::std::convert::From<ElicitRequestFormParams> for ElicitRequestParams {
    fn from(value: ElicitRequestFormParams) -> Self {
        Self::FormParams(value)
    }
}
#[doc = "The parameters for a request to elicit information from the user via a URL in the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The parameters for a request to elicit information from the user via a URL in the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"elicitationId\","]
#[doc = "    \"message\","]
#[doc = "    \"mode\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"elicitationId\": {"]
#[doc = "      \"description\": \"The ID of the elicitation, which must be unique within the context of the server.\\nThe client MUST treat this ID as an opaque value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"The message to present to the user explaining why the interaction is needed.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"The elicitation mode.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"url\""]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting task-augmented execution for this request.\\nThe request will return a CreateTaskResult immediately, and the actual result can be\\nretrieved later via tasks/result.\\n\\nTask augmentation is subject to capability negotiation - receivers MUST declare support\\nfor task augmentation of specific request types in their capabilities.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskMetadata\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"description\": \"The URL that the user should navigate to.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitRequestUrlParams {
    #[doc = "The ID of the elicitation, which must be unique within the context of the server.\nThe client MUST treat this ID as an opaque value."]
    #[serde(rename = "elicitationId")]
    pub elicitation_id: ::std::string::String,
    #[doc = "The message to present to the user explaining why the interaction is needed."]
    pub message: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ElicitRequestUrlParamsMeta>,
    #[doc = "The elicitation mode."]
    pub mode: ::std::string::String,
    #[doc = "If specified, the caller is requesting task-augmented execution for this request.\nThe request will return a CreateTaskResult immediately, and the actual result can be\nretrieved later via tasks/result.\n\nTask augmentation is subject to capability negotiation - receivers MUST declare support\nfor task augmentation of specific request types in their capabilities."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub task: ::std::option::Option<TaskMetadata>,
    #[doc = "The URL that the user should navigate to."]
    pub url: ::std::string::String,
}
impl ::std::convert::From<&ElicitRequestUrlParams> for ElicitRequestUrlParams {
    fn from(value: &ElicitRequestUrlParams) -> Self {
        value.clone()
    }
}
impl ElicitRequestUrlParams {
    pub fn builder() -> builder::ElicitRequestUrlParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ElicitRequestUrlParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&ElicitRequestUrlParamsMeta> for ElicitRequestUrlParamsMeta {
    fn from(value: &ElicitRequestUrlParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ElicitRequestUrlParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl ElicitRequestUrlParamsMeta {
    pub fn builder() -> builder::ElicitRequestUrlParamsMeta {
        Default::default()
    }
}
#[doc = "The client's response to an elicitation request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The client's response to an elicitation request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"action\": {"]
#[doc = "      \"description\": \"The user action in response to the elicitation.\\n- \\\"accept\\\": User submitted the form/confirmed the action\\n- \\\"decline\\\": User explicitly decline the action\\n- \\\"cancel\\\": User dismissed without making an explicit choice\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"accept\","]
#[doc = "        \"cancel\","]
#[doc = "        \"decline\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"content\": {"]
#[doc = "      \"description\": \"The submitted form data, only present when action is \\\"accept\\\" and mode was \\\"form\\\".\\nContains values matching the requested schema.\\nOmitted for out-of-band mode responses.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": ["]
#[doc = "              \"string\","]
#[doc = "              \"integer\","]
#[doc = "              \"boolean\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitResult {
    #[doc = "The user action in response to the elicitation.\n- \"accept\": User submitted the form/confirmed the action\n- \"decline\": User explicitly decline the action\n- \"cancel\": User dismissed without making an explicit choice"]
    pub action: ElicitResultAction,
    #[doc = "The submitted form data, only present when action is \"accept\" and mode was \"form\".\nContains values matching the requested schema.\nOmitted for out-of-band mode responses."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub content: ::std::collections::HashMap<::std::string::String, ElicitResultContentValue>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ElicitResultMeta>,
}
impl ::std::convert::From<&ElicitResult> for ElicitResult {
    fn from(value: &ElicitResult) -> Self {
        value.clone()
    }
}
impl ElicitResult {
    pub fn builder() -> builder::ElicitResult {
        Default::default()
    }
}
#[doc = "The user action in response to the elicitation.\n- \"accept\": User submitted the form/confirmed the action\n- \"decline\": User explicitly decline the action\n- \"cancel\": User dismissed without making an explicit choice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The user action in response to the elicitation.\\n- \\\"accept\\\": User submitted the form/confirmed the action\\n- \\\"decline\\\": User explicitly decline the action\\n- \\\"cancel\\\": User dismissed without making an explicit choice\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"accept\","]
#[doc = "    \"cancel\","]
#[doc = "    \"decline\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ElicitResultAction {
    #[serde(rename = "accept")]
    Accept,
    #[serde(rename = "cancel")]
    Cancel,
    #[serde(rename = "decline")]
    Decline,
}
impl ::std::convert::From<&Self> for ElicitResultAction {
    fn from(value: &ElicitResultAction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ElicitResultAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Accept => write!(f, "accept"),
            Self::Cancel => write!(f, "cancel"),
            Self::Decline => write!(f, "decline"),
        }
    }
}
impl ::std::str::FromStr for ElicitResultAction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "accept" => Ok(Self::Accept),
            "cancel" => Ok(Self::Cancel),
            "decline" => Ok(Self::Decline),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ElicitResultAction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ElicitResultAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ElicitResultAction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ElicitResultContentValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"integer\","]
#[doc = "        \"boolean\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ElicitResultContentValue {
    Variant0(::std::vec::Vec<::std::string::String>),
    Variant1(ElicitResultContentValueVariant1),
}
impl ::std::convert::From<&Self> for ElicitResultContentValue {
    fn from(value: &ElicitResultContentValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for ElicitResultContentValue {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ElicitResultContentValueVariant1> for ElicitResultContentValue {
    fn from(value: ElicitResultContentValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ElicitResultContentValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": ["]
#[doc = "    \"string\","]
#[doc = "    \"integer\","]
#[doc = "    \"boolean\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ElicitResultContentValueVariant1 {
    Boolean(bool),
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for ElicitResultContentValueVariant1 {
    fn from(value: &ElicitResultContentValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ElicitResultContentValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Boolean(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::String(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Integer(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ElicitResultContentValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ElicitResultContentValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ElicitResultContentValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ElicitResultContentValueVariant1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Boolean(x) => x.fmt(f),
            Self::String(x) => x.fmt(f),
            Self::Integer(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<bool> for ElicitResultContentValueVariant1 {
    fn from(value: bool) -> Self {
        Self::Boolean(value)
    }
}
impl ::std::convert::From<i64> for ElicitResultContentValueVariant1 {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ElicitResultMeta {}
impl ::std::convert::From<&ElicitResultMeta> for ElicitResultMeta {
    fn from(value: &ElicitResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ElicitResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ElicitResultMeta {
    pub fn builder() -> builder::ElicitResultMeta {
        Default::default()
    }
}
#[doc = "An optional notification from the server to the client, informing it of a completion of a out-of-band elicitation request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional notification from the server to the client, informing it of a completion of a out-of-band elicitation request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/elicitation/complete\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"elicitationId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"elicitationId\": {"]
#[doc = "          \"description\": \"The ID of the elicitation that completed.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitationCompleteNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: ElicitationCompleteNotificationParams,
}
impl ::std::convert::From<&ElicitationCompleteNotification> for ElicitationCompleteNotification {
    fn from(value: &ElicitationCompleteNotification) -> Self {
        value.clone()
    }
}
impl ElicitationCompleteNotification {
    pub fn builder() -> builder::ElicitationCompleteNotification {
        Default::default()
    }
}
#[doc = "`ElicitationCompleteNotificationParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"elicitationId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"elicitationId\": {"]
#[doc = "      \"description\": \"The ID of the elicitation that completed.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ElicitationCompleteNotificationParams {
    #[doc = "The ID of the elicitation that completed."]
    #[serde(rename = "elicitationId")]
    pub elicitation_id: ::std::string::String,
}
impl ::std::convert::From<&ElicitationCompleteNotificationParams>
    for ElicitationCompleteNotificationParams
{
    fn from(value: &ElicitationCompleteNotificationParams) -> Self {
        value.clone()
    }
}
impl ElicitationCompleteNotificationParams {
    pub fn builder() -> builder::ElicitationCompleteNotificationParams {
        Default::default()
    }
}
#[doc = "The contents of a resource, embedded into a prompt or tool call result.\n\nIt is up to the client how best to render embedded resources for the benefit\nof the LLM and/or the user."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The contents of a resource, embedded into a prompt or tool call result.\\n\\nIt is up to the client how best to render embedded resources for the benefit\\nof the LLM and/or the user.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"resource\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"resource\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/TextResourceContents\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/BlobResourceContents\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resource\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EmbeddedResource {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<EmbeddedResourceMeta>,
    pub resource: EmbeddedResourceResource,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&EmbeddedResource> for EmbeddedResource {
    fn from(value: &EmbeddedResource) -> Self {
        value.clone()
    }
}
impl EmbeddedResource {
    pub fn builder() -> builder::EmbeddedResource {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EmbeddedResourceMeta {}
impl ::std::convert::From<&EmbeddedResourceMeta> for EmbeddedResourceMeta {
    fn from(value: &EmbeddedResourceMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EmbeddedResourceMeta {
    fn default() -> Self {
        Self {}
    }
}
impl EmbeddedResourceMeta {
    pub fn builder() -> builder::EmbeddedResourceMeta {
        Default::default()
    }
}
#[doc = "`EmbeddedResourceResource`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextResourceContents\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/BlobResourceContents\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EmbeddedResourceResource {
    TextResourceContents(TextResourceContents),
    BlobResourceContents(BlobResourceContents),
}
impl ::std::convert::From<&Self> for EmbeddedResourceResource {
    fn from(value: &EmbeddedResourceResource) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextResourceContents> for EmbeddedResourceResource {
    fn from(value: TextResourceContents) -> Self {
        Self::TextResourceContents(value)
    }
}
impl ::std::convert::From<BlobResourceContents> for EmbeddedResourceResource {
    fn from(value: BlobResourceContents) -> Self {
        Self::BlobResourceContents(value)
    }
}
#[doc = "`EmptyResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$ref\": \"#/$defs/Result\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EmptyResult(pub Result);
impl ::std::ops::Deref for EmptyResult {
    type Target = Result;
    fn deref(&self) -> &Result {
        &self.0
    }
}
impl ::std::convert::From<EmptyResult> for Result {
    fn from(value: EmptyResult) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EmptyResult> for EmptyResult {
    fn from(value: &EmptyResult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Result> for EmptyResult {
    fn from(value: Result) -> Self {
        Self(value)
    }
}
#[doc = "`EnumSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledSingleSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledSingleSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledMultiSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledMultiSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/LegacyTitledEnumSchema\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EnumSchema {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<UntitledSingleSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<TitledSingleSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_2: ::std::option::Option<UntitledMultiSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_3: ::std::option::Option<TitledMultiSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_4: ::std::option::Option<LegacyTitledEnumSchema>,
}
impl ::std::convert::From<&EnumSchema> for EnumSchema {
    fn from(value: &EnumSchema) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EnumSchema {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
            subtype_2: Default::default(),
            subtype_3: Default::default(),
            subtype_4: Default::default(),
        }
    }
}
impl EnumSchema {
    pub fn builder() -> builder::EnumSchema {
        Default::default()
    }
}
#[doc = "`Error`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"description\": \"The error type that occurred.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"A short description of the error. The message SHOULD be limited to a concise single sentence.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Error {
    #[doc = "The error type that occurred."]
    pub code: i64,
    #[doc = "Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::serde_json::Value>,
    #[doc = "A short description of the error. The message SHOULD be limited to a concise single sentence."]
    pub message: ::std::string::String,
}
impl ::std::convert::From<&Error> for Error {
    fn from(value: &Error) -> Self {
        value.clone()
    }
}
impl Error {
    pub fn builder() -> builder::Error {
        Default::default()
    }
}
#[doc = "Used by the client to get a prompt provided by the server."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Used by the client to get a prompt provided by the server.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"prompts/get\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/GetPromptRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetPromptRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: GetPromptRequestParams,
}
impl ::std::convert::From<&GetPromptRequest> for GetPromptRequest {
    fn from(value: &GetPromptRequest) -> Self {
        value.clone()
    }
}
impl GetPromptRequest {
    pub fn builder() -> builder::GetPromptRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `prompts/get` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `prompts/get` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"description\": \"Arguments to use for templating the prompt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the prompt or prompt template.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetPromptRequestParams {
    #[doc = "Arguments to use for templating the prompt."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub arguments: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<GetPromptRequestParamsMeta>,
    #[doc = "The name of the prompt or prompt template."]
    pub name: ::std::string::String,
}
impl ::std::convert::From<&GetPromptRequestParams> for GetPromptRequestParams {
    fn from(value: &GetPromptRequestParams) -> Self {
        value.clone()
    }
}
impl GetPromptRequestParams {
    pub fn builder() -> builder::GetPromptRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GetPromptRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&GetPromptRequestParamsMeta> for GetPromptRequestParamsMeta {
    fn from(value: &GetPromptRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GetPromptRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl GetPromptRequestParamsMeta {
    pub fn builder() -> builder::GetPromptRequestParamsMeta {
        Default::default()
    }
}
#[doc = "The server's response to a prompts/get request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a prompts/get request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"messages\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"An optional description for the prompt.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"messages\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/PromptMessage\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetPromptResult {
    #[doc = "An optional description for the prompt."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    pub messages: ::std::vec::Vec<PromptMessage>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<GetPromptResultMeta>,
}
impl ::std::convert::From<&GetPromptResult> for GetPromptResult {
    fn from(value: &GetPromptResult) -> Self {
        value.clone()
    }
}
impl GetPromptResult {
    pub fn builder() -> builder::GetPromptResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GetPromptResultMeta {}
impl ::std::convert::From<&GetPromptResultMeta> for GetPromptResultMeta {
    fn from(value: &GetPromptResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GetPromptResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl GetPromptResultMeta {
    pub fn builder() -> builder::GetPromptResultMeta {
        Default::default()
    }
}
#[doc = "A request to retrieve the result of a completed task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request to retrieve the result of a completed task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tasks/result\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"taskId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"taskId\": {"]
#[doc = "          \"description\": \"The task identifier to retrieve results for.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetTaskPayloadRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: GetTaskPayloadRequestParams,
}
impl ::std::convert::From<&GetTaskPayloadRequest> for GetTaskPayloadRequest {
    fn from(value: &GetTaskPayloadRequest) -> Self {
        value.clone()
    }
}
impl GetTaskPayloadRequest {
    pub fn builder() -> builder::GetTaskPayloadRequest {
        Default::default()
    }
}
#[doc = "`GetTaskPayloadRequestParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"taskId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"taskId\": {"]
#[doc = "      \"description\": \"The task identifier to retrieve results for.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetTaskPayloadRequestParams {
    #[doc = "The task identifier to retrieve results for."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
}
impl ::std::convert::From<&GetTaskPayloadRequestParams> for GetTaskPayloadRequestParams {
    fn from(value: &GetTaskPayloadRequestParams) -> Self {
        value.clone()
    }
}
impl GetTaskPayloadRequestParams {
    pub fn builder() -> builder::GetTaskPayloadRequestParams {
        Default::default()
    }
}
#[doc = "The response to a tasks/result request.\nThe structure matches the result type of the original request.\nFor example, a tools/call task would return the CallToolResult structure."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The response to a tasks/result request.\\nThe structure matches the result type of the original request.\\nFor example, a tools/call task would return the CallToolResult structure.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GetTaskPayloadResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<GetTaskPayloadResultMeta>,
}
impl ::std::convert::From<&GetTaskPayloadResult> for GetTaskPayloadResult {
    fn from(value: &GetTaskPayloadResult) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GetTaskPayloadResult {
    fn default() -> Self {
        Self {
            meta: Default::default(),
        }
    }
}
impl GetTaskPayloadResult {
    pub fn builder() -> builder::GetTaskPayloadResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GetTaskPayloadResultMeta {}
impl ::std::convert::From<&GetTaskPayloadResultMeta> for GetTaskPayloadResultMeta {
    fn from(value: &GetTaskPayloadResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GetTaskPayloadResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl GetTaskPayloadResultMeta {
    pub fn builder() -> builder::GetTaskPayloadResultMeta {
        Default::default()
    }
}
#[doc = "A request to retrieve the state of a task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request to retrieve the state of a task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tasks/get\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"taskId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"taskId\": {"]
#[doc = "          \"description\": \"The task identifier to query.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetTaskRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: GetTaskRequestParams,
}
impl ::std::convert::From<&GetTaskRequest> for GetTaskRequest {
    fn from(value: &GetTaskRequest) -> Self {
        value.clone()
    }
}
impl GetTaskRequest {
    pub fn builder() -> builder::GetTaskRequest {
        Default::default()
    }
}
#[doc = "`GetTaskRequestParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"taskId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"taskId\": {"]
#[doc = "      \"description\": \"The task identifier to query.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GetTaskRequestParams {
    #[doc = "The task identifier to query."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
}
impl ::std::convert::From<&GetTaskRequestParams> for GetTaskRequestParams {
    fn from(value: &GetTaskRequestParams) -> Self {
        value.clone()
    }
}
impl GetTaskRequestParams {
    pub fn builder() -> builder::GetTaskRequestParams {
        Default::default()
    }
}
#[doc = "`GetTaskResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The response to a tasks/get request.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Result\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Task\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum GetTaskResult {}
impl ::std::convert::From<&Self> for GetTaskResult {
    fn from(value: &GetTaskResult) -> Self {
        value.clone()
    }
}
#[doc = "An optionally-sized icon that can be displayed in a user interface."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optionally-sized icon that can be displayed in a user interface.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"src\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"Optional MIME type override if the source MIME type is missing or generic.\\nFor example: `\\\"image/png\\\"`, `\\\"image/jpeg\\\"`, or `\\\"image/svg+xml\\\"`.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sizes\": {"]
#[doc = "      \"description\": \"Optional array of strings that specify sizes at which the icon can be used.\\nEach string should be in WxH format (e.g., `\\\"48x48\\\"`, `\\\"96x96\\\"`) or `\\\"any\\\"` for scalable formats like SVG.\\n\\nIf not provided, the client should assume that the icon can be used at any size.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"src\": {"]
#[doc = "      \"description\": \"A standard URI pointing to an icon resource. May be an HTTP/HTTPS URL or a\\n`data:` URI with Base64-encoded image data.\\n\\nConsumers SHOULD takes steps to ensure URLs serving icons are from the\\nsame domain as the client/server or a trusted domain.\\n\\nConsumers SHOULD take appropriate precautions when consuming SVGs as they can contain\\nexecutable JavaScript.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    },"]
#[doc = "    \"theme\": {"]
#[doc = "      \"description\": \"Optional specifier for the theme this icon is designed for. `light` indicates\\nthe icon is designed to be used with a light background, and `dark` indicates\\nthe icon is designed to be used with a dark background.\\n\\nIf not provided, the client should assume the icon can be used with any theme.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"dark\","]
#[doc = "        \"light\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Icon {
    #[doc = "Optional MIME type override if the source MIME type is missing or generic.\nFor example: `\"image/png\"`, `\"image/jpeg\"`, or `\"image/svg+xml\"`."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "Optional array of strings that specify sizes at which the icon can be used.\nEach string should be in WxH format (e.g., `\"48x48\"`, `\"96x96\"`) or `\"any\"` for scalable formats like SVG.\n\nIf not provided, the client should assume that the icon can be used at any size."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub sizes: ::std::vec::Vec<::std::string::String>,
    #[doc = "A standard URI pointing to an icon resource. May be an HTTP/HTTPS URL or a\n`data:` URI with Base64-encoded image data.\n\nConsumers SHOULD takes steps to ensure URLs serving icons are from the\nsame domain as the client/server or a trusted domain.\n\nConsumers SHOULD take appropriate precautions when consuming SVGs as they can contain\nexecutable JavaScript."]
    pub src: ::std::string::String,
    #[doc = "Optional specifier for the theme this icon is designed for. `light` indicates\nthe icon is designed to be used with a light background, and `dark` indicates\nthe icon is designed to be used with a dark background.\n\nIf not provided, the client should assume the icon can be used with any theme."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub theme: ::std::option::Option<IconTheme>,
}
impl ::std::convert::From<&Icon> for Icon {
    fn from(value: &Icon) -> Self {
        value.clone()
    }
}
impl Icon {
    pub fn builder() -> builder::Icon {
        Default::default()
    }
}
#[doc = "Optional specifier for the theme this icon is designed for. `light` indicates\nthe icon is designed to be used with a light background, and `dark` indicates\nthe icon is designed to be used with a dark background.\n\nIf not provided, the client should assume the icon can be used with any theme."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Optional specifier for the theme this icon is designed for. `light` indicates\\nthe icon is designed to be used with a light background, and `dark` indicates\\nthe icon is designed to be used with a dark background.\\n\\nIf not provided, the client should assume the icon can be used with any theme.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"dark\","]
#[doc = "    \"light\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IconTheme {
    #[serde(rename = "dark")]
    Dark,
    #[serde(rename = "light")]
    Light,
}
impl ::std::convert::From<&Self> for IconTheme {
    fn from(value: &IconTheme) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IconTheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dark => write!(f, "dark"),
            Self::Light => write!(f, "light"),
        }
    }
}
impl ::std::str::FromStr for IconTheme {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dark" => Ok(Self::Dark),
            "light" => Ok(Self::Light),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IconTheme {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IconTheme {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IconTheme {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Base interface to add `icons` property."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Base interface to add `icons` property.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Icons {
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
}
impl ::std::convert::From<&Icons> for Icons {
    fn from(value: &Icons) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Icons {
    fn default() -> Self {
        Self {
            icons: Default::default(),
        }
    }
}
impl Icons {
    pub fn builder() -> builder::Icons {
        Default::default()
    }
}
#[doc = "An image provided to or from an LLM."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An image provided to or from an LLM.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data\","]
#[doc = "    \"mimeType\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"The base64-encoded image data.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"byte\""]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of the image. Different providers may support different image types.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"image\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ImageContent {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[doc = "The base64-encoded image data."]
    pub data: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ImageContentMeta>,
    #[doc = "The MIME type of the image. Different providers may support different image types."]
    #[serde(rename = "mimeType")]
    pub mime_type: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ImageContent> for ImageContent {
    fn from(value: &ImageContent) -> Self {
        value.clone()
    }
}
impl ImageContent {
    pub fn builder() -> builder::ImageContent {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ImageContentMeta {}
impl ::std::convert::From<&ImageContentMeta> for ImageContentMeta {
    fn from(value: &ImageContentMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ImageContentMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ImageContentMeta {
    pub fn builder() -> builder::ImageContentMeta {
        Default::default()
    }
}
#[doc = "Describes the MCP implementation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the MCP implementation.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"An optional human-readable description of what this implementation does.\\n\\nThis can be used by clients or servers to provide context about their purpose\\nand capabilities. For example, a server might describe the types of resources\\nor tools it provides, while a client might describe its intended use case.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"websiteUrl\": {"]
#[doc = "      \"description\": \"An optional URL of the website for this implementation.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Implementation {
    #[doc = "An optional human-readable description of what this implementation does.\n\nThis can be used by clients or servers to provide context about their purpose\nand capabilities. For example, a server might describe the types of resources\nor tools it provides, while a client might describe its intended use case."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    pub version: ::std::string::String,
    #[doc = "An optional URL of the website for this implementation."]
    #[serde(
        rename = "websiteUrl",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub website_url: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Implementation> for Implementation {
    fn from(value: &Implementation) -> Self {
        value.clone()
    }
}
impl Implementation {
    pub fn builder() -> builder::Implementation {
        Default::default()
    }
}
#[doc = "This request is sent from the client to the server when it first connects, asking it to begin initialization."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This request is sent from the client to the server when it first connects, asking it to begin initialization.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"initialize\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/InitializeRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: InitializeRequestParams,
}
impl ::std::convert::From<&InitializeRequest> for InitializeRequest {
    fn from(value: &InitializeRequest) -> Self {
        value.clone()
    }
}
impl InitializeRequest {
    pub fn builder() -> builder::InitializeRequest {
        Default::default()
    }
}
#[doc = "Parameters for an `initialize` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for an `initialize` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"capabilities\","]
#[doc = "    \"clientInfo\","]
#[doc = "    \"protocolVersion\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"capabilities\": {"]
#[doc = "      \"$ref\": \"#/$defs/ClientCapabilities\""]
#[doc = "    },"]
#[doc = "    \"clientInfo\": {"]
#[doc = "      \"$ref\": \"#/$defs/Implementation\""]
#[doc = "    },"]
#[doc = "    \"protocolVersion\": {"]
#[doc = "      \"description\": \"The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeRequestParams {
    pub capabilities: ClientCapabilities,
    #[serde(rename = "clientInfo")]
    pub client_info: Implementation,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<InitializeRequestParamsMeta>,
    #[doc = "The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well."]
    #[serde(rename = "protocolVersion")]
    pub protocol_version: ::std::string::String,
}
impl ::std::convert::From<&InitializeRequestParams> for InitializeRequestParams {
    fn from(value: &InitializeRequestParams) -> Self {
        value.clone()
    }
}
impl InitializeRequestParams {
    pub fn builder() -> builder::InitializeRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InitializeRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&InitializeRequestParamsMeta> for InitializeRequestParamsMeta {
    fn from(value: &InitializeRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InitializeRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl InitializeRequestParamsMeta {
    pub fn builder() -> builder::InitializeRequestParamsMeta {
        Default::default()
    }
}
#[doc = "After receiving an initialize request from the client, the server sends this response."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"After receiving an initialize request from the client, the server sends this response.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"capabilities\","]
#[doc = "    \"protocolVersion\","]
#[doc = "    \"serverInfo\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"capabilities\": {"]
#[doc = "      \"$ref\": \"#/$defs/ServerCapabilities\""]
#[doc = "    },"]
#[doc = "    \"instructions\": {"]
#[doc = "      \"description\": \"Instructions describing how to use the server and its features.\\n\\nThis can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \\\"hint\\\" to the model. For example, this information MAY be added to the system prompt.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"protocolVersion\": {"]
#[doc = "      \"description\": \"The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"serverInfo\": {"]
#[doc = "      \"$ref\": \"#/$defs/Implementation\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializeResult {
    pub capabilities: ServerCapabilities,
    #[doc = "Instructions describing how to use the server and its features.\n\nThis can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub instructions: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<InitializeResultMeta>,
    #[doc = "The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect."]
    #[serde(rename = "protocolVersion")]
    pub protocol_version: ::std::string::String,
    #[serde(rename = "serverInfo")]
    pub server_info: Implementation,
}
impl ::std::convert::From<&InitializeResult> for InitializeResult {
    fn from(value: &InitializeResult) -> Self {
        value.clone()
    }
}
impl InitializeResult {
    pub fn builder() -> builder::InitializeResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InitializeResultMeta {}
impl ::std::convert::From<&InitializeResultMeta> for InitializeResultMeta {
    fn from(value: &InitializeResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for InitializeResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl InitializeResultMeta {
    pub fn builder() -> builder::InitializeResultMeta {
        Default::default()
    }
}
#[doc = "This notification is sent from the client to the server after initialization has finished."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This notification is sent from the client to the server after initialization has finished.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/initialized\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct InitializedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&InitializedNotification> for InitializedNotification {
    fn from(value: &InitializedNotification) -> Self {
        value.clone()
    }
}
impl InitializedNotification {
    pub fn builder() -> builder::InitializedNotification {
        Default::default()
    }
}
#[doc = "A response to a request that indicates an error occurred."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A response to a request that indicates an error occurred.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"$ref\": \"#/$defs/Error\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonrpcErrorResponse {
    pub error: Error,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<RequestId>,
    pub jsonrpc: ::std::string::String,
}
impl ::std::convert::From<&JsonrpcErrorResponse> for JsonrpcErrorResponse {
    fn from(value: &JsonrpcErrorResponse) -> Self {
        value.clone()
    }
}
impl JsonrpcErrorResponse {
    pub fn builder() -> builder::JsonrpcErrorResponse {
        Default::default()
    }
}
#[doc = "Refers to any valid JSON-RPC object that can be decoded off the wire, or encoded to be sent."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Refers to any valid JSON-RPC object that can be decoded off the wire, or encoded to be sent.\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCResultResponse\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCErrorResponse\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonrpcMessage {
    Request(JsonrpcRequest),
    Notification(JsonrpcNotification),
    ResultResponse(JsonrpcResultResponse),
    ErrorResponse(JsonrpcErrorResponse),
}
impl ::std::convert::From<&Self> for JsonrpcMessage {
    fn from(value: &JsonrpcMessage) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<JsonrpcRequest> for JsonrpcMessage {
    fn from(value: JsonrpcRequest) -> Self {
        Self::Request(value)
    }
}
impl ::std::convert::From<JsonrpcNotification> for JsonrpcMessage {
    fn from(value: JsonrpcNotification) -> Self {
        Self::Notification(value)
    }
}
impl ::std::convert::From<JsonrpcResultResponse> for JsonrpcMessage {
    fn from(value: JsonrpcResultResponse) -> Self {
        Self::ResultResponse(value)
    }
}
impl ::std::convert::From<JsonrpcErrorResponse> for JsonrpcMessage {
    fn from(value: JsonrpcErrorResponse) -> Self {
        Self::ErrorResponse(value)
    }
}
#[doc = "A notification which does not expect a response."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A notification which does not expect a response.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonrpcNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<JsonrpcNotificationParams>,
}
impl ::std::convert::From<&JsonrpcNotification> for JsonrpcNotification {
    fn from(value: &JsonrpcNotification) -> Self {
        value.clone()
    }
}
impl JsonrpcNotification {
    pub fn builder() -> builder::JsonrpcNotification {
        Default::default()
    }
}
#[doc = "`JsonrpcNotificationParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct JsonrpcNotificationParams {}
impl ::std::convert::From<&JsonrpcNotificationParams> for JsonrpcNotificationParams {
    fn from(value: &JsonrpcNotificationParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for JsonrpcNotificationParams {
    fn default() -> Self {
        Self {}
    }
}
impl JsonrpcNotificationParams {
    pub fn builder() -> builder::JsonrpcNotificationParams {
        Default::default()
    }
}
#[doc = "A request that expects a response."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request that expects a response.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonrpcRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<JsonrpcRequestParams>,
}
impl ::std::convert::From<&JsonrpcRequest> for JsonrpcRequest {
    fn from(value: &JsonrpcRequest) -> Self {
        value.clone()
    }
}
impl JsonrpcRequest {
    pub fn builder() -> builder::JsonrpcRequest {
        Default::default()
    }
}
#[doc = "`JsonrpcRequestParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct JsonrpcRequestParams {}
impl ::std::convert::From<&JsonrpcRequestParams> for JsonrpcRequestParams {
    fn from(value: &JsonrpcRequestParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for JsonrpcRequestParams {
    fn default() -> Self {
        Self {}
    }
}
impl JsonrpcRequestParams {
    pub fn builder() -> builder::JsonrpcRequestParams {
        Default::default()
    }
}
#[doc = "A response to a request, containing either the result or error."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A response to a request, containing either the result or error.\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCResultResponse\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/JSONRPCErrorResponse\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonrpcResponse {
    ResultResponse(JsonrpcResultResponse),
    ErrorResponse(JsonrpcErrorResponse),
}
impl ::std::convert::From<&Self> for JsonrpcResponse {
    fn from(value: &JsonrpcResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<JsonrpcResultResponse> for JsonrpcResponse {
    fn from(value: JsonrpcResultResponse) -> Self {
        Self::ResultResponse(value)
    }
}
impl ::std::convert::From<JsonrpcErrorResponse> for JsonrpcResponse {
    fn from(value: JsonrpcErrorResponse) -> Self {
        Self::ErrorResponse(value)
    }
}
#[doc = "A successful (non-error) response to a request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A successful (non-error) response to a request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"$ref\": \"#/$defs/Result\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonrpcResultResponse {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub result: Result,
}
impl ::std::convert::From<&JsonrpcResultResponse> for JsonrpcResultResponse {
    fn from(value: &JsonrpcResultResponse) -> Self {
        value.clone()
    }
}
impl JsonrpcResultResponse {
    pub fn builder() -> builder::JsonrpcResultResponse {
        Default::default()
    }
}
#[doc = "Use TitledSingleSelectEnumSchema instead.\nThis interface will be removed in a future version."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Use TitledSingleSelectEnumSchema instead.\\nThis interface will be removed in a future version.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"enum\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"enum\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"enumNames\": {"]
#[doc = "      \"description\": \"(Legacy) Display names for enum values.\\nNon-standard according to JSON schema 2020-12.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LegacyTitledEnumSchema {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(rename = "enum")]
    pub enum_: ::std::vec::Vec<::std::string::String>,
    #[doc = "(Legacy) Display names for enum values.\nNon-standard according to JSON schema 2020-12."]
    #[serde(
        rename = "enumNames",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub enum_names: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&LegacyTitledEnumSchema> for LegacyTitledEnumSchema {
    fn from(value: &LegacyTitledEnumSchema) -> Self {
        value.clone()
    }
}
impl LegacyTitledEnumSchema {
    pub fn builder() -> builder::LegacyTitledEnumSchema {
        Default::default()
    }
}
#[doc = "Sent from the client to request a list of prompts and prompt templates the server has."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request a list of prompts and prompt templates the server has.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"prompts/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListPromptsRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&ListPromptsRequest> for ListPromptsRequest {
    fn from(value: &ListPromptsRequest) -> Self {
        value.clone()
    }
}
impl ListPromptsRequest {
    pub fn builder() -> builder::ListPromptsRequest {
        Default::default()
    }
}
#[doc = "The server's response to a prompts/list request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a prompts/list request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"prompts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"prompts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Prompt\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListPromptsResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListPromptsResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
    pub prompts: ::std::vec::Vec<Prompt>,
}
impl ::std::convert::From<&ListPromptsResult> for ListPromptsResult {
    fn from(value: &ListPromptsResult) -> Self {
        value.clone()
    }
}
impl ListPromptsResult {
    pub fn builder() -> builder::ListPromptsResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListPromptsResultMeta {}
impl ::std::convert::From<&ListPromptsResultMeta> for ListPromptsResultMeta {
    fn from(value: &ListPromptsResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListPromptsResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListPromptsResultMeta {
    pub fn builder() -> builder::ListPromptsResultMeta {
        Default::default()
    }
}
#[doc = "Sent from the client to request a list of resource templates the server has."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request a list of resource templates the server has.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resources/templates/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListResourceTemplatesRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&ListResourceTemplatesRequest> for ListResourceTemplatesRequest {
    fn from(value: &ListResourceTemplatesRequest) -> Self {
        value.clone()
    }
}
impl ListResourceTemplatesRequest {
    pub fn builder() -> builder::ListResourceTemplatesRequest {
        Default::default()
    }
}
#[doc = "The server's response to a resources/templates/list request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a resources/templates/list request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"resourceTemplates\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"resourceTemplates\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/ResourceTemplate\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListResourceTemplatesResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListResourceTemplatesResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
    #[serde(rename = "resourceTemplates")]
    pub resource_templates: ::std::vec::Vec<ResourceTemplate>,
}
impl ::std::convert::From<&ListResourceTemplatesResult> for ListResourceTemplatesResult {
    fn from(value: &ListResourceTemplatesResult) -> Self {
        value.clone()
    }
}
impl ListResourceTemplatesResult {
    pub fn builder() -> builder::ListResourceTemplatesResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListResourceTemplatesResultMeta {}
impl ::std::convert::From<&ListResourceTemplatesResultMeta> for ListResourceTemplatesResultMeta {
    fn from(value: &ListResourceTemplatesResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListResourceTemplatesResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListResourceTemplatesResultMeta {
    pub fn builder() -> builder::ListResourceTemplatesResultMeta {
        Default::default()
    }
}
#[doc = "Sent from the client to request a list of resources the server has."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request a list of resources the server has.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resources/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListResourcesRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&ListResourcesRequest> for ListResourcesRequest {
    fn from(value: &ListResourcesRequest) -> Self {
        value.clone()
    }
}
impl ListResourcesRequest {
    pub fn builder() -> builder::ListResourcesRequest {
        Default::default()
    }
}
#[doc = "The server's response to a resources/list request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a resources/list request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"resources\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"resources\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Resource\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListResourcesResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListResourcesResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
    pub resources: ::std::vec::Vec<Resource>,
}
impl ::std::convert::From<&ListResourcesResult> for ListResourcesResult {
    fn from(value: &ListResourcesResult) -> Self {
        value.clone()
    }
}
impl ListResourcesResult {
    pub fn builder() -> builder::ListResourcesResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListResourcesResultMeta {}
impl ::std::convert::From<&ListResourcesResultMeta> for ListResourcesResultMeta {
    fn from(value: &ListResourcesResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListResourcesResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListResourcesResultMeta {
    pub fn builder() -> builder::ListResourcesResultMeta {
        Default::default()
    }
}
#[doc = "Sent from the server to request a list of root URIs from the client. Roots allow\nservers to ask for specific directories or files to operate on. A common example\nfor roots is providing a set of repositories or directories a server should operate\non.\n\nThis request is typically used when the server needs to understand the file system\nstructure or access specific locations that the client has permission to read from."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the server to request a list of root URIs from the client. Roots allow\\nservers to ask for specific directories or files to operate on. A common example\\nfor roots is providing a set of repositories or directories a server should operate\\non.\\n\\nThis request is typically used when the server needs to understand the file system\\nstructure or access specific locations that the client has permission to read from.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"roots/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListRootsRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<RequestParams>,
}
impl ::std::convert::From<&ListRootsRequest> for ListRootsRequest {
    fn from(value: &ListRootsRequest) -> Self {
        value.clone()
    }
}
impl ListRootsRequest {
    pub fn builder() -> builder::ListRootsRequest {
        Default::default()
    }
}
#[doc = "The client's response to a roots/list request from the server.\nThis result contains an array of Root objects, each representing a root directory\nor file that the server can operate on."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The client's response to a roots/list request from the server.\\nThis result contains an array of Root objects, each representing a root directory\\nor file that the server can operate on.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"roots\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"roots\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Root\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListRootsResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListRootsResultMeta>,
    pub roots: ::std::vec::Vec<Root>,
}
impl ::std::convert::From<&ListRootsResult> for ListRootsResult {
    fn from(value: &ListRootsResult) -> Self {
        value.clone()
    }
}
impl ListRootsResult {
    pub fn builder() -> builder::ListRootsResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListRootsResultMeta {}
impl ::std::convert::From<&ListRootsResultMeta> for ListRootsResultMeta {
    fn from(value: &ListRootsResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListRootsResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListRootsResultMeta {
    pub fn builder() -> builder::ListRootsResultMeta {
        Default::default()
    }
}
#[doc = "A request to retrieve a list of tasks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request to retrieve a list of tasks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tasks/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListTasksRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&ListTasksRequest> for ListTasksRequest {
    fn from(value: &ListTasksRequest) -> Self {
        value.clone()
    }
}
impl ListTasksRequest {
    pub fn builder() -> builder::ListTasksRequest {
        Default::default()
    }
}
#[doc = "The response to a tasks/list request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The response to a tasks/list request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"tasks\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tasks\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Task\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListTasksResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListTasksResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
    pub tasks: ::std::vec::Vec<Task>,
}
impl ::std::convert::From<&ListTasksResult> for ListTasksResult {
    fn from(value: &ListTasksResult) -> Self {
        value.clone()
    }
}
impl ListTasksResult {
    pub fn builder() -> builder::ListTasksResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListTasksResultMeta {}
impl ::std::convert::From<&ListTasksResultMeta> for ListTasksResultMeta {
    fn from(value: &ListTasksResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListTasksResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListTasksResultMeta {
    pub fn builder() -> builder::ListTasksResultMeta {
        Default::default()
    }
}
#[doc = "Sent from the client to request a list of tools the server has."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request a list of tools the server has.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tools/list\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListToolsRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&ListToolsRequest> for ListToolsRequest {
    fn from(value: &ListToolsRequest) -> Self {
        value.clone()
    }
}
impl ListToolsRequest {
    pub fn builder() -> builder::ListToolsRequest {
        Default::default()
    }
}
#[doc = "The server's response to a tools/list request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a tools/list request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"tools\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tools\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Tool\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListToolsResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ListToolsResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
    pub tools: ::std::vec::Vec<Tool>,
}
impl ::std::convert::From<&ListToolsResult> for ListToolsResult {
    fn from(value: &ListToolsResult) -> Self {
        value.clone()
    }
}
impl ListToolsResult {
    pub fn builder() -> builder::ListToolsResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ListToolsResultMeta {}
impl ::std::convert::From<&ListToolsResultMeta> for ListToolsResultMeta {
    fn from(value: &ListToolsResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ListToolsResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ListToolsResultMeta {
    pub fn builder() -> builder::ListToolsResultMeta {
        Default::default()
    }
}
#[doc = "The severity of a log message.\n\nThese map to syslog message severities, as specified in RFC-5424:\nhttps://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The severity of a log message.\\n\\nThese map to syslog message severities, as specified in RFC-5424:\\nhttps://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"alert\","]
#[doc = "    \"critical\","]
#[doc = "    \"debug\","]
#[doc = "    \"emergency\","]
#[doc = "    \"error\","]
#[doc = "    \"info\","]
#[doc = "    \"notice\","]
#[doc = "    \"warning\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoggingLevel {
    #[serde(rename = "alert")]
    Alert,
    #[serde(rename = "critical")]
    Critical,
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "emergency")]
    Emergency,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "notice")]
    Notice,
    #[serde(rename = "warning")]
    Warning,
}
impl ::std::convert::From<&Self> for LoggingLevel {
    fn from(value: &LoggingLevel) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoggingLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Alert => write!(f, "alert"),
            Self::Critical => write!(f, "critical"),
            Self::Debug => write!(f, "debug"),
            Self::Emergency => write!(f, "emergency"),
            Self::Error => write!(f, "error"),
            Self::Info => write!(f, "info"),
            Self::Notice => write!(f, "notice"),
            Self::Warning => write!(f, "warning"),
        }
    }
}
impl ::std::str::FromStr for LoggingLevel {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "alert" => Ok(Self::Alert),
            "critical" => Ok(Self::Critical),
            "debug" => Ok(Self::Debug),
            "emergency" => Ok(Self::Emergency),
            "error" => Ok(Self::Error),
            "info" => Ok(Self::Info),
            "notice" => Ok(Self::Notice),
            "warning" => Ok(Self::Warning),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoggingLevel {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoggingLevel {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoggingLevel {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "JSONRPCNotification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"JSONRPCNotification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/message\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/LoggingMessageNotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoggingMessageNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: LoggingMessageNotificationParams,
}
impl ::std::convert::From<&LoggingMessageNotification> for LoggingMessageNotification {
    fn from(value: &LoggingMessageNotification) -> Self {
        value.clone()
    }
}
impl LoggingMessageNotification {
    pub fn builder() -> builder::LoggingMessageNotification {
        Default::default()
    }
}
#[doc = "Parameters for a `notifications/message` notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `notifications/message` notification.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data\","]
#[doc = "    \"level\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\""]
#[doc = "    },"]
#[doc = "    \"level\": {"]
#[doc = "      \"description\": \"The severity of this log message.\","]
#[doc = "      \"$ref\": \"#/$defs/LoggingLevel\""]
#[doc = "    },"]
#[doc = "    \"logger\": {"]
#[doc = "      \"description\": \"An optional name of the logger issuing this message.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LoggingMessageNotificationParams {
    #[doc = "The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here."]
    pub data: ::serde_json::Value,
    #[doc = "The severity of this log message."]
    pub level: LoggingLevel,
    #[doc = "An optional name of the logger issuing this message."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub logger: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<LoggingMessageNotificationParamsMeta>,
}
impl ::std::convert::From<&LoggingMessageNotificationParams> for LoggingMessageNotificationParams {
    fn from(value: &LoggingMessageNotificationParams) -> Self {
        value.clone()
    }
}
impl LoggingMessageNotificationParams {
    pub fn builder() -> builder::LoggingMessageNotificationParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LoggingMessageNotificationParamsMeta {}
impl ::std::convert::From<&LoggingMessageNotificationParamsMeta>
    for LoggingMessageNotificationParamsMeta
{
    fn from(value: &LoggingMessageNotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LoggingMessageNotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl LoggingMessageNotificationParamsMeta {
    pub fn builder() -> builder::LoggingMessageNotificationParamsMeta {
        Default::default()
    }
}
#[doc = "Hints to use for model selection.\n\nKeys not declared here are currently left unspecified by the spec and are up\nto the client to interpret."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Hints to use for model selection.\\n\\nKeys not declared here are currently left unspecified by the spec and are up\\nto the client to interpret.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"A hint for a model name.\\n\\nThe client SHOULD treat this as a substring of a model name; for example:\\n - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`\\n - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.\\n - `claude` should match any Claude model\\n\\nThe client MAY also map the string to a different provider's model name or a different model family, as long as it fills a similar niche; for example:\\n - `gemini-1.5-flash` could match `claude-3-haiku-20240307`\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModelHint {
    #[doc = "A hint for a model name.\n\nThe client SHOULD treat this as a substring of a model name; for example:\n - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`\n - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.\n - `claude` should match any Claude model\n\nThe client MAY also map the string to a different provider's model name or a different model family, as long as it fills a similar niche; for example:\n - `gemini-1.5-flash` could match `claude-3-haiku-20240307`"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ModelHint> for ModelHint {
    fn from(value: &ModelHint) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ModelHint {
    fn default() -> Self {
        Self {
            name: Default::default(),
        }
    }
}
impl ModelHint {
    pub fn builder() -> builder::ModelHint {
        Default::default()
    }
}
#[doc = "The server's preferences for model selection, requested of the client during sampling.\n\nBecause LLMs can vary along multiple dimensions, choosing the \"best\" model is\nrarely straightforward.  Different models excel in different areas—some are\nfaster but less capable, others are more capable but more expensive, and so\non. This interface allows servers to express their priorities across multiple\ndimensions to help clients make an appropriate selection for their use case.\n\nThese preferences are always advisory. The client MAY ignore them. It is also\nup to the client to decide how to interpret these preferences and how to\nbalance them against other considerations."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's preferences for model selection, requested of the client during sampling.\\n\\nBecause LLMs can vary along multiple dimensions, choosing the \\\"best\\\" model is\\nrarely straightforward.  Different models excel in different areas—some are\\nfaster but less capable, others are more capable but more expensive, and so\\non. This interface allows servers to express their priorities across multiple\\ndimensions to help clients make an appropriate selection for their use case.\\n\\nThese preferences are always advisory. The client MAY ignore them. It is also\\nup to the client to decide how to interpret these preferences and how to\\nbalance them against other considerations.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"costPriority\": {"]
#[doc = "      \"description\": \"How much to prioritize cost when selecting a model. A value of 0 means cost\\nis not important, while a value of 1 means cost is the most important\\nfactor.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"maximum\": 1.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"hints\": {"]
#[doc = "      \"description\": \"Optional hints to use for model selection.\\n\\nIf multiple hints are specified, the client MUST evaluate them in order\\n(such that the first match is taken).\\n\\nThe client SHOULD prioritize these hints over the numeric priorities, but\\nMAY still use the priorities to select from ambiguous matches.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/ModelHint\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"intelligencePriority\": {"]
#[doc = "      \"description\": \"How much to prioritize intelligence and capabilities when selecting a\\nmodel. A value of 0 means intelligence is not important, while a value of 1\\nmeans intelligence is the most important factor.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"maximum\": 1.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"speedPriority\": {"]
#[doc = "      \"description\": \"How much to prioritize sampling speed (latency) when selecting a model. A\\nvalue of 0 means speed is not important, while a value of 1 means speed is\\nthe most important factor.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"maximum\": 1.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ModelPreferences {
    #[serde(
        rename = "costPriority",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cost_priority: ::std::option::Option<f64>,
    #[doc = "Optional hints to use for model selection.\n\nIf multiple hints are specified, the client MUST evaluate them in order\n(such that the first match is taken).\n\nThe client SHOULD prioritize these hints over the numeric priorities, but\nMAY still use the priorities to select from ambiguous matches."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub hints: ::std::vec::Vec<ModelHint>,
    #[serde(
        rename = "intelligencePriority",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub intelligence_priority: ::std::option::Option<f64>,
    #[serde(
        rename = "speedPriority",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub speed_priority: ::std::option::Option<f64>,
}
impl ::std::convert::From<&ModelPreferences> for ModelPreferences {
    fn from(value: &ModelPreferences) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ModelPreferences {
    fn default() -> Self {
        Self {
            cost_priority: Default::default(),
            hints: Default::default(),
            intelligence_priority: Default::default(),
            speed_priority: Default::default(),
        }
    }
}
impl ModelPreferences {
    pub fn builder() -> builder::ModelPreferences {
        Default::default()
    }
}
#[doc = "`MultiSelectEnumSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledMultiSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledMultiSelectEnumSchema\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MultiSelectEnumSchema {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<UntitledMultiSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<TitledMultiSelectEnumSchema>,
}
impl ::std::convert::From<&MultiSelectEnumSchema> for MultiSelectEnumSchema {
    fn from(value: &MultiSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for MultiSelectEnumSchema {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
        }
    }
}
impl MultiSelectEnumSchema {
    pub fn builder() -> builder::MultiSelectEnumSchema {
        Default::default()
    }
}
#[doc = "`Notification`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Notification {
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&Notification> for Notification {
    fn from(value: &Notification) -> Self {
        value.clone()
    }
}
impl Notification {
    pub fn builder() -> builder::Notification {
        Default::default()
    }
}
#[doc = "`NotificationParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NotificationParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<NotificationParamsMeta>,
}
impl ::std::convert::From<&NotificationParams> for NotificationParams {
    fn from(value: &NotificationParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NotificationParams {
    fn default() -> Self {
        Self {
            meta: Default::default(),
        }
    }
}
impl NotificationParams {
    pub fn builder() -> builder::NotificationParams {
        Default::default()
    }
}

#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NotificationParamsMeta {}
impl ::std::convert::From<&NotificationParamsMeta> for NotificationParamsMeta {
    fn from(value: &NotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl NotificationParamsMeta {
    pub fn builder() -> builder::NotificationParamsMeta {
        Default::default()
    }
}
#[doc = "`NumberSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"maximum\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"minimum\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"number\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NumberSchema {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub maximum: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub minimum: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: NumberSchemaType,
}
impl ::std::convert::From<&NumberSchema> for NumberSchema {
    fn from(value: &NumberSchema) -> Self {
        value.clone()
    }
}
impl NumberSchema {
    pub fn builder() -> builder::NumberSchema {
        Default::default()
    }
}
#[doc = "`NumberSchemaType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"integer\","]
#[doc = "    \"number\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NumberSchemaType {
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "number")]
    Number,
}
impl ::std::convert::From<&Self> for NumberSchemaType {
    fn from(value: &NumberSchemaType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NumberSchemaType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Integer => write!(f, "integer"),
            Self::Number => write!(f, "number"),
        }
    }
}
impl ::std::str::FromStr for NumberSchemaType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "integer" => Ok(Self::Integer),
            "number" => Ok(Self::Number),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberSchemaType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberSchemaType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberSchemaType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PaginatedRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/PaginatedRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PaginatedRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<PaginatedRequestParams>,
}
impl ::std::convert::From<&PaginatedRequest> for PaginatedRequest {
    fn from(value: &PaginatedRequest) -> Self {
        value.clone()
    }
}
impl PaginatedRequest {
    pub fn builder() -> builder::PaginatedRequest {
        Default::default()
    }
}
#[doc = "Common parameters for paginated requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Common parameters for paginated requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"cursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the current pagination position.\\nIf provided, the server should return results starting after this cursor.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PaginatedRequestParams {
    #[doc = "An opaque token representing the current pagination position.\nIf provided, the server should return results starting after this cursor."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cursor: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<PaginatedRequestParamsMeta>,
}
impl ::std::convert::From<&PaginatedRequestParams> for PaginatedRequestParams {
    fn from(value: &PaginatedRequestParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PaginatedRequestParams {
    fn default() -> Self {
        Self {
            cursor: Default::default(),
            meta: Default::default(),
        }
    }
}
impl PaginatedRequestParams {
    pub fn builder() -> builder::PaginatedRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PaginatedRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&PaginatedRequestParamsMeta> for PaginatedRequestParamsMeta {
    fn from(value: &PaginatedRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PaginatedRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl PaginatedRequestParamsMeta {
    pub fn builder() -> builder::PaginatedRequestParamsMeta {
        Default::default()
    }
}
#[doc = "`PaginatedResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nextCursor\": {"]
#[doc = "      \"description\": \"An opaque token representing the pagination position after the last returned result.\\nIf present, there may be more results available.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PaginatedResult {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<PaginatedResultMeta>,
    #[doc = "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."]
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub next_cursor: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&PaginatedResult> for PaginatedResult {
    fn from(value: &PaginatedResult) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PaginatedResult {
    fn default() -> Self {
        Self {
            meta: Default::default(),
            next_cursor: Default::default(),
        }
    }
}
impl PaginatedResult {
    pub fn builder() -> builder::PaginatedResult {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PaginatedResultMeta {}
impl ::std::convert::From<&PaginatedResultMeta> for PaginatedResultMeta {
    fn from(value: &PaginatedResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PaginatedResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl PaginatedResultMeta {
    pub fn builder() -> builder::PaginatedResultMeta {
        Default::default()
    }
}
#[doc = "A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"ping\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PingRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<RequestParams>,
}
impl ::std::convert::From<&PingRequest> for PingRequest {
    fn from(value: &PingRequest) -> Self {
        value.clone()
    }
}
impl PingRequest {
    pub fn builder() -> builder::PingRequest {
        Default::default()
    }
}
#[doc = "Restricted schema definitions that only allow primitive types\nwithout nested objects or arrays."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Restricted schema definitions that only allow primitive types\\nwithout nested objects or arrays.\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/StringSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/NumberSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/BooleanSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledSingleSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledSingleSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledMultiSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledMultiSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/LegacyTitledEnumSchema\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PrimitiveSchemaDefinition {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<StringSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<NumberSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_2: ::std::option::Option<BooleanSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_3: ::std::option::Option<UntitledSingleSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_4: ::std::option::Option<TitledSingleSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_5: ::std::option::Option<UntitledMultiSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_6: ::std::option::Option<TitledMultiSelectEnumSchema>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_7: ::std::option::Option<LegacyTitledEnumSchema>,
}
impl ::std::convert::From<&PrimitiveSchemaDefinition> for PrimitiveSchemaDefinition {
    fn from(value: &PrimitiveSchemaDefinition) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PrimitiveSchemaDefinition {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
            subtype_2: Default::default(),
            subtype_3: Default::default(),
            subtype_4: Default::default(),
            subtype_5: Default::default(),
            subtype_6: Default::default(),
            subtype_7: Default::default(),
        }
    }
}
impl PrimitiveSchemaDefinition {
    pub fn builder() -> builder::PrimitiveSchemaDefinition {
        Default::default()
    }
}
#[doc = "An out-of-band notification used to inform the receiver of a progress update for a long-running request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An out-of-band notification used to inform the receiver of a progress update for a long-running request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/progress\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/ProgressNotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: ProgressNotificationParams,
}
impl ::std::convert::From<&ProgressNotification> for ProgressNotification {
    fn from(value: &ProgressNotification) -> Self {
        value.clone()
    }
}
impl ProgressNotification {
    pub fn builder() -> builder::ProgressNotification {
        Default::default()
    }
}
#[doc = "Parameters for a `notifications/progress` notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `notifications/progress` notification.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"progress\","]
#[doc = "    \"progressToken\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"An optional message describing the current progress.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"progress\": {"]
#[doc = "      \"description\": \"The progress thus far. This should increase every time progress is made, even if the total is unknown.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    },"]
#[doc = "    \"total\": {"]
#[doc = "      \"description\": \"Total number of items to process (or total progress required), if known.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ProgressNotificationParams {
    #[doc = "An optional message describing the current progress."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ProgressNotificationParamsMeta>,
    pub progress: f64,
    #[doc = "The progress token which was given in the initial request, used to associate this notification with the request that is proceeding."]
    #[serde(rename = "progressToken")]
    pub progress_token: ProgressToken,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub total: ::std::option::Option<f64>,
}
impl ::std::convert::From<&ProgressNotificationParams> for ProgressNotificationParams {
    fn from(value: &ProgressNotificationParams) -> Self {
        value.clone()
    }
}
impl ProgressNotificationParams {
    pub fn builder() -> builder::ProgressNotificationParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProgressNotificationParamsMeta {}
impl ::std::convert::From<&ProgressNotificationParamsMeta> for ProgressNotificationParamsMeta {
    fn from(value: &ProgressNotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ProgressNotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ProgressNotificationParamsMeta {
    pub fn builder() -> builder::ProgressNotificationParamsMeta {
        Default::default()
    }
}
#[doc = "A progress token, used to associate progress notifications with the original request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A progress token, used to associate progress notifications with the original request.\","]
#[doc = "  \"type\": ["]
#[doc = "    \"string\","]
#[doc = "    \"integer\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProgressToken {
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for ProgressToken {
    fn from(value: &ProgressToken) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ProgressToken {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::String(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Integer(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProgressToken {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProgressToken {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProgressToken {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ProgressToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::String(x) => x.fmt(f),
            Self::Integer(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for ProgressToken {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
#[doc = "A prompt or prompt template that the server offers."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A prompt or prompt template that the server offers.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"description\": \"A list of arguments to use for templating the prompt.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/PromptArgument\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"An optional description of what this prompt provides\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Prompt {
    #[doc = "A list of arguments to use for templating the prompt."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub arguments: ::std::vec::Vec<PromptArgument>,
    #[doc = "An optional description of what this prompt provides"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<PromptMeta>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Prompt> for Prompt {
    fn from(value: &Prompt) -> Self {
        value.clone()
    }
}
impl Prompt {
    pub fn builder() -> builder::Prompt {
        Default::default()
    }
}
#[doc = "Describes an argument that a prompt can accept."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes an argument that a prompt can accept.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A human-readable description of the argument.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"required\": {"]
#[doc = "      \"description\": \"Whether this argument must be provided.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PromptArgument {
    #[doc = "A human-readable description of the argument."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Whether this argument must be provided."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub required: ::std::option::Option<bool>,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&PromptArgument> for PromptArgument {
    fn from(value: &PromptArgument) -> Self {
        value.clone()
    }
}
impl PromptArgument {
    pub fn builder() -> builder::PromptArgument {
        Default::default()
    }
}
#[doc = "An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/prompts/list_changed\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PromptListChangedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&PromptListChangedNotification> for PromptListChangedNotification {
    fn from(value: &PromptListChangedNotification) -> Self {
        value.clone()
    }
}
impl PromptListChangedNotification {
    pub fn builder() -> builder::PromptListChangedNotification {
        Default::default()
    }
}
#[doc = "Describes a message returned as part of a prompt.\n\nThis is similar to `SamplingMessage`, but also supports the embedding of\nresources from the MCP server."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes a message returned as part of a prompt.\\n\\nThis is similar to `SamplingMessage`, but also supports the embedding of\\nresources from the MCP server.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\","]
#[doc = "    \"role\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"content\": {"]
#[doc = "      \"$ref\": \"#/$defs/ContentBlock\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"$ref\": \"#/$defs/Role\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PromptMessage {
    pub content: ContentBlock,
    pub role: Role,
}
impl ::std::convert::From<&PromptMessage> for PromptMessage {
    fn from(value: &PromptMessage) -> Self {
        value.clone()
    }
}
impl PromptMessage {
    pub fn builder() -> builder::PromptMessage {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PromptMeta {}
impl ::std::convert::From<&PromptMeta> for PromptMeta {
    fn from(value: &PromptMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PromptMeta {
    fn default() -> Self {
        Self {}
    }
}
impl PromptMeta {
    pub fn builder() -> builder::PromptMeta {
        Default::default()
    }
}
#[doc = "Identifies a prompt."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Identifies a prompt.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"ref/prompt\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PromptReference {
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&PromptReference> for PromptReference {
    fn from(value: &PromptReference) -> Self {
        value.clone()
    }
}
impl PromptReference {
    pub fn builder() -> builder::PromptReference {
        Default::default()
    }
}
#[doc = "Sent from the client to the server, to read a specific resource URI."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to the server, to read a specific resource URI.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resources/read\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/ReadResourceRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadResourceRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: ReadResourceRequestParams,
}
impl ::std::convert::From<&ReadResourceRequest> for ReadResourceRequest {
    fn from(value: &ReadResourceRequest) -> Self {
        value.clone()
    }
}
impl ReadResourceRequest {
    pub fn builder() -> builder::ReadResourceRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `resources/read` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `resources/read` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadResourceRequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ReadResourceRequestParamsMeta>,
    #[doc = "The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ReadResourceRequestParams> for ReadResourceRequestParams {
    fn from(value: &ReadResourceRequestParams) -> Self {
        value.clone()
    }
}
impl ReadResourceRequestParams {
    pub fn builder() -> builder::ReadResourceRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReadResourceRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&ReadResourceRequestParamsMeta> for ReadResourceRequestParamsMeta {
    fn from(value: &ReadResourceRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ReadResourceRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl ReadResourceRequestParamsMeta {
    pub fn builder() -> builder::ReadResourceRequestParamsMeta {
        Default::default()
    }
}
#[doc = "The server's response to a resources/read request from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The server's response to a resources/read request from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"contents\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"contents\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/$defs/TextResourceContents\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/$defs/BlobResourceContents\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReadResourceResult {
    pub contents: ::std::vec::Vec<ReadResourceResultContentsItem>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ReadResourceResultMeta>,
}
impl ::std::convert::From<&ReadResourceResult> for ReadResourceResult {
    fn from(value: &ReadResourceResult) -> Self {
        value.clone()
    }
}
impl ReadResourceResult {
    pub fn builder() -> builder::ReadResourceResult {
        Default::default()
    }
}
#[doc = "`ReadResourceResultContentsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextResourceContents\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/BlobResourceContents\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ReadResourceResultContentsItem {
    TextResourceContents(TextResourceContents),
    BlobResourceContents(BlobResourceContents),
}
impl ::std::convert::From<&Self> for ReadResourceResultContentsItem {
    fn from(value: &ReadResourceResultContentsItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextResourceContents> for ReadResourceResultContentsItem {
    fn from(value: TextResourceContents) -> Self {
        Self::TextResourceContents(value)
    }
}
impl ::std::convert::From<BlobResourceContents> for ReadResourceResultContentsItem {
    fn from(value: BlobResourceContents) -> Self {
        Self::BlobResourceContents(value)
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReadResourceResultMeta {}
impl ::std::convert::From<&ReadResourceResultMeta> for ReadResourceResultMeta {
    fn from(value: &ReadResourceResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ReadResourceResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ReadResourceResultMeta {
    pub fn builder() -> builder::ReadResourceResultMeta {
        Default::default()
    }
}
#[doc = "Metadata for associating messages with a task.\nInclude this in the `_meta` field under the key `io.modelcontextprotocol/related-task`."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Metadata for associating messages with a task.\\nInclude this in the `_meta` field under the key `io.modelcontextprotocol/related-task`.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"taskId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"taskId\": {"]
#[doc = "      \"description\": \"The task identifier this message is associated with.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RelatedTaskMetadata {
    #[doc = "The task identifier this message is associated with."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
}
impl ::std::convert::From<&RelatedTaskMetadata> for RelatedTaskMetadata {
    fn from(value: &RelatedTaskMetadata) -> Self {
        value.clone()
    }
}
impl RelatedTaskMetadata {
    pub fn builder() -> builder::RelatedTaskMetadata {
        Default::default()
    }
}
#[doc = "`Request`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Request {
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<RequestParams>,
}
impl ::std::convert::From<&Request> for Request {
    fn from(value: &Request) -> Self {
        value.clone()
    }
}
impl Request {
    pub fn builder() -> builder::Request {
        Default::default()
    }
}
#[doc = "A uniquely identifying ID for a request in JSON-RPC."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A uniquely identifying ID for a request in JSON-RPC.\","]
#[doc = "  \"type\": ["]
#[doc = "    \"string\","]
#[doc = "    \"integer\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RequestId {
    String(::std::string::String),
    Integer(i64),
}
impl ::std::convert::From<&Self> for RequestId {
    fn from(value: &RequestId) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RequestId {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::String(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Integer(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for RequestId {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RequestId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RequestId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for RequestId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::String(x) => x.fmt(f),
            Self::Integer(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<i64> for RequestId {
    fn from(value: i64) -> Self {
        Self::Integer(value)
    }
}
#[doc = "Common params for any request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Common params for any request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<RequestParamsMeta>,
}
impl ::std::convert::From<&RequestParams> for RequestParams {
    fn from(value: &RequestParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RequestParams {
    fn default() -> Self {
        Self {
            meta: Default::default(),
        }
    }
}
impl RequestParams {
    pub fn builder() -> builder::RequestParams {
        Default::default()
    }
}

#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&RequestParamsMeta> for RequestParamsMeta {
    fn from(value: &RequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl RequestParamsMeta {
    pub fn builder() -> builder::RequestParamsMeta {
        Default::default()
    }
}
#[doc = "A known resource that the server is capable of reading."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A known resource that the server is capable of reading.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A description of what this resource represents.\\n\\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \\\"hint\\\" to the model.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of this resource, if known.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"description\": \"The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\\n\\nThis can be used by Hosts to display file sizes and estimate context window usage.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of this resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Resource {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[doc = "A description of what this resource represents.\n\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceMeta>,
    #[doc = "The MIME type of this resource, if known."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\n\nThis can be used by Hosts to display file sizes and estimate context window usage."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<i64>,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[doc = "The URI of this resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&Resource> for Resource {
    fn from(value: &Resource) -> Self {
        value.clone()
    }
}
impl Resource {
    pub fn builder() -> builder::Resource {
        Default::default()
    }
}
#[doc = "The contents of a specific resource or sub-resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The contents of a specific resource or sub-resource.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of this resource, if known.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of this resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceContents {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceContentsMeta>,
    #[doc = "The MIME type of this resource, if known."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "The URI of this resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ResourceContents> for ResourceContents {
    fn from(value: &ResourceContents) -> Self {
        value.clone()
    }
}
impl ResourceContents {
    pub fn builder() -> builder::ResourceContents {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceContentsMeta {}
impl ::std::convert::From<&ResourceContentsMeta> for ResourceContentsMeta {
    fn from(value: &ResourceContentsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceContentsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResourceContentsMeta {
    pub fn builder() -> builder::ResourceContentsMeta {
        Default::default()
    }
}
#[doc = "A resource that the server is capable of reading, included in a prompt or tool call result.\n\nNote: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A resource that the server is capable of reading, included in a prompt or tool call result.\\n\\nNote: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"type\","]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A description of what this resource represents.\\n\\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \\\"hint\\\" to the model.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of this resource, if known.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"description\": \"The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\\n\\nThis can be used by Hosts to display file sizes and estimate context window usage.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resource_link\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of this resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceLink {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[doc = "A description of what this resource represents.\n\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceLinkMeta>,
    #[doc = "The MIME type of this resource, if known."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\n\nThis can be used by Hosts to display file sizes and estimate context window usage."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<i64>,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    #[doc = "The URI of this resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ResourceLink> for ResourceLink {
    fn from(value: &ResourceLink) -> Self {
        value.clone()
    }
}
impl ResourceLink {
    pub fn builder() -> builder::ResourceLink {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceLinkMeta {}
impl ::std::convert::From<&ResourceLinkMeta> for ResourceLinkMeta {
    fn from(value: &ResourceLinkMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceLinkMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResourceLinkMeta {
    pub fn builder() -> builder::ResourceLinkMeta {
        Default::default()
    }
}
#[doc = "An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/resources/list_changed\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceListChangedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&ResourceListChangedNotification> for ResourceListChangedNotification {
    fn from(value: &ResourceListChangedNotification) -> Self {
        value.clone()
    }
}
impl ResourceListChangedNotification {
    pub fn builder() -> builder::ResourceListChangedNotification {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceMeta {}
impl ::std::convert::From<&ResourceMeta> for ResourceMeta {
    fn from(value: &ResourceMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResourceMeta {
    pub fn builder() -> builder::ResourceMeta {
        Default::default()
    }
}
#[doc = "Common parameters when working with resources."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Common parameters when working with resources.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceRequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceRequestParamsMeta>,
    #[doc = "The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ResourceRequestParams> for ResourceRequestParams {
    fn from(value: &ResourceRequestParams) -> Self {
        value.clone()
    }
}
impl ResourceRequestParams {
    pub fn builder() -> builder::ResourceRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&ResourceRequestParamsMeta> for ResourceRequestParamsMeta {
    fn from(value: &ResourceRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl ResourceRequestParamsMeta {
    pub fn builder() -> builder::ResourceRequestParamsMeta {
        Default::default()
    }
}
#[doc = "A template description for resources available on the server."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A template description for resources available on the server.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"uriTemplate\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A description of what this template is for.\\n\\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \\\"hint\\\" to the model.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uriTemplate\": {"]
#[doc = "      \"description\": \"A URI template (according to RFC 6570) that can be used to construct resource URIs.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceTemplate {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[doc = "A description of what this template is for.\n\nThis can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceTemplateMeta>,
    #[doc = "The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[doc = "A URI template (according to RFC 6570) that can be used to construct resource URIs."]
    #[serde(rename = "uriTemplate")]
    pub uri_template: ::std::string::String,
}
impl ::std::convert::From<&ResourceTemplate> for ResourceTemplate {
    fn from(value: &ResourceTemplate) -> Self {
        value.clone()
    }
}
impl ResourceTemplate {
    pub fn builder() -> builder::ResourceTemplate {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceTemplateMeta {}
impl ::std::convert::From<&ResourceTemplateMeta> for ResourceTemplateMeta {
    fn from(value: &ResourceTemplateMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceTemplateMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResourceTemplateMeta {
    pub fn builder() -> builder::ResourceTemplateMeta {
        Default::default()
    }
}
#[doc = "A reference to a resource or resource template definition."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A reference to a resource or resource template definition.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"ref/resource\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI or URI template of the resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceTemplateReference {
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
    #[doc = "The URI or URI template of the resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ResourceTemplateReference> for ResourceTemplateReference {
    fn from(value: &ResourceTemplateReference) -> Self {
        value.clone()
    }
}
impl ResourceTemplateReference {
    pub fn builder() -> builder::ResourceTemplateReference {
        Default::default()
    }
}
#[doc = "A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/resources/updated\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/ResourceUpdatedNotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceUpdatedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: ResourceUpdatedNotificationParams,
}
impl ::std::convert::From<&ResourceUpdatedNotification> for ResourceUpdatedNotification {
    fn from(value: &ResourceUpdatedNotification) -> Self {
        value.clone()
    }
}
impl ResourceUpdatedNotification {
    pub fn builder() -> builder::ResourceUpdatedNotification {
        Default::default()
    }
}
#[doc = "Parameters for a `notifications/resources/updated` notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `notifications/resources/updated` notification.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ResourceUpdatedNotificationParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResourceUpdatedNotificationParamsMeta>,
    #[doc = "The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&ResourceUpdatedNotificationParams>
    for ResourceUpdatedNotificationParams
{
    fn from(value: &ResourceUpdatedNotificationParams) -> Self {
        value.clone()
    }
}
impl ResourceUpdatedNotificationParams {
    pub fn builder() -> builder::ResourceUpdatedNotificationParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResourceUpdatedNotificationParamsMeta {}
impl ::std::convert::From<&ResourceUpdatedNotificationParamsMeta>
    for ResourceUpdatedNotificationParamsMeta
{
    fn from(value: &ResourceUpdatedNotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResourceUpdatedNotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResourceUpdatedNotificationParamsMeta {
    pub fn builder() -> builder::ResourceUpdatedNotificationParamsMeta {
        Default::default()
    }
}
#[doc = "`Result`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Result {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ResultMeta>,
}
impl ::std::convert::From<&Result> for Result {
    fn from(value: &Result) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Result {
    fn default() -> Self {
        Self {
            meta: Default::default(),
        }
    }
}
impl Result {
    pub fn builder() -> builder::Result {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResultMeta {}
impl ::std::convert::From<&ResultMeta> for ResultMeta {
    fn from(value: &ResultMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ResultMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ResultMeta {
    pub fn builder() -> builder::ResultMeta {
        Default::default()
    }
}
#[doc = "The sender or recipient of messages and data in a conversation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The sender or recipient of messages and data in a conversation.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"assistant\","]
#[doc = "    \"user\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Role {
    #[serde(rename = "assistant")]
    Assistant,
    #[serde(rename = "user")]
    User,
}
impl ::std::convert::From<&Self> for Role {
    fn from(value: &Role) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Role {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Assistant => write!(f, "assistant"),
            Self::User => write!(f, "user"),
        }
    }
}
impl ::std::str::FromStr for Role {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "assistant" => Ok(Self::Assistant),
            "user" => Ok(Self::User),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Role {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Role {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Role {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Represents a root directory or file that the server can operate on."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Represents a root directory or file that the server can operate on.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"An optional name for the root. This can be used to provide a human-readable\\nidentifier for the root, which may be useful for display purposes or for\\nreferencing the root in other parts of the application.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI identifying the root. This *must* start with file:// for now.\\nThis restriction may be relaxed in future versions of the protocol to allow\\nother URI schemes.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Root {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<RootMeta>,
    #[doc = "An optional name for the root. This can be used to provide a human-readable\nidentifier for the root, which may be useful for display purposes or for\nreferencing the root in other parts of the application."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[doc = "The URI identifying the root. This *must* start with file:// for now.\nThis restriction may be relaxed in future versions of the protocol to allow\nother URI schemes."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&Root> for Root {
    fn from(value: &Root) -> Self {
        value.clone()
    }
}
impl Root {
    pub fn builder() -> builder::Root {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RootMeta {}
impl ::std::convert::From<&RootMeta> for RootMeta {
    fn from(value: &RootMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RootMeta {
    fn default() -> Self {
        Self {}
    }
}
impl RootMeta {
    pub fn builder() -> builder::RootMeta {
        Default::default()
    }
}
#[doc = "A notification from the client to the server, informing it that the list of roots has changed.\nThis notification should be sent whenever the client adds, removes, or modifies any root.\nThe server should then request an updated list of roots using the ListRootsRequest."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A notification from the client to the server, informing it that the list of roots has changed.\\nThis notification should be sent whenever the client adds, removes, or modifies any root.\\nThe server should then request an updated list of roots using the ListRootsRequest.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/roots/list_changed\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RootsListChangedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&RootsListChangedNotification> for RootsListChangedNotification {
    fn from(value: &RootsListChangedNotification) -> Self {
        value.clone()
    }
}
impl RootsListChangedNotification {
    pub fn builder() -> builder::RootsListChangedNotification {
        Default::default()
    }
}
#[doc = "Describes a message issued to or received from an LLM API."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes a message issued to or received from an LLM API.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\","]
#[doc = "    \"role\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"content\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/TextContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ToolUseContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/ToolResultContent\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/$defs/SamplingMessageContentBlock\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"$ref\": \"#/$defs/Role\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SamplingMessage {
    pub content: SamplingMessageContent,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<SamplingMessageMeta>,
    pub role: Role,
}
impl ::std::convert::From<&SamplingMessage> for SamplingMessage {
    fn from(value: &SamplingMessage) -> Self {
        value.clone()
    }
}
impl SamplingMessage {
    pub fn builder() -> builder::SamplingMessage {
        Default::default()
    }
}
#[doc = "`SamplingMessageContent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolUseContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolResultContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/SamplingMessageContentBlock\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SamplingMessageContent {
    Variant0(TextContent),
    Variant1(ImageContent),
    Variant2(AudioContent),
    Variant3(ToolUseContent),
    Variant4(ToolResultContent),
    Variant5(::std::vec::Vec<SamplingMessageContentBlock>),
}
impl ::std::convert::From<&Self> for SamplingMessageContent {
    fn from(value: &SamplingMessageContent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextContent> for SamplingMessageContent {
    fn from(value: TextContent) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ImageContent> for SamplingMessageContent {
    fn from(value: ImageContent) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AudioContent> for SamplingMessageContent {
    fn from(value: AudioContent) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ToolUseContent> for SamplingMessageContent {
    fn from(value: ToolUseContent) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<ToolResultContent> for SamplingMessageContent {
    fn from(value: ToolResultContent) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<SamplingMessageContentBlock>> for SamplingMessageContent {
    fn from(value: ::std::vec::Vec<SamplingMessageContentBlock>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`SamplingMessageContentBlock`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TextContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ImageContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/AudioContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolUseContent\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolResultContent\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SamplingMessageContentBlock {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ToolUseContent(ToolUseContent),
    ToolResultContent(ToolResultContent),
}
impl ::std::convert::From<&Self> for SamplingMessageContentBlock {
    fn from(value: &SamplingMessageContentBlock) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextContent> for SamplingMessageContentBlock {
    fn from(value: TextContent) -> Self {
        Self::TextContent(value)
    }
}
impl ::std::convert::From<ImageContent> for SamplingMessageContentBlock {
    fn from(value: ImageContent) -> Self {
        Self::ImageContent(value)
    }
}
impl ::std::convert::From<AudioContent> for SamplingMessageContentBlock {
    fn from(value: AudioContent) -> Self {
        Self::AudioContent(value)
    }
}
impl ::std::convert::From<ToolUseContent> for SamplingMessageContentBlock {
    fn from(value: ToolUseContent) -> Self {
        Self::ToolUseContent(value)
    }
}
impl ::std::convert::From<ToolResultContent> for SamplingMessageContentBlock {
    fn from(value: ToolResultContent) -> Self {
        Self::ToolResultContent(value)
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SamplingMessageMeta {}
impl ::std::convert::From<&SamplingMessageMeta> for SamplingMessageMeta {
    fn from(value: &SamplingMessageMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SamplingMessageMeta {
    fn default() -> Self {
        Self {}
    }
}
impl SamplingMessageMeta {
    pub fn builder() -> builder::SamplingMessageMeta {
        Default::default()
    }
}
#[doc = "Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"completions\": {"]
#[doc = "      \"description\": \"Present if the server supports argument autocompletion suggestions.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"experimental\": {"]
#[doc = "      \"description\": \"Experimental, non-standard capabilities that the server supports.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"additionalProperties\": true"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"logging\": {"]
#[doc = "      \"description\": \"Present if the server supports sending log messages to the client.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"prompts\": {"]
#[doc = "      \"description\": \"Present if the server offers any prompt templates.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"listChanged\": {"]
#[doc = "          \"description\": \"Whether this server supports notifications for changes to the prompt list.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"resources\": {"]
#[doc = "      \"description\": \"Present if the server offers any resources to read.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"listChanged\": {"]
#[doc = "          \"description\": \"Whether this server supports notifications for changes to the resource list.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"subscribe\": {"]
#[doc = "          \"description\": \"Whether this server supports subscribing to resource updates.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"tasks\": {"]
#[doc = "      \"description\": \"Present if the server supports task-augmented requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"cancel\": {"]
#[doc = "          \"description\": \"Whether this server supports tasks/cancel.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"list\": {"]
#[doc = "          \"description\": \"Whether this server supports tasks/list.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"requests\": {"]
#[doc = "          \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"tools\": {"]
#[doc = "              \"description\": \"Task support for tool-related requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"call\": {"]
#[doc = "                  \"description\": \"Whether the server supports task-augmented tools/call requests.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"tools\": {"]
#[doc = "      \"description\": \"Present if the server offers any tools to call.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"listChanged\": {"]
#[doc = "          \"description\": \"Whether this server supports notifications for changes to the tool list.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilities {
    #[doc = "Present if the server supports argument autocompletion suggestions."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub completions: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Experimental, non-standard capabilities that the server supports."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub experimental: ::std::collections::HashMap<
        ::std::string::String,
        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    >,
    #[doc = "Present if the server supports sending log messages to the client."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub logging: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub prompts: ::std::option::Option<ServerCapabilitiesPrompts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub resources: ::std::option::Option<ServerCapabilitiesResources>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tasks: ::std::option::Option<ServerCapabilitiesTasks>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tools: ::std::option::Option<ServerCapabilitiesTools>,
}
impl ::std::convert::From<&ServerCapabilities> for ServerCapabilities {
    fn from(value: &ServerCapabilities) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilities {
    fn default() -> Self {
        Self {
            completions: Default::default(),
            experimental: Default::default(),
            logging: Default::default(),
            prompts: Default::default(),
            resources: Default::default(),
            tasks: Default::default(),
            tools: Default::default(),
        }
    }
}
impl ServerCapabilities {
    pub fn builder() -> builder::ServerCapabilities {
        Default::default()
    }
}
#[doc = "Present if the server offers any prompt templates."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the server offers any prompt templates.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"listChanged\": {"]
#[doc = "      \"description\": \"Whether this server supports notifications for changes to the prompt list.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesPrompts {
    #[doc = "Whether this server supports notifications for changes to the prompt list."]
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub list_changed: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ServerCapabilitiesPrompts> for ServerCapabilitiesPrompts {
    fn from(value: &ServerCapabilitiesPrompts) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesPrompts {
    fn default() -> Self {
        Self {
            list_changed: Default::default(),
        }
    }
}
impl ServerCapabilitiesPrompts {
    pub fn builder() -> builder::ServerCapabilitiesPrompts {
        Default::default()
    }
}
#[doc = "Present if the server offers any resources to read."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the server offers any resources to read.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"listChanged\": {"]
#[doc = "      \"description\": \"Whether this server supports notifications for changes to the resource list.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"subscribe\": {"]
#[doc = "      \"description\": \"Whether this server supports subscribing to resource updates.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesResources {
    #[doc = "Whether this server supports notifications for changes to the resource list."]
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub list_changed: ::std::option::Option<bool>,
    #[doc = "Whether this server supports subscribing to resource updates."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subscribe: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ServerCapabilitiesResources> for ServerCapabilitiesResources {
    fn from(value: &ServerCapabilitiesResources) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesResources {
    fn default() -> Self {
        Self {
            list_changed: Default::default(),
            subscribe: Default::default(),
        }
    }
}
impl ServerCapabilitiesResources {
    pub fn builder() -> builder::ServerCapabilitiesResources {
        Default::default()
    }
}
#[doc = "Present if the server supports task-augmented requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the server supports task-augmented requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"cancel\": {"]
#[doc = "      \"description\": \"Whether this server supports tasks/cancel.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"list\": {"]
#[doc = "      \"description\": \"Whether this server supports tasks/list.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"requests\": {"]
#[doc = "      \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"tools\": {"]
#[doc = "          \"description\": \"Task support for tool-related requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"call\": {"]
#[doc = "              \"description\": \"Whether the server supports task-augmented tools/call requests.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesTasks {
    #[doc = "Whether this server supports tasks/cancel."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub cancel: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Whether this server supports tasks/list."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub list: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub requests: ::std::option::Option<ServerCapabilitiesTasksRequests>,
}
impl ::std::convert::From<&ServerCapabilitiesTasks> for ServerCapabilitiesTasks {
    fn from(value: &ServerCapabilitiesTasks) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesTasks {
    fn default() -> Self {
        Self {
            cancel: Default::default(),
            list: Default::default(),
            requests: Default::default(),
        }
    }
}
impl ServerCapabilitiesTasks {
    pub fn builder() -> builder::ServerCapabilitiesTasks {
        Default::default()
    }
}
#[doc = "Specifies which request types can be augmented with tasks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Specifies which request types can be augmented with tasks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"tools\": {"]
#[doc = "      \"description\": \"Task support for tool-related requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"description\": \"Whether the server supports task-augmented tools/call requests.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesTasksRequests {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tools: ::std::option::Option<ServerCapabilitiesTasksRequestsTools>,
}
impl ::std::convert::From<&ServerCapabilitiesTasksRequests> for ServerCapabilitiesTasksRequests {
    fn from(value: &ServerCapabilitiesTasksRequests) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesTasksRequests {
    fn default() -> Self {
        Self {
            tools: Default::default(),
        }
    }
}
impl ServerCapabilitiesTasksRequests {
    pub fn builder() -> builder::ServerCapabilitiesTasksRequests {
        Default::default()
    }
}
#[doc = "Task support for tool-related requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Task support for tool-related requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"call\": {"]
#[doc = "      \"description\": \"Whether the server supports task-augmented tools/call requests.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesTasksRequestsTools {
    #[doc = "Whether the server supports task-augmented tools/call requests."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub call: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&ServerCapabilitiesTasksRequestsTools>
    for ServerCapabilitiesTasksRequestsTools
{
    fn from(value: &ServerCapabilitiesTasksRequestsTools) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesTasksRequestsTools {
    fn default() -> Self {
        Self {
            call: Default::default(),
        }
    }
}
impl ServerCapabilitiesTasksRequestsTools {
    pub fn builder() -> builder::ServerCapabilitiesTasksRequestsTools {
        Default::default()
    }
}
#[doc = "Present if the server offers any tools to call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Present if the server offers any tools to call.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"listChanged\": {"]
#[doc = "      \"description\": \"Whether this server supports notifications for changes to the tool list.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerCapabilitiesTools {
    #[doc = "Whether this server supports notifications for changes to the tool list."]
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub list_changed: ::std::option::Option<bool>,
}
impl ::std::convert::From<&ServerCapabilitiesTools> for ServerCapabilitiesTools {
    fn from(value: &ServerCapabilitiesTools) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerCapabilitiesTools {
    fn default() -> Self {
        Self {
            list_changed: Default::default(),
        }
    }
}
impl ServerCapabilitiesTools {
    pub fn builder() -> builder::ServerCapabilitiesTools {
        Default::default()
    }
}
#[doc = "`ServerNotification`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CancelledNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ProgressNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ResourceListChangedNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ResourceUpdatedNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/PromptListChangedNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ToolListChangedNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TaskStatusNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/LoggingMessageNotification\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitationCompleteNotification\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ServerNotification {
    CancelledNotification(CancelledNotification),
    ProgressNotification(ProgressNotification),
    ResourceListChangedNotification(ResourceListChangedNotification),
    ResourceUpdatedNotification(ResourceUpdatedNotification),
    PromptListChangedNotification(PromptListChangedNotification),
    ToolListChangedNotification(ToolListChangedNotification),
    TaskStatusNotification(TaskStatusNotification),
    LoggingMessageNotification(LoggingMessageNotification),
    ElicitationCompleteNotification(ElicitationCompleteNotification),
}
impl ::std::convert::From<&Self> for ServerNotification {
    fn from(value: &ServerNotification) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CancelledNotification> for ServerNotification {
    fn from(value: CancelledNotification) -> Self {
        Self::CancelledNotification(value)
    }
}
impl ::std::convert::From<ProgressNotification> for ServerNotification {
    fn from(value: ProgressNotification) -> Self {
        Self::ProgressNotification(value)
    }
}
impl ::std::convert::From<ResourceListChangedNotification> for ServerNotification {
    fn from(value: ResourceListChangedNotification) -> Self {
        Self::ResourceListChangedNotification(value)
    }
}
impl ::std::convert::From<ResourceUpdatedNotification> for ServerNotification {
    fn from(value: ResourceUpdatedNotification) -> Self {
        Self::ResourceUpdatedNotification(value)
    }
}
impl ::std::convert::From<PromptListChangedNotification> for ServerNotification {
    fn from(value: PromptListChangedNotification) -> Self {
        Self::PromptListChangedNotification(value)
    }
}
impl ::std::convert::From<ToolListChangedNotification> for ServerNotification {
    fn from(value: ToolListChangedNotification) -> Self {
        Self::ToolListChangedNotification(value)
    }
}
impl ::std::convert::From<TaskStatusNotification> for ServerNotification {
    fn from(value: TaskStatusNotification) -> Self {
        Self::TaskStatusNotification(value)
    }
}
impl ::std::convert::From<LoggingMessageNotification> for ServerNotification {
    fn from(value: LoggingMessageNotification) -> Self {
        Self::LoggingMessageNotification(value)
    }
}
impl ::std::convert::From<ElicitationCompleteNotification> for ServerNotification {
    fn from(value: ElicitationCompleteNotification) -> Self {
        Self::ElicitationCompleteNotification(value)
    }
}
#[doc = "`ServerRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/PingRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskPayloadRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CancelTaskRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListTasksRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CreateMessageRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListRootsRequest\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ElicitRequest\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ServerRequest {
    PingRequest(PingRequest),
    GetTaskRequest(GetTaskRequest),
    GetTaskPayloadRequest(GetTaskPayloadRequest),
    CancelTaskRequest(CancelTaskRequest),
    ListTasksRequest(ListTasksRequest),
    CreateMessageRequest(CreateMessageRequest),
    ListRootsRequest(ListRootsRequest),
    ElicitRequest(ElicitRequest),
}
impl ::std::convert::From<&Self> for ServerRequest {
    fn from(value: &ServerRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PingRequest> for ServerRequest {
    fn from(value: PingRequest) -> Self {
        Self::PingRequest(value)
    }
}
impl ::std::convert::From<GetTaskRequest> for ServerRequest {
    fn from(value: GetTaskRequest) -> Self {
        Self::GetTaskRequest(value)
    }
}
impl ::std::convert::From<GetTaskPayloadRequest> for ServerRequest {
    fn from(value: GetTaskPayloadRequest) -> Self {
        Self::GetTaskPayloadRequest(value)
    }
}
impl ::std::convert::From<CancelTaskRequest> for ServerRequest {
    fn from(value: CancelTaskRequest) -> Self {
        Self::CancelTaskRequest(value)
    }
}
impl ::std::convert::From<ListTasksRequest> for ServerRequest {
    fn from(value: ListTasksRequest) -> Self {
        Self::ListTasksRequest(value)
    }
}
impl ::std::convert::From<CreateMessageRequest> for ServerRequest {
    fn from(value: CreateMessageRequest) -> Self {
        Self::CreateMessageRequest(value)
    }
}
impl ::std::convert::From<ListRootsRequest> for ServerRequest {
    fn from(value: ListRootsRequest) -> Self {
        Self::ListRootsRequest(value)
    }
}
impl ::std::convert::From<ElicitRequest> for ServerRequest {
    fn from(value: ElicitRequest) -> Self {
        Self::ElicitRequest(value)
    }
}
#[doc = "`ServerResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Result\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/InitializeResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListResourcesResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListResourceTemplatesResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ReadResourceResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListPromptsResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetPromptResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListToolsResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CallToolResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The response to a tasks/get request.\","]
#[doc = "      \"$ref\": \"#/$defs/GetTaskResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/GetTaskPayloadResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The response to a tasks/cancel request.\","]
#[doc = "      \"$ref\": \"#/$defs/CancelTaskResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/ListTasksResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/CompleteResult\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerResult {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<Result>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<InitializeResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_2: ::std::option::Option<ListResourcesResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_3: ::std::option::Option<ListResourceTemplatesResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_4: ::std::option::Option<ReadResourceResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_5: ::std::option::Option<ListPromptsResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_6: ::std::option::Option<GetPromptResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_7: ::std::option::Option<ListToolsResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_8: ::std::option::Option<CallToolResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_9: ::std::option::Option<GetTaskResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_10: ::std::option::Option<GetTaskPayloadResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_11: ::std::option::Option<CancelTaskResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_12: ::std::option::Option<ListTasksResult>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_13: ::std::option::Option<CompleteResult>,
}
impl ::std::convert::From<&ServerResult> for ServerResult {
    fn from(value: &ServerResult) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ServerResult {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
            subtype_2: Default::default(),
            subtype_3: Default::default(),
            subtype_4: Default::default(),
            subtype_5: Default::default(),
            subtype_6: Default::default(),
            subtype_7: Default::default(),
            subtype_8: Default::default(),
            subtype_9: Default::default(),
            subtype_10: Default::default(),
            subtype_11: Default::default(),
            subtype_12: Default::default(),
            subtype_13: Default::default(),
        }
    }
}
impl ServerResult {
    pub fn builder() -> builder::ServerResult {
        Default::default()
    }
}
#[doc = "A request from the client to the server, to enable or adjust logging."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request from the client to the server, to enable or adjust logging.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"logging/setLevel\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/SetLevelRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetLevelRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: SetLevelRequestParams,
}
impl ::std::convert::From<&SetLevelRequest> for SetLevelRequest {
    fn from(value: &SetLevelRequest) -> Self {
        value.clone()
    }
}
impl SetLevelRequest {
    pub fn builder() -> builder::SetLevelRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `logging/setLevel` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `logging/setLevel` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"level\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"level\": {"]
#[doc = "      \"description\": \"The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/message.\","]
#[doc = "      \"$ref\": \"#/$defs/LoggingLevel\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetLevelRequestParams {
    #[doc = "The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/message."]
    pub level: LoggingLevel,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<SetLevelRequestParamsMeta>,
}
impl ::std::convert::From<&SetLevelRequestParams> for SetLevelRequestParams {
    fn from(value: &SetLevelRequestParams) -> Self {
        value.clone()
    }
}
impl SetLevelRequestParams {
    pub fn builder() -> builder::SetLevelRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SetLevelRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&SetLevelRequestParamsMeta> for SetLevelRequestParamsMeta {
    fn from(value: &SetLevelRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SetLevelRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl SetLevelRequestParamsMeta {
    pub fn builder() -> builder::SetLevelRequestParamsMeta {
        Default::default()
    }
}
#[doc = "`SingleSelectEnumSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/UntitledSingleSelectEnumSchema\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/TitledSingleSelectEnumSchema\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SingleSelectEnumSchema {
    UntitledSingleSelectEnumSchema(UntitledSingleSelectEnumSchema),
    TitledSingleSelectEnumSchema(TitledSingleSelectEnumSchema),
}
impl ::std::convert::From<&Self> for SingleSelectEnumSchema {
    fn from(value: &SingleSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<UntitledSingleSelectEnumSchema> for SingleSelectEnumSchema {
    fn from(value: UntitledSingleSelectEnumSchema) -> Self {
        Self::UntitledSingleSelectEnumSchema(value)
    }
}
impl ::std::convert::From<TitledSingleSelectEnumSchema> for SingleSelectEnumSchema {
    fn from(value: TitledSingleSelectEnumSchema) -> Self {
        Self::TitledSingleSelectEnumSchema(value)
    }
}
#[doc = "`StringSchema`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"date\","]
#[doc = "        \"date-time\","]
#[doc = "        \"email\","]
#[doc = "        \"uri\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxLength\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"minLength\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StringSchema {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<StringSchemaFormat>,
    #[serde(
        rename = "maxLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_length: ::std::option::Option<i64>,
    #[serde(
        rename = "minLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_length: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&StringSchema> for StringSchema {
    fn from(value: &StringSchema) -> Self {
        value.clone()
    }
}
impl StringSchema {
    pub fn builder() -> builder::StringSchema {
        Default::default()
    }
}
#[doc = "`StringSchemaFormat`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"date\","]
#[doc = "    \"date-time\","]
#[doc = "    \"email\","]
#[doc = "    \"uri\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StringSchemaFormat {
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "date-time")]
    DateTime,
    #[serde(rename = "email")]
    Email,
    #[serde(rename = "uri")]
    Uri,
}
impl ::std::convert::From<&Self> for StringSchemaFormat {
    fn from(value: &StringSchemaFormat) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StringSchemaFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Date => write!(f, "date"),
            Self::DateTime => write!(f, "date-time"),
            Self::Email => write!(f, "email"),
            Self::Uri => write!(f, "uri"),
        }
    }
}
impl ::std::str::FromStr for StringSchemaFormat {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "date" => Ok(Self::Date),
            "date-time" => Ok(Self::DateTime),
            "email" => Ok(Self::Email),
            "uri" => Ok(Self::Uri),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StringSchemaFormat {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StringSchemaFormat {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StringSchemaFormat {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Sent from the client to request resources/updated notifications from the server whenever a particular resource changes."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resources/subscribe\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/SubscribeRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SubscribeRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: SubscribeRequestParams,
}
impl ::std::convert::From<&SubscribeRequest> for SubscribeRequest {
    fn from(value: &SubscribeRequest) -> Self {
        value.clone()
    }
}
impl SubscribeRequest {
    pub fn builder() -> builder::SubscribeRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `resources/subscribe` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `resources/subscribe` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SubscribeRequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<SubscribeRequestParamsMeta>,
    #[doc = "The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&SubscribeRequestParams> for SubscribeRequestParams {
    fn from(value: &SubscribeRequestParams) -> Self {
        value.clone()
    }
}
impl SubscribeRequestParams {
    pub fn builder() -> builder::SubscribeRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubscribeRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&SubscribeRequestParamsMeta> for SubscribeRequestParamsMeta {
    fn from(value: &SubscribeRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SubscribeRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl SubscribeRequestParamsMeta {
    pub fn builder() -> builder::SubscribeRequestParamsMeta {
        Default::default()
    }
}
#[doc = "Data associated with a task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Data associated with a task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"createdAt\","]
#[doc = "    \"lastUpdatedAt\","]
#[doc = "    \"status\","]
#[doc = "    \"taskId\","]
#[doc = "    \"ttl\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"createdAt\": {"]
#[doc = "      \"description\": \"ISO 8601 timestamp when the task was created.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"lastUpdatedAt\": {"]
#[doc = "      \"description\": \"ISO 8601 timestamp when the task was last updated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"pollInterval\": {"]
#[doc = "      \"description\": \"Suggested polling interval in milliseconds.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"Current task state.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskStatus\""]
#[doc = "    },"]
#[doc = "    \"statusMessage\": {"]
#[doc = "      \"description\": \"Optional human-readable message describing the current task state.\\nThis can provide context for any status, including:\\n- Reasons for \\\"cancelled\\\" status\\n- Summaries for \\\"completed\\\" status\\n- Diagnostic information for \\\"failed\\\" status (e.g., error details, what went wrong)\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"taskId\": {"]
#[doc = "      \"description\": \"The task identifier.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ttl\": {"]
#[doc = "      \"description\": \"Actual retention duration from creation in milliseconds, null for unlimited.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Task {
    #[doc = "ISO 8601 timestamp when the task was created."]
    #[serde(rename = "createdAt")]
    pub created_at: ::std::string::String,
    #[doc = "ISO 8601 timestamp when the task was last updated."]
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: ::std::string::String,
    #[doc = "Suggested polling interval in milliseconds."]
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub poll_interval: ::std::option::Option<i64>,
    #[doc = "Current task state."]
    pub status: TaskStatus,
    #[doc = "Optional human-readable message describing the current task state.\nThis can provide context for any status, including:\n- Reasons for \"cancelled\" status\n- Summaries for \"completed\" status\n- Diagnostic information for \"failed\" status (e.g., error details, what went wrong)"]
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub status_message: ::std::option::Option<::std::string::String>,
    #[doc = "The task identifier."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
    #[doc = "Actual retention duration from creation in milliseconds, null for unlimited."]
    pub ttl: i64,
}
impl ::std::convert::From<&Task> for Task {
    fn from(value: &Task) -> Self {
        value.clone()
    }
}
impl Task {
    pub fn builder() -> builder::Task {
        Default::default()
    }
}
#[doc = "Common params for any task-augmented request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Common params for any task-augmented request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"task\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting task-augmented execution for this request.\\nThe request will return a CreateTaskResult immediately, and the actual result can be\\nretrieved later via tasks/result.\\n\\nTask augmentation is subject to capability negotiation - receivers MUST declare support\\nfor task augmentation of specific request types in their capabilities.\","]
#[doc = "      \"$ref\": \"#/$defs/TaskMetadata\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TaskAugmentedRequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<TaskAugmentedRequestParamsMeta>,
    #[doc = "If specified, the caller is requesting task-augmented execution for this request.\nThe request will return a CreateTaskResult immediately, and the actual result can be\nretrieved later via tasks/result.\n\nTask augmentation is subject to capability negotiation - receivers MUST declare support\nfor task augmentation of specific request types in their capabilities."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub task: ::std::option::Option<TaskMetadata>,
}
impl ::std::convert::From<&TaskAugmentedRequestParams> for TaskAugmentedRequestParams {
    fn from(value: &TaskAugmentedRequestParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TaskAugmentedRequestParams {
    fn default() -> Self {
        Self {
            meta: Default::default(),
            task: Default::default(),
        }
    }
}
impl TaskAugmentedRequestParams {
    pub fn builder() -> builder::TaskAugmentedRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TaskAugmentedRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&TaskAugmentedRequestParamsMeta> for TaskAugmentedRequestParamsMeta {
    fn from(value: &TaskAugmentedRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TaskAugmentedRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl TaskAugmentedRequestParamsMeta {
    pub fn builder() -> builder::TaskAugmentedRequestParamsMeta {
        Default::default()
    }
}
#[doc = "Metadata for augmenting a request with task execution.\nInclude this in the `task` field of the request parameters."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Metadata for augmenting a request with task execution.\\nInclude this in the `task` field of the request parameters.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"ttl\": {"]
#[doc = "      \"description\": \"Requested duration in milliseconds to retain task from creation.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TaskMetadata {
    #[doc = "Requested duration in milliseconds to retain task from creation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ttl: ::std::option::Option<i64>,
}
impl ::std::convert::From<&TaskMetadata> for TaskMetadata {
    fn from(value: &TaskMetadata) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TaskMetadata {
    fn default() -> Self {
        Self {
            ttl: Default::default(),
        }
    }
}
impl TaskMetadata {
    pub fn builder() -> builder::TaskMetadata {
        Default::default()
    }
}
#[doc = "The status of a task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The status of a task.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"cancelled\","]
#[doc = "    \"completed\","]
#[doc = "    \"failed\","]
#[doc = "    \"input_required\","]
#[doc = "    \"working\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TaskStatus {
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "input_required")]
    InputRequired,
    #[serde(rename = "working")]
    Working,
}
impl ::std::convert::From<&Self> for TaskStatus {
    fn from(value: &TaskStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Cancelled => write!(f, "cancelled"),
            Self::Completed => write!(f, "completed"),
            Self::Failed => write!(f, "failed"),
            Self::InputRequired => write!(f, "input_required"),
            Self::Working => write!(f, "working"),
        }
    }
}
impl ::std::str::FromStr for TaskStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "failed" => Ok(Self::Failed),
            "input_required" => Ok(Self::InputRequired),
            "working" => Ok(Self::Working),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TaskStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TaskStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TaskStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "An optional notification from the receiver to the requestor, informing them that a task's status has changed. Receivers are not required to send these notifications."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional notification from the receiver to the requestor, informing them that a task's status has changed. Receivers are not required to send these notifications.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/tasks/status\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/TaskStatusNotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TaskStatusNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: TaskStatusNotificationParams,
}
impl ::std::convert::From<&TaskStatusNotification> for TaskStatusNotification {
    fn from(value: &TaskStatusNotification) -> Self {
        value.clone()
    }
}
impl TaskStatusNotification {
    pub fn builder() -> builder::TaskStatusNotification {
        Default::default()
    }
}
#[doc = "Parameters for a `notifications/tasks/status` notification."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `notifications/tasks/status` notification.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Task\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TaskStatusNotificationParams {
    #[doc = "ISO 8601 timestamp when the task was created."]
    #[serde(rename = "createdAt")]
    pub created_at: ::std::string::String,
    #[doc = "ISO 8601 timestamp when the task was last updated."]
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: ::std::string::String,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<TaskStatusNotificationParamsMeta>,
    #[doc = "Suggested polling interval in milliseconds."]
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub poll_interval: ::std::option::Option<i64>,
    #[doc = "Current task state."]
    pub status: TaskStatus,
    #[doc = "Optional human-readable message describing the current task state.\nThis can provide context for any status, including:\n- Reasons for \"cancelled\" status\n- Summaries for \"completed\" status\n- Diagnostic information for \"failed\" status (e.g., error details, what went wrong)"]
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub status_message: ::std::option::Option<::std::string::String>,
    #[doc = "The task identifier."]
    #[serde(rename = "taskId")]
    pub task_id: ::std::string::String,
    #[doc = "Actual retention duration from creation in milliseconds, null for unlimited."]
    pub ttl: i64,
}
impl ::std::convert::From<&TaskStatusNotificationParams> for TaskStatusNotificationParams {
    fn from(value: &TaskStatusNotificationParams) -> Self {
        value.clone()
    }
}
impl TaskStatusNotificationParams {
    pub fn builder() -> builder::TaskStatusNotificationParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TaskStatusNotificationParamsMeta {}
impl ::std::convert::From<&TaskStatusNotificationParamsMeta> for TaskStatusNotificationParamsMeta {
    fn from(value: &TaskStatusNotificationParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TaskStatusNotificationParamsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl TaskStatusNotificationParamsMeta {
    pub fn builder() -> builder::TaskStatusNotificationParamsMeta {
        Default::default()
    }
}
#[doc = "Text provided to or from an LLM."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Text provided to or from an LLM.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"text\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional annotations for the client.\","]
#[doc = "      \"$ref\": \"#/$defs/Annotations\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"description\": \"The text content of the message.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"text\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TextContent {
    #[doc = "Optional annotations for the client."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<Annotations>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<TextContentMeta>,
    #[doc = "The text content of the message."]
    pub text: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&TextContent> for TextContent {
    fn from(value: &TextContent) -> Self {
        value.clone()
    }
}
impl TextContent {
    pub fn builder() -> builder::TextContent {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TextContentMeta {}
impl ::std::convert::From<&TextContentMeta> for TextContentMeta {
    fn from(value: &TextContentMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TextContentMeta {
    fn default() -> Self {
        Self {}
    }
}
impl TextContentMeta {
    pub fn builder() -> builder::TextContentMeta {
        Default::default()
    }
}
#[doc = "`TextResourceContents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"text\","]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"mimeType\": {"]
#[doc = "      \"description\": \"The MIME type of this resource, if known.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"description\": \"The text of the item. This must only be set if the item can actually be represented as text (not binary data).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of this resource.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TextResourceContents {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<TextResourceContentsMeta>,
    #[doc = "The MIME type of this resource, if known."]
    #[serde(
        rename = "mimeType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mime_type: ::std::option::Option<::std::string::String>,
    #[doc = "The text of the item. This must only be set if the item can actually be represented as text (not binary data)."]
    pub text: ::std::string::String,
    #[doc = "The URI of this resource."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&TextResourceContents> for TextResourceContents {
    fn from(value: &TextResourceContents) -> Self {
        value.clone()
    }
}
impl TextResourceContents {
    pub fn builder() -> builder::TextResourceContents {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TextResourceContentsMeta {}
impl ::std::convert::From<&TextResourceContentsMeta> for TextResourceContentsMeta {
    fn from(value: &TextResourceContentsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TextResourceContentsMeta {
    fn default() -> Self {
        Self {}
    }
}
impl TextResourceContentsMeta {
    pub fn builder() -> builder::TextResourceContentsMeta {
        Default::default()
    }
}
#[doc = "Schema for multiple-selection enumeration with display titles for each option."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for multiple-selection enumeration with display titles for each option.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"items\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"description\": \"Optional default value.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Optional description for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"items\": {"]
#[doc = "      \"description\": \"Schema for array items with enum options and display labels.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"anyOf\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"anyOf\": {"]
#[doc = "          \"description\": \"Array of enum options with values and display labels.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"const\","]
#[doc = "              \"title\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"const\": {"]
#[doc = "                \"description\": \"The constant enum value.\","]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"title\": {"]
#[doc = "                \"description\": \"Display title for this option.\","]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"maxItems\": {"]
#[doc = "      \"description\": \"Maximum number of items to select.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"minItems\": {"]
#[doc = "      \"description\": \"Minimum number of items to select.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Optional title for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"array\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitledMultiSelectEnumSchema {
    #[doc = "Optional default value."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub default: ::std::vec::Vec<::std::string::String>,
    #[doc = "Optional description for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    pub items: TitledMultiSelectEnumSchemaItems,
    #[doc = "Maximum number of items to select."]
    #[serde(
        rename = "maxItems",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_items: ::std::option::Option<i64>,
    #[doc = "Minimum number of items to select."]
    #[serde(
        rename = "minItems",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_items: ::std::option::Option<i64>,
    #[doc = "Optional title for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&TitledMultiSelectEnumSchema> for TitledMultiSelectEnumSchema {
    fn from(value: &TitledMultiSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl TitledMultiSelectEnumSchema {
    pub fn builder() -> builder::TitledMultiSelectEnumSchema {
        Default::default()
    }
}
#[doc = "Schema for array items with enum options and display labels."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for array items with enum options and display labels.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"anyOf\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"anyOf\": {"]
#[doc = "      \"description\": \"Array of enum options with values and display labels.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"const\","]
#[doc = "          \"title\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"const\": {"]
#[doc = "            \"description\": \"The constant enum value.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"title\": {"]
#[doc = "            \"description\": \"Display title for this option.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitledMultiSelectEnumSchemaItems {
    #[doc = "Array of enum options with values and display labels."]
    #[serde(rename = "anyOf")]
    pub any_of: ::std::vec::Vec<TitledMultiSelectEnumSchemaItemsAnyOfItem>,
}
impl ::std::convert::From<&TitledMultiSelectEnumSchemaItems> for TitledMultiSelectEnumSchemaItems {
    fn from(value: &TitledMultiSelectEnumSchemaItems) -> Self {
        value.clone()
    }
}
impl TitledMultiSelectEnumSchemaItems {
    pub fn builder() -> builder::TitledMultiSelectEnumSchemaItems {
        Default::default()
    }
}
#[doc = "`TitledMultiSelectEnumSchemaItemsAnyOfItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"const\","]
#[doc = "    \"title\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"const\": {"]
#[doc = "      \"description\": \"The constant enum value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Display title for this option.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitledMultiSelectEnumSchemaItemsAnyOfItem {
    #[doc = "The constant enum value."]
    #[serde(rename = "const")]
    pub const_: ::std::string::String,
    #[doc = "Display title for this option."]
    pub title: ::std::string::String,
}
impl ::std::convert::From<&TitledMultiSelectEnumSchemaItemsAnyOfItem>
    for TitledMultiSelectEnumSchemaItemsAnyOfItem
{
    fn from(value: &TitledMultiSelectEnumSchemaItemsAnyOfItem) -> Self {
        value.clone()
    }
}
impl TitledMultiSelectEnumSchemaItemsAnyOfItem {
    pub fn builder() -> builder::TitledMultiSelectEnumSchemaItemsAnyOfItem {
        Default::default()
    }
}
#[doc = "Schema for single-selection enumeration with display titles for each option."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for single-selection enumeration with display titles for each option.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"oneOf\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"description\": \"Optional default value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Optional description for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"oneOf\": {"]
#[doc = "      \"description\": \"Array of enum options with values and display labels.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"const\","]
#[doc = "          \"title\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"const\": {"]
#[doc = "            \"description\": \"The enum value.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"title\": {"]
#[doc = "            \"description\": \"Display label for this option.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Optional title for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitledSingleSelectEnumSchema {
    #[doc = "Optional default value."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<::std::string::String>,
    #[doc = "Optional description for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Array of enum options with values and display labels."]
    #[serde(rename = "oneOf")]
    pub one_of: ::std::vec::Vec<TitledSingleSelectEnumSchemaOneOfItem>,
    #[doc = "Optional title for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&TitledSingleSelectEnumSchema> for TitledSingleSelectEnumSchema {
    fn from(value: &TitledSingleSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl TitledSingleSelectEnumSchema {
    pub fn builder() -> builder::TitledSingleSelectEnumSchema {
        Default::default()
    }
}
#[doc = "`TitledSingleSelectEnumSchemaOneOfItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"const\","]
#[doc = "    \"title\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"const\": {"]
#[doc = "      \"description\": \"The enum value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Display label for this option.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitledSingleSelectEnumSchemaOneOfItem {
    #[doc = "The enum value."]
    #[serde(rename = "const")]
    pub const_: ::std::string::String,
    #[doc = "Display label for this option."]
    pub title: ::std::string::String,
}
impl ::std::convert::From<&TitledSingleSelectEnumSchemaOneOfItem>
    for TitledSingleSelectEnumSchemaOneOfItem
{
    fn from(value: &TitledSingleSelectEnumSchemaOneOfItem) -> Self {
        value.clone()
    }
}
impl TitledSingleSelectEnumSchemaOneOfItem {
    pub fn builder() -> builder::TitledSingleSelectEnumSchemaOneOfItem {
        Default::default()
    }
}
#[doc = "Definition for a tool the client can call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Definition for a tool the client can call.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"inputSchema\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"annotations\": {"]
#[doc = "      \"description\": \"Optional additional tool information.\\n\\nDisplay name precedence order is: title, annotations.title, then name.\","]
#[doc = "      \"$ref\": \"#/$defs/ToolAnnotations\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"A human-readable description of the tool.\\n\\nThis can be used by clients to improve the LLM's understanding of available tools. It can be thought of like a \\\"hint\\\" to the model.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"execution\": {"]
#[doc = "      \"description\": \"Execution-related properties for this tool.\","]
#[doc = "      \"$ref\": \"#/$defs/ToolExecution\""]
#[doc = "    },"]
#[doc = "    \"icons\": {"]
#[doc = "      \"description\": \"Optional set of sized icons that the client can display in a user interface.\\n\\nClients that support rendering icons MUST support at least the following MIME types:\\n- `image/png` - PNG images (safe, universal compatibility)\\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\\n\\nClients that support rendering icons SHOULD also support:\\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\\n- `image/webp` - WebP images (modern, efficient format)\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/Icon\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"inputSchema\": {"]
#[doc = "      \"description\": \"A JSON Schema object defining the expected parameters for the tool.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"$schema\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"additionalProperties\": true"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"required\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"outputSchema\": {"]
#[doc = "      \"description\": \"An optional JSON Schema object defining the structure of the tool's output returned in\\nthe structuredContent field of a CallToolResult.\\n\\nDefaults to JSON Schema 2020-12 when no explicit $schema is provided.\\nCurrently restricted to type: \\\"object\\\" at the root level.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"$schema\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"properties\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"additionalProperties\": true"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"required\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\\neven by those unfamiliar with domain-specific terminology.\\n\\nIf not provided, the name should be used for display (except for Tool,\\nwhere `annotations.title` should be given precedence over using `name`,\\nif present).\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Tool {
    #[doc = "Optional additional tool information.\n\nDisplay name precedence order is: title, annotations.title, then name."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub annotations: ::std::option::Option<ToolAnnotations>,
    #[doc = "A human-readable description of the tool.\n\nThis can be used by clients to improve the LLM's understanding of available tools. It can be thought of like a \"hint\" to the model."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Execution-related properties for this tool."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub execution: ::std::option::Option<ToolExecution>,
    #[doc = "Optional set of sized icons that the client can display in a user interface.\n\nClients that support rendering icons MUST support at least the following MIME types:\n- `image/png` - PNG images (safe, universal compatibility)\n- `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)\n\nClients that support rendering icons SHOULD also support:\n- `image/svg+xml` - SVG images (scalable but requires security precautions)\n- `image/webp` - WebP images (modern, efficient format)"]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub icons: ::std::vec::Vec<Icon>,
    #[serde(rename = "inputSchema")]
    pub input_schema: ToolInputSchema,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ToolMeta>,
    #[doc = "Intended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn't present)."]
    pub name: ::std::string::String,
    #[serde(
        rename = "outputSchema",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub output_schema: ::std::option::Option<ToolOutputSchema>,
    #[doc = "Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\neven by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title` should be given precedence over using `name`,\nif present)."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Tool> for Tool {
    fn from(value: &Tool) -> Self {
        value.clone()
    }
}
impl Tool {
    pub fn builder() -> builder::Tool {
        Default::default()
    }
}
#[doc = "Additional properties describing a Tool to clients.\n\nNOTE: all properties in ToolAnnotations are **hints**.\nThey are not guaranteed to provide a faithful description of\ntool behavior (including descriptive properties like `title`).\n\nClients should never make tool use decisions based on ToolAnnotations\nreceived from untrusted servers."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Additional properties describing a Tool to clients.\\n\\nNOTE: all properties in ToolAnnotations are **hints**.\\nThey are not guaranteed to provide a faithful description of\\ntool behavior (including descriptive properties like `title`).\\n\\nClients should never make tool use decisions based on ToolAnnotations\\nreceived from untrusted servers.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"destructiveHint\": {"]
#[doc = "      \"description\": \"If true, the tool may perform destructive updates to its environment.\\nIf false, the tool performs only additive updates.\\n\\n(This property is meaningful only when `readOnlyHint == false`)\\n\\nDefault: true\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"idempotentHint\": {"]
#[doc = "      \"description\": \"If true, calling the tool repeatedly with the same arguments\\nwill have no additional effect on its environment.\\n\\n(This property is meaningful only when `readOnlyHint == false`)\\n\\nDefault: false\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"openWorldHint\": {"]
#[doc = "      \"description\": \"If true, this tool may interact with an \\\"open world\\\" of external\\nentities. If false, the tool's domain of interaction is closed.\\nFor example, the world of a web search tool is open, whereas that\\nof a memory tool is not.\\n\\nDefault: true\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"readOnlyHint\": {"]
#[doc = "      \"description\": \"If true, the tool does not modify its environment.\\n\\nDefault: false\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"A human-readable title for the tool.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolAnnotations {
    #[doc = "If true, the tool may perform destructive updates to its environment.\nIf false, the tool performs only additive updates.\n\n(This property is meaningful only when `readOnlyHint == false`)\n\nDefault: true"]
    #[serde(
        rename = "destructiveHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub destructive_hint: ::std::option::Option<bool>,
    #[doc = "If true, calling the tool repeatedly with the same arguments\nwill have no additional effect on its environment.\n\n(This property is meaningful only when `readOnlyHint == false`)\n\nDefault: false"]
    #[serde(
        rename = "idempotentHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub idempotent_hint: ::std::option::Option<bool>,
    #[doc = "If true, this tool may interact with an \"open world\" of external\nentities. If false, the tool's domain of interaction is closed.\nFor example, the world of a web search tool is open, whereas that\nof a memory tool is not.\n\nDefault: true"]
    #[serde(
        rename = "openWorldHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub open_world_hint: ::std::option::Option<bool>,
    #[doc = "If true, the tool does not modify its environment.\n\nDefault: false"]
    #[serde(
        rename = "readOnlyHint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub read_only_hint: ::std::option::Option<bool>,
    #[doc = "A human-readable title for the tool."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ToolAnnotations> for ToolAnnotations {
    fn from(value: &ToolAnnotations) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolAnnotations {
    fn default() -> Self {
        Self {
            destructive_hint: Default::default(),
            idempotent_hint: Default::default(),
            open_world_hint: Default::default(),
            read_only_hint: Default::default(),
            title: Default::default(),
        }
    }
}
impl ToolAnnotations {
    pub fn builder() -> builder::ToolAnnotations {
        Default::default()
    }
}
#[doc = "Controls tool selection behavior for sampling requests."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Controls tool selection behavior for sampling requests.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"mode\": {"]
#[doc = "      \"description\": \"Controls the tool use ability of the model:\\n- \\\"auto\\\": Model decides whether to use tools (default)\\n- \\\"required\\\": Model MUST use at least one tool before completing\\n- \\\"none\\\": Model MUST NOT use any tools\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\","]
#[doc = "        \"none\","]
#[doc = "        \"required\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolChoice {
    #[doc = "Controls the tool use ability of the model:\n- \"auto\": Model decides whether to use tools (default)\n- \"required\": Model MUST use at least one tool before completing\n- \"none\": Model MUST NOT use any tools"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mode: ::std::option::Option<ToolChoiceMode>,
}
impl ::std::convert::From<&ToolChoice> for ToolChoice {
    fn from(value: &ToolChoice) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolChoice {
    fn default() -> Self {
        Self {
            mode: Default::default(),
        }
    }
}
impl ToolChoice {
    pub fn builder() -> builder::ToolChoice {
        Default::default()
    }
}
#[doc = "Controls the tool use ability of the model:\n- \"auto\": Model decides whether to use tools (default)\n- \"required\": Model MUST use at least one tool before completing\n- \"none\": Model MUST NOT use any tools"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Controls the tool use ability of the model:\\n- \\\"auto\\\": Model decides whether to use tools (default)\\n- \\\"required\\\": Model MUST use at least one tool before completing\\n- \\\"none\\\": Model MUST NOT use any tools\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\","]
#[doc = "    \"none\","]
#[doc = "    \"required\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ToolChoiceMode {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "required")]
    Required,
}
impl ::std::convert::From<&Self> for ToolChoiceMode {
    fn from(value: &ToolChoiceMode) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ToolChoiceMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
            Self::None => write!(f, "none"),
            Self::Required => write!(f, "required"),
        }
    }
}
impl ::std::str::FromStr for ToolChoiceMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            "none" => Ok(Self::None),
            "required" => Ok(Self::Required),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ToolChoiceMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ToolChoiceMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ToolChoiceMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Execution-related properties for a tool."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Execution-related properties for a tool.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"taskSupport\": {"]
#[doc = "      \"description\": \"Indicates whether this tool supports task-augmented execution.\\nThis allows clients to handle long-running operations through polling\\nthe task system.\\n\\n- \\\"forbidden\\\": Tool does not support task-augmented execution (default when absent)\\n- \\\"optional\\\": Tool may support task-augmented execution\\n- \\\"required\\\": Tool requires task-augmented execution\\n\\nDefault: \\\"forbidden\\\"\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"forbidden\","]
#[doc = "        \"optional\","]
#[doc = "        \"required\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolExecution {
    #[doc = "Indicates whether this tool supports task-augmented execution.\nThis allows clients to handle long-running operations through polling\nthe task system.\n\n- \"forbidden\": Tool does not support task-augmented execution (default when absent)\n- \"optional\": Tool may support task-augmented execution\n- \"required\": Tool requires task-augmented execution\n\nDefault: \"forbidden\""]
    #[serde(
        rename = "taskSupport",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub task_support: ::std::option::Option<ToolExecutionTaskSupport>,
}
impl ::std::convert::From<&ToolExecution> for ToolExecution {
    fn from(value: &ToolExecution) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolExecution {
    fn default() -> Self {
        Self {
            task_support: Default::default(),
        }
    }
}
impl ToolExecution {
    pub fn builder() -> builder::ToolExecution {
        Default::default()
    }
}
#[doc = "Indicates whether this tool supports task-augmented execution.\nThis allows clients to handle long-running operations through polling\nthe task system.\n\n- \"forbidden\": Tool does not support task-augmented execution (default when absent)\n- \"optional\": Tool may support task-augmented execution\n- \"required\": Tool requires task-augmented execution\n\nDefault: \"forbidden\""]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Indicates whether this tool supports task-augmented execution.\\nThis allows clients to handle long-running operations through polling\\nthe task system.\\n\\n- \\\"forbidden\\\": Tool does not support task-augmented execution (default when absent)\\n- \\\"optional\\\": Tool may support task-augmented execution\\n- \\\"required\\\": Tool requires task-augmented execution\\n\\nDefault: \\\"forbidden\\\"\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"forbidden\","]
#[doc = "    \"optional\","]
#[doc = "    \"required\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ToolExecutionTaskSupport {
    #[serde(rename = "forbidden")]
    Forbidden,
    #[serde(rename = "optional")]
    Optional,
    #[serde(rename = "required")]
    Required,
}
impl ::std::convert::From<&Self> for ToolExecutionTaskSupport {
    fn from(value: &ToolExecutionTaskSupport) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ToolExecutionTaskSupport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Forbidden => write!(f, "forbidden"),
            Self::Optional => write!(f, "optional"),
            Self::Required => write!(f, "required"),
        }
    }
}
impl ::std::str::FromStr for ToolExecutionTaskSupport {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "forbidden" => Ok(Self::Forbidden),
            "optional" => Ok(Self::Optional),
            "required" => Ok(Self::Required),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ToolExecutionTaskSupport {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ToolExecutionTaskSupport {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ToolExecutionTaskSupport {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A JSON Schema object defining the expected parameters for the tool."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A JSON Schema object defining the expected parameters for the tool.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"$schema\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"properties\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"additionalProperties\": true"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"required\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"object\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolInputSchema {
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub properties: ::std::collections::HashMap<
        ::std::string::String,
        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    >,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub required: ::std::vec::Vec<::std::string::String>,
    #[serde(
        rename = "$schema",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub schema: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ToolInputSchema> for ToolInputSchema {
    fn from(value: &ToolInputSchema) -> Self {
        value.clone()
    }
}
impl ToolInputSchema {
    pub fn builder() -> builder::ToolInputSchema {
        Default::default()
    }
}
#[doc = "An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"notifications/tools/list_changed\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/NotificationParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolListChangedNotification {
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NotificationParams>,
}
impl ::std::convert::From<&ToolListChangedNotification> for ToolListChangedNotification {
    fn from(value: &ToolListChangedNotification) -> Self {
        value.clone()
    }
}
impl ToolListChangedNotification {
    pub fn builder() -> builder::ToolListChangedNotification {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ToolMeta {}
impl ::std::convert::From<&ToolMeta> for ToolMeta {
    fn from(value: &ToolMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ToolMeta {
    pub fn builder() -> builder::ToolMeta {
        Default::default()
    }
}
#[doc = "An optional JSON Schema object defining the structure of the tool's output returned in\nthe structuredContent field of a CallToolResult.\n\nDefaults to JSON Schema 2020-12 when no explicit $schema is provided.\nCurrently restricted to type: \"object\" at the root level."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional JSON Schema object defining the structure of the tool's output returned in\\nthe structuredContent field of a CallToolResult.\\n\\nDefaults to JSON Schema 2020-12 when no explicit $schema is provided.\\nCurrently restricted to type: \\\"object\\\" at the root level.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"$schema\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"properties\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"additionalProperties\": true"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"required\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"object\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolOutputSchema {
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub properties: ::std::collections::HashMap<
        ::std::string::String,
        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    >,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub required: ::std::vec::Vec<::std::string::String>,
    #[serde(
        rename = "$schema",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub schema: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ToolOutputSchema> for ToolOutputSchema {
    fn from(value: &ToolOutputSchema) -> Self {
        value.clone()
    }
}
impl ToolOutputSchema {
    pub fn builder() -> builder::ToolOutputSchema {
        Default::default()
    }
}
#[doc = "The result of a tool use, provided by the user back to the assistant."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The result of a tool use, provided by the user back to the assistant.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"content\","]
#[doc = "    \"toolUseId\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"Optional metadata about the tool result. Clients SHOULD preserve this field when\\nincluding tool results in subsequent sampling requests to enable caching optimizations.\\n\\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"content\": {"]
#[doc = "      \"description\": \"The unstructured result content of the tool use.\\n\\nThis has the same format as CallToolResult.content and can include text, images,\\naudio, resource links, and embedded resources.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/ContentBlock\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"isError\": {"]
#[doc = "      \"description\": \"Whether the tool use resulted in an error.\\n\\nIf true, the content typically describes the error that occurred.\\nDefault: false\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"structuredContent\": {"]
#[doc = "      \"description\": \"An optional structured result object.\\n\\nIf the tool defined an outputSchema, this SHOULD conform to that schema.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"toolUseId\": {"]
#[doc = "      \"description\": \"The ID of the tool use this result corresponds to.\\n\\nThis MUST match the ID from a previous ToolUseContent.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tool_result\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolResultContent {
    #[doc = "The unstructured result content of the tool use.\n\nThis has the same format as CallToolResult.content and can include text, images,\naudio, resource links, and embedded resources."]
    pub content: ::std::vec::Vec<ContentBlock>,
    #[doc = "Whether the tool use resulted in an error.\n\nIf true, the content typically describes the error that occurred.\nDefault: false"]
    #[serde(
        rename = "isError",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_error: ::std::option::Option<bool>,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ToolResultContentMeta>,
    #[serde(
        rename = "structuredContent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub structured_content: ::std::option::Option<ToolResultContentStructuredContent>,
    #[doc = "The ID of the tool use this result corresponds to.\n\nThis MUST match the ID from a previous ToolUseContent."]
    #[serde(rename = "toolUseId")]
    pub tool_use_id: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ToolResultContent> for ToolResultContent {
    fn from(value: &ToolResultContent) -> Self {
        value.clone()
    }
}
impl ToolResultContent {
    pub fn builder() -> builder::ToolResultContent {
        Default::default()
    }
}
#[doc = "Optional metadata about the tool result. Clients SHOULD preserve this field when\nincluding tool results in subsequent sampling requests to enable caching optimizations.\n\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Optional metadata about the tool result. Clients SHOULD preserve this field when\\nincluding tool results in subsequent sampling requests to enable caching optimizations.\\n\\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ToolResultContentMeta {}
impl ::std::convert::From<&ToolResultContentMeta> for ToolResultContentMeta {
    fn from(value: &ToolResultContentMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolResultContentMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ToolResultContentMeta {
    pub fn builder() -> builder::ToolResultContentMeta {
        Default::default()
    }
}
#[doc = "An optional structured result object.\n\nIf the tool defined an outputSchema, this SHOULD conform to that schema."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An optional structured result object.\\n\\nIf the tool defined an outputSchema, this SHOULD conform to that schema.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ToolResultContentStructuredContent {}
impl ::std::convert::From<&ToolResultContentStructuredContent>
    for ToolResultContentStructuredContent
{
    fn from(value: &ToolResultContentStructuredContent) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolResultContentStructuredContent {
    fn default() -> Self {
        Self {}
    }
}
impl ToolResultContentStructuredContent {
    pub fn builder() -> builder::ToolResultContentStructuredContent {
        Default::default()
    }
}
#[doc = "A request from the assistant to call a tool."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A request from the assistant to call a tool.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"input\","]
#[doc = "    \"name\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"Optional metadata about the tool use. Clients SHOULD preserve this field when\\nincluding tool uses in subsequent sampling requests to enable caching optimizations.\\n\\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"A unique identifier for this tool use.\\n\\nThis ID is used to match tool results to their corresponding tool uses.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"description\": \"The arguments to pass to the tool, conforming to the tool's input schema.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"description\": \"The name of the tool to call.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"tool_use\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ToolUseContent {
    #[doc = "A unique identifier for this tool use.\n\nThis ID is used to match tool results to their corresponding tool uses."]
    pub id: ::std::string::String,
    pub input: ToolUseContentInput,
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<ToolUseContentMeta>,
    #[doc = "The name of the tool to call."]
    pub name: ::std::string::String,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&ToolUseContent> for ToolUseContent {
    fn from(value: &ToolUseContent) -> Self {
        value.clone()
    }
}
impl ToolUseContent {
    pub fn builder() -> builder::ToolUseContent {
        Default::default()
    }
}
#[doc = "The arguments to pass to the tool, conforming to the tool's input schema."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The arguments to pass to the tool, conforming to the tool's input schema.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ToolUseContentInput {}
impl ::std::convert::From<&ToolUseContentInput> for ToolUseContentInput {
    fn from(value: &ToolUseContentInput) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolUseContentInput {
    fn default() -> Self {
        Self {}
    }
}
impl ToolUseContentInput {
    pub fn builder() -> builder::ToolUseContentInput {
        Default::default()
    }
}
#[doc = "Optional metadata about the tool use. Clients SHOULD preserve this field when\nincluding tool uses in subsequent sampling requests to enable caching optimizations.\n\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Optional metadata about the tool use. Clients SHOULD preserve this field when\\nincluding tool uses in subsequent sampling requests to enable caching optimizations.\\n\\nSee [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ToolUseContentMeta {}
impl ::std::convert::From<&ToolUseContentMeta> for ToolUseContentMeta {
    fn from(value: &ToolUseContentMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ToolUseContentMeta {
    fn default() -> Self {
        Self {}
    }
}
impl ToolUseContentMeta {
    pub fn builder() -> builder::ToolUseContentMeta {
        Default::default()
    }
}
#[doc = "Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"resources/unsubscribe\""]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/$defs/UnsubscribeRequestParams\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UnsubscribeRequest {
    pub id: RequestId,
    pub jsonrpc: ::std::string::String,
    pub method: ::std::string::String,
    pub params: UnsubscribeRequestParams,
}
impl ::std::convert::From<&UnsubscribeRequest> for UnsubscribeRequest {
    fn from(value: &UnsubscribeRequest) -> Self {
        value.clone()
    }
}
impl UnsubscribeRequest {
    pub fn builder() -> builder::UnsubscribeRequest {
        Default::default()
    }
}
#[doc = "Parameters for a `resources/unsubscribe` request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Parameters for a `resources/unsubscribe` request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"uri\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"_meta\": {"]
#[doc = "      \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"progressToken\": {"]
#[doc = "          \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "          \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"uri\": {"]
#[doc = "      \"description\": \"The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UnsubscribeRequestParams {
    #[serde(
        rename = "_meta",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub meta: ::std::option::Option<UnsubscribeRequestParamsMeta>,
    #[doc = "The URI of the resource. The URI can use any protocol; it is up to the server how to interpret it."]
    pub uri: ::std::string::String,
}
impl ::std::convert::From<&UnsubscribeRequestParams> for UnsubscribeRequestParams {
    fn from(value: &UnsubscribeRequestParams) -> Self {
        value.clone()
    }
}
impl UnsubscribeRequestParams {
    pub fn builder() -> builder::UnsubscribeRequestParams {
        Default::default()
    }
}
#[doc = "See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for notes on `_meta` usage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"progressToken\": {"]
#[doc = "      \"description\": \"If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\","]
#[doc = "      \"$ref\": \"#/$defs/ProgressToken\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct UnsubscribeRequestParamsMeta {
    #[doc = "If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications."]
    #[serde(
        rename = "progressToken",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub progress_token: ::std::option::Option<ProgressToken>,
}
impl ::std::convert::From<&UnsubscribeRequestParamsMeta> for UnsubscribeRequestParamsMeta {
    fn from(value: &UnsubscribeRequestParamsMeta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for UnsubscribeRequestParamsMeta {
    fn default() -> Self {
        Self {
            progress_token: Default::default(),
        }
    }
}
impl UnsubscribeRequestParamsMeta {
    pub fn builder() -> builder::UnsubscribeRequestParamsMeta {
        Default::default()
    }
}
#[doc = "Schema for multiple-selection enumeration without display titles for options."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for multiple-selection enumeration without display titles for options.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"items\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"description\": \"Optional default value.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Optional description for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"items\": {"]
#[doc = "      \"description\": \"Schema for the array items.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"enum\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"enum\": {"]
#[doc = "          \"description\": \"Array of enum values to choose from.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"maxItems\": {"]
#[doc = "      \"description\": \"Maximum number of items to select.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"minItems\": {"]
#[doc = "      \"description\": \"Minimum number of items to select.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Optional title for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"array\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UntitledMultiSelectEnumSchema {
    #[doc = "Optional default value."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub default: ::std::vec::Vec<::std::string::String>,
    #[doc = "Optional description for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    pub items: UntitledMultiSelectEnumSchemaItems,
    #[doc = "Maximum number of items to select."]
    #[serde(
        rename = "maxItems",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_items: ::std::option::Option<i64>,
    #[doc = "Minimum number of items to select."]
    #[serde(
        rename = "minItems",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_items: ::std::option::Option<i64>,
    #[doc = "Optional title for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&UntitledMultiSelectEnumSchema> for UntitledMultiSelectEnumSchema {
    fn from(value: &UntitledMultiSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl UntitledMultiSelectEnumSchema {
    pub fn builder() -> builder::UntitledMultiSelectEnumSchema {
        Default::default()
    }
}
#[doc = "Schema for the array items."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for the array items.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"enum\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"enum\": {"]
#[doc = "      \"description\": \"Array of enum values to choose from.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UntitledMultiSelectEnumSchemaItems {
    #[doc = "Array of enum values to choose from."]
    #[serde(rename = "enum")]
    pub enum_: ::std::vec::Vec<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&UntitledMultiSelectEnumSchemaItems>
    for UntitledMultiSelectEnumSchemaItems
{
    fn from(value: &UntitledMultiSelectEnumSchemaItems) -> Self {
        value.clone()
    }
}
impl UntitledMultiSelectEnumSchemaItems {
    pub fn builder() -> builder::UntitledMultiSelectEnumSchemaItems {
        Default::default()
    }
}
#[doc = "Schema for single-selection enumeration without display titles for options."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Schema for single-selection enumeration without display titles for options.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"enum\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"description\": \"Optional default value.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"description\": \"Optional description for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"enum\": {"]
#[doc = "      \"description\": \"Array of enum values to choose from.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"description\": \"Optional title for the enum field.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UntitledSingleSelectEnumSchema {
    #[doc = "Optional default value."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<::std::string::String>,
    #[doc = "Optional description for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[doc = "Array of enum values to choose from."]
    #[serde(rename = "enum")]
    pub enum_: ::std::vec::Vec<::std::string::String>,
    #[doc = "Optional title for the enum field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&UntitledSingleSelectEnumSchema> for UntitledSingleSelectEnumSchema {
    fn from(value: &UntitledSingleSelectEnumSchema) -> Self {
        value.clone()
    }
}
impl UntitledSingleSelectEnumSchema {
    pub fn builder() -> builder::UntitledSingleSelectEnumSchema {
        Default::default()
    }
}
#[doc = "An error response that indicates that the server requires the client to provide additional information via an elicitation request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An error response that indicates that the server requires the client to provide additional information via an elicitation request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/Error\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\","]
#[doc = "            \"data\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"const\": -32042"]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"elicitations\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"elicitations\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/$defs/ElicitRequestURLParams\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/$defs/RequestId\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"const\": \"2.0\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UrlElicitationRequiredError {
    pub error: UrlElicitationRequiredErrorError,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<RequestId>,
    pub jsonrpc: ::std::string::String,
}
impl ::std::convert::From<&UrlElicitationRequiredError> for UrlElicitationRequiredError {
    fn from(value: &UrlElicitationRequiredError) -> Self {
        value.clone()
    }
}
impl UrlElicitationRequiredError {
    pub fn builder() -> builder::UrlElicitationRequiredError {
        Default::default()
    }
}
#[doc = "`UrlElicitationRequiredErrorError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/Error\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"const\": -32042"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"elicitations\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"elicitations\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/$defs/ElicitRequestURLParams\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UrlElicitationRequiredErrorError {
    pub code: UrlElicitationRequiredErrorErrorCode,
    pub data: UrlElicitationRequiredErrorErrorData,
    #[doc = "A short description of the error. The message SHOULD be limited to a concise single sentence."]
    pub message: ::std::string::String,
}
impl ::std::convert::From<&UrlElicitationRequiredErrorError> for UrlElicitationRequiredErrorError {
    fn from(value: &UrlElicitationRequiredErrorError) -> Self {
        value.clone()
    }
}
impl UrlElicitationRequiredErrorError {
    pub fn builder() -> builder::UrlElicitationRequiredErrorError {
        Default::default()
    }
}
#[doc = "`UrlElicitationRequiredErrorErrorCode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    -32042"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UrlElicitationRequiredErrorErrorCode(i64);
impl ::std::ops::Deref for UrlElicitationRequiredErrorErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<UrlElicitationRequiredErrorErrorCode> for i64 {
    fn from(value: UrlElicitationRequiredErrorErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UrlElicitationRequiredErrorErrorCode>
    for UrlElicitationRequiredErrorErrorCode
{
    fn from(value: &UrlElicitationRequiredErrorErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for UrlElicitationRequiredErrorErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![-32042_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for UrlElicitationRequiredErrorErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`UrlElicitationRequiredErrorErrorData`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"elicitations\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"elicitations\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/$defs/ElicitRequestURLParams\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct UrlElicitationRequiredErrorErrorData {
    pub elicitations: ::std::vec::Vec<ElicitRequestUrlParams>,
}
impl ::std::convert::From<&UrlElicitationRequiredErrorErrorData>
    for UrlElicitationRequiredErrorErrorData
{
    fn from(value: &UrlElicitationRequiredErrorErrorData) -> Self {
        value.clone()
    }
}
impl UrlElicitationRequiredErrorErrorData {
    pub fn builder() -> builder::UrlElicitationRequiredErrorErrorData {
        Default::default()
    }
}
#[doc = r" Types for composing complex structures."]
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct Annotations {
        audience: ::std::result::Result<::std::vec::Vec<super::Role>, ::std::string::String>,
        last_modified: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        priority: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for Annotations {
        fn default() -> Self {
            Self {
                audience: Ok(Default::default()),
                last_modified: Ok(Default::default()),
                priority: Ok(Default::default()),
            }
        }
    }
    impl Annotations {
        pub fn audience<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Role>>,
            T::Error: ::std::fmt::Display,
        {
            self.audience = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for audience: {}", e));
            self
        }
        pub fn last_modified<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.last_modified = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for last_modified: {}", e));
            self
        }
        pub fn priority<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.priority = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for priority: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Annotations> for super::Annotations {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Annotations,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                audience: value.audience?,
                last_modified: value.last_modified?,
                priority: value.priority?,
            })
        }
    }
    impl ::std::convert::From<super::Annotations> for Annotations {
        fn from(value: super::Annotations) -> Self {
            Self {
                audience: Ok(value.audience),
                last_modified: Ok(value.last_modified),
                priority: Ok(value.priority),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct AudioContent {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        data: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::AudioContentMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for AudioContent {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                data: Err("no value supplied for data".to_string()),
                meta: Ok(Default::default()),
                mime_type: Err("no value supplied for mime_type".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl AudioContent {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::AudioContentMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<AudioContent> for super::AudioContent {
        type Error = super::error::ConversionError;
        fn try_from(
            value: AudioContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                data: value.data?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::AudioContent> for AudioContent {
        fn from(value: super::AudioContent) -> Self {
            Self {
                annotations: Ok(value.annotations),
                data: Ok(value.data),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct AudioContentMeta {}
    impl ::std::default::Default for AudioContentMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl AudioContentMeta {}
    impl ::std::convert::TryFrom<AudioContentMeta> for super::AudioContentMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: AudioContentMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::AudioContentMeta> for AudioContentMeta {
        fn from(_value: super::AudioContentMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct BaseMetadata {
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BaseMetadata {
        fn default() -> Self {
            Self {
                name: Err("no value supplied for name".to_string()),
                title: Ok(Default::default()),
            }
        }
    }
    impl BaseMetadata {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BaseMetadata> for super::BaseMetadata {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BaseMetadata,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                name: value.name?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::BaseMetadata> for BaseMetadata {
        fn from(value: super::BaseMetadata) -> Self {
            Self {
                name: Ok(value.name),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BlobResourceContents {
        blob: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::BlobResourceContentsMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for BlobResourceContents {
        fn default() -> Self {
            Self {
                blob: Err("no value supplied for blob".to_string()),
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl BlobResourceContents {
        pub fn blob<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.blob = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for blob: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::BlobResourceContentsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BlobResourceContents> for super::BlobResourceContents {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BlobResourceContents,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                blob: value.blob?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::BlobResourceContents> for BlobResourceContents {
        fn from(value: super::BlobResourceContents) -> Self {
            Self {
                blob: Ok(value.blob),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BlobResourceContentsMeta {}
    impl ::std::default::Default for BlobResourceContentsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl BlobResourceContentsMeta {}
    impl ::std::convert::TryFrom<BlobResourceContentsMeta> for super::BlobResourceContentsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: BlobResourceContentsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::BlobResourceContentsMeta> for BlobResourceContentsMeta {
        fn from(_value: super::BlobResourceContentsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct BooleanSchema {
        default: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for BooleanSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl BooleanSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BooleanSchema> for super::BooleanSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BooleanSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::BooleanSchema> for BooleanSchema {
        fn from(value: super::BooleanSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::CallToolRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for CallToolRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl CallToolRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CallToolRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CallToolRequest> for super::CallToolRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CallToolRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::CallToolRequest> for CallToolRequest {
        fn from(value: super::CallToolRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolRequestParams {
        arguments: ::std::result::Result<
            ::std::option::Option<super::CallToolRequestParamsArguments>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::CallToolRequestParamsMeta>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        task: ::std::result::Result<
            ::std::option::Option<super::TaskMetadata>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CallToolRequestParams {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
                meta: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                task: Ok(Default::default()),
            }
        }
    }
    impl CallToolRequestParams {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::CallToolRequestParamsArguments>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CallToolRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskMetadata>>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CallToolRequestParams> for super::CallToolRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CallToolRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
                meta: value.meta?,
                name: value.name?,
                task: value.task?,
            })
        }
    }
    impl ::std::convert::From<super::CallToolRequestParams> for CallToolRequestParams {
        fn from(value: super::CallToolRequestParams) -> Self {
            Self {
                arguments: Ok(value.arguments),
                meta: Ok(value.meta),
                name: Ok(value.name),
                task: Ok(value.task),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolRequestParamsArguments {}
    impl ::std::default::Default for CallToolRequestParamsArguments {
        fn default() -> Self {
            Self {}
        }
    }
    impl CallToolRequestParamsArguments {}
    impl ::std::convert::TryFrom<CallToolRequestParamsArguments>
        for super::CallToolRequestParamsArguments
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CallToolRequestParamsArguments,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CallToolRequestParamsArguments>
        for CallToolRequestParamsArguments
    {
        fn from(_value: super::CallToolRequestParamsArguments) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CallToolRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl CallToolRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CallToolRequestParamsMeta> for super::CallToolRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CallToolRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::CallToolRequestParamsMeta> for CallToolRequestParamsMeta {
        fn from(value: super::CallToolRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolResult {
        content: ::std::result::Result<::std::vec::Vec<super::ContentBlock>, ::std::string::String>,
        is_error: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::CallToolResultMeta>,
            ::std::string::String,
        >,
        structured_content: ::std::result::Result<
            ::std::option::Option<super::CallToolResultStructuredContent>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CallToolResult {
        fn default() -> Self {
            Self {
                content: Err("no value supplied for content".to_string()),
                is_error: Ok(Default::default()),
                meta: Ok(Default::default()),
                structured_content: Ok(Default::default()),
            }
        }
    }
    impl CallToolResult {
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ContentBlock>>,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn is_error<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_error = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for is_error: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CallToolResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn structured_content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::CallToolResultStructuredContent>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.structured_content = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for structured_content: {}",
                    e
                )
            });
            self
        }
    }
    impl ::std::convert::TryFrom<CallToolResult> for super::CallToolResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CallToolResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                content: value.content?,
                is_error: value.is_error?,
                meta: value.meta?,
                structured_content: value.structured_content?,
            })
        }
    }
    impl ::std::convert::From<super::CallToolResult> for CallToolResult {
        fn from(value: super::CallToolResult) -> Self {
            Self {
                content: Ok(value.content),
                is_error: Ok(value.is_error),
                meta: Ok(value.meta),
                structured_content: Ok(value.structured_content),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolResultMeta {}
    impl ::std::default::Default for CallToolResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl CallToolResultMeta {}
    impl ::std::convert::TryFrom<CallToolResultMeta> for super::CallToolResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CallToolResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CallToolResultMeta> for CallToolResultMeta {
        fn from(_value: super::CallToolResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct CallToolResultStructuredContent {}
    impl ::std::default::Default for CallToolResultStructuredContent {
        fn default() -> Self {
            Self {}
        }
    }
    impl CallToolResultStructuredContent {}
    impl ::std::convert::TryFrom<CallToolResultStructuredContent>
        for super::CallToolResultStructuredContent
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CallToolResultStructuredContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CallToolResultStructuredContent>
        for CallToolResultStructuredContent
    {
        fn from(_value: super::CallToolResultStructuredContent) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct CancelTaskRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::CancelTaskRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for CancelTaskRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl CancelTaskRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CancelTaskRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CancelTaskRequest> for super::CancelTaskRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CancelTaskRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::CancelTaskRequest> for CancelTaskRequest {
        fn from(value: super::CancelTaskRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CancelTaskRequestParams {
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for CancelTaskRequestParams {
        fn default() -> Self {
            Self {
                task_id: Err("no value supplied for task_id".to_string()),
            }
        }
    }
    impl CancelTaskRequestParams {
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CancelTaskRequestParams> for super::CancelTaskRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CancelTaskRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                task_id: value.task_id?,
            })
        }
    }
    impl ::std::convert::From<super::CancelTaskRequestParams> for CancelTaskRequestParams {
        fn from(value: super::CancelTaskRequestParams) -> Self {
            Self {
                task_id: Ok(value.task_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CancelledNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::CancelledNotificationParams, ::std::string::String>,
    }
    impl ::std::default::Default for CancelledNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl CancelledNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CancelledNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CancelledNotification> for super::CancelledNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CancelledNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::CancelledNotification> for CancelledNotification {
        fn from(value: super::CancelledNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CancelledNotificationParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::CancelledNotificationParamsMeta>,
            ::std::string::String,
        >,
        reason: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        request_id:
            ::std::result::Result<::std::option::Option<super::RequestId>, ::std::string::String>,
    }
    impl ::std::default::Default for CancelledNotificationParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
            }
        }
    }
    impl CancelledNotificationParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::CancelledNotificationParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestId>>,
            T::Error: ::std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CancelledNotificationParams> for super::CancelledNotificationParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CancelledNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                reason: value.reason?,
                request_id: value.request_id?,
            })
        }
    }
    impl ::std::convert::From<super::CancelledNotificationParams> for CancelledNotificationParams {
        fn from(value: super::CancelledNotificationParams) -> Self {
            Self {
                meta: Ok(value.meta),
                reason: Ok(value.reason),
                request_id: Ok(value.request_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CancelledNotificationParamsMeta {}
    impl ::std::default::Default for CancelledNotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl CancelledNotificationParamsMeta {}
    impl ::std::convert::TryFrom<CancelledNotificationParamsMeta>
        for super::CancelledNotificationParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CancelledNotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CancelledNotificationParamsMeta>
        for CancelledNotificationParamsMeta
    {
        fn from(_value: super::CancelledNotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilities {
        elicitation: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesElicitation>,
            ::std::string::String,
        >,
        experimental: ::std::result::Result<
            ::std::collections::HashMap<
                ::std::string::String,
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            ::std::string::String,
        >,
        roots: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesRoots>,
            ::std::string::String,
        >,
        sampling: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesSampling>,
            ::std::string::String,
        >,
        tasks: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesTasks>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilities {
        fn default() -> Self {
            Self {
                elicitation: Ok(Default::default()),
                experimental: Ok(Default::default()),
                roots: Ok(Default::default()),
                sampling: Ok(Default::default()),
                tasks: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilities {
        pub fn elicitation<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ClientCapabilitiesElicitation>>,
            T::Error: ::std::fmt::Display,
        {
            self.elicitation = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for elicitation: {}", e));
            self
        }
        pub fn experimental<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.experimental = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for experimental: {}", e));
            self
        }
        pub fn roots<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ClientCapabilitiesRoots>>,
            T::Error: ::std::fmt::Display,
        {
            self.roots = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for roots: {}", e));
            self
        }
        pub fn sampling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ClientCapabilitiesSampling>>,
            T::Error: ::std::fmt::Display,
        {
            self.sampling = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for sampling: {}", e));
            self
        }
        pub fn tasks<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ClientCapabilitiesTasks>>,
            T::Error: ::std::fmt::Display,
        {
            self.tasks = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tasks: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilities> for super::ClientCapabilities {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilities,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                elicitation: value.elicitation?,
                experimental: value.experimental?,
                roots: value.roots?,
                sampling: value.sampling?,
                tasks: value.tasks?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilities> for ClientCapabilities {
        fn from(value: super::ClientCapabilities) -> Self {
            Self {
                elicitation: Ok(value.elicitation),
                experimental: Ok(value.experimental),
                roots: Ok(value.roots),
                sampling: Ok(value.sampling),
                tasks: Ok(value.tasks),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesElicitation {
        form: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        url: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesElicitation {
        fn default() -> Self {
            Self {
                form: Ok(Default::default()),
                url: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesElicitation {
        pub fn form<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.form = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for form: {}", e));
            self
        }
        pub fn url<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.url = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for url: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesElicitation>
        for super::ClientCapabilitiesElicitation
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesElicitation,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                form: value.form?,
                url: value.url?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesElicitation> for ClientCapabilitiesElicitation {
        fn from(value: super::ClientCapabilitiesElicitation) -> Self {
            Self {
                form: Ok(value.form),
                url: Ok(value.url),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesRoots {
        list_changed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
    }
    impl ::std::default::Default for ClientCapabilitiesRoots {
        fn default() -> Self {
            Self {
                list_changed: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesRoots {
        pub fn list_changed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.list_changed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list_changed: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesRoots> for super::ClientCapabilitiesRoots {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesRoots,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                list_changed: value.list_changed?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesRoots> for ClientCapabilitiesRoots {
        fn from(value: super::ClientCapabilitiesRoots) -> Self {
            Self {
                list_changed: Ok(value.list_changed),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesSampling {
        context: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        tools: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesSampling {
        fn default() -> Self {
            Self {
                context: Ok(Default::default()),
                tools: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesSampling {
        pub fn context<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.context = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for context: {}", e));
            self
        }
        pub fn tools<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.tools = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tools: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesSampling> for super::ClientCapabilitiesSampling {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesSampling,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                context: value.context?,
                tools: value.tools?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesSampling> for ClientCapabilitiesSampling {
        fn from(value: super::ClientCapabilitiesSampling) -> Self {
            Self {
                context: Ok(value.context),
                tools: Ok(value.tools),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesTasks {
        cancel: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        list: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        requests: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesTasksRequests>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesTasks {
        fn default() -> Self {
            Self {
                cancel: Ok(Default::default()),
                list: Ok(Default::default()),
                requests: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesTasks {
        pub fn cancel<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.cancel = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancel: {}", e));
            self
        }
        pub fn list<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.list = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list: {}", e));
            self
        }
        pub fn requests<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ClientCapabilitiesTasksRequests>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.requests = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for requests: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesTasks> for super::ClientCapabilitiesTasks {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesTasks,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancel: value.cancel?,
                list: value.list?,
                requests: value.requests?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesTasks> for ClientCapabilitiesTasks {
        fn from(value: super::ClientCapabilitiesTasks) -> Self {
            Self {
                cancel: Ok(value.cancel),
                list: Ok(value.list),
                requests: Ok(value.requests),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesTasksRequests {
        elicitation: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesTasksRequestsElicitation>,
            ::std::string::String,
        >,
        sampling: ::std::result::Result<
            ::std::option::Option<super::ClientCapabilitiesTasksRequestsSampling>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesTasksRequests {
        fn default() -> Self {
            Self {
                elicitation: Ok(Default::default()),
                sampling: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesTasksRequests {
        pub fn elicitation<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ClientCapabilitiesTasksRequestsElicitation>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.elicitation = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for elicitation: {}", e));
            self
        }
        pub fn sampling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ClientCapabilitiesTasksRequestsSampling>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.sampling = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for sampling: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesTasksRequests>
        for super::ClientCapabilitiesTasksRequests
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesTasksRequests,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                elicitation: value.elicitation?,
                sampling: value.sampling?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesTasksRequests>
        for ClientCapabilitiesTasksRequests
    {
        fn from(value: super::ClientCapabilitiesTasksRequests) -> Self {
            Self {
                elicitation: Ok(value.elicitation),
                sampling: Ok(value.sampling),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesTasksRequestsElicitation {
        create: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesTasksRequestsElicitation {
        fn default() -> Self {
            Self {
                create: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesTasksRequestsElicitation {
        pub fn create<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.create = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesTasksRequestsElicitation>
        for super::ClientCapabilitiesTasksRequestsElicitation
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesTasksRequestsElicitation,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                create: value.create?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesTasksRequestsElicitation>
        for ClientCapabilitiesTasksRequestsElicitation
    {
        fn from(value: super::ClientCapabilitiesTasksRequestsElicitation) -> Self {
            Self {
                create: Ok(value.create),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientCapabilitiesTasksRequestsSampling {
        create_message: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientCapabilitiesTasksRequestsSampling {
        fn default() -> Self {
            Self {
                create_message: Ok(Default::default()),
            }
        }
    }
    impl ClientCapabilitiesTasksRequestsSampling {
        pub fn create_message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.create_message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_message: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientCapabilitiesTasksRequestsSampling>
        for super::ClientCapabilitiesTasksRequestsSampling
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientCapabilitiesTasksRequestsSampling,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                create_message: value.create_message?,
            })
        }
    }
    impl ::std::convert::From<super::ClientCapabilitiesTasksRequestsSampling>
        for ClientCapabilitiesTasksRequestsSampling
    {
        fn from(value: super::ClientCapabilitiesTasksRequestsSampling) -> Self {
            Self {
                create_message: Ok(value.create_message),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ClientResult {
        subtype_0:
            ::std::result::Result<::std::option::Option<super::Result>, ::std::string::String>,
        subtype_1: ::std::result::Result<
            ::std::option::Option<super::GetTaskResult>,
            ::std::string::String,
        >,
        subtype_2: ::std::result::Result<
            ::std::option::Option<super::GetTaskPayloadResult>,
            ::std::string::String,
        >,
        subtype_3: ::std::result::Result<
            ::std::option::Option<super::CancelTaskResult>,
            ::std::string::String,
        >,
        subtype_4: ::std::result::Result<
            ::std::option::Option<super::ListTasksResult>,
            ::std::string::String,
        >,
        subtype_5: ::std::result::Result<
            ::std::option::Option<super::CreateMessageResult>,
            ::std::string::String,
        >,
        subtype_6: ::std::result::Result<
            ::std::option::Option<super::ListRootsResult>,
            ::std::string::String,
        >,
        subtype_7: ::std::result::Result<
            ::std::option::Option<super::ElicitResult>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ClientResult {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
                subtype_2: Ok(Default::default()),
                subtype_3: Ok(Default::default()),
                subtype_4: Ok(Default::default()),
                subtype_5: Ok(Default::default()),
                subtype_6: Ok(Default::default()),
                subtype_7: Ok(Default::default()),
            }
        }
    }
    impl ClientResult {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Result>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetTaskResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
        pub fn subtype_2<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetTaskPayloadResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_2 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
            self
        }
        pub fn subtype_3<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CancelTaskResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_3 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
            self
        }
        pub fn subtype_4<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListTasksResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_4 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
            self
        }
        pub fn subtype_5<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CreateMessageResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_5 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_5: {}", e));
            self
        }
        pub fn subtype_6<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListRootsResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_6 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_6: {}", e));
            self
        }
        pub fn subtype_7<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ElicitResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_7 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_7: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ClientResult> for super::ClientResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
                subtype_2: value.subtype_2?,
                subtype_3: value.subtype_3?,
                subtype_4: value.subtype_4?,
                subtype_5: value.subtype_5?,
                subtype_6: value.subtype_6?,
                subtype_7: value.subtype_7?,
            })
        }
    }
    impl ::std::convert::From<super::ClientResult> for ClientResult {
        fn from(value: super::ClientResult) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
                subtype_2: Ok(value.subtype_2),
                subtype_3: Ok(value.subtype_3),
                subtype_4: Ok(value.subtype_4),
                subtype_5: Ok(value.subtype_5),
                subtype_6: Ok(value.subtype_6),
                subtype_7: Ok(value.subtype_7),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::CompleteRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for CompleteRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl CompleteRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CompleteRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteRequest> for super::CompleteRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteRequest> for CompleteRequest {
        fn from(value: super::CompleteRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteRequestParams {
        argument:
            ::std::result::Result<super::CompleteRequestParamsArgument, ::std::string::String>,
        context: ::std::result::Result<
            ::std::option::Option<super::CompleteRequestParamsContext>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::CompleteRequestParamsMeta>,
            ::std::string::String,
        >,
        ref_: ::std::result::Result<super::CompleteRequestParamsRef, ::std::string::String>,
    }
    impl ::std::default::Default for CompleteRequestParams {
        fn default() -> Self {
            Self {
                argument: Err("no value supplied for argument".to_string()),
                context: Ok(Default::default()),
                meta: Ok(Default::default()),
                ref_: Err("no value supplied for ref_".to_string()),
            }
        }
    }
    impl CompleteRequestParams {
        pub fn argument<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CompleteRequestParamsArgument>,
            T::Error: ::std::fmt::Display,
        {
            self.argument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for argument: {}", e));
            self
        }
        pub fn context<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CompleteRequestParamsContext>>,
            T::Error: ::std::fmt::Display,
        {
            self.context = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for context: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CompleteRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn ref_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CompleteRequestParamsRef>,
            T::Error: ::std::fmt::Display,
        {
            self.ref_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ref_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteRequestParams> for super::CompleteRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                argument: value.argument?,
                context: value.context?,
                meta: value.meta?,
                ref_: value.ref_?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteRequestParams> for CompleteRequestParams {
        fn from(value: super::CompleteRequestParams) -> Self {
            Self {
                argument: Ok(value.argument),
                context: Ok(value.context),
                meta: Ok(value.meta),
                ref_: Ok(value.ref_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteRequestParamsArgument {
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        value: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for CompleteRequestParamsArgument {
        fn default() -> Self {
            Self {
                name: Err("no value supplied for name".to_string()),
                value: Err("no value supplied for value".to_string()),
            }
        }
    }
    impl CompleteRequestParamsArgument {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for value: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteRequestParamsArgument>
        for super::CompleteRequestParamsArgument
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteRequestParamsArgument,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                name: value.name?,
                value: value.value?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteRequestParamsArgument> for CompleteRequestParamsArgument {
        fn from(value: super::CompleteRequestParamsArgument) -> Self {
            Self {
                name: Ok(value.name),
                value: Ok(value.value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteRequestParamsContext {
        arguments: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CompleteRequestParamsContext {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
            }
        }
    }
    impl CompleteRequestParamsContext {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteRequestParamsContext> for super::CompleteRequestParamsContext {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteRequestParamsContext,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteRequestParamsContext> for CompleteRequestParamsContext {
        fn from(value: super::CompleteRequestParamsContext) -> Self {
            Self {
                arguments: Ok(value.arguments),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CompleteRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl CompleteRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteRequestParamsMeta> for super::CompleteRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteRequestParamsMeta> for CompleteRequestParamsMeta {
        fn from(value: super::CompleteRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteResult {
        completion: ::std::result::Result<super::CompleteResultCompletion, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::CompleteResultMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CompleteResult {
        fn default() -> Self {
            Self {
                completion: Err("no value supplied for completion".to_string()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl CompleteResult {
        pub fn completion<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CompleteResultCompletion>,
            T::Error: ::std::fmt::Display,
        {
            self.completion = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for completion: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CompleteResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteResult> for super::CompleteResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                completion: value.completion?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteResult> for CompleteResult {
        fn from(value: super::CompleteResult) -> Self {
            Self {
                completion: Ok(value.completion),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteResultCompletion {
        has_more: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        total: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        values:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
    }
    impl ::std::default::Default for CompleteResultCompletion {
        fn default() -> Self {
            Self {
                has_more: Ok(Default::default()),
                total: Ok(Default::default()),
                values: Err("no value supplied for values".to_string()),
            }
        }
    }
    impl CompleteResultCompletion {
        pub fn has_more<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_more = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for has_more: {}", e));
            self
        }
        pub fn total<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.total = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for total: {}", e));
            self
        }
        pub fn values<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.values = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for values: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CompleteResultCompletion> for super::CompleteResultCompletion {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CompleteResultCompletion,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                has_more: value.has_more?,
                total: value.total?,
                values: value.values?,
            })
        }
    }
    impl ::std::convert::From<super::CompleteResultCompletion> for CompleteResultCompletion {
        fn from(value: super::CompleteResultCompletion) -> Self {
            Self {
                has_more: Ok(value.has_more),
                total: Ok(value.total),
                values: Ok(value.values),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CompleteResultMeta {}
    impl ::std::default::Default for CompleteResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl CompleteResultMeta {}
    impl ::std::convert::TryFrom<CompleteResultMeta> for super::CompleteResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CompleteResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CompleteResultMeta> for CompleteResultMeta {
        fn from(_value: super::CompleteResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateMessageRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::CreateMessageRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for CreateMessageRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl CreateMessageRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CreateMessageRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CreateMessageRequest> for super::CreateMessageRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CreateMessageRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::CreateMessageRequest> for CreateMessageRequest {
        fn from(value: super::CreateMessageRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateMessageRequestParams {
        include_context: ::std::result::Result<
            ::std::option::Option<super::CreateMessageRequestParamsIncludeContext>,
            ::std::string::String,
        >,
        max_tokens: ::std::result::Result<i64, ::std::string::String>,
        messages:
            ::std::result::Result<::std::vec::Vec<super::SamplingMessage>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::CreateMessageRequestParamsMeta>,
            ::std::string::String,
        >,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        model_preferences: ::std::result::Result<
            ::std::option::Option<super::ModelPreferences>,
            ::std::string::String,
        >,
        stop_sequences:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        system_prompt: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        task: ::std::result::Result<
            ::std::option::Option<super::TaskMetadata>,
            ::std::string::String,
        >,
        temperature: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        tool_choice:
            ::std::result::Result<::std::option::Option<super::ToolChoice>, ::std::string::String>,
        tools: ::std::result::Result<::std::vec::Vec<super::Tool>, ::std::string::String>,
    }
    impl ::std::default::Default for CreateMessageRequestParams {
        fn default() -> Self {
            Self {
                include_context: Ok(Default::default()),
                max_tokens: Err("no value supplied for max_tokens".to_string()),
                messages: Err("no value supplied for messages".to_string()),
                meta: Ok(Default::default()),
                metadata: Ok(Default::default()),
                model_preferences: Ok(Default::default()),
                stop_sequences: Ok(Default::default()),
                system_prompt: Ok(Default::default()),
                task: Ok(Default::default()),
                temperature: Ok(Default::default()),
                tool_choice: Ok(Default::default()),
                tools: Ok(Default::default()),
            }
        }
    }
    impl CreateMessageRequestParams {
        pub fn include_context<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateMessageRequestParamsIncludeContext>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.include_context = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for include_context: {}", e));
            self
        }
        pub fn max_tokens<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<i64>,
            T::Error: ::std::fmt::Display,
        {
            self.max_tokens = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for max_tokens: {}", e));
            self
        }
        pub fn messages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::SamplingMessage>>,
            T::Error: ::std::fmt::Display,
        {
            self.messages = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for messages: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateMessageRequestParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn model_preferences<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ModelPreferences>>,
            T::Error: ::std::fmt::Display,
        {
            self.model_preferences = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for model_preferences: {}",
                    e
                )
            });
            self
        }
        pub fn stop_sequences<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.stop_sequences = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for stop_sequences: {}", e));
            self
        }
        pub fn system_prompt<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.system_prompt = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for system_prompt: {}", e));
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskMetadata>>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
        pub fn temperature<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.temperature = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for temperature: {}", e));
            self
        }
        pub fn tool_choice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolChoice>>,
            T::Error: ::std::fmt::Display,
        {
            self.tool_choice = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tool_choice: {}", e));
            self
        }
        pub fn tools<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Tool>>,
            T::Error: ::std::fmt::Display,
        {
            self.tools = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tools: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CreateMessageRequestParams> for super::CreateMessageRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CreateMessageRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                include_context: value.include_context?,
                max_tokens: value.max_tokens?,
                messages: value.messages?,
                meta: value.meta?,
                metadata: value.metadata?,
                model_preferences: value.model_preferences?,
                stop_sequences: value.stop_sequences?,
                system_prompt: value.system_prompt?,
                task: value.task?,
                temperature: value.temperature?,
                tool_choice: value.tool_choice?,
                tools: value.tools?,
            })
        }
    }
    impl ::std::convert::From<super::CreateMessageRequestParams> for CreateMessageRequestParams {
        fn from(value: super::CreateMessageRequestParams) -> Self {
            Self {
                include_context: Ok(value.include_context),
                max_tokens: Ok(value.max_tokens),
                messages: Ok(value.messages),
                meta: Ok(value.meta),
                metadata: Ok(value.metadata),
                model_preferences: Ok(value.model_preferences),
                stop_sequences: Ok(value.stop_sequences),
                system_prompt: Ok(value.system_prompt),
                task: Ok(value.task),
                temperature: Ok(value.temperature),
                tool_choice: Ok(value.tool_choice),
                tools: Ok(value.tools),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateMessageRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CreateMessageRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl CreateMessageRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CreateMessageRequestParamsMeta>
        for super::CreateMessageRequestParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CreateMessageRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::CreateMessageRequestParamsMeta>
        for CreateMessageRequestParamsMeta
    {
        fn from(value: super::CreateMessageRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateMessageResult {
        content: ::std::result::Result<super::CreateMessageResultContent, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::CreateMessageResultMeta>,
            ::std::string::String,
        >,
        model: ::std::result::Result<::std::string::String, ::std::string::String>,
        role: ::std::result::Result<super::Role, ::std::string::String>,
        stop_reason: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for CreateMessageResult {
        fn default() -> Self {
            Self {
                content: Err("no value supplied for content".to_string()),
                meta: Ok(Default::default()),
                model: Err("no value supplied for model".to_string()),
                role: Err("no value supplied for role".to_string()),
                stop_reason: Ok(Default::default()),
            }
        }
    }
    impl CreateMessageResult {
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::CreateMessageResultContent>,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CreateMessageResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.model = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for model: {}", e));
            self
        }
        pub fn role<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Role>,
            T::Error: ::std::fmt::Display,
        {
            self.role = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for role: {}", e));
            self
        }
        pub fn stop_reason<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.stop_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for stop_reason: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CreateMessageResult> for super::CreateMessageResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CreateMessageResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                content: value.content?,
                meta: value.meta?,
                model: value.model?,
                role: value.role?,
                stop_reason: value.stop_reason?,
            })
        }
    }
    impl ::std::convert::From<super::CreateMessageResult> for CreateMessageResult {
        fn from(value: super::CreateMessageResult) -> Self {
            Self {
                content: Ok(value.content),
                meta: Ok(value.meta),
                model: Ok(value.model),
                role: Ok(value.role),
                stop_reason: Ok(value.stop_reason),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateMessageResultMeta {}
    impl ::std::default::Default for CreateMessageResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl CreateMessageResultMeta {}
    impl ::std::convert::TryFrom<CreateMessageResultMeta> for super::CreateMessageResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CreateMessageResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CreateMessageResultMeta> for CreateMessageResultMeta {
        fn from(_value: super::CreateMessageResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateTaskResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::CreateTaskResultMeta>,
            ::std::string::String,
        >,
        task: ::std::result::Result<super::Task, ::std::string::String>,
    }
    impl ::std::default::Default for CreateTaskResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                task: Err("no value supplied for task".to_string()),
            }
        }
    }
    impl CreateTaskResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CreateTaskResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Task>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<CreateTaskResult> for super::CreateTaskResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: CreateTaskResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                task: value.task?,
            })
        }
    }
    impl ::std::convert::From<super::CreateTaskResult> for CreateTaskResult {
        fn from(value: super::CreateTaskResult) -> Self {
            Self {
                meta: Ok(value.meta),
                task: Ok(value.task),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct CreateTaskResultMeta {}
    impl ::std::default::Default for CreateTaskResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl CreateTaskResultMeta {}
    impl ::std::convert::TryFrom<CreateTaskResultMeta> for super::CreateTaskResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: CreateTaskResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::CreateTaskResultMeta> for CreateTaskResultMeta {
        fn from(_value: super::CreateTaskResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::ElicitRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for ElicitRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl ElicitRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ElicitRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequest> for super::ElicitRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequest> for ElicitRequest {
        fn from(value: super::ElicitRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequestFormParams {
        message: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ElicitRequestFormParamsMeta>,
            ::std::string::String,
        >,
        mode: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        requested_schema: ::std::result::Result<
            super::ElicitRequestFormParamsRequestedSchema,
            ::std::string::String,
        >,
        task: ::std::result::Result<
            ::std::option::Option<super::TaskMetadata>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ElicitRequestFormParams {
        fn default() -> Self {
            Self {
                message: Err("no value supplied for message".to_string()),
                meta: Ok(Default::default()),
                mode: Ok(Default::default()),
                requested_schema: Err("no value supplied for requested_schema".to_string()),
                task: Ok(Default::default()),
            }
        }
    }
    impl ElicitRequestFormParams {
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ElicitRequestFormParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mode<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mode = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mode: {}", e));
            self
        }
        pub fn requested_schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ElicitRequestFormParamsRequestedSchema>,
            T::Error: ::std::fmt::Display,
        {
            self.requested_schema = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for requested_schema: {}",
                    e
                )
            });
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskMetadata>>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequestFormParams> for super::ElicitRequestFormParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequestFormParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                message: value.message?,
                meta: value.meta?,
                mode: value.mode?,
                requested_schema: value.requested_schema?,
                task: value.task?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequestFormParams> for ElicitRequestFormParams {
        fn from(value: super::ElicitRequestFormParams) -> Self {
            Self {
                message: Ok(value.message),
                meta: Ok(value.meta),
                mode: Ok(value.mode),
                requested_schema: Ok(value.requested_schema),
                task: Ok(value.task),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequestFormParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ElicitRequestFormParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl ElicitRequestFormParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequestFormParamsMeta> for super::ElicitRequestFormParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequestFormParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequestFormParamsMeta> for ElicitRequestFormParamsMeta {
        fn from(value: super::ElicitRequestFormParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequestFormParamsRequestedSchema {
        properties: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::PrimitiveSchemaDefinition>,
            ::std::string::String,
        >,
        required:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        schema: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ElicitRequestFormParamsRequestedSchema {
        fn default() -> Self {
            Self {
                properties: Err("no value supplied for properties".to_string()),
                required: Ok(Default::default()),
                schema: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ElicitRequestFormParamsRequestedSchema {
        pub fn properties<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        super::PrimitiveSchemaDefinition,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.properties = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for properties: {}", e));
            self
        }
        pub fn required<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.required = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for required: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequestFormParamsRequestedSchema>
        for super::ElicitRequestFormParamsRequestedSchema
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequestFormParamsRequestedSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                properties: value.properties?,
                required: value.required?,
                schema: value.schema?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequestFormParamsRequestedSchema>
        for ElicitRequestFormParamsRequestedSchema
    {
        fn from(value: super::ElicitRequestFormParamsRequestedSchema) -> Self {
            Self {
                properties: Ok(value.properties),
                required: Ok(value.required),
                schema: Ok(value.schema),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequestUrlParams {
        elicitation_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        message: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ElicitRequestUrlParamsMeta>,
            ::std::string::String,
        >,
        mode: ::std::result::Result<::std::string::String, ::std::string::String>,
        task: ::std::result::Result<
            ::std::option::Option<super::TaskMetadata>,
            ::std::string::String,
        >,
        url: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ElicitRequestUrlParams {
        fn default() -> Self {
            Self {
                elicitation_id: Err("no value supplied for elicitation_id".to_string()),
                message: Err("no value supplied for message".to_string()),
                meta: Ok(Default::default()),
                mode: Err("no value supplied for mode".to_string()),
                task: Ok(Default::default()),
                url: Err("no value supplied for url".to_string()),
            }
        }
    }
    impl ElicitRequestUrlParams {
        pub fn elicitation_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.elicitation_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for elicitation_id: {}", e));
            self
        }
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ElicitRequestUrlParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mode<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.mode = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mode: {}", e));
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskMetadata>>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
        pub fn url<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.url = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for url: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequestUrlParams> for super::ElicitRequestUrlParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequestUrlParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                elicitation_id: value.elicitation_id?,
                message: value.message?,
                meta: value.meta?,
                mode: value.mode?,
                task: value.task?,
                url: value.url?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequestUrlParams> for ElicitRequestUrlParams {
        fn from(value: super::ElicitRequestUrlParams) -> Self {
            Self {
                elicitation_id: Ok(value.elicitation_id),
                message: Ok(value.message),
                meta: Ok(value.meta),
                mode: Ok(value.mode),
                task: Ok(value.task),
                url: Ok(value.url),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitRequestUrlParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ElicitRequestUrlParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl ElicitRequestUrlParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitRequestUrlParamsMeta> for super::ElicitRequestUrlParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitRequestUrlParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitRequestUrlParamsMeta> for ElicitRequestUrlParamsMeta {
        fn from(value: super::ElicitRequestUrlParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitResult {
        action: ::std::result::Result<super::ElicitResultAction, ::std::string::String>,
        content: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::ElicitResultContentValue>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::ElicitResultMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ElicitResult {
        fn default() -> Self {
            Self {
                action: Err("no value supplied for action".to_string()),
                content: Ok(Default::default()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl ElicitResult {
        pub fn action<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ElicitResultAction>,
            T::Error: ::std::fmt::Display,
        {
            self.action = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for action: {}", e));
            self
        }
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        super::ElicitResultContentValue,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ElicitResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitResult> for super::ElicitResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                action: value.action?,
                content: value.content?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitResult> for ElicitResult {
        fn from(value: super::ElicitResult) -> Self {
            Self {
                action: Ok(value.action),
                content: Ok(value.content),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitResultMeta {}
    impl ::std::default::Default for ElicitResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ElicitResultMeta {}
    impl ::std::convert::TryFrom<ElicitResultMeta> for super::ElicitResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ElicitResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ElicitResultMeta> for ElicitResultMeta {
        fn from(_value: super::ElicitResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitationCompleteNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            super::ElicitationCompleteNotificationParams,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ElicitationCompleteNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl ElicitationCompleteNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ElicitationCompleteNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitationCompleteNotification>
        for super::ElicitationCompleteNotification
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitationCompleteNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitationCompleteNotification>
        for ElicitationCompleteNotification
    {
        fn from(value: super::ElicitationCompleteNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ElicitationCompleteNotificationParams {
        elicitation_id: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ElicitationCompleteNotificationParams {
        fn default() -> Self {
            Self {
                elicitation_id: Err("no value supplied for elicitation_id".to_string()),
            }
        }
    }
    impl ElicitationCompleteNotificationParams {
        pub fn elicitation_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.elicitation_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for elicitation_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ElicitationCompleteNotificationParams>
        for super::ElicitationCompleteNotificationParams
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ElicitationCompleteNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                elicitation_id: value.elicitation_id?,
            })
        }
    }
    impl ::std::convert::From<super::ElicitationCompleteNotificationParams>
        for ElicitationCompleteNotificationParams
    {
        fn from(value: super::ElicitationCompleteNotificationParams) -> Self {
            Self {
                elicitation_id: Ok(value.elicitation_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmbeddedResource {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::EmbeddedResourceMeta>,
            ::std::string::String,
        >,
        resource: ::std::result::Result<super::EmbeddedResourceResource, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for EmbeddedResource {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                meta: Ok(Default::default()),
                resource: Err("no value supplied for resource".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl EmbeddedResource {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EmbeddedResourceMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn resource<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EmbeddedResourceResource>,
            T::Error: ::std::fmt::Display,
        {
            self.resource = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resource: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EmbeddedResource> for super::EmbeddedResource {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EmbeddedResource,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                meta: value.meta?,
                resource: value.resource?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::EmbeddedResource> for EmbeddedResource {
        fn from(value: super::EmbeddedResource) -> Self {
            Self {
                annotations: Ok(value.annotations),
                meta: Ok(value.meta),
                resource: Ok(value.resource),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmbeddedResourceMeta {}
    impl ::std::default::Default for EmbeddedResourceMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl EmbeddedResourceMeta {}
    impl ::std::convert::TryFrom<EmbeddedResourceMeta> for super::EmbeddedResourceMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: EmbeddedResourceMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::EmbeddedResourceMeta> for EmbeddedResourceMeta {
        fn from(_value: super::EmbeddedResourceMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct EnumSchema {
        subtype_0: ::std::result::Result<
            ::std::option::Option<super::UntitledSingleSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_1: ::std::result::Result<
            ::std::option::Option<super::TitledSingleSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_2: ::std::result::Result<
            ::std::option::Option<super::UntitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_3: ::std::result::Result<
            ::std::option::Option<super::TitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_4: ::std::result::Result<
            ::std::option::Option<super::LegacyTitledEnumSchema>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for EnumSchema {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
                subtype_2: Ok(Default::default()),
                subtype_3: Ok(Default::default()),
                subtype_4: Ok(Default::default()),
            }
        }
    }
    impl EnumSchema {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::UntitledSingleSelectEnumSchema>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TitledSingleSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
        pub fn subtype_2<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::UntitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_2 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
            self
        }
        pub fn subtype_3<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_3 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
            self
        }
        pub fn subtype_4<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::LegacyTitledEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_4 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EnumSchema> for super::EnumSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
                subtype_2: value.subtype_2?,
                subtype_3: value.subtype_3?,
                subtype_4: value.subtype_4?,
            })
        }
    }
    impl ::std::convert::From<super::EnumSchema> for EnumSchema {
        fn from(value: super::EnumSchema) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
                subtype_2: Ok(value.subtype_2),
                subtype_3: Ok(value.subtype_3),
                subtype_4: Ok(value.subtype_4),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Error {
        code: ::std::result::Result<i64, ::std::string::String>,
        data: ::std::result::Result<
            ::std::option::Option<::serde_json::Value>,
            ::std::string::String,
        >,
        message: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Self {
                code: Err("no value supplied for code".to_string()),
                data: Ok(Default::default()),
                message: Err("no value supplied for message".to_string()),
            }
        }
    }
    impl Error {
        pub fn code<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<i64>,
            T::Error: ::std::fmt::Display,
        {
            self.code = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for code: {}", e));
            self
        }
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Error> for super::Error {
        type Error = super::error::ConversionError;
        fn try_from(value: Error) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                code: value.code?,
                data: value.data?,
                message: value.message?,
            })
        }
    }
    impl ::std::convert::From<super::Error> for Error {
        fn from(value: super::Error) -> Self {
            Self {
                code: Ok(value.code),
                data: Ok(value.data),
                message: Ok(value.message),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetPromptRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::GetPromptRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for GetPromptRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl GetPromptRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::GetPromptRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetPromptRequest> for super::GetPromptRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetPromptRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::GetPromptRequest> for GetPromptRequest {
        fn from(value: super::GetPromptRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetPromptRequestParams {
        arguments: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::GetPromptRequestParamsMeta>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for GetPromptRequestParams {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
                meta: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
            }
        }
    }
    impl GetPromptRequestParams {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetPromptRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetPromptRequestParams> for super::GetPromptRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetPromptRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
                meta: value.meta?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::GetPromptRequestParams> for GetPromptRequestParams {
        fn from(value: super::GetPromptRequestParams) -> Self {
            Self {
                arguments: Ok(value.arguments),
                meta: Ok(value.meta),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetPromptRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for GetPromptRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl GetPromptRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetPromptRequestParamsMeta> for super::GetPromptRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetPromptRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::GetPromptRequestParamsMeta> for GetPromptRequestParamsMeta {
        fn from(value: super::GetPromptRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetPromptResult {
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        messages:
            ::std::result::Result<::std::vec::Vec<super::PromptMessage>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::GetPromptResultMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for GetPromptResult {
        fn default() -> Self {
            Self {
                description: Ok(Default::default()),
                messages: Err("no value supplied for messages".to_string()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl GetPromptResult {
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn messages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::PromptMessage>>,
            T::Error: ::std::fmt::Display,
        {
            self.messages = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for messages: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetPromptResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetPromptResult> for super::GetPromptResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetPromptResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                description: value.description?,
                messages: value.messages?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::GetPromptResult> for GetPromptResult {
        fn from(value: super::GetPromptResult) -> Self {
            Self {
                description: Ok(value.description),
                messages: Ok(value.messages),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetPromptResultMeta {}
    impl ::std::default::Default for GetPromptResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl GetPromptResultMeta {}
    impl ::std::convert::TryFrom<GetPromptResultMeta> for super::GetPromptResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: GetPromptResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::GetPromptResultMeta> for GetPromptResultMeta {
        fn from(_value: super::GetPromptResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskPayloadRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::GetTaskPayloadRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for GetTaskPayloadRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl GetTaskPayloadRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::GetTaskPayloadRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetTaskPayloadRequest> for super::GetTaskPayloadRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTaskPayloadRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::GetTaskPayloadRequest> for GetTaskPayloadRequest {
        fn from(value: super::GetTaskPayloadRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskPayloadRequestParams {
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for GetTaskPayloadRequestParams {
        fn default() -> Self {
            Self {
                task_id: Err("no value supplied for task_id".to_string()),
            }
        }
    }
    impl GetTaskPayloadRequestParams {
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetTaskPayloadRequestParams> for super::GetTaskPayloadRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTaskPayloadRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                task_id: value.task_id?,
            })
        }
    }
    impl ::std::convert::From<super::GetTaskPayloadRequestParams> for GetTaskPayloadRequestParams {
        fn from(value: super::GetTaskPayloadRequestParams) -> Self {
            Self {
                task_id: Ok(value.task_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskPayloadResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::GetTaskPayloadResultMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for GetTaskPayloadResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
            }
        }
    }
    impl GetTaskPayloadResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetTaskPayloadResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetTaskPayloadResult> for super::GetTaskPayloadResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTaskPayloadResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { meta: value.meta? })
        }
    }
    impl ::std::convert::From<super::GetTaskPayloadResult> for GetTaskPayloadResult {
        fn from(value: super::GetTaskPayloadResult) -> Self {
            Self {
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskPayloadResultMeta {}
    impl ::std::default::Default for GetTaskPayloadResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl GetTaskPayloadResultMeta {}
    impl ::std::convert::TryFrom<GetTaskPayloadResultMeta> for super::GetTaskPayloadResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: GetTaskPayloadResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::GetTaskPayloadResultMeta> for GetTaskPayloadResultMeta {
        fn from(_value: super::GetTaskPayloadResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::GetTaskRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for GetTaskRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl GetTaskRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::GetTaskRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetTaskRequest> for super::GetTaskRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTaskRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::GetTaskRequest> for GetTaskRequest {
        fn from(value: super::GetTaskRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GetTaskRequestParams {
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for GetTaskRequestParams {
        fn default() -> Self {
            Self {
                task_id: Err("no value supplied for task_id".to_string()),
            }
        }
    }
    impl GetTaskRequestParams {
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GetTaskRequestParams> for super::GetTaskRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTaskRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                task_id: value.task_id?,
            })
        }
    }
    impl ::std::convert::From<super::GetTaskRequestParams> for GetTaskRequestParams {
        fn from(value: super::GetTaskRequestParams) -> Self {
            Self {
                task_id: Ok(value.task_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Icon {
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        sizes: ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        src: ::std::result::Result<::std::string::String, ::std::string::String>,
        theme:
            ::std::result::Result<::std::option::Option<super::IconTheme>, ::std::string::String>,
    }
    impl ::std::default::Default for Icon {
        fn default() -> Self {
            Self {
                mime_type: Ok(Default::default()),
                sizes: Ok(Default::default()),
                src: Err("no value supplied for src".to_string()),
                theme: Ok(Default::default()),
            }
        }
    }
    impl Icon {
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn sizes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.sizes = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for sizes: {}", e));
            self
        }
        pub fn src<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.src = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for src: {}", e));
            self
        }
        pub fn theme<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::IconTheme>>,
            T::Error: ::std::fmt::Display,
        {
            self.theme = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for theme: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Icon> for super::Icon {
        type Error = super::error::ConversionError;
        fn try_from(value: Icon) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                mime_type: value.mime_type?,
                sizes: value.sizes?,
                src: value.src?,
                theme: value.theme?,
            })
        }
    }
    impl ::std::convert::From<super::Icon> for Icon {
        fn from(value: super::Icon) -> Self {
            Self {
                mime_type: Ok(value.mime_type),
                sizes: Ok(value.sizes),
                src: Ok(value.src),
                theme: Ok(value.theme),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Icons {
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
    }
    impl ::std::default::Default for Icons {
        fn default() -> Self {
            Self {
                icons: Ok(Default::default()),
            }
        }
    }
    impl Icons {
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Icons> for super::Icons {
        type Error = super::error::ConversionError;
        fn try_from(value: Icons) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                icons: value.icons?,
            })
        }
    }
    impl ::std::convert::From<super::Icons> for Icons {
        fn from(value: super::Icons) -> Self {
            Self {
                icons: Ok(value.icons),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ImageContent {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        data: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ImageContentMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ImageContent {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                data: Err("no value supplied for data".to_string()),
                meta: Ok(Default::default()),
                mime_type: Err("no value supplied for mime_type".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ImageContent {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ImageContentMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ImageContent> for super::ImageContent {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ImageContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                data: value.data?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ImageContent> for ImageContent {
        fn from(value: super::ImageContent) -> Self {
            Self {
                annotations: Ok(value.annotations),
                data: Ok(value.data),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ImageContentMeta {}
    impl ::std::default::Default for ImageContentMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ImageContentMeta {}
    impl ::std::convert::TryFrom<ImageContentMeta> for super::ImageContentMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ImageContentMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ImageContentMeta> for ImageContentMeta {
        fn from(_value: super::ImageContentMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct Implementation {
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        version: ::std::result::Result<::std::string::String, ::std::string::String>,
        website_url: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Implementation {
        fn default() -> Self {
            Self {
                description: Ok(Default::default()),
                icons: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                title: Ok(Default::default()),
                version: Err("no value supplied for version".to_string()),
                website_url: Ok(Default::default()),
            }
        }
    }
    impl Implementation {
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for version: {}", e));
            self
        }
        pub fn website_url<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.website_url = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for website_url: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Implementation> for super::Implementation {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Implementation,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                description: value.description?,
                icons: value.icons?,
                name: value.name?,
                title: value.title?,
                version: value.version?,
                website_url: value.website_url?,
            })
        }
    }
    impl ::std::convert::From<super::Implementation> for Implementation {
        fn from(value: super::Implementation) -> Self {
            Self {
                description: Ok(value.description),
                icons: Ok(value.icons),
                name: Ok(value.name),
                title: Ok(value.title),
                version: Ok(value.version),
                website_url: Ok(value.website_url),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializeRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::InitializeRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for InitializeRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl InitializeRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::InitializeRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<InitializeRequest> for super::InitializeRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: InitializeRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::InitializeRequest> for InitializeRequest {
        fn from(value: super::InitializeRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializeRequestParams {
        capabilities: ::std::result::Result<super::ClientCapabilities, ::std::string::String>,
        client_info: ::std::result::Result<super::Implementation, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::InitializeRequestParamsMeta>,
            ::std::string::String,
        >,
        protocol_version: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for InitializeRequestParams {
        fn default() -> Self {
            Self {
                capabilities: Err("no value supplied for capabilities".to_string()),
                client_info: Err("no value supplied for client_info".to_string()),
                meta: Ok(Default::default()),
                protocol_version: Err("no value supplied for protocol_version".to_string()),
            }
        }
    }
    impl InitializeRequestParams {
        pub fn capabilities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ClientCapabilities>,
            T::Error: ::std::fmt::Display,
        {
            self.capabilities = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for capabilities: {}", e));
            self
        }
        pub fn client_info<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Implementation>,
            T::Error: ::std::fmt::Display,
        {
            self.client_info = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_info: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::InitializeRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn protocol_version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.protocol_version = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for protocol_version: {}",
                    e
                )
            });
            self
        }
    }
    impl ::std::convert::TryFrom<InitializeRequestParams> for super::InitializeRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: InitializeRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                capabilities: value.capabilities?,
                client_info: value.client_info?,
                meta: value.meta?,
                protocol_version: value.protocol_version?,
            })
        }
    }
    impl ::std::convert::From<super::InitializeRequestParams> for InitializeRequestParams {
        fn from(value: super::InitializeRequestParams) -> Self {
            Self {
                capabilities: Ok(value.capabilities),
                client_info: Ok(value.client_info),
                meta: Ok(value.meta),
                protocol_version: Ok(value.protocol_version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializeRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for InitializeRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl InitializeRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<InitializeRequestParamsMeta> for super::InitializeRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: InitializeRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::InitializeRequestParamsMeta> for InitializeRequestParamsMeta {
        fn from(value: super::InitializeRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializeResult {
        capabilities: ::std::result::Result<super::ServerCapabilities, ::std::string::String>,
        instructions: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::InitializeResultMeta>,
            ::std::string::String,
        >,
        protocol_version: ::std::result::Result<::std::string::String, ::std::string::String>,
        server_info: ::std::result::Result<super::Implementation, ::std::string::String>,
    }
    impl ::std::default::Default for InitializeResult {
        fn default() -> Self {
            Self {
                capabilities: Err("no value supplied for capabilities".to_string()),
                instructions: Ok(Default::default()),
                meta: Ok(Default::default()),
                protocol_version: Err("no value supplied for protocol_version".to_string()),
                server_info: Err("no value supplied for server_info".to_string()),
            }
        }
    }
    impl InitializeResult {
        pub fn capabilities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ServerCapabilities>,
            T::Error: ::std::fmt::Display,
        {
            self.capabilities = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for capabilities: {}", e));
            self
        }
        pub fn instructions<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.instructions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instructions: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::InitializeResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn protocol_version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.protocol_version = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for protocol_version: {}",
                    e
                )
            });
            self
        }
        pub fn server_info<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Implementation>,
            T::Error: ::std::fmt::Display,
        {
            self.server_info = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for server_info: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<InitializeResult> for super::InitializeResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: InitializeResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                capabilities: value.capabilities?,
                instructions: value.instructions?,
                meta: value.meta?,
                protocol_version: value.protocol_version?,
                server_info: value.server_info?,
            })
        }
    }
    impl ::std::convert::From<super::InitializeResult> for InitializeResult {
        fn from(value: super::InitializeResult) -> Self {
            Self {
                capabilities: Ok(value.capabilities),
                instructions: Ok(value.instructions),
                meta: Ok(value.meta),
                protocol_version: Ok(value.protocol_version),
                server_info: Ok(value.server_info),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializeResultMeta {}
    impl ::std::default::Default for InitializeResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl InitializeResultMeta {}
    impl ::std::convert::TryFrom<InitializeResultMeta> for super::InitializeResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: InitializeResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::InitializeResultMeta> for InitializeResultMeta {
        fn from(_value: super::InitializeResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct InitializedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for InitializedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl InitializedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<InitializedNotification> for super::InitializedNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: InitializedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::InitializedNotification> for InitializedNotification {
        fn from(value: super::InitializedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcErrorResponse {
        error: ::std::result::Result<super::Error, ::std::string::String>,
        id: ::std::result::Result<::std::option::Option<super::RequestId>, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for JsonrpcErrorResponse {
        fn default() -> Self {
            Self {
                error: Err("no value supplied for error".to_string()),
                id: Ok(Default::default()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
            }
        }
    }
    impl JsonrpcErrorResponse {
        pub fn error<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Error>,
            T::Error: ::std::fmt::Display,
        {
            self.error = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for error: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestId>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<JsonrpcErrorResponse> for super::JsonrpcErrorResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: JsonrpcErrorResponse,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                error: value.error?,
                id: value.id?,
                jsonrpc: value.jsonrpc?,
            })
        }
    }
    impl ::std::convert::From<super::JsonrpcErrorResponse> for JsonrpcErrorResponse {
        fn from(value: super::JsonrpcErrorResponse) -> Self {
            Self {
                error: Ok(value.error),
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::JsonrpcNotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for JsonrpcNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl JsonrpcNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::JsonrpcNotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<JsonrpcNotification> for super::JsonrpcNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: JsonrpcNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::JsonrpcNotification> for JsonrpcNotification {
        fn from(value: super::JsonrpcNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcNotificationParams {}
    impl ::std::default::Default for JsonrpcNotificationParams {
        fn default() -> Self {
            Self {}
        }
    }
    impl JsonrpcNotificationParams {}
    impl ::std::convert::TryFrom<JsonrpcNotificationParams> for super::JsonrpcNotificationParams {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: JsonrpcNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::JsonrpcNotificationParams> for JsonrpcNotificationParams {
        fn from(_value: super::JsonrpcNotificationParams) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::JsonrpcRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for JsonrpcRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl JsonrpcRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::JsonrpcRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<JsonrpcRequest> for super::JsonrpcRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: JsonrpcRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::JsonrpcRequest> for JsonrpcRequest {
        fn from(value: super::JsonrpcRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcRequestParams {}
    impl ::std::default::Default for JsonrpcRequestParams {
        fn default() -> Self {
            Self {}
        }
    }
    impl JsonrpcRequestParams {}
    impl ::std::convert::TryFrom<JsonrpcRequestParams> for super::JsonrpcRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: JsonrpcRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::JsonrpcRequestParams> for JsonrpcRequestParams {
        fn from(_value: super::JsonrpcRequestParams) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct JsonrpcResultResponse {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        result: ::std::result::Result<super::Result, ::std::string::String>,
    }
    impl ::std::default::Default for JsonrpcResultResponse {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                result: Err("no value supplied for result".to_string()),
            }
        }
    }
    impl JsonrpcResultResponse {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn result<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Result>,
            T::Error: ::std::fmt::Display,
        {
            self.result = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for result: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<JsonrpcResultResponse> for super::JsonrpcResultResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: JsonrpcResultResponse,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                result: value.result?,
            })
        }
    }
    impl ::std::convert::From<super::JsonrpcResultResponse> for JsonrpcResultResponse {
        fn from(value: super::JsonrpcResultResponse) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                result: Ok(value.result),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct LegacyTitledEnumSchema {
        default: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        enum_: ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        enum_names:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for LegacyTitledEnumSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                enum_: Err("no value supplied for enum_".to_string()),
                enum_names: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl LegacyTitledEnumSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn enum_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.enum_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for enum_: {}", e));
            self
        }
        pub fn enum_names<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.enum_names = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for enum_names: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<LegacyTitledEnumSchema> for super::LegacyTitledEnumSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LegacyTitledEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                enum_: value.enum_?,
                enum_names: value.enum_names?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::LegacyTitledEnumSchema> for LegacyTitledEnumSchema {
        fn from(value: super::LegacyTitledEnumSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                enum_: Ok(value.enum_),
                enum_names: Ok(value.enum_names),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListPromptsRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListPromptsRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListPromptsRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListPromptsRequest> for super::ListPromptsRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListPromptsRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListPromptsRequest> for ListPromptsRequest {
        fn from(value: super::ListPromptsRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListPromptsResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListPromptsResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        prompts: ::std::result::Result<::std::vec::Vec<super::Prompt>, ::std::string::String>,
    }
    impl ::std::default::Default for ListPromptsResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
                prompts: Err("no value supplied for prompts".to_string()),
            }
        }
    }
    impl ListPromptsResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListPromptsResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
        pub fn prompts<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Prompt>>,
            T::Error: ::std::fmt::Display,
        {
            self.prompts = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for prompts: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListPromptsResult> for super::ListPromptsResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListPromptsResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
                prompts: value.prompts?,
            })
        }
    }
    impl ::std::convert::From<super::ListPromptsResult> for ListPromptsResult {
        fn from(value: super::ListPromptsResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
                prompts: Ok(value.prompts),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListPromptsResultMeta {}
    impl ::std::default::Default for ListPromptsResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListPromptsResultMeta {}
    impl ::std::convert::TryFrom<ListPromptsResultMeta> for super::ListPromptsResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListPromptsResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListPromptsResultMeta> for ListPromptsResultMeta {
        fn from(_value: super::ListPromptsResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourceTemplatesRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListResourceTemplatesRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListResourceTemplatesRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListResourceTemplatesRequest> for super::ListResourceTemplatesRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListResourceTemplatesRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListResourceTemplatesRequest> for ListResourceTemplatesRequest {
        fn from(value: super::ListResourceTemplatesRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourceTemplatesResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListResourceTemplatesResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        resource_templates:
            ::std::result::Result<::std::vec::Vec<super::ResourceTemplate>, ::std::string::String>,
    }
    impl ::std::default::Default for ListResourceTemplatesResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
                resource_templates: Err("no value supplied for resource_templates".to_string()),
            }
        }
    }
    impl ListResourceTemplatesResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ListResourceTemplatesResultMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
        pub fn resource_templates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ResourceTemplate>>,
            T::Error: ::std::fmt::Display,
        {
            self.resource_templates = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for resource_templates: {}",
                    e
                )
            });
            self
        }
    }
    impl ::std::convert::TryFrom<ListResourceTemplatesResult> for super::ListResourceTemplatesResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListResourceTemplatesResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
                resource_templates: value.resource_templates?,
            })
        }
    }
    impl ::std::convert::From<super::ListResourceTemplatesResult> for ListResourceTemplatesResult {
        fn from(value: super::ListResourceTemplatesResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
                resource_templates: Ok(value.resource_templates),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourceTemplatesResultMeta {}
    impl ::std::default::Default for ListResourceTemplatesResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListResourceTemplatesResultMeta {}
    impl ::std::convert::TryFrom<ListResourceTemplatesResultMeta>
        for super::ListResourceTemplatesResultMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListResourceTemplatesResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListResourceTemplatesResultMeta>
        for ListResourceTemplatesResultMeta
    {
        fn from(_value: super::ListResourceTemplatesResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourcesRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListResourcesRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListResourcesRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListResourcesRequest> for super::ListResourcesRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListResourcesRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListResourcesRequest> for ListResourcesRequest {
        fn from(value: super::ListResourcesRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourcesResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListResourcesResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        resources: ::std::result::Result<::std::vec::Vec<super::Resource>, ::std::string::String>,
    }
    impl ::std::default::Default for ListResourcesResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
                resources: Err("no value supplied for resources".to_string()),
            }
        }
    }
    impl ListResourcesResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListResourcesResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
        pub fn resources<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Resource>>,
            T::Error: ::std::fmt::Display,
        {
            self.resources = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resources: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListResourcesResult> for super::ListResourcesResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListResourcesResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
                resources: value.resources?,
            })
        }
    }
    impl ::std::convert::From<super::ListResourcesResult> for ListResourcesResult {
        fn from(value: super::ListResourcesResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
                resources: Ok(value.resources),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListResourcesResultMeta {}
    impl ::std::default::Default for ListResourcesResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListResourcesResultMeta {}
    impl ::std::convert::TryFrom<ListResourcesResultMeta> for super::ListResourcesResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListResourcesResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListResourcesResultMeta> for ListResourcesResultMeta {
        fn from(_value: super::ListResourcesResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListRootsRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::RequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListRootsRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListRootsRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListRootsRequest> for super::ListRootsRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListRootsRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListRootsRequest> for ListRootsRequest {
        fn from(value: super::ListRootsRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListRootsResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListRootsResultMeta>,
            ::std::string::String,
        >,
        roots: ::std::result::Result<::std::vec::Vec<super::Root>, ::std::string::String>,
    }
    impl ::std::default::Default for ListRootsResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                roots: Err("no value supplied for roots".to_string()),
            }
        }
    }
    impl ListRootsResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListRootsResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn roots<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Root>>,
            T::Error: ::std::fmt::Display,
        {
            self.roots = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for roots: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListRootsResult> for super::ListRootsResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListRootsResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                roots: value.roots?,
            })
        }
    }
    impl ::std::convert::From<super::ListRootsResult> for ListRootsResult {
        fn from(value: super::ListRootsResult) -> Self {
            Self {
                meta: Ok(value.meta),
                roots: Ok(value.roots),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListRootsResultMeta {}
    impl ::std::default::Default for ListRootsResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListRootsResultMeta {}
    impl ::std::convert::TryFrom<ListRootsResultMeta> for super::ListRootsResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListRootsResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListRootsResultMeta> for ListRootsResultMeta {
        fn from(_value: super::ListRootsResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListTasksRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListTasksRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListTasksRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListTasksRequest> for super::ListTasksRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListTasksRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListTasksRequest> for ListTasksRequest {
        fn from(value: super::ListTasksRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListTasksResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListTasksResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        tasks: ::std::result::Result<::std::vec::Vec<super::Task>, ::std::string::String>,
    }
    impl ::std::default::Default for ListTasksResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
                tasks: Err("no value supplied for tasks".to_string()),
            }
        }
    }
    impl ListTasksResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListTasksResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
        pub fn tasks<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Task>>,
            T::Error: ::std::fmt::Display,
        {
            self.tasks = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tasks: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListTasksResult> for super::ListTasksResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListTasksResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
                tasks: value.tasks?,
            })
        }
    }
    impl ::std::convert::From<super::ListTasksResult> for ListTasksResult {
        fn from(value: super::ListTasksResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
                tasks: Ok(value.tasks),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListTasksResultMeta {}
    impl ::std::default::Default for ListTasksResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListTasksResultMeta {}
    impl ::std::convert::TryFrom<ListTasksResultMeta> for super::ListTasksResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListTasksResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListTasksResultMeta> for ListTasksResultMeta {
        fn from(_value: super::ListTasksResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListToolsRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ListToolsRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ListToolsRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListToolsRequest> for super::ListToolsRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListToolsRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ListToolsRequest> for ListToolsRequest {
        fn from(value: super::ListToolsRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListToolsResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::ListToolsResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        tools: ::std::result::Result<::std::vec::Vec<super::Tool>, ::std::string::String>,
    }
    impl ::std::default::Default for ListToolsResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
                tools: Err("no value supplied for tools".to_string()),
            }
        }
    }
    impl ListToolsResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListToolsResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
        pub fn tools<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Tool>>,
            T::Error: ::std::fmt::Display,
        {
            self.tools = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tools: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListToolsResult> for super::ListToolsResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListToolsResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
                tools: value.tools?,
            })
        }
    }
    impl ::std::convert::From<super::ListToolsResult> for ListToolsResult {
        fn from(value: super::ListToolsResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
                tools: Ok(value.tools),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListToolsResultMeta {}
    impl ::std::default::Default for ListToolsResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ListToolsResultMeta {}
    impl ::std::convert::TryFrom<ListToolsResultMeta> for super::ListToolsResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ListToolsResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ListToolsResultMeta> for ListToolsResultMeta {
        fn from(_value: super::ListToolsResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct LoggingMessageNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params:
            ::std::result::Result<super::LoggingMessageNotificationParams, ::std::string::String>,
    }
    impl ::std::default::Default for LoggingMessageNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl LoggingMessageNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::LoggingMessageNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<LoggingMessageNotification> for super::LoggingMessageNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LoggingMessageNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::LoggingMessageNotification> for LoggingMessageNotification {
        fn from(value: super::LoggingMessageNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct LoggingMessageNotificationParams {
        data: ::std::result::Result<::serde_json::Value, ::std::string::String>,
        level: ::std::result::Result<super::LoggingLevel, ::std::string::String>,
        logger: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::LoggingMessageNotificationParamsMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for LoggingMessageNotificationParams {
        fn default() -> Self {
            Self {
                data: Err("no value supplied for data".to_string()),
                level: Err("no value supplied for level".to_string()),
                logger: Ok(Default::default()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl LoggingMessageNotificationParams {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::serde_json::Value>,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn level<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::LoggingLevel>,
            T::Error: ::std::fmt::Display,
        {
            self.level = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for level: {}", e));
            self
        }
        pub fn logger<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.logger = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for logger: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::LoggingMessageNotificationParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<LoggingMessageNotificationParams>
        for super::LoggingMessageNotificationParams
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LoggingMessageNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                level: value.level?,
                logger: value.logger?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::LoggingMessageNotificationParams>
        for LoggingMessageNotificationParams
    {
        fn from(value: super::LoggingMessageNotificationParams) -> Self {
            Self {
                data: Ok(value.data),
                level: Ok(value.level),
                logger: Ok(value.logger),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct LoggingMessageNotificationParamsMeta {}
    impl ::std::default::Default for LoggingMessageNotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl LoggingMessageNotificationParamsMeta {}
    impl ::std::convert::TryFrom<LoggingMessageNotificationParamsMeta>
        for super::LoggingMessageNotificationParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: LoggingMessageNotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::LoggingMessageNotificationParamsMeta>
        for LoggingMessageNotificationParamsMeta
    {
        fn from(_value: super::LoggingMessageNotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ModelHint {
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ModelHint {
        fn default() -> Self {
            Self {
                name: Ok(Default::default()),
            }
        }
    }
    impl ModelHint {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ModelHint> for super::ModelHint {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ModelHint,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { name: value.name? })
        }
    }
    impl ::std::convert::From<super::ModelHint> for ModelHint {
        fn from(value: super::ModelHint) -> Self {
            Self {
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ModelPreferences {
        cost_priority: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        hints: ::std::result::Result<::std::vec::Vec<super::ModelHint>, ::std::string::String>,
        intelligence_priority:
            ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        speed_priority: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for ModelPreferences {
        fn default() -> Self {
            Self {
                cost_priority: Ok(Default::default()),
                hints: Ok(Default::default()),
                intelligence_priority: Ok(Default::default()),
                speed_priority: Ok(Default::default()),
            }
        }
    }
    impl ModelPreferences {
        pub fn cost_priority<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.cost_priority = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cost_priority: {}", e));
            self
        }
        pub fn hints<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ModelHint>>,
            T::Error: ::std::fmt::Display,
        {
            self.hints = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for hints: {}", e));
            self
        }
        pub fn intelligence_priority<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.intelligence_priority = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intelligence_priority: {}",
                    e
                )
            });
            self
        }
        pub fn speed_priority<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.speed_priority = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for speed_priority: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ModelPreferences> for super::ModelPreferences {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ModelPreferences,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cost_priority: value.cost_priority?,
                hints: value.hints?,
                intelligence_priority: value.intelligence_priority?,
                speed_priority: value.speed_priority?,
            })
        }
    }
    impl ::std::convert::From<super::ModelPreferences> for ModelPreferences {
        fn from(value: super::ModelPreferences) -> Self {
            Self {
                cost_priority: Ok(value.cost_priority),
                hints: Ok(value.hints),
                intelligence_priority: Ok(value.intelligence_priority),
                speed_priority: Ok(value.speed_priority),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct MultiSelectEnumSchema {
        subtype_0: ::std::result::Result<
            ::std::option::Option<super::UntitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_1: ::std::result::Result<
            ::std::option::Option<super::TitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for MultiSelectEnumSchema {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
            }
        }
    }
    impl MultiSelectEnumSchema {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::UntitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<MultiSelectEnumSchema> for super::MultiSelectEnumSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MultiSelectEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
            })
        }
    }
    impl ::std::convert::From<super::MultiSelectEnumSchema> for MultiSelectEnumSchema {
        fn from(value: super::MultiSelectEnumSchema) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Notification {
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Notification {
        fn default() -> Self {
            Self {
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl Notification {
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Notification> for super::Notification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Notification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::Notification> for Notification {
        fn from(value: super::Notification) -> Self {
            Self {
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NotificationParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::NotificationParamsMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NotificationParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
            }
        }
    }
    impl NotificationParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<NotificationParams> for super::NotificationParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { meta: value.meta? })
        }
    }
    impl ::std::convert::From<super::NotificationParams> for NotificationParams {
        fn from(value: super::NotificationParams) -> Self {
            Self {
                meta: Ok(value.meta),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct NotificationParamsMeta {}
    impl ::std::default::Default for NotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl NotificationParamsMeta {}
    impl ::std::convert::TryFrom<NotificationParamsMeta> for super::NotificationParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: NotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::NotificationParamsMeta> for NotificationParamsMeta {
        fn from(_value: super::NotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct NumberSchema {
        default: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        maximum: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        minimum: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<super::NumberSchemaType, ::std::string::String>,
    }
    impl ::std::default::Default for NumberSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                maximum: Ok(Default::default()),
                minimum: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl NumberSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn maximum<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.maximum = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for maximum: {}", e));
            self
        }
        pub fn minimum<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.minimum = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for minimum: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::NumberSchemaType>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<NumberSchema> for super::NumberSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NumberSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                maximum: value.maximum?,
                minimum: value.minimum?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::NumberSchema> for NumberSchema {
        fn from(value: super::NumberSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                maximum: Ok(value.maximum),
                minimum: Ok(value.minimum),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PaginatedRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PaginatedRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl PaginatedRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PaginatedRequest> for super::PaginatedRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PaginatedRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::PaginatedRequest> for PaginatedRequest {
        fn from(value: super::PaginatedRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PaginatedRequestParams {
        cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::PaginatedRequestParamsMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PaginatedRequestParams {
        fn default() -> Self {
            Self {
                cursor: Ok(Default::default()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl PaginatedRequestParams {
        pub fn cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cursor: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PaginatedRequestParams> for super::PaginatedRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PaginatedRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cursor: value.cursor?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::PaginatedRequestParams> for PaginatedRequestParams {
        fn from(value: super::PaginatedRequestParams) -> Self {
            Self {
                cursor: Ok(value.cursor),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PaginatedRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PaginatedRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl PaginatedRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PaginatedRequestParamsMeta> for super::PaginatedRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PaginatedRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::PaginatedRequestParamsMeta> for PaginatedRequestParamsMeta {
        fn from(value: super::PaginatedRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PaginatedResult {
        meta: ::std::result::Result<
            ::std::option::Option<super::PaginatedResultMeta>,
            ::std::string::String,
        >,
        next_cursor: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PaginatedResult {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                next_cursor: Ok(Default::default()),
            }
        }
    }
    impl PaginatedResult {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PaginatedResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn next_cursor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.next_cursor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PaginatedResult> for super::PaginatedResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PaginatedResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                next_cursor: value.next_cursor?,
            })
        }
    }
    impl ::std::convert::From<super::PaginatedResult> for PaginatedResult {
        fn from(value: super::PaginatedResult) -> Self {
            Self {
                meta: Ok(value.meta),
                next_cursor: Ok(value.next_cursor),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PaginatedResultMeta {}
    impl ::std::default::Default for PaginatedResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl PaginatedResultMeta {}
    impl ::std::convert::TryFrom<PaginatedResultMeta> for super::PaginatedResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: PaginatedResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::PaginatedResultMeta> for PaginatedResultMeta {
        fn from(_value: super::PaginatedResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct PingRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::RequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PingRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl PingRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PingRequest> for super::PingRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PingRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::PingRequest> for PingRequest {
        fn from(value: super::PingRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PrimitiveSchemaDefinition {
        subtype_0: ::std::result::Result<
            ::std::option::Option<super::StringSchema>,
            ::std::string::String,
        >,
        subtype_1: ::std::result::Result<
            ::std::option::Option<super::NumberSchema>,
            ::std::string::String,
        >,
        subtype_2: ::std::result::Result<
            ::std::option::Option<super::BooleanSchema>,
            ::std::string::String,
        >,
        subtype_3: ::std::result::Result<
            ::std::option::Option<super::UntitledSingleSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_4: ::std::result::Result<
            ::std::option::Option<super::TitledSingleSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_5: ::std::result::Result<
            ::std::option::Option<super::UntitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_6: ::std::result::Result<
            ::std::option::Option<super::TitledMultiSelectEnumSchema>,
            ::std::string::String,
        >,
        subtype_7: ::std::result::Result<
            ::std::option::Option<super::LegacyTitledEnumSchema>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PrimitiveSchemaDefinition {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
                subtype_2: Ok(Default::default()),
                subtype_3: Ok(Default::default()),
                subtype_4: Ok(Default::default()),
                subtype_5: Ok(Default::default()),
                subtype_6: Ok(Default::default()),
                subtype_7: Ok(Default::default()),
            }
        }
    }
    impl PrimitiveSchemaDefinition {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::StringSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NumberSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
        pub fn subtype_2<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::BooleanSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_2 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
            self
        }
        pub fn subtype_3<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::UntitledSingleSelectEnumSchema>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_3 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
            self
        }
        pub fn subtype_4<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TitledSingleSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_4 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
            self
        }
        pub fn subtype_5<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::UntitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_5 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_5: {}", e));
            self
        }
        pub fn subtype_6<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TitledMultiSelectEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_6 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_6: {}", e));
            self
        }
        pub fn subtype_7<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::LegacyTitledEnumSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_7 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_7: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PrimitiveSchemaDefinition> for super::PrimitiveSchemaDefinition {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PrimitiveSchemaDefinition,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
                subtype_2: value.subtype_2?,
                subtype_3: value.subtype_3?,
                subtype_4: value.subtype_4?,
                subtype_5: value.subtype_5?,
                subtype_6: value.subtype_6?,
                subtype_7: value.subtype_7?,
            })
        }
    }
    impl ::std::convert::From<super::PrimitiveSchemaDefinition> for PrimitiveSchemaDefinition {
        fn from(value: super::PrimitiveSchemaDefinition) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
                subtype_2: Ok(value.subtype_2),
                subtype_3: Ok(value.subtype_3),
                subtype_4: Ok(value.subtype_4),
                subtype_5: Ok(value.subtype_5),
                subtype_6: Ok(value.subtype_6),
                subtype_7: Ok(value.subtype_7),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ProgressNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::ProgressNotificationParams, ::std::string::String>,
    }
    impl ::std::default::Default for ProgressNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl ProgressNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ProgressNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ProgressNotification> for super::ProgressNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ProgressNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ProgressNotification> for ProgressNotification {
        fn from(value: super::ProgressNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ProgressNotificationParams {
        message: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::ProgressNotificationParamsMeta>,
            ::std::string::String,
        >,
        progress: ::std::result::Result<f64, ::std::string::String>,
        progress_token: ::std::result::Result<super::ProgressToken, ::std::string::String>,
        total: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for ProgressNotificationParams {
        fn default() -> Self {
            Self {
                message: Ok(Default::default()),
                meta: Ok(Default::default()),
                progress: Err("no value supplied for progress".to_string()),
                progress_token: Err("no value supplied for progress_token".to_string()),
                total: Ok(Default::default()),
            }
        }
    }
    impl ProgressNotificationParams {
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ProgressNotificationParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn progress<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<f64>,
            T::Error: ::std::fmt::Display,
        {
            self.progress = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress: {}", e));
            self
        }
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ProgressToken>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
        pub fn total<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.total = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for total: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ProgressNotificationParams> for super::ProgressNotificationParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ProgressNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                message: value.message?,
                meta: value.meta?,
                progress: value.progress?,
                progress_token: value.progress_token?,
                total: value.total?,
            })
        }
    }
    impl ::std::convert::From<super::ProgressNotificationParams> for ProgressNotificationParams {
        fn from(value: super::ProgressNotificationParams) -> Self {
            Self {
                message: Ok(value.message),
                meta: Ok(value.meta),
                progress: Ok(value.progress),
                progress_token: Ok(value.progress_token),
                total: Ok(value.total),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ProgressNotificationParamsMeta {}
    impl ::std::default::Default for ProgressNotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ProgressNotificationParamsMeta {}
    impl ::std::convert::TryFrom<ProgressNotificationParamsMeta>
        for super::ProgressNotificationParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ProgressNotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ProgressNotificationParamsMeta>
        for ProgressNotificationParamsMeta
    {
        fn from(_value: super::ProgressNotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct Prompt {
        arguments:
            ::std::result::Result<::std::vec::Vec<super::PromptArgument>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        meta:
            ::std::result::Result<::std::option::Option<super::PromptMeta>, ::std::string::String>,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Prompt {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
                description: Ok(Default::default()),
                icons: Ok(Default::default()),
                meta: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                title: Ok(Default::default()),
            }
        }
    }
    impl Prompt {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::PromptArgument>>,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::PromptMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Prompt> for super::Prompt {
        type Error = super::error::ConversionError;
        fn try_from(value: Prompt) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
                description: value.description?,
                icons: value.icons?,
                meta: value.meta?,
                name: value.name?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::Prompt> for Prompt {
        fn from(value: super::Prompt) -> Self {
            Self {
                arguments: Ok(value.arguments),
                description: Ok(value.description),
                icons: Ok(value.icons),
                meta: Ok(value.meta),
                name: Ok(value.name),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PromptArgument {
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        required: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PromptArgument {
        fn default() -> Self {
            Self {
                description: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                required: Ok(Default::default()),
                title: Ok(Default::default()),
            }
        }
    }
    impl PromptArgument {
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn required<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.required = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for required: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PromptArgument> for super::PromptArgument {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PromptArgument,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                description: value.description?,
                name: value.name?,
                required: value.required?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::PromptArgument> for PromptArgument {
        fn from(value: super::PromptArgument) -> Self {
            Self {
                description: Ok(value.description),
                name: Ok(value.name),
                required: Ok(value.required),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PromptListChangedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for PromptListChangedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl PromptListChangedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PromptListChangedNotification>
        for super::PromptListChangedNotification
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PromptListChangedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::PromptListChangedNotification> for PromptListChangedNotification {
        fn from(value: super::PromptListChangedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PromptMessage {
        content: ::std::result::Result<super::ContentBlock, ::std::string::String>,
        role: ::std::result::Result<super::Role, ::std::string::String>,
    }
    impl ::std::default::Default for PromptMessage {
        fn default() -> Self {
            Self {
                content: Err("no value supplied for content".to_string()),
                role: Err("no value supplied for role".to_string()),
            }
        }
    }
    impl PromptMessage {
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ContentBlock>,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn role<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Role>,
            T::Error: ::std::fmt::Display,
        {
            self.role = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for role: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PromptMessage> for super::PromptMessage {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PromptMessage,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                content: value.content?,
                role: value.role?,
            })
        }
    }
    impl ::std::convert::From<super::PromptMessage> for PromptMessage {
        fn from(value: super::PromptMessage) -> Self {
            Self {
                content: Ok(value.content),
                role: Ok(value.role),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct PromptMeta {}
    impl ::std::default::Default for PromptMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl PromptMeta {}
    impl ::std::convert::TryFrom<PromptMeta> for super::PromptMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: PromptMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::PromptMeta> for PromptMeta {
        fn from(_value: super::PromptMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct PromptReference {
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for PromptReference {
        fn default() -> Self {
            Self {
                name: Err("no value supplied for name".to_string()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl PromptReference {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<PromptReference> for super::PromptReference {
        type Error = super::error::ConversionError;
        fn try_from(
            value: PromptReference,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                name: value.name?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::PromptReference> for PromptReference {
        fn from(value: super::PromptReference) -> Self {
            Self {
                name: Ok(value.name),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ReadResourceRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::ReadResourceRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for ReadResourceRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl ReadResourceRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ReadResourceRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ReadResourceRequest> for super::ReadResourceRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ReadResourceRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ReadResourceRequest> for ReadResourceRequest {
        fn from(value: super::ReadResourceRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ReadResourceRequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::ReadResourceRequestParamsMeta>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ReadResourceRequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ReadResourceRequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ReadResourceRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ReadResourceRequestParams> for super::ReadResourceRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ReadResourceRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ReadResourceRequestParams> for ReadResourceRequestParams {
        fn from(value: super::ReadResourceRequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ReadResourceRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ReadResourceRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl ReadResourceRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ReadResourceRequestParamsMeta>
        for super::ReadResourceRequestParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ReadResourceRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::ReadResourceRequestParamsMeta> for ReadResourceRequestParamsMeta {
        fn from(value: super::ReadResourceRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ReadResourceResult {
        contents: ::std::result::Result<
            ::std::vec::Vec<super::ReadResourceResultContentsItem>,
            ::std::string::String,
        >,
        meta: ::std::result::Result<
            ::std::option::Option<super::ReadResourceResultMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ReadResourceResult {
        fn default() -> Self {
            Self {
                contents: Err("no value supplied for contents".to_string()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl ReadResourceResult {
        pub fn contents<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ReadResourceResultContentsItem>>,
            T::Error: ::std::fmt::Display,
        {
            self.contents = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for contents: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ReadResourceResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ReadResourceResult> for super::ReadResourceResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ReadResourceResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                contents: value.contents?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::ReadResourceResult> for ReadResourceResult {
        fn from(value: super::ReadResourceResult) -> Self {
            Self {
                contents: Ok(value.contents),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ReadResourceResultMeta {}
    impl ::std::default::Default for ReadResourceResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ReadResourceResultMeta {}
    impl ::std::convert::TryFrom<ReadResourceResultMeta> for super::ReadResourceResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ReadResourceResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ReadResourceResultMeta> for ReadResourceResultMeta {
        fn from(_value: super::ReadResourceResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct RelatedTaskMetadata {
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for RelatedTaskMetadata {
        fn default() -> Self {
            Self {
                task_id: Err("no value supplied for task_id".to_string()),
            }
        }
    }
    impl RelatedTaskMetadata {
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RelatedTaskMetadata> for super::RelatedTaskMetadata {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RelatedTaskMetadata,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                task_id: value.task_id?,
            })
        }
    }
    impl ::std::convert::From<super::RelatedTaskMetadata> for RelatedTaskMetadata {
        fn from(value: super::RelatedTaskMetadata) -> Self {
            Self {
                task_id: Ok(value.task_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Request {
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::RequestParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Request {
        fn default() -> Self {
            Self {
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl Request {
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Request> for super::Request {
        type Error = super::error::ConversionError;
        fn try_from(value: Request) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::Request> for Request {
        fn from(value: super::Request) -> Self {
            Self {
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::RequestParamsMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for RequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
            }
        }
    }
    impl RequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RequestParams> for super::RequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { meta: value.meta? })
        }
    }
    impl ::std::convert::From<super::RequestParams> for RequestParams {
        fn from(value: super::RequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct RequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for RequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl RequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RequestParamsMeta> for super::RequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::RequestParamsMeta> for RequestParamsMeta {
        fn from(value: super::RequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Resource {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        size: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for Resource {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                description: Ok(Default::default()),
                icons: Ok(Default::default()),
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                size: Ok(Default::default()),
                title: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl Resource {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResourceMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn size<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.size = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for size: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Resource> for super::Resource {
        type Error = super::error::ConversionError;
        fn try_from(value: Resource) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                description: value.description?,
                icons: value.icons?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                name: value.name?,
                size: value.size?,
                title: value.title?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::Resource> for Resource {
        fn from(value: super::Resource) -> Self {
            Self {
                annotations: Ok(value.annotations),
                description: Ok(value.description),
                icons: Ok(value.icons),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                name: Ok(value.name),
                size: Ok(value.size),
                title: Ok(value.title),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceContents {
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceContentsMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceContents {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceContents {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResourceContentsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceContents> for super::ResourceContents {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceContents,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                mime_type: value.mime_type?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceContents> for ResourceContents {
        fn from(value: super::ResourceContents) -> Self {
            Self {
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceContentsMeta {}
    impl ::std::default::Default for ResourceContentsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResourceContentsMeta {}
    impl ::std::convert::TryFrom<ResourceContentsMeta> for super::ResourceContentsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResourceContentsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResourceContentsMeta> for ResourceContentsMeta {
        fn from(_value: super::ResourceContentsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceLink {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceLinkMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        size: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceLink {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                description: Ok(Default::default()),
                icons: Ok(Default::default()),
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                size: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceLink {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResourceLinkMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn size<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.size = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for size: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceLink> for super::ResourceLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                description: value.description?,
                icons: value.icons?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                name: value.name?,
                size: value.size?,
                title: value.title?,
                type_: value.type_?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceLink> for ResourceLink {
        fn from(value: super::ResourceLink) -> Self {
            Self {
                annotations: Ok(value.annotations),
                description: Ok(value.description),
                icons: Ok(value.icons),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                name: Ok(value.name),
                size: Ok(value.size),
                title: Ok(value.title),
                type_: Ok(value.type_),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceLinkMeta {}
    impl ::std::default::Default for ResourceLinkMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResourceLinkMeta {}
    impl ::std::convert::TryFrom<ResourceLinkMeta> for super::ResourceLinkMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResourceLinkMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResourceLinkMeta> for ResourceLinkMeta {
        fn from(_value: super::ResourceLinkMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceListChangedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ResourceListChangedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ResourceListChangedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceListChangedNotification>
        for super::ResourceListChangedNotification
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceListChangedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceListChangedNotification>
        for ResourceListChangedNotification
    {
        fn from(value: super::ResourceListChangedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceMeta {}
    impl ::std::default::Default for ResourceMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResourceMeta {}
    impl ::std::convert::TryFrom<ResourceMeta> for super::ResourceMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResourceMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResourceMeta> for ResourceMeta {
        fn from(_value: super::ResourceMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceRequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceRequestParamsMeta>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceRequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceRequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResourceRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceRequestParams> for super::ResourceRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceRequestParams> for ResourceRequestParams {
        fn from(value: super::ResourceRequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ResourceRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl ResourceRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceRequestParamsMeta> for super::ResourceRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceRequestParamsMeta> for ResourceRequestParamsMeta {
        fn from(value: super::ResourceRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceTemplate {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceTemplateMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        uri_template: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceTemplate {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                description: Ok(Default::default()),
                icons: Ok(Default::default()),
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                title: Ok(Default::default()),
                uri_template: Err("no value supplied for uri_template".to_string()),
            }
        }
    }
    impl ResourceTemplate {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResourceTemplateMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn uri_template<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri_template = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri_template: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceTemplate> for super::ResourceTemplate {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceTemplate,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                description: value.description?,
                icons: value.icons?,
                meta: value.meta?,
                mime_type: value.mime_type?,
                name: value.name?,
                title: value.title?,
                uri_template: value.uri_template?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceTemplate> for ResourceTemplate {
        fn from(value: super::ResourceTemplate) -> Self {
            Self {
                annotations: Ok(value.annotations),
                description: Ok(value.description),
                icons: Ok(value.icons),
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                name: Ok(value.name),
                title: Ok(value.title),
                uri_template: Ok(value.uri_template),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceTemplateMeta {}
    impl ::std::default::Default for ResourceTemplateMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResourceTemplateMeta {}
    impl ::std::convert::TryFrom<ResourceTemplateMeta> for super::ResourceTemplateMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResourceTemplateMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResourceTemplateMeta> for ResourceTemplateMeta {
        fn from(_value: super::ResourceTemplateMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceTemplateReference {
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceTemplateReference {
        fn default() -> Self {
            Self {
                type_: Err("no value supplied for type_".to_string()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceTemplateReference {
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceTemplateReference> for super::ResourceTemplateReference {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceTemplateReference,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                type_: value.type_?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceTemplateReference> for ResourceTemplateReference {
        fn from(value: super::ResourceTemplateReference) -> Self {
            Self {
                type_: Ok(value.type_),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceUpdatedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params:
            ::std::result::Result<super::ResourceUpdatedNotificationParams, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceUpdatedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl ResourceUpdatedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ResourceUpdatedNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceUpdatedNotification> for super::ResourceUpdatedNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceUpdatedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceUpdatedNotification> for ResourceUpdatedNotification {
        fn from(value: super::ResourceUpdatedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceUpdatedNotificationParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::ResourceUpdatedNotificationParamsMeta>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ResourceUpdatedNotificationParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl ResourceUpdatedNotificationParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ResourceUpdatedNotificationParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ResourceUpdatedNotificationParams>
        for super::ResourceUpdatedNotificationParams
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResourceUpdatedNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::ResourceUpdatedNotificationParams>
        for ResourceUpdatedNotificationParams
    {
        fn from(value: super::ResourceUpdatedNotificationParams) -> Self {
            Self {
                meta: Ok(value.meta),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResourceUpdatedNotificationParamsMeta {}
    impl ::std::default::Default for ResourceUpdatedNotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResourceUpdatedNotificationParamsMeta {}
    impl ::std::convert::TryFrom<ResourceUpdatedNotificationParamsMeta>
        for super::ResourceUpdatedNotificationParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResourceUpdatedNotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResourceUpdatedNotificationParamsMeta>
        for ResourceUpdatedNotificationParamsMeta
    {
        fn from(_value: super::ResourceUpdatedNotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct Result {
        meta:
            ::std::result::Result<::std::option::Option<super::ResultMeta>, ::std::string::String>,
    }
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
            }
        }
    }
    impl Result {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ResultMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Result> for super::Result {
        type Error = super::error::ConversionError;
        fn try_from(value: Result) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { meta: value.meta? })
        }
    }
    impl ::std::convert::From<super::Result> for Result {
        fn from(value: super::Result) -> Self {
            Self {
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ResultMeta {}
    impl ::std::default::Default for ResultMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ResultMeta {}
    impl ::std::convert::TryFrom<ResultMeta> for super::ResultMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ResultMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ResultMeta> for ResultMeta {
        fn from(_value: super::ResultMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct Root {
        meta: ::std::result::Result<::std::option::Option<super::RootMeta>, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for Root {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                name: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl Root {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RootMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Root> for super::Root {
        type Error = super::error::ConversionError;
        fn try_from(value: Root) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                name: value.name?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::Root> for Root {
        fn from(value: super::Root) -> Self {
            Self {
                meta: Ok(value.meta),
                name: Ok(value.name),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RootMeta {}
    impl ::std::default::Default for RootMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl RootMeta {}
    impl ::std::convert::TryFrom<RootMeta> for super::RootMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: RootMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::RootMeta> for RootMeta {
        fn from(_value: super::RootMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct RootsListChangedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for RootsListChangedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl RootsListChangedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RootsListChangedNotification> for super::RootsListChangedNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RootsListChangedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::RootsListChangedNotification> for RootsListChangedNotification {
        fn from(value: super::RootsListChangedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SamplingMessage {
        content: ::std::result::Result<super::SamplingMessageContent, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::SamplingMessageMeta>,
            ::std::string::String,
        >,
        role: ::std::result::Result<super::Role, ::std::string::String>,
    }
    impl ::std::default::Default for SamplingMessage {
        fn default() -> Self {
            Self {
                content: Err("no value supplied for content".to_string()),
                meta: Ok(Default::default()),
                role: Err("no value supplied for role".to_string()),
            }
        }
    }
    impl SamplingMessage {
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::SamplingMessageContent>,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::SamplingMessageMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn role<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Role>,
            T::Error: ::std::fmt::Display,
        {
            self.role = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for role: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SamplingMessage> for super::SamplingMessage {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SamplingMessage,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                content: value.content?,
                meta: value.meta?,
                role: value.role?,
            })
        }
    }
    impl ::std::convert::From<super::SamplingMessage> for SamplingMessage {
        fn from(value: super::SamplingMessage) -> Self {
            Self {
                content: Ok(value.content),
                meta: Ok(value.meta),
                role: Ok(value.role),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SamplingMessageMeta {}
    impl ::std::default::Default for SamplingMessageMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl SamplingMessageMeta {}
    impl ::std::convert::TryFrom<SamplingMessageMeta> for super::SamplingMessageMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: SamplingMessageMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::SamplingMessageMeta> for SamplingMessageMeta {
        fn from(_value: super::SamplingMessageMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilities {
        completions: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        experimental: ::std::result::Result<
            ::std::collections::HashMap<
                ::std::string::String,
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            ::std::string::String,
        >,
        logging: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        prompts: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesPrompts>,
            ::std::string::String,
        >,
        resources: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesResources>,
            ::std::string::String,
        >,
        tasks: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesTasks>,
            ::std::string::String,
        >,
        tools: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesTools>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ServerCapabilities {
        fn default() -> Self {
            Self {
                completions: Ok(Default::default()),
                experimental: Ok(Default::default()),
                logging: Ok(Default::default()),
                prompts: Ok(Default::default()),
                resources: Ok(Default::default()),
                tasks: Ok(Default::default()),
                tools: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilities {
        pub fn completions<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.completions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for completions: {}", e));
            self
        }
        pub fn experimental<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.experimental = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for experimental: {}", e));
            self
        }
        pub fn logging<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.logging = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for logging: {}", e));
            self
        }
        pub fn prompts<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ServerCapabilitiesPrompts>>,
            T::Error: ::std::fmt::Display,
        {
            self.prompts = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for prompts: {}", e));
            self
        }
        pub fn resources<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ServerCapabilitiesResources>>,
            T::Error: ::std::fmt::Display,
        {
            self.resources = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resources: {}", e));
            self
        }
        pub fn tasks<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ServerCapabilitiesTasks>>,
            T::Error: ::std::fmt::Display,
        {
            self.tasks = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tasks: {}", e));
            self
        }
        pub fn tools<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ServerCapabilitiesTools>>,
            T::Error: ::std::fmt::Display,
        {
            self.tools = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tools: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilities> for super::ServerCapabilities {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilities,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                completions: value.completions?,
                experimental: value.experimental?,
                logging: value.logging?,
                prompts: value.prompts?,
                resources: value.resources?,
                tasks: value.tasks?,
                tools: value.tools?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilities> for ServerCapabilities {
        fn from(value: super::ServerCapabilities) -> Self {
            Self {
                completions: Ok(value.completions),
                experimental: Ok(value.experimental),
                logging: Ok(value.logging),
                prompts: Ok(value.prompts),
                resources: Ok(value.resources),
                tasks: Ok(value.tasks),
                tools: Ok(value.tools),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesPrompts {
        list_changed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
    }
    impl ::std::default::Default for ServerCapabilitiesPrompts {
        fn default() -> Self {
            Self {
                list_changed: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesPrompts {
        pub fn list_changed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.list_changed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list_changed: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesPrompts> for super::ServerCapabilitiesPrompts {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesPrompts,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                list_changed: value.list_changed?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesPrompts> for ServerCapabilitiesPrompts {
        fn from(value: super::ServerCapabilitiesPrompts) -> Self {
            Self {
                list_changed: Ok(value.list_changed),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesResources {
        list_changed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        subscribe: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
    }
    impl ::std::default::Default for ServerCapabilitiesResources {
        fn default() -> Self {
            Self {
                list_changed: Ok(Default::default()),
                subscribe: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesResources {
        pub fn list_changed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.list_changed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list_changed: {}", e));
            self
        }
        pub fn subscribe<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.subscribe = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subscribe: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesResources> for super::ServerCapabilitiesResources {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesResources,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                list_changed: value.list_changed?,
                subscribe: value.subscribe?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesResources> for ServerCapabilitiesResources {
        fn from(value: super::ServerCapabilitiesResources) -> Self {
            Self {
                list_changed: Ok(value.list_changed),
                subscribe: Ok(value.subscribe),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesTasks {
        cancel: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        list: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        requests: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesTasksRequests>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ServerCapabilitiesTasks {
        fn default() -> Self {
            Self {
                cancel: Ok(Default::default()),
                list: Ok(Default::default()),
                requests: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesTasks {
        pub fn cancel<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.cancel = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancel: {}", e));
            self
        }
        pub fn list<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.list = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list: {}", e));
            self
        }
        pub fn requests<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ServerCapabilitiesTasksRequests>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.requests = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for requests: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesTasks> for super::ServerCapabilitiesTasks {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesTasks,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancel: value.cancel?,
                list: value.list?,
                requests: value.requests?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesTasks> for ServerCapabilitiesTasks {
        fn from(value: super::ServerCapabilitiesTasks) -> Self {
            Self {
                cancel: Ok(value.cancel),
                list: Ok(value.list),
                requests: Ok(value.requests),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesTasksRequests {
        tools: ::std::result::Result<
            ::std::option::Option<super::ServerCapabilitiesTasksRequestsTools>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ServerCapabilitiesTasksRequests {
        fn default() -> Self {
            Self {
                tools: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesTasksRequests {
        pub fn tools<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ServerCapabilitiesTasksRequestsTools>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.tools = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tools: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesTasksRequests>
        for super::ServerCapabilitiesTasksRequests
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesTasksRequests,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                tools: value.tools?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesTasksRequests>
        for ServerCapabilitiesTasksRequests
    {
        fn from(value: super::ServerCapabilitiesTasksRequests) -> Self {
            Self {
                tools: Ok(value.tools),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesTasksRequestsTools {
        call: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ServerCapabilitiesTasksRequestsTools {
        fn default() -> Self {
            Self {
                call: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesTasksRequestsTools {
        pub fn call<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.call = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for call: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesTasksRequestsTools>
        for super::ServerCapabilitiesTasksRequestsTools
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesTasksRequestsTools,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { call: value.call? })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesTasksRequestsTools>
        for ServerCapabilitiesTasksRequestsTools
    {
        fn from(value: super::ServerCapabilitiesTasksRequestsTools) -> Self {
            Self {
                call: Ok(value.call),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerCapabilitiesTools {
        list_changed: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
    }
    impl ::std::default::Default for ServerCapabilitiesTools {
        fn default() -> Self {
            Self {
                list_changed: Ok(Default::default()),
            }
        }
    }
    impl ServerCapabilitiesTools {
        pub fn list_changed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.list_changed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for list_changed: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerCapabilitiesTools> for super::ServerCapabilitiesTools {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerCapabilitiesTools,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                list_changed: value.list_changed?,
            })
        }
    }
    impl ::std::convert::From<super::ServerCapabilitiesTools> for ServerCapabilitiesTools {
        fn from(value: super::ServerCapabilitiesTools) -> Self {
            Self {
                list_changed: Ok(value.list_changed),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerResult {
        subtype_0:
            ::std::result::Result<::std::option::Option<super::Result>, ::std::string::String>,
        subtype_1: ::std::result::Result<
            ::std::option::Option<super::InitializeResult>,
            ::std::string::String,
        >,
        subtype_2: ::std::result::Result<
            ::std::option::Option<super::ListResourcesResult>,
            ::std::string::String,
        >,
        subtype_3: ::std::result::Result<
            ::std::option::Option<super::ListResourceTemplatesResult>,
            ::std::string::String,
        >,
        subtype_4: ::std::result::Result<
            ::std::option::Option<super::ReadResourceResult>,
            ::std::string::String,
        >,
        subtype_5: ::std::result::Result<
            ::std::option::Option<super::ListPromptsResult>,
            ::std::string::String,
        >,
        subtype_6: ::std::result::Result<
            ::std::option::Option<super::GetPromptResult>,
            ::std::string::String,
        >,
        subtype_7: ::std::result::Result<
            ::std::option::Option<super::ListToolsResult>,
            ::std::string::String,
        >,
        subtype_8: ::std::result::Result<
            ::std::option::Option<super::CallToolResult>,
            ::std::string::String,
        >,
        subtype_9: ::std::result::Result<
            ::std::option::Option<super::GetTaskResult>,
            ::std::string::String,
        >,
        subtype_10: ::std::result::Result<
            ::std::option::Option<super::GetTaskPayloadResult>,
            ::std::string::String,
        >,
        subtype_11: ::std::result::Result<
            ::std::option::Option<super::CancelTaskResult>,
            ::std::string::String,
        >,
        subtype_12: ::std::result::Result<
            ::std::option::Option<super::ListTasksResult>,
            ::std::string::String,
        >,
        subtype_13: ::std::result::Result<
            ::std::option::Option<super::CompleteResult>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ServerResult {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
                subtype_2: Ok(Default::default()),
                subtype_3: Ok(Default::default()),
                subtype_4: Ok(Default::default()),
                subtype_5: Ok(Default::default()),
                subtype_6: Ok(Default::default()),
                subtype_7: Ok(Default::default()),
                subtype_8: Ok(Default::default()),
                subtype_9: Ok(Default::default()),
                subtype_10: Ok(Default::default()),
                subtype_11: Ok(Default::default()),
                subtype_12: Ok(Default::default()),
                subtype_13: Ok(Default::default()),
            }
        }
    }
    impl ServerResult {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Result>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::InitializeResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
        pub fn subtype_2<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListResourcesResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_2 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
            self
        }
        pub fn subtype_3<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListResourceTemplatesResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_3 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
            self
        }
        pub fn subtype_4<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ReadResourceResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_4 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
            self
        }
        pub fn subtype_5<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListPromptsResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_5 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_5: {}", e));
            self
        }
        pub fn subtype_6<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetPromptResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_6 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_6: {}", e));
            self
        }
        pub fn subtype_7<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListToolsResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_7 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_7: {}", e));
            self
        }
        pub fn subtype_8<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CallToolResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_8 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_8: {}", e));
            self
        }
        pub fn subtype_9<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetTaskResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_9 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_9: {}", e));
            self
        }
        pub fn subtype_10<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GetTaskPayloadResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_10 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_10: {}", e));
            self
        }
        pub fn subtype_11<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CancelTaskResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_11 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_11: {}", e));
            self
        }
        pub fn subtype_12<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ListTasksResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_12 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_12: {}", e));
            self
        }
        pub fn subtype_13<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::CompleteResult>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_13 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_13: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerResult> for super::ServerResult {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerResult,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
                subtype_2: value.subtype_2?,
                subtype_3: value.subtype_3?,
                subtype_4: value.subtype_4?,
                subtype_5: value.subtype_5?,
                subtype_6: value.subtype_6?,
                subtype_7: value.subtype_7?,
                subtype_8: value.subtype_8?,
                subtype_9: value.subtype_9?,
                subtype_10: value.subtype_10?,
                subtype_11: value.subtype_11?,
                subtype_12: value.subtype_12?,
                subtype_13: value.subtype_13?,
            })
        }
    }
    impl ::std::convert::From<super::ServerResult> for ServerResult {
        fn from(value: super::ServerResult) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
                subtype_2: Ok(value.subtype_2),
                subtype_3: Ok(value.subtype_3),
                subtype_4: Ok(value.subtype_4),
                subtype_5: Ok(value.subtype_5),
                subtype_6: Ok(value.subtype_6),
                subtype_7: Ok(value.subtype_7),
                subtype_8: Ok(value.subtype_8),
                subtype_9: Ok(value.subtype_9),
                subtype_10: Ok(value.subtype_10),
                subtype_11: Ok(value.subtype_11),
                subtype_12: Ok(value.subtype_12),
                subtype_13: Ok(value.subtype_13),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SetLevelRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::SetLevelRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for SetLevelRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl SetLevelRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::SetLevelRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SetLevelRequest> for super::SetLevelRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetLevelRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::SetLevelRequest> for SetLevelRequest {
        fn from(value: super::SetLevelRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SetLevelRequestParams {
        level: ::std::result::Result<super::LoggingLevel, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::SetLevelRequestParamsMeta>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for SetLevelRequestParams {
        fn default() -> Self {
            Self {
                level: Err("no value supplied for level".to_string()),
                meta: Ok(Default::default()),
            }
        }
    }
    impl SetLevelRequestParams {
        pub fn level<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::LoggingLevel>,
            T::Error: ::std::fmt::Display,
        {
            self.level = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for level: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::SetLevelRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SetLevelRequestParams> for super::SetLevelRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetLevelRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                level: value.level?,
                meta: value.meta?,
            })
        }
    }
    impl ::std::convert::From<super::SetLevelRequestParams> for SetLevelRequestParams {
        fn from(value: super::SetLevelRequestParams) -> Self {
            Self {
                level: Ok(value.level),
                meta: Ok(value.meta),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SetLevelRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for SetLevelRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl SetLevelRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SetLevelRequestParamsMeta> for super::SetLevelRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetLevelRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::SetLevelRequestParamsMeta> for SetLevelRequestParamsMeta {
        fn from(value: super::SetLevelRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct StringSchema {
        default: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        format: ::std::result::Result<
            ::std::option::Option<super::StringSchemaFormat>,
            ::std::string::String,
        >,
        max_length: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        min_length: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for StringSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                format: Ok(Default::default()),
                max_length: Ok(Default::default()),
                min_length: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl StringSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn format<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::StringSchemaFormat>>,
            T::Error: ::std::fmt::Display,
        {
            self.format = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for format: {}", e));
            self
        }
        pub fn max_length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_length = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for max_length: {}", e));
            self
        }
        pub fn min_length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_length = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for min_length: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<StringSchema> for super::StringSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: StringSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                format: value.format?,
                max_length: value.max_length?,
                min_length: value.min_length?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::StringSchema> for StringSchema {
        fn from(value: super::StringSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                format: Ok(value.format),
                max_length: Ok(value.max_length),
                min_length: Ok(value.min_length),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SubscribeRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::SubscribeRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for SubscribeRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl SubscribeRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::SubscribeRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SubscribeRequest> for super::SubscribeRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SubscribeRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::SubscribeRequest> for SubscribeRequest {
        fn from(value: super::SubscribeRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SubscribeRequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::SubscribeRequestParamsMeta>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for SubscribeRequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl SubscribeRequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::SubscribeRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SubscribeRequestParams> for super::SubscribeRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SubscribeRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::SubscribeRequestParams> for SubscribeRequestParams {
        fn from(value: super::SubscribeRequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SubscribeRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for SubscribeRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl SubscribeRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SubscribeRequestParamsMeta> for super::SubscribeRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SubscribeRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::SubscribeRequestParamsMeta> for SubscribeRequestParamsMeta {
        fn from(value: super::SubscribeRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Task {
        created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        last_updated_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        poll_interval: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        status: ::std::result::Result<super::TaskStatus, ::std::string::String>,
        status_message: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        ttl: ::std::result::Result<i64, ::std::string::String>,
    }
    impl ::std::default::Default for Task {
        fn default() -> Self {
            Self {
                created_at: Err("no value supplied for created_at".to_string()),
                last_updated_at: Err("no value supplied for last_updated_at".to_string()),
                poll_interval: Ok(Default::default()),
                status: Err("no value supplied for status".to_string()),
                status_message: Ok(Default::default()),
                task_id: Err("no value supplied for task_id".to_string()),
                ttl: Err("no value supplied for ttl".to_string()),
            }
        }
    }
    impl Task {
        pub fn created_at<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.created_at = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for created_at: {}", e));
            self
        }
        pub fn last_updated_at<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.last_updated_at = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for last_updated_at: {}", e));
            self
        }
        pub fn poll_interval<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.poll_interval = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for poll_interval: {}", e));
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskStatus>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status: {}", e));
            self
        }
        pub fn status_message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.status_message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status_message: {}", e));
            self
        }
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
        pub fn ttl<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<i64>,
            T::Error: ::std::fmt::Display,
        {
            self.ttl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ttl: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Task> for super::Task {
        type Error = super::error::ConversionError;
        fn try_from(value: Task) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                created_at: value.created_at?,
                last_updated_at: value.last_updated_at?,
                poll_interval: value.poll_interval?,
                status: value.status?,
                status_message: value.status_message?,
                task_id: value.task_id?,
                ttl: value.ttl?,
            })
        }
    }
    impl ::std::convert::From<super::Task> for Task {
        fn from(value: super::Task) -> Self {
            Self {
                created_at: Ok(value.created_at),
                last_updated_at: Ok(value.last_updated_at),
                poll_interval: Ok(value.poll_interval),
                status: Ok(value.status),
                status_message: Ok(value.status_message),
                task_id: Ok(value.task_id),
                ttl: Ok(value.ttl),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskAugmentedRequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::TaskAugmentedRequestParamsMeta>,
            ::std::string::String,
        >,
        task: ::std::result::Result<
            ::std::option::Option<super::TaskMetadata>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TaskAugmentedRequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                task: Ok(Default::default()),
            }
        }
    }
    impl TaskAugmentedRequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::TaskAugmentedRequestParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn task<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskMetadata>>,
            T::Error: ::std::fmt::Display,
        {
            self.task = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskAugmentedRequestParams> for super::TaskAugmentedRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TaskAugmentedRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                task: value.task?,
            })
        }
    }
    impl ::std::convert::From<super::TaskAugmentedRequestParams> for TaskAugmentedRequestParams {
        fn from(value: super::TaskAugmentedRequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
                task: Ok(value.task),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskAugmentedRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TaskAugmentedRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl TaskAugmentedRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskAugmentedRequestParamsMeta>
        for super::TaskAugmentedRequestParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TaskAugmentedRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::TaskAugmentedRequestParamsMeta>
        for TaskAugmentedRequestParamsMeta
    {
        fn from(value: super::TaskAugmentedRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskMetadata {
        ttl: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
    }
    impl ::std::default::Default for TaskMetadata {
        fn default() -> Self {
            Self {
                ttl: Ok(Default::default()),
            }
        }
    }
    impl TaskMetadata {
        pub fn ttl<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.ttl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ttl: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskMetadata> for super::TaskMetadata {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TaskMetadata,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { ttl: value.ttl? })
        }
    }
    impl ::std::convert::From<super::TaskMetadata> for TaskMetadata {
        fn from(value: super::TaskMetadata) -> Self {
            Self { ttl: Ok(value.ttl) }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskStatusNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::TaskStatusNotificationParams, ::std::string::String>,
    }
    impl ::std::default::Default for TaskStatusNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl TaskStatusNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskStatusNotificationParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskStatusNotification> for super::TaskStatusNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TaskStatusNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::TaskStatusNotification> for TaskStatusNotification {
        fn from(value: super::TaskStatusNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskStatusNotificationParams {
        created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        last_updated_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::TaskStatusNotificationParamsMeta>,
            ::std::string::String,
        >,
        poll_interval: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        status: ::std::result::Result<super::TaskStatus, ::std::string::String>,
        status_message: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        task_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        ttl: ::std::result::Result<i64, ::std::string::String>,
    }
    impl ::std::default::Default for TaskStatusNotificationParams {
        fn default() -> Self {
            Self {
                created_at: Err("no value supplied for created_at".to_string()),
                last_updated_at: Err("no value supplied for last_updated_at".to_string()),
                meta: Ok(Default::default()),
                poll_interval: Ok(Default::default()),
                status: Err("no value supplied for status".to_string()),
                status_message: Ok(Default::default()),
                task_id: Err("no value supplied for task_id".to_string()),
                ttl: Err("no value supplied for ttl".to_string()),
            }
        }
    }
    impl TaskStatusNotificationParams {
        pub fn created_at<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.created_at = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for created_at: {}", e));
            self
        }
        pub fn last_updated_at<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.last_updated_at = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for last_updated_at: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::TaskStatusNotificationParamsMeta>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn poll_interval<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.poll_interval = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for poll_interval: {}", e));
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskStatus>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status: {}", e));
            self
        }
        pub fn status_message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.status_message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status_message: {}", e));
            self
        }
        pub fn task_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.task_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_id: {}", e));
            self
        }
        pub fn ttl<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<i64>,
            T::Error: ::std::fmt::Display,
        {
            self.ttl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ttl: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskStatusNotificationParams> for super::TaskStatusNotificationParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TaskStatusNotificationParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                created_at: value.created_at?,
                last_updated_at: value.last_updated_at?,
                meta: value.meta?,
                poll_interval: value.poll_interval?,
                status: value.status?,
                status_message: value.status_message?,
                task_id: value.task_id?,
                ttl: value.ttl?,
            })
        }
    }
    impl ::std::convert::From<super::TaskStatusNotificationParams> for TaskStatusNotificationParams {
        fn from(value: super::TaskStatusNotificationParams) -> Self {
            Self {
                created_at: Ok(value.created_at),
                last_updated_at: Ok(value.last_updated_at),
                meta: Ok(value.meta),
                poll_interval: Ok(value.poll_interval),
                status: Ok(value.status),
                status_message: Ok(value.status_message),
                task_id: Ok(value.task_id),
                ttl: Ok(value.ttl),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskStatusNotificationParamsMeta {}
    impl ::std::default::Default for TaskStatusNotificationParamsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl TaskStatusNotificationParamsMeta {}
    impl ::std::convert::TryFrom<TaskStatusNotificationParamsMeta>
        for super::TaskStatusNotificationParamsMeta
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: TaskStatusNotificationParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::TaskStatusNotificationParamsMeta>
        for TaskStatusNotificationParamsMeta
    {
        fn from(_value: super::TaskStatusNotificationParamsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct TextContent {
        annotations:
            ::std::result::Result<::std::option::Option<super::Annotations>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::TextContentMeta>,
            ::std::string::String,
        >,
        text: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TextContent {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                meta: Ok(Default::default()),
                text: Err("no value supplied for text".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl TextContent {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Annotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TextContentMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn text<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.text = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for text: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TextContent> for super::TextContent {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TextContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                meta: value.meta?,
                text: value.text?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::TextContent> for TextContent {
        fn from(value: super::TextContent) -> Self {
            Self {
                annotations: Ok(value.annotations),
                meta: Ok(value.meta),
                text: Ok(value.text),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TextContentMeta {}
    impl ::std::default::Default for TextContentMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl TextContentMeta {}
    impl ::std::convert::TryFrom<TextContentMeta> for super::TextContentMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: TextContentMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::TextContentMeta> for TextContentMeta {
        fn from(_value: super::TextContentMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct TextResourceContents {
        meta: ::std::result::Result<
            ::std::option::Option<super::TextResourceContentsMeta>,
            ::std::string::String,
        >,
        mime_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        text: ::std::result::Result<::std::string::String, ::std::string::String>,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TextResourceContents {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                mime_type: Ok(Default::default()),
                text: Err("no value supplied for text".to_string()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl TextResourceContents {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TextResourceContentsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn mime_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.mime_type = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
            self
        }
        pub fn text<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.text = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for text: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TextResourceContents> for super::TextResourceContents {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TextResourceContents,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                mime_type: value.mime_type?,
                text: value.text?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::TextResourceContents> for TextResourceContents {
        fn from(value: super::TextResourceContents) -> Self {
            Self {
                meta: Ok(value.meta),
                mime_type: Ok(value.mime_type),
                text: Ok(value.text),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TextResourceContentsMeta {}
    impl ::std::default::Default for TextResourceContentsMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl TextResourceContentsMeta {}
    impl ::std::convert::TryFrom<TextResourceContentsMeta> for super::TextResourceContentsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: TextResourceContentsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::TextResourceContentsMeta> for TextResourceContentsMeta {
        fn from(_value: super::TextResourceContentsMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct TitledMultiSelectEnumSchema {
        default:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        items:
            ::std::result::Result<super::TitledMultiSelectEnumSchemaItems, ::std::string::String>,
        max_items: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        min_items: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TitledMultiSelectEnumSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                items: Err("no value supplied for items".to_string()),
                max_items: Ok(Default::default()),
                min_items: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl TitledMultiSelectEnumSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TitledMultiSelectEnumSchemaItems>,
            T::Error: ::std::fmt::Display,
        {
            self.items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for items: {}", e));
            self
        }
        pub fn max_items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for max_items: {}", e));
            self
        }
        pub fn min_items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for min_items: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TitledMultiSelectEnumSchema> for super::TitledMultiSelectEnumSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TitledMultiSelectEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                items: value.items?,
                max_items: value.max_items?,
                min_items: value.min_items?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::TitledMultiSelectEnumSchema> for TitledMultiSelectEnumSchema {
        fn from(value: super::TitledMultiSelectEnumSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                items: Ok(value.items),
                max_items: Ok(value.max_items),
                min_items: Ok(value.min_items),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TitledMultiSelectEnumSchemaItems {
        any_of: ::std::result::Result<
            ::std::vec::Vec<super::TitledMultiSelectEnumSchemaItemsAnyOfItem>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TitledMultiSelectEnumSchemaItems {
        fn default() -> Self {
            Self {
                any_of: Err("no value supplied for any_of".to_string()),
            }
        }
    }
    impl TitledMultiSelectEnumSchemaItems {
        pub fn any_of<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::TitledMultiSelectEnumSchemaItemsAnyOfItem>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.any_of = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for any_of: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TitledMultiSelectEnumSchemaItems>
        for super::TitledMultiSelectEnumSchemaItems
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TitledMultiSelectEnumSchemaItems,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                any_of: value.any_of?,
            })
        }
    }
    impl ::std::convert::From<super::TitledMultiSelectEnumSchemaItems>
        for TitledMultiSelectEnumSchemaItems
    {
        fn from(value: super::TitledMultiSelectEnumSchemaItems) -> Self {
            Self {
                any_of: Ok(value.any_of),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TitledMultiSelectEnumSchemaItemsAnyOfItem {
        const_: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TitledMultiSelectEnumSchemaItemsAnyOfItem {
        fn default() -> Self {
            Self {
                const_: Err("no value supplied for const_".to_string()),
                title: Err("no value supplied for title".to_string()),
            }
        }
    }
    impl TitledMultiSelectEnumSchemaItemsAnyOfItem {
        pub fn const_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.const_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for const_: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TitledMultiSelectEnumSchemaItemsAnyOfItem>
        for super::TitledMultiSelectEnumSchemaItemsAnyOfItem
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TitledMultiSelectEnumSchemaItemsAnyOfItem,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                const_: value.const_?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::TitledMultiSelectEnumSchemaItemsAnyOfItem>
        for TitledMultiSelectEnumSchemaItemsAnyOfItem
    {
        fn from(value: super::TitledMultiSelectEnumSchemaItemsAnyOfItem) -> Self {
            Self {
                const_: Ok(value.const_),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TitledSingleSelectEnumSchema {
        default: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        one_of: ::std::result::Result<
            ::std::vec::Vec<super::TitledSingleSelectEnumSchemaOneOfItem>,
            ::std::string::String,
        >,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TitledSingleSelectEnumSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                one_of: Err("no value supplied for one_of".to_string()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl TitledSingleSelectEnumSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn one_of<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::TitledSingleSelectEnumSchemaOneOfItem>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.one_of = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for one_of: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TitledSingleSelectEnumSchema> for super::TitledSingleSelectEnumSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TitledSingleSelectEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                one_of: value.one_of?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::TitledSingleSelectEnumSchema> for TitledSingleSelectEnumSchema {
        fn from(value: super::TitledSingleSelectEnumSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                one_of: Ok(value.one_of),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TitledSingleSelectEnumSchemaOneOfItem {
        const_: ::std::result::Result<::std::string::String, ::std::string::String>,
        title: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for TitledSingleSelectEnumSchemaOneOfItem {
        fn default() -> Self {
            Self {
                const_: Err("no value supplied for const_".to_string()),
                title: Err("no value supplied for title".to_string()),
            }
        }
    }
    impl TitledSingleSelectEnumSchemaOneOfItem {
        pub fn const_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.const_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for const_: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TitledSingleSelectEnumSchemaOneOfItem>
        for super::TitledSingleSelectEnumSchemaOneOfItem
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TitledSingleSelectEnumSchemaOneOfItem,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                const_: value.const_?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::TitledSingleSelectEnumSchemaOneOfItem>
        for TitledSingleSelectEnumSchemaOneOfItem
    {
        fn from(value: super::TitledSingleSelectEnumSchemaOneOfItem) -> Self {
            Self {
                const_: Ok(value.const_),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Tool {
        annotations: ::std::result::Result<
            ::std::option::Option<super::ToolAnnotations>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        execution: ::std::result::Result<
            ::std::option::Option<super::ToolExecution>,
            ::std::string::String,
        >,
        icons: ::std::result::Result<::std::vec::Vec<super::Icon>, ::std::string::String>,
        input_schema: ::std::result::Result<super::ToolInputSchema, ::std::string::String>,
        meta: ::std::result::Result<::std::option::Option<super::ToolMeta>, ::std::string::String>,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        output_schema: ::std::result::Result<
            ::std::option::Option<super::ToolOutputSchema>,
            ::std::string::String,
        >,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Tool {
        fn default() -> Self {
            Self {
                annotations: Ok(Default::default()),
                description: Ok(Default::default()),
                execution: Ok(Default::default()),
                icons: Ok(Default::default()),
                input_schema: Err("no value supplied for input_schema".to_string()),
                meta: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                output_schema: Ok(Default::default()),
                title: Ok(Default::default()),
            }
        }
    }
    impl Tool {
        pub fn annotations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolAnnotations>>,
            T::Error: ::std::fmt::Display,
        {
            self.annotations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for annotations: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn execution<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolExecution>>,
            T::Error: ::std::fmt::Display,
        {
            self.execution = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for execution: {}", e));
            self
        }
        pub fn icons<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::Icon>>,
            T::Error: ::std::fmt::Display,
        {
            self.icons = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for icons: {}", e));
            self
        }
        pub fn input_schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ToolInputSchema>,
            T::Error: ::std::fmt::Display,
        {
            self.input_schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input_schema: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn output_schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolOutputSchema>>,
            T::Error: ::std::fmt::Display,
        {
            self.output_schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output_schema: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Tool> for super::Tool {
        type Error = super::error::ConversionError;
        fn try_from(value: Tool) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                annotations: value.annotations?,
                description: value.description?,
                execution: value.execution?,
                icons: value.icons?,
                input_schema: value.input_schema?,
                meta: value.meta?,
                name: value.name?,
                output_schema: value.output_schema?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::Tool> for Tool {
        fn from(value: super::Tool) -> Self {
            Self {
                annotations: Ok(value.annotations),
                description: Ok(value.description),
                execution: Ok(value.execution),
                icons: Ok(value.icons),
                input_schema: Ok(value.input_schema),
                meta: Ok(value.meta),
                name: Ok(value.name),
                output_schema: Ok(value.output_schema),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolAnnotations {
        destructive_hint: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        idempotent_hint: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        open_world_hint: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        read_only_hint: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ToolAnnotations {
        fn default() -> Self {
            Self {
                destructive_hint: Ok(Default::default()),
                idempotent_hint: Ok(Default::default()),
                open_world_hint: Ok(Default::default()),
                read_only_hint: Ok(Default::default()),
                title: Ok(Default::default()),
            }
        }
    }
    impl ToolAnnotations {
        pub fn destructive_hint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.destructive_hint = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for destructive_hint: {}",
                    e
                )
            });
            self
        }
        pub fn idempotent_hint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.idempotent_hint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for idempotent_hint: {}", e));
            self
        }
        pub fn open_world_hint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.open_world_hint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for open_world_hint: {}", e));
            self
        }
        pub fn read_only_hint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.read_only_hint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for read_only_hint: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolAnnotations> for super::ToolAnnotations {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolAnnotations,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                destructive_hint: value.destructive_hint?,
                idempotent_hint: value.idempotent_hint?,
                open_world_hint: value.open_world_hint?,
                read_only_hint: value.read_only_hint?,
                title: value.title?,
            })
        }
    }
    impl ::std::convert::From<super::ToolAnnotations> for ToolAnnotations {
        fn from(value: super::ToolAnnotations) -> Self {
            Self {
                destructive_hint: Ok(value.destructive_hint),
                idempotent_hint: Ok(value.idempotent_hint),
                open_world_hint: Ok(value.open_world_hint),
                read_only_hint: Ok(value.read_only_hint),
                title: Ok(value.title),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolChoice {
        mode: ::std::result::Result<
            ::std::option::Option<super::ToolChoiceMode>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ToolChoice {
        fn default() -> Self {
            Self {
                mode: Ok(Default::default()),
            }
        }
    }
    impl ToolChoice {
        pub fn mode<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolChoiceMode>>,
            T::Error: ::std::fmt::Display,
        {
            self.mode = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mode: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolChoice> for super::ToolChoice {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolChoice,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { mode: value.mode? })
        }
    }
    impl ::std::convert::From<super::ToolChoice> for ToolChoice {
        fn from(value: super::ToolChoice) -> Self {
            Self {
                mode: Ok(value.mode),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolExecution {
        task_support: ::std::result::Result<
            ::std::option::Option<super::ToolExecutionTaskSupport>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ToolExecution {
        fn default() -> Self {
            Self {
                task_support: Ok(Default::default()),
            }
        }
    }
    impl ToolExecution {
        pub fn task_support<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolExecutionTaskSupport>>,
            T::Error: ::std::fmt::Display,
        {
            self.task_support = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for task_support: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolExecution> for super::ToolExecution {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolExecution,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                task_support: value.task_support?,
            })
        }
    }
    impl ::std::convert::From<super::ToolExecution> for ToolExecution {
        fn from(value: super::ToolExecution) -> Self {
            Self {
                task_support: Ok(value.task_support),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolInputSchema {
        properties: ::std::result::Result<
            ::std::collections::HashMap<
                ::std::string::String,
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            ::std::string::String,
        >,
        required:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        schema: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ToolInputSchema {
        fn default() -> Self {
            Self {
                properties: Ok(Default::default()),
                required: Ok(Default::default()),
                schema: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ToolInputSchema {
        pub fn properties<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.properties = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for properties: {}", e));
            self
        }
        pub fn required<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.required = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for required: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolInputSchema> for super::ToolInputSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolInputSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                properties: value.properties?,
                required: value.required?,
                schema: value.schema?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ToolInputSchema> for ToolInputSchema {
        fn from(value: super::ToolInputSchema) -> Self {
            Self {
                properties: Ok(value.properties),
                required: Ok(value.required),
                schema: Ok(value.schema),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolListChangedNotification {
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<
            ::std::option::Option<super::NotificationParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ToolListChangedNotification {
        fn default() -> Self {
            Self {
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Ok(Default::default()),
            }
        }
    }
    impl ToolListChangedNotification {
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::NotificationParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolListChangedNotification> for super::ToolListChangedNotification {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolListChangedNotification,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::ToolListChangedNotification> for ToolListChangedNotification {
        fn from(value: super::ToolListChangedNotification) -> Self {
            Self {
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolMeta {}
    impl ::std::default::Default for ToolMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ToolMeta {}
    impl ::std::convert::TryFrom<ToolMeta> for super::ToolMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ToolMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ToolMeta> for ToolMeta {
        fn from(_value: super::ToolMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolOutputSchema {
        properties: ::std::result::Result<
            ::std::collections::HashMap<
                ::std::string::String,
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            ::std::string::String,
        >,
        required:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        schema: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ToolOutputSchema {
        fn default() -> Self {
            Self {
                properties: Ok(Default::default()),
                required: Ok(Default::default()),
                schema: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ToolOutputSchema {
        pub fn properties<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                    >,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.properties = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for properties: {}", e));
            self
        }
        pub fn required<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.required = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for required: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolOutputSchema> for super::ToolOutputSchema {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolOutputSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                properties: value.properties?,
                required: value.required?,
                schema: value.schema?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ToolOutputSchema> for ToolOutputSchema {
        fn from(value: super::ToolOutputSchema) -> Self {
            Self {
                properties: Ok(value.properties),
                required: Ok(value.required),
                schema: Ok(value.schema),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolResultContent {
        content: ::std::result::Result<::std::vec::Vec<super::ContentBlock>, ::std::string::String>,
        is_error: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ToolResultContentMeta>,
            ::std::string::String,
        >,
        structured_content: ::std::result::Result<
            ::std::option::Option<super::ToolResultContentStructuredContent>,
            ::std::string::String,
        >,
        tool_use_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ToolResultContent {
        fn default() -> Self {
            Self {
                content: Err("no value supplied for content".to_string()),
                is_error: Ok(Default::default()),
                meta: Ok(Default::default()),
                structured_content: Ok(Default::default()),
                tool_use_id: Err("no value supplied for tool_use_id".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ToolResultContent {
        pub fn content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ContentBlock>>,
            T::Error: ::std::fmt::Display,
        {
            self.content = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for content: {}", e));
            self
        }
        pub fn is_error<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_error = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for is_error: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolResultContentMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn structured_content<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                    ::std::option::Option<super::ToolResultContentStructuredContent>,
                >,
            T::Error: ::std::fmt::Display,
        {
            self.structured_content = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for structured_content: {}",
                    e
                )
            });
            self
        }
        pub fn tool_use_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.tool_use_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tool_use_id: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolResultContent> for super::ToolResultContent {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolResultContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                content: value.content?,
                is_error: value.is_error?,
                meta: value.meta?,
                structured_content: value.structured_content?,
                tool_use_id: value.tool_use_id?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ToolResultContent> for ToolResultContent {
        fn from(value: super::ToolResultContent) -> Self {
            Self {
                content: Ok(value.content),
                is_error: Ok(value.is_error),
                meta: Ok(value.meta),
                structured_content: Ok(value.structured_content),
                tool_use_id: Ok(value.tool_use_id),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolResultContentMeta {}
    impl ::std::default::Default for ToolResultContentMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ToolResultContentMeta {}
    impl ::std::convert::TryFrom<ToolResultContentMeta> for super::ToolResultContentMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ToolResultContentMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ToolResultContentMeta> for ToolResultContentMeta {
        fn from(_value: super::ToolResultContentMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolResultContentStructuredContent {}
    impl ::std::default::Default for ToolResultContentStructuredContent {
        fn default() -> Self {
            Self {}
        }
    }
    impl ToolResultContentStructuredContent {}
    impl ::std::convert::TryFrom<ToolResultContentStructuredContent>
        for super::ToolResultContentStructuredContent
    {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ToolResultContentStructuredContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ToolResultContentStructuredContent>
        for ToolResultContentStructuredContent
    {
        fn from(_value: super::ToolResultContentStructuredContent) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolUseContent {
        id: ::std::result::Result<::std::string::String, ::std::string::String>,
        input: ::std::result::Result<super::ToolUseContentInput, ::std::string::String>,
        meta: ::std::result::Result<
            ::std::option::Option<super::ToolUseContentMeta>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ToolUseContent {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                input: Err("no value supplied for input".to_string()),
                meta: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl ToolUseContent {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ToolUseContentInput>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ToolUseContentMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ToolUseContent> for super::ToolUseContent {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ToolUseContent,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                input: value.input?,
                meta: value.meta?,
                name: value.name?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::ToolUseContent> for ToolUseContent {
        fn from(value: super::ToolUseContent) -> Self {
            Self {
                id: Ok(value.id),
                input: Ok(value.input),
                meta: Ok(value.meta),
                name: Ok(value.name),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolUseContentInput {}
    impl ::std::default::Default for ToolUseContentInput {
        fn default() -> Self {
            Self {}
        }
    }
    impl ToolUseContentInput {}
    impl ::std::convert::TryFrom<ToolUseContentInput> for super::ToolUseContentInput {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ToolUseContentInput,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ToolUseContentInput> for ToolUseContentInput {
        fn from(_value: super::ToolUseContentInput) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct ToolUseContentMeta {}
    impl ::std::default::Default for ToolUseContentMeta {
        fn default() -> Self {
            Self {}
        }
    }
    impl ToolUseContentMeta {}
    impl ::std::convert::TryFrom<ToolUseContentMeta> for super::ToolUseContentMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: ToolUseContentMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::ToolUseContentMeta> for ToolUseContentMeta {
        fn from(_value: super::ToolUseContentMeta) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct UnsubscribeRequest {
        id: ::std::result::Result<super::RequestId, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        params: ::std::result::Result<super::UnsubscribeRequestParams, ::std::string::String>,
    }
    impl ::std::default::Default for UnsubscribeRequest {
        fn default() -> Self {
            Self {
                id: Err("no value supplied for id".to_string()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                method: Err("no value supplied for method".to_string()),
                params: Err("no value supplied for params".to_string()),
            }
        }
    }
    impl UnsubscribeRequest {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RequestId>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn params<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::UnsubscribeRequestParams>,
            T::Error: ::std::fmt::Display,
        {
            self.params = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for params: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UnsubscribeRequest> for super::UnsubscribeRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UnsubscribeRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                jsonrpc: value.jsonrpc?,
                method: value.method?,
                params: value.params?,
            })
        }
    }
    impl ::std::convert::From<super::UnsubscribeRequest> for UnsubscribeRequest {
        fn from(value: super::UnsubscribeRequest) -> Self {
            Self {
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
                method: Ok(value.method),
                params: Ok(value.params),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UnsubscribeRequestParams {
        meta: ::std::result::Result<
            ::std::option::Option<super::UnsubscribeRequestParamsMeta>,
            ::std::string::String,
        >,
        uri: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UnsubscribeRequestParams {
        fn default() -> Self {
            Self {
                meta: Ok(Default::default()),
                uri: Err("no value supplied for uri".to_string()),
            }
        }
    }
    impl UnsubscribeRequestParams {
        pub fn meta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::UnsubscribeRequestParamsMeta>>,
            T::Error: ::std::fmt::Display,
        {
            self.meta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for meta: {}", e));
            self
        }
        pub fn uri<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.uri = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for uri: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UnsubscribeRequestParams> for super::UnsubscribeRequestParams {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UnsubscribeRequestParams,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                meta: value.meta?,
                uri: value.uri?,
            })
        }
    }
    impl ::std::convert::From<super::UnsubscribeRequestParams> for UnsubscribeRequestParams {
        fn from(value: super::UnsubscribeRequestParams) -> Self {
            Self {
                meta: Ok(value.meta),
                uri: Ok(value.uri),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UnsubscribeRequestParamsMeta {
        progress_token: ::std::result::Result<
            ::std::option::Option<super::ProgressToken>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for UnsubscribeRequestParamsMeta {
        fn default() -> Self {
            Self {
                progress_token: Ok(Default::default()),
            }
        }
    }
    impl UnsubscribeRequestParamsMeta {
        pub fn progress_token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ProgressToken>>,
            T::Error: ::std::fmt::Display,
        {
            self.progress_token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for progress_token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UnsubscribeRequestParamsMeta> for super::UnsubscribeRequestParamsMeta {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UnsubscribeRequestParamsMeta,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                progress_token: value.progress_token?,
            })
        }
    }
    impl ::std::convert::From<super::UnsubscribeRequestParamsMeta> for UnsubscribeRequestParamsMeta {
        fn from(value: super::UnsubscribeRequestParamsMeta) -> Self {
            Self {
                progress_token: Ok(value.progress_token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UntitledMultiSelectEnumSchema {
        default:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        items:
            ::std::result::Result<super::UntitledMultiSelectEnumSchemaItems, ::std::string::String>,
        max_items: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        min_items: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UntitledMultiSelectEnumSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                items: Err("no value supplied for items".to_string()),
                max_items: Ok(Default::default()),
                min_items: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl UntitledMultiSelectEnumSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::UntitledMultiSelectEnumSchemaItems>,
            T::Error: ::std::fmt::Display,
        {
            self.items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for items: {}", e));
            self
        }
        pub fn max_items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for max_items: {}", e));
            self
        }
        pub fn min_items<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_items = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for min_items: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UntitledMultiSelectEnumSchema>
        for super::UntitledMultiSelectEnumSchema
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UntitledMultiSelectEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                items: value.items?,
                max_items: value.max_items?,
                min_items: value.min_items?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::UntitledMultiSelectEnumSchema> for UntitledMultiSelectEnumSchema {
        fn from(value: super::UntitledMultiSelectEnumSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                items: Ok(value.items),
                max_items: Ok(value.max_items),
                min_items: Ok(value.min_items),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UntitledMultiSelectEnumSchemaItems {
        enum_: ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UntitledMultiSelectEnumSchemaItems {
        fn default() -> Self {
            Self {
                enum_: Err("no value supplied for enum_".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl UntitledMultiSelectEnumSchemaItems {
        pub fn enum_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.enum_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for enum_: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UntitledMultiSelectEnumSchemaItems>
        for super::UntitledMultiSelectEnumSchemaItems
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UntitledMultiSelectEnumSchemaItems,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                enum_: value.enum_?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::UntitledMultiSelectEnumSchemaItems>
        for UntitledMultiSelectEnumSchemaItems
    {
        fn from(value: super::UntitledMultiSelectEnumSchemaItems) -> Self {
            Self {
                enum_: Ok(value.enum_),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UntitledSingleSelectEnumSchema {
        default: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        enum_: ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UntitledSingleSelectEnumSchema {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                description: Ok(Default::default()),
                enum_: Err("no value supplied for enum_".to_string()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl UntitledSingleSelectEnumSchema {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for description: {}", e));
            self
        }
        pub fn enum_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.enum_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for enum_: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UntitledSingleSelectEnumSchema>
        for super::UntitledSingleSelectEnumSchema
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UntitledSingleSelectEnumSchema,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                description: value.description?,
                enum_: value.enum_?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::UntitledSingleSelectEnumSchema>
        for UntitledSingleSelectEnumSchema
    {
        fn from(value: super::UntitledSingleSelectEnumSchema) -> Self {
            Self {
                default: Ok(value.default),
                description: Ok(value.description),
                enum_: Ok(value.enum_),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UrlElicitationRequiredError {
        error:
            ::std::result::Result<super::UrlElicitationRequiredErrorError, ::std::string::String>,
        id: ::std::result::Result<::std::option::Option<super::RequestId>, ::std::string::String>,
        jsonrpc: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UrlElicitationRequiredError {
        fn default() -> Self {
            Self {
                error: Err("no value supplied for error".to_string()),
                id: Ok(Default::default()),
                jsonrpc: Err("no value supplied for jsonrpc".to_string()),
            }
        }
    }
    impl UrlElicitationRequiredError {
        pub fn error<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::UrlElicitationRequiredErrorError>,
            T::Error: ::std::fmt::Display,
        {
            self.error = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for error: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RequestId>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn jsonrpc<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.jsonrpc = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jsonrpc: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UrlElicitationRequiredError> for super::UrlElicitationRequiredError {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UrlElicitationRequiredError,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                error: value.error?,
                id: value.id?,
                jsonrpc: value.jsonrpc?,
            })
        }
    }
    impl ::std::convert::From<super::UrlElicitationRequiredError> for UrlElicitationRequiredError {
        fn from(value: super::UrlElicitationRequiredError) -> Self {
            Self {
                error: Ok(value.error),
                id: Ok(value.id),
                jsonrpc: Ok(value.jsonrpc),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UrlElicitationRequiredErrorError {
        code: ::std::result::Result<
            super::UrlElicitationRequiredErrorErrorCode,
            ::std::string::String,
        >,
        data: ::std::result::Result<
            super::UrlElicitationRequiredErrorErrorData,
            ::std::string::String,
        >,
        message: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for UrlElicitationRequiredErrorError {
        fn default() -> Self {
            Self {
                code: Err("no value supplied for code".to_string()),
                data: Err("no value supplied for data".to_string()),
                message: Err("no value supplied for message".to_string()),
            }
        }
    }
    impl UrlElicitationRequiredErrorError {
        pub fn code<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::UrlElicitationRequiredErrorErrorCode>,
            T::Error: ::std::fmt::Display,
        {
            self.code = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for code: {}", e));
            self
        }
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::UrlElicitationRequiredErrorErrorData>,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UrlElicitationRequiredErrorError>
        for super::UrlElicitationRequiredErrorError
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UrlElicitationRequiredErrorError,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                code: value.code?,
                data: value.data?,
                message: value.message?,
            })
        }
    }
    impl ::std::convert::From<super::UrlElicitationRequiredErrorError>
        for UrlElicitationRequiredErrorError
    {
        fn from(value: super::UrlElicitationRequiredErrorError) -> Self {
            Self {
                code: Ok(value.code),
                data: Ok(value.data),
                message: Ok(value.message),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UrlElicitationRequiredErrorErrorData {
        elicitations: ::std::result::Result<
            ::std::vec::Vec<super::ElicitRequestUrlParams>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for UrlElicitationRequiredErrorErrorData {
        fn default() -> Self {
            Self {
                elicitations: Err("no value supplied for elicitations".to_string()),
            }
        }
    }
    impl UrlElicitationRequiredErrorErrorData {
        pub fn elicitations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<super::ElicitRequestUrlParams>>,
            T::Error: ::std::fmt::Display,
        {
            self.elicitations = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for elicitations: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UrlElicitationRequiredErrorErrorData>
        for super::UrlElicitationRequiredErrorErrorData
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UrlElicitationRequiredErrorErrorData,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                elicitations: value.elicitations?,
            })
        }
    }
    impl ::std::convert::From<super::UrlElicitationRequiredErrorErrorData>
        for UrlElicitationRequiredErrorErrorData
    {
        fn from(value: super::UrlElicitationRequiredErrorErrorData) -> Self {
            Self {
                elicitations: Ok(value.elicitations),
            }
        }
    }
}
